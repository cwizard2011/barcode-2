(function webpackUniversalModuleDefinition(root, factory) {
  if (typeof exports === "object" && typeof module === "object")
    module.exports = factory(factory.toString()).default;
  else if (typeof exports === "object")
    exports["Quagga"] = factory(factory.toString()).default;
  else root["Quagga"] = factory(factory.toString()).default;
})(window, function () {
  return /******/ (function (modules) {
    // webpackBootstrap
    /******/ // The module cache
    /******/ var installedModules = {};
    /******/
    /******/ // The require function
    /******/ function __webpack_require__(moduleId) {
      /******/
      /******/ // Check if module is in cache
      /******/ if (installedModules[moduleId]) {
        /******/ return installedModules[moduleId].exports;
        /******/
      }
      /******/ // Create a new module (and put it into the cache)
      /******/ var module = (installedModules[moduleId] = {
        /******/ i: moduleId,
        /******/ l: false,
        /******/ exports: {},
        /******/
      });
      /******/
      /******/ // Execute the module function
      /******/ modules[moduleId].call(
        module.exports,
        module,
        module.exports,
        __webpack_require__
      );
      /******/
      /******/ // Flag the module as loaded
      /******/ module.l = true;
      /******/
      /******/ // Return the exports of the module
      /******/ return module.exports;
      /******/
    }
    /******/
    /******/
    /******/ // expose the modules object (__webpack_modules__)
    /******/ __webpack_require__.m = modules;
    /******/
    /******/ // expose the module cache
    /******/ __webpack_require__.c = installedModules;
    /******/
    /******/ // define getter function for harmony exports
    /******/ __webpack_require__.d = function (exports, name, getter) {
      /******/ if (!__webpack_require__.o(exports, name)) {
        /******/ Object.defineProperty(exports, name, {
          enumerable: true,
          get: getter,
        });
        /******/
      }
      /******/
    };
    /******/
    /******/ // define __esModule on exports
    /******/ __webpack_require__.r = function (exports) {
      /******/ if (typeof Symbol !== "undefined" && Symbol.toStringTag) {
        /******/ Object.defineProperty(exports, Symbol.toStringTag, {
          value: "Module",
        });
        /******/
      }
      /******/ Object.defineProperty(exports, "__esModule", { value: true });
      /******/
    };
    /******/
    /******/ // create a fake namespace object
    /******/ // mode & 1: value is a module id, require it
    /******/ // mode & 2: merge all properties of value into the ns
    /******/ // mode & 4: return value when already ns object
    /******/ // mode & 8|1: behave like require
    /******/ __webpack_require__.t = function (value, mode) {
      /******/ if (mode & 1) value = __webpack_require__(value);
      /******/ if (mode & 8) return value;
      /******/ if (
        mode & 4 &&
        typeof value === "object" &&
        value &&
        value.__esModule
      )
        return value;
      /******/ var ns = Object.create(null);
      /******/ __webpack_require__.r(ns);
      /******/ Object.defineProperty(ns, "default", {
        enumerable: true,
        value: value,
      });
      /******/ if (mode & 2 && typeof value != "string")
        for (var key in value)
          __webpack_require__.d(
            ns,
            key,
            function (key) {
              return value[key];
            }.bind(null, key)
          );
      /******/ return ns;
      /******/
    };
    /******/
    /******/ // getDefaultExport function for compatibility with non-harmony modules
    /******/ __webpack_require__.n = function (module) {
      /******/ var getter =
        module && module.__esModule
          ? /******/ function getDefault() {
              return module["default"];
            }
          : /******/ function getModuleExports() {
              return module;
            };
      /******/ __webpack_require__.d(getter, "a", getter);
      /******/ return getter;
      /******/
    };
    /******/
    /******/ // Object.prototype.hasOwnProperty.call
    /******/ __webpack_require__.o = function (object, property) {
      return Object.prototype.hasOwnProperty.call(object, property);
    };
    /******/
    /******/ // __webpack_public_path__
    /******/ __webpack_require__.p = "/";
    /******/
    /******/
    /******/ // Load entry module and return exports
    /******/ return __webpack_require__((__webpack_require__.s = 72));
    /******/
  })(
    /************************************************************************/
    /******/ [
      /* 0 */
      /***/ function (module, exports) {
        function _defineProperty(obj, key, value) {
          if (key in obj) {
            Object.defineProperty(obj, key, {
              value: value,
              enumerable: true,
              configurable: true,
              writable: true,
            });
          } else {
            obj[key] = value;
          }

          return obj;
        }

        (module.exports = _defineProperty),
          (module.exports.__esModule = true),
          (module.exports["default"] = module.exports);

        /***/
      },
      /* 1 */
      /***/ function (module, exports) {
        function _assertThisInitialized(self) {
          if (self === void 0) {
            throw new ReferenceError(
              "this hasn't been initialised - super() hasn't been called"
            );
          }

          return self;
        }

        (module.exports = _assertThisInitialized),
          (module.exports.__esModule = true),
          (module.exports["default"] = module.exports);

        /***/
      },
      /* 2 */
      /***/ function (module, exports) {
        function _getPrototypeOf(o) {
          (module.exports = _getPrototypeOf =
            Object.setPrototypeOf
              ? Object.getPrototypeOf.bind()
              : function _getPrototypeOf(o) {
                  return o.__proto__ || Object.getPrototypeOf(o);
                }),
            (module.exports.__esModule = true),
            (module.exports["default"] = module.exports);
          return _getPrototypeOf(o);
        }

        (module.exports = _getPrototypeOf),
          (module.exports.__esModule = true),
          (module.exports["default"] = module.exports);

        /***/
      },
      /* 3 */
      /***/ function (module, exports) {
        function _classCallCheck(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
          }
        }

        (module.exports = _classCallCheck),
          (module.exports.__esModule = true),
          (module.exports["default"] = module.exports);

        /***/
      },
      /* 4 */
      /***/ function (module, exports) {
        function _defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor) descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor);
          }
        }

        function _createClass(Constructor, protoProps, staticProps) {
          if (protoProps) _defineProperties(Constructor.prototype, protoProps);
          if (staticProps) _defineProperties(Constructor, staticProps);
          Object.defineProperty(Constructor, "prototype", {
            writable: false,
          });
          return Constructor;
        }

        (module.exports = _createClass),
          (module.exports.__esModule = true),
          (module.exports["default"] = module.exports);

        /***/
      },
      /* 5 */
      /***/ function (module, __webpack_exports__, __webpack_require__) {
        "use strict";

        // EXPORTS
        __webpack_require__.d(__webpack_exports__, "a", function () {
          return /* reexport */ common_namespaceObject;
        });
        __webpack_require__.d(__webpack_exports__, "b", function () {
          return /* reexport */ mat2_namespaceObject;
        });
        __webpack_require__.d(__webpack_exports__, "c", function () {
          return /* reexport */ vec2_namespaceObject;
        });
        __webpack_require__.d(__webpack_exports__, "d", function () {
          return /* reexport */ vec3_namespaceObject;
        });

        // UNUSED EXPORTS: mat2d, mat3, mat4, quat, quat2, vec4

        // NAMESPACE OBJECT: ./node_modules/gl-matrix/esm/common.js
        var common_namespaceObject = {};
        __webpack_require__.r(common_namespaceObject);
        __webpack_require__.d(common_namespaceObject, "EPSILON", function () {
          return EPSILON;
        });
        __webpack_require__.d(
          common_namespaceObject,
          "ARRAY_TYPE",
          function () {
            return ARRAY_TYPE;
          }
        );
        __webpack_require__.d(common_namespaceObject, "RANDOM", function () {
          return RANDOM;
        });
        __webpack_require__.d(
          common_namespaceObject,
          "setMatrixArrayType",
          function () {
            return setMatrixArrayType;
          }
        );
        __webpack_require__.d(common_namespaceObject, "toRadian", function () {
          return toRadian;
        });
        __webpack_require__.d(common_namespaceObject, "equals", function () {
          return equals;
        });

        // NAMESPACE OBJECT: ./node_modules/gl-matrix/esm/mat2.js
        var mat2_namespaceObject = {};
        __webpack_require__.r(mat2_namespaceObject);
        __webpack_require__.d(mat2_namespaceObject, "create", function () {
          return create;
        });
        __webpack_require__.d(mat2_namespaceObject, "clone", function () {
          return clone;
        });
        __webpack_require__.d(mat2_namespaceObject, "copy", function () {
          return copy;
        });
        __webpack_require__.d(mat2_namespaceObject, "identity", function () {
          return identity;
        });
        __webpack_require__.d(mat2_namespaceObject, "fromValues", function () {
          return fromValues;
        });
        __webpack_require__.d(mat2_namespaceObject, "set", function () {
          return set;
        });
        __webpack_require__.d(mat2_namespaceObject, "transpose", function () {
          return transpose;
        });
        __webpack_require__.d(mat2_namespaceObject, "invert", function () {
          return invert;
        });
        __webpack_require__.d(mat2_namespaceObject, "adjoint", function () {
          return adjoint;
        });
        __webpack_require__.d(mat2_namespaceObject, "determinant", function () {
          return determinant;
        });
        __webpack_require__.d(mat2_namespaceObject, "multiply", function () {
          return multiply;
        });
        __webpack_require__.d(mat2_namespaceObject, "rotate", function () {
          return rotate;
        });
        __webpack_require__.d(mat2_namespaceObject, "scale", function () {
          return mat2_scale;
        });
        __webpack_require__.d(
          mat2_namespaceObject,
          "fromRotation",
          function () {
            return fromRotation;
          }
        );
        __webpack_require__.d(mat2_namespaceObject, "fromScaling", function () {
          return fromScaling;
        });
        __webpack_require__.d(mat2_namespaceObject, "str", function () {
          return str;
        });
        __webpack_require__.d(mat2_namespaceObject, "frob", function () {
          return frob;
        });
        __webpack_require__.d(mat2_namespaceObject, "LDU", function () {
          return LDU;
        });
        __webpack_require__.d(mat2_namespaceObject, "add", function () {
          return add;
        });
        __webpack_require__.d(mat2_namespaceObject, "subtract", function () {
          return subtract;
        });
        __webpack_require__.d(mat2_namespaceObject, "exactEquals", function () {
          return exactEquals;
        });
        __webpack_require__.d(mat2_namespaceObject, "equals", function () {
          return mat2_equals;
        });
        __webpack_require__.d(
          mat2_namespaceObject,
          "multiplyScalar",
          function () {
            return multiplyScalar;
          }
        );
        __webpack_require__.d(
          mat2_namespaceObject,
          "multiplyScalarAndAdd",
          function () {
            return multiplyScalarAndAdd;
          }
        );
        __webpack_require__.d(mat2_namespaceObject, "mul", function () {
          return mul;
        });
        __webpack_require__.d(mat2_namespaceObject, "sub", function () {
          return sub;
        });

        // NAMESPACE OBJECT: ./node_modules/gl-matrix/esm/vec2.js
        var vec2_namespaceObject = {};
        __webpack_require__.r(vec2_namespaceObject);
        __webpack_require__.d(vec2_namespaceObject, "create", function () {
          return vec2_create;
        });
        __webpack_require__.d(vec2_namespaceObject, "clone", function () {
          return vec2_clone;
        });
        __webpack_require__.d(vec2_namespaceObject, "fromValues", function () {
          return vec2_fromValues;
        });
        __webpack_require__.d(vec2_namespaceObject, "copy", function () {
          return vec2_copy;
        });
        __webpack_require__.d(vec2_namespaceObject, "set", function () {
          return vec2_set;
        });
        __webpack_require__.d(vec2_namespaceObject, "add", function () {
          return vec2_add;
        });
        __webpack_require__.d(vec2_namespaceObject, "subtract", function () {
          return vec2_subtract;
        });
        __webpack_require__.d(vec2_namespaceObject, "multiply", function () {
          return vec2_multiply;
        });
        __webpack_require__.d(vec2_namespaceObject, "divide", function () {
          return divide;
        });
        __webpack_require__.d(vec2_namespaceObject, "ceil", function () {
          return ceil;
        });
        __webpack_require__.d(vec2_namespaceObject, "floor", function () {
          return floor;
        });
        __webpack_require__.d(vec2_namespaceObject, "min", function () {
          return min;
        });
        __webpack_require__.d(vec2_namespaceObject, "max", function () {
          return max;
        });
        __webpack_require__.d(vec2_namespaceObject, "round", function () {
          return round;
        });
        __webpack_require__.d(vec2_namespaceObject, "scale", function () {
          return vec2_scale;
        });
        __webpack_require__.d(vec2_namespaceObject, "scaleAndAdd", function () {
          return scaleAndAdd;
        });
        __webpack_require__.d(vec2_namespaceObject, "distance", function () {
          return distance;
        });
        __webpack_require__.d(
          vec2_namespaceObject,
          "squaredDistance",
          function () {
            return squaredDistance;
          }
        );
        __webpack_require__.d(vec2_namespaceObject, "length", function () {
          return vec2_length;
        });
        __webpack_require__.d(
          vec2_namespaceObject,
          "squaredLength",
          function () {
            return squaredLength;
          }
        );
        __webpack_require__.d(vec2_namespaceObject, "negate", function () {
          return negate;
        });
        __webpack_require__.d(vec2_namespaceObject, "inverse", function () {
          return inverse;
        });
        __webpack_require__.d(vec2_namespaceObject, "normalize", function () {
          return normalize;
        });
        __webpack_require__.d(vec2_namespaceObject, "dot", function () {
          return dot;
        });
        __webpack_require__.d(vec2_namespaceObject, "cross", function () {
          return cross;
        });
        __webpack_require__.d(vec2_namespaceObject, "lerp", function () {
          return lerp;
        });
        __webpack_require__.d(vec2_namespaceObject, "random", function () {
          return random;
        });
        __webpack_require__.d(
          vec2_namespaceObject,
          "transformMat2",
          function () {
            return transformMat2;
          }
        );
        __webpack_require__.d(
          vec2_namespaceObject,
          "transformMat2d",
          function () {
            return transformMat2d;
          }
        );
        __webpack_require__.d(
          vec2_namespaceObject,
          "transformMat3",
          function () {
            return transformMat3;
          }
        );
        __webpack_require__.d(
          vec2_namespaceObject,
          "transformMat4",
          function () {
            return transformMat4;
          }
        );
        __webpack_require__.d(vec2_namespaceObject, "rotate", function () {
          return vec2_rotate;
        });
        __webpack_require__.d(vec2_namespaceObject, "angle", function () {
          return angle;
        });
        __webpack_require__.d(vec2_namespaceObject, "zero", function () {
          return zero;
        });
        __webpack_require__.d(vec2_namespaceObject, "str", function () {
          return vec2_str;
        });
        __webpack_require__.d(vec2_namespaceObject, "exactEquals", function () {
          return vec2_exactEquals;
        });
        __webpack_require__.d(vec2_namespaceObject, "equals", function () {
          return vec2_equals;
        });
        __webpack_require__.d(vec2_namespaceObject, "len", function () {
          return len;
        });
        __webpack_require__.d(vec2_namespaceObject, "sub", function () {
          return vec2_sub;
        });
        __webpack_require__.d(vec2_namespaceObject, "mul", function () {
          return vec2_mul;
        });
        __webpack_require__.d(vec2_namespaceObject, "div", function () {
          return div;
        });
        __webpack_require__.d(vec2_namespaceObject, "dist", function () {
          return dist;
        });
        __webpack_require__.d(vec2_namespaceObject, "sqrDist", function () {
          return sqrDist;
        });
        __webpack_require__.d(vec2_namespaceObject, "sqrLen", function () {
          return sqrLen;
        });
        __webpack_require__.d(vec2_namespaceObject, "forEach", function () {
          return forEach;
        });

        // NAMESPACE OBJECT: ./node_modules/gl-matrix/esm/vec3.js
        var vec3_namespaceObject = {};
        __webpack_require__.r(vec3_namespaceObject);
        __webpack_require__.d(vec3_namespaceObject, "create", function () {
          return vec3_create;
        });
        __webpack_require__.d(vec3_namespaceObject, "clone", function () {
          return vec3_clone;
        });
        __webpack_require__.d(vec3_namespaceObject, "length", function () {
          return vec3_length;
        });
        __webpack_require__.d(vec3_namespaceObject, "fromValues", function () {
          return vec3_fromValues;
        });
        __webpack_require__.d(vec3_namespaceObject, "copy", function () {
          return vec3_copy;
        });
        __webpack_require__.d(vec3_namespaceObject, "set", function () {
          return vec3_set;
        });
        __webpack_require__.d(vec3_namespaceObject, "add", function () {
          return vec3_add;
        });
        __webpack_require__.d(vec3_namespaceObject, "subtract", function () {
          return vec3_subtract;
        });
        __webpack_require__.d(vec3_namespaceObject, "multiply", function () {
          return vec3_multiply;
        });
        __webpack_require__.d(vec3_namespaceObject, "divide", function () {
          return vec3_divide;
        });
        __webpack_require__.d(vec3_namespaceObject, "ceil", function () {
          return vec3_ceil;
        });
        __webpack_require__.d(vec3_namespaceObject, "floor", function () {
          return vec3_floor;
        });
        __webpack_require__.d(vec3_namespaceObject, "min", function () {
          return vec3_min;
        });
        __webpack_require__.d(vec3_namespaceObject, "max", function () {
          return vec3_max;
        });
        __webpack_require__.d(vec3_namespaceObject, "round", function () {
          return vec3_round;
        });
        __webpack_require__.d(vec3_namespaceObject, "scale", function () {
          return vec3_scale;
        });
        __webpack_require__.d(vec3_namespaceObject, "scaleAndAdd", function () {
          return vec3_scaleAndAdd;
        });
        __webpack_require__.d(vec3_namespaceObject, "distance", function () {
          return vec3_distance;
        });
        __webpack_require__.d(
          vec3_namespaceObject,
          "squaredDistance",
          function () {
            return vec3_squaredDistance;
          }
        );
        __webpack_require__.d(
          vec3_namespaceObject,
          "squaredLength",
          function () {
            return vec3_squaredLength;
          }
        );
        __webpack_require__.d(vec3_namespaceObject, "negate", function () {
          return vec3_negate;
        });
        __webpack_require__.d(vec3_namespaceObject, "inverse", function () {
          return vec3_inverse;
        });
        __webpack_require__.d(vec3_namespaceObject, "normalize", function () {
          return vec3_normalize;
        });
        __webpack_require__.d(vec3_namespaceObject, "dot", function () {
          return vec3_dot;
        });
        __webpack_require__.d(vec3_namespaceObject, "cross", function () {
          return vec3_cross;
        });
        __webpack_require__.d(vec3_namespaceObject, "lerp", function () {
          return vec3_lerp;
        });
        __webpack_require__.d(vec3_namespaceObject, "hermite", function () {
          return hermite;
        });
        __webpack_require__.d(vec3_namespaceObject, "bezier", function () {
          return bezier;
        });
        __webpack_require__.d(vec3_namespaceObject, "random", function () {
          return vec3_random;
        });
        __webpack_require__.d(
          vec3_namespaceObject,
          "transformMat4",
          function () {
            return vec3_transformMat4;
          }
        );
        __webpack_require__.d(
          vec3_namespaceObject,
          "transformMat3",
          function () {
            return vec3_transformMat3;
          }
        );
        __webpack_require__.d(
          vec3_namespaceObject,
          "transformQuat",
          function () {
            return transformQuat;
          }
        );
        __webpack_require__.d(vec3_namespaceObject, "rotateX", function () {
          return rotateX;
        });
        __webpack_require__.d(vec3_namespaceObject, "rotateY", function () {
          return rotateY;
        });
        __webpack_require__.d(vec3_namespaceObject, "rotateZ", function () {
          return rotateZ;
        });
        __webpack_require__.d(vec3_namespaceObject, "angle", function () {
          return vec3_angle;
        });
        __webpack_require__.d(vec3_namespaceObject, "zero", function () {
          return vec3_zero;
        });
        __webpack_require__.d(vec3_namespaceObject, "str", function () {
          return vec3_str;
        });
        __webpack_require__.d(vec3_namespaceObject, "exactEquals", function () {
          return vec3_exactEquals;
        });
        __webpack_require__.d(vec3_namespaceObject, "equals", function () {
          return vec3_equals;
        });
        __webpack_require__.d(vec3_namespaceObject, "sub", function () {
          return vec3_sub;
        });
        __webpack_require__.d(vec3_namespaceObject, "mul", function () {
          return vec3_mul;
        });
        __webpack_require__.d(vec3_namespaceObject, "div", function () {
          return vec3_div;
        });
        __webpack_require__.d(vec3_namespaceObject, "dist", function () {
          return vec3_dist;
        });
        __webpack_require__.d(vec3_namespaceObject, "sqrDist", function () {
          return vec3_sqrDist;
        });
        __webpack_require__.d(vec3_namespaceObject, "len", function () {
          return vec3_len;
        });
        __webpack_require__.d(vec3_namespaceObject, "sqrLen", function () {
          return vec3_sqrLen;
        });
        __webpack_require__.d(vec3_namespaceObject, "forEach", function () {
          return vec3_forEach;
        });

        // CONCATENATED MODULE: ./node_modules/gl-matrix/esm/common.js
        /**
         * Common utilities
         * @module glMatrix
         */
        // Configuration Constants
        var EPSILON = 0.000001;
        var ARRAY_TYPE =
          typeof Float32Array !== "undefined" ? Float32Array : Array;
        var RANDOM = Math.random;
        /**
         * Sets the type of array used when creating new vectors and matrices
         *
         * @param {Float32ArrayConstructor | ArrayConstructor} type Array type, such as Float32Array or Array
         */

        function setMatrixArrayType(type) {
          ARRAY_TYPE = type;
        }
        var degree = Math.PI / 180;
        /**
         * Convert Degree To Radian
         *
         * @param {Number} a Angle in Degrees
         */

        function toRadian(a) {
          return a * degree;
        }
        /**
         * Tests whether or not the arguments have approximately the same value, within an absolute
         * or relative tolerance of glMatrix.EPSILON (an absolute tolerance is used for values less
         * than or equal to 1.0, and a relative tolerance is used for larger values)
         *
         * @param {Number} a The first number to test.
         * @param {Number} b The second number to test.
         * @returns {Boolean} True if the numbers are approximately equal, false otherwise.
         */

        function equals(a, b) {
          return (
            Math.abs(a - b) <= EPSILON * Math.max(1.0, Math.abs(a), Math.abs(b))
          );
        }
        if (!Math.hypot)
          Math.hypot = function () {
            var y = 0,
              i = arguments.length;

            while (i--) {
              y += arguments[i] * arguments[i];
            }

            return Math.sqrt(y);
          };
        // CONCATENATED MODULE: ./node_modules/gl-matrix/esm/mat2.js

        /**
         * 2x2 Matrix
         * @module mat2
         */

        /**
         * Creates a new identity mat2
         *
         * @returns {mat2} a new 2x2 matrix
         */

        function create() {
          var out = new ARRAY_TYPE(4);

          if (ARRAY_TYPE != Float32Array) {
            out[1] = 0;
            out[2] = 0;
          }

          out[0] = 1;
          out[3] = 1;
          return out;
        }
        /**
         * Creates a new mat2 initialized with values from an existing matrix
         *
         * @param {ReadonlyMat2} a matrix to clone
         * @returns {mat2} a new 2x2 matrix
         */

        function clone(a) {
          var out = new ARRAY_TYPE(4);
          out[0] = a[0];
          out[1] = a[1];
          out[2] = a[2];
          out[3] = a[3];
          return out;
        }
        /**
         * Copy the values from one mat2 to another
         *
         * @param {mat2} out the receiving matrix
         * @param {ReadonlyMat2} a the source matrix
         * @returns {mat2} out
         */

        function copy(out, a) {
          out[0] = a[0];
          out[1] = a[1];
          out[2] = a[2];
          out[3] = a[3];
          return out;
        }
        /**
         * Set a mat2 to the identity matrix
         *
         * @param {mat2} out the receiving matrix
         * @returns {mat2} out
         */

        function identity(out) {
          out[0] = 1;
          out[1] = 0;
          out[2] = 0;
          out[3] = 1;
          return out;
        }
        /**
         * Create a new mat2 with the given values
         *
         * @param {Number} m00 Component in column 0, row 0 position (index 0)
         * @param {Number} m01 Component in column 0, row 1 position (index 1)
         * @param {Number} m10 Component in column 1, row 0 position (index 2)
         * @param {Number} m11 Component in column 1, row 1 position (index 3)
         * @returns {mat2} out A new 2x2 matrix
         */

        function fromValues(m00, m01, m10, m11) {
          var out = new ARRAY_TYPE(4);
          out[0] = m00;
          out[1] = m01;
          out[2] = m10;
          out[3] = m11;
          return out;
        }
        /**
         * Set the components of a mat2 to the given values
         *
         * @param {mat2} out the receiving matrix
         * @param {Number} m00 Component in column 0, row 0 position (index 0)
         * @param {Number} m01 Component in column 0, row 1 position (index 1)
         * @param {Number} m10 Component in column 1, row 0 position (index 2)
         * @param {Number} m11 Component in column 1, row 1 position (index 3)
         * @returns {mat2} out
         */

        function set(out, m00, m01, m10, m11) {
          out[0] = m00;
          out[1] = m01;
          out[2] = m10;
          out[3] = m11;
          return out;
        }
        /**
         * Transpose the values of a mat2
         *
         * @param {mat2} out the receiving matrix
         * @param {ReadonlyMat2} a the source matrix
         * @returns {mat2} out
         */

        function transpose(out, a) {
          // If we are transposing ourselves we can skip a few steps but have to cache
          // some values
          if (out === a) {
            var a1 = a[1];
            out[1] = a[2];
            out[2] = a1;
          } else {
            out[0] = a[0];
            out[1] = a[2];
            out[2] = a[1];
            out[3] = a[3];
          }

          return out;
        }
        /**
         * Inverts a mat2
         *
         * @param {mat2} out the receiving matrix
         * @param {ReadonlyMat2} a the source matrix
         * @returns {mat2} out
         */

        function invert(out, a) {
          var a0 = a[0],
            a1 = a[1],
            a2 = a[2],
            a3 = a[3]; // Calculate the determinant

          var det = a0 * a3 - a2 * a1;

          if (!det) {
            return null;
          }

          det = 1.0 / det;
          out[0] = a3 * det;
          out[1] = -a1 * det;
          out[2] = -a2 * det;
          out[3] = a0 * det;
          return out;
        }
        /**
         * Calculates the adjugate of a mat2
         *
         * @param {mat2} out the receiving matrix
         * @param {ReadonlyMat2} a the source matrix
         * @returns {mat2} out
         */

        function adjoint(out, a) {
          // Caching this value is nessecary if out == a
          var a0 = a[0];
          out[0] = a[3];
          out[1] = -a[1];
          out[2] = -a[2];
          out[3] = a0;
          return out;
        }
        /**
         * Calculates the determinant of a mat2
         *
         * @param {ReadonlyMat2} a the source matrix
         * @returns {Number} determinant of a
         */

        function determinant(a) {
          return a[0] * a[3] - a[2] * a[1];
        }
        /**
         * Multiplies two mat2's
         *
         * @param {mat2} out the receiving matrix
         * @param {ReadonlyMat2} a the first operand
         * @param {ReadonlyMat2} b the second operand
         * @returns {mat2} out
         */

        function multiply(out, a, b) {
          var a0 = a[0],
            a1 = a[1],
            a2 = a[2],
            a3 = a[3];
          var b0 = b[0],
            b1 = b[1],
            b2 = b[2],
            b3 = b[3];
          out[0] = a0 * b0 + a2 * b1;
          out[1] = a1 * b0 + a3 * b1;
          out[2] = a0 * b2 + a2 * b3;
          out[3] = a1 * b2 + a3 * b3;
          return out;
        }
        /**
         * Rotates a mat2 by the given angle
         *
         * @param {mat2} out the receiving matrix
         * @param {ReadonlyMat2} a the matrix to rotate
         * @param {Number} rad the angle to rotate the matrix by
         * @returns {mat2} out
         */

        function rotate(out, a, rad) {
          var a0 = a[0],
            a1 = a[1],
            a2 = a[2],
            a3 = a[3];
          var s = Math.sin(rad);
          var c = Math.cos(rad);
          out[0] = a0 * c + a2 * s;
          out[1] = a1 * c + a3 * s;
          out[2] = a0 * -s + a2 * c;
          out[3] = a1 * -s + a3 * c;
          return out;
        }
        /**
         * Scales the mat2 by the dimensions in the given vec2
         *
         * @param {mat2} out the receiving matrix
         * @param {ReadonlyMat2} a the matrix to rotate
         * @param {ReadonlyVec2} v the vec2 to scale the matrix by
         * @returns {mat2} out
         **/

        function mat2_scale(out, a, v) {
          var a0 = a[0],
            a1 = a[1],
            a2 = a[2],
            a3 = a[3];
          var v0 = v[0],
            v1 = v[1];
          out[0] = a0 * v0;
          out[1] = a1 * v0;
          out[2] = a2 * v1;
          out[3] = a3 * v1;
          return out;
        }
        /**
         * Creates a matrix from a given angle
         * This is equivalent to (but much faster than):
         *
         *     mat2.identity(dest);
         *     mat2.rotate(dest, dest, rad);
         *
         * @param {mat2} out mat2 receiving operation result
         * @param {Number} rad the angle to rotate the matrix by
         * @returns {mat2} out
         */

        function fromRotation(out, rad) {
          var s = Math.sin(rad);
          var c = Math.cos(rad);
          out[0] = c;
          out[1] = s;
          out[2] = -s;
          out[3] = c;
          return out;
        }
        /**
         * Creates a matrix from a vector scaling
         * This is equivalent to (but much faster than):
         *
         *     mat2.identity(dest);
         *     mat2.scale(dest, dest, vec);
         *
         * @param {mat2} out mat2 receiving operation result
         * @param {ReadonlyVec2} v Scaling vector
         * @returns {mat2} out
         */

        function fromScaling(out, v) {
          out[0] = v[0];
          out[1] = 0;
          out[2] = 0;
          out[3] = v[1];
          return out;
        }
        /**
         * Returns a string representation of a mat2
         *
         * @param {ReadonlyMat2} a matrix to represent as a string
         * @returns {String} string representation of the matrix
         */

        function str(a) {
          return "mat2(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ")";
        }
        /**
         * Returns Frobenius norm of a mat2
         *
         * @param {ReadonlyMat2} a the matrix to calculate Frobenius norm of
         * @returns {Number} Frobenius norm
         */

        function frob(a) {
          return Math.hypot(a[0], a[1], a[2], a[3]);
        }
        /**
         * Returns L, D and U matrices (Lower triangular, Diagonal and Upper triangular) by factorizing the input matrix
         * @param {ReadonlyMat2} L the lower triangular matrix
         * @param {ReadonlyMat2} D the diagonal matrix
         * @param {ReadonlyMat2} U the upper triangular matrix
         * @param {ReadonlyMat2} a the input matrix to factorize
         */

        function LDU(L, D, U, a) {
          L[2] = a[2] / a[0];
          U[0] = a[0];
          U[1] = a[1];
          U[3] = a[3] - L[2] * U[1];
          return [L, D, U];
        }
        /**
         * Adds two mat2's
         *
         * @param {mat2} out the receiving matrix
         * @param {ReadonlyMat2} a the first operand
         * @param {ReadonlyMat2} b the second operand
         * @returns {mat2} out
         */

        function add(out, a, b) {
          out[0] = a[0] + b[0];
          out[1] = a[1] + b[1];
          out[2] = a[2] + b[2];
          out[3] = a[3] + b[3];
          return out;
        }
        /**
         * Subtracts matrix b from matrix a
         *
         * @param {mat2} out the receiving matrix
         * @param {ReadonlyMat2} a the first operand
         * @param {ReadonlyMat2} b the second operand
         * @returns {mat2} out
         */

        function subtract(out, a, b) {
          out[0] = a[0] - b[0];
          out[1] = a[1] - b[1];
          out[2] = a[2] - b[2];
          out[3] = a[3] - b[3];
          return out;
        }
        /**
         * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
         *
         * @param {ReadonlyMat2} a The first matrix.
         * @param {ReadonlyMat2} b The second matrix.
         * @returns {Boolean} True if the matrices are equal, false otherwise.
         */

        function exactEquals(a, b) {
          return (
            a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3]
          );
        }
        /**
         * Returns whether or not the matrices have approximately the same elements in the same position.
         *
         * @param {ReadonlyMat2} a The first matrix.
         * @param {ReadonlyMat2} b The second matrix.
         * @returns {Boolean} True if the matrices are equal, false otherwise.
         */

        function mat2_equals(a, b) {
          var a0 = a[0],
            a1 = a[1],
            a2 = a[2],
            a3 = a[3];
          var b0 = b[0],
            b1 = b[1],
            b2 = b[2],
            b3 = b[3];
          return (
            Math.abs(a0 - b0) <=
              EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) &&
            Math.abs(a1 - b1) <=
              EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) &&
            Math.abs(a2 - b2) <=
              EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) &&
            Math.abs(a3 - b3) <=
              EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3))
          );
        }
        /**
         * Multiply each element of the matrix by a scalar.
         *
         * @param {mat2} out the receiving matrix
         * @param {ReadonlyMat2} a the matrix to scale
         * @param {Number} b amount to scale the matrix's elements by
         * @returns {mat2} out
         */

        function multiplyScalar(out, a, b) {
          out[0] = a[0] * b;
          out[1] = a[1] * b;
          out[2] = a[2] * b;
          out[3] = a[3] * b;
          return out;
        }
        /**
         * Adds two mat2's after multiplying each element of the second operand by a scalar value.
         *
         * @param {mat2} out the receiving vector
         * @param {ReadonlyMat2} a the first operand
         * @param {ReadonlyMat2} b the second operand
         * @param {Number} scale the amount to scale b's elements by before adding
         * @returns {mat2} out
         */

        function multiplyScalarAndAdd(out, a, b, scale) {
          out[0] = a[0] + b[0] * scale;
          out[1] = a[1] + b[1] * scale;
          out[2] = a[2] + b[2] * scale;
          out[3] = a[3] + b[3] * scale;
          return out;
        }
        /**
         * Alias for {@link mat2.multiply}
         * @function
         */

        var mul = multiply;
        /**
         * Alias for {@link mat2.subtract}
         * @function
         */

        var sub = subtract;
        // CONCATENATED MODULE: ./node_modules/gl-matrix/esm/vec2.js

        /**
         * 2 Dimensional Vector
         * @module vec2
         */

        /**
         * Creates a new, empty vec2
         *
         * @returns {vec2} a new 2D vector
         */

        function vec2_create() {
          var out = new ARRAY_TYPE(2);

          if (ARRAY_TYPE != Float32Array) {
            out[0] = 0;
            out[1] = 0;
          }

          return out;
        }
        /**
         * Creates a new vec2 initialized with values from an existing vector
         *
         * @param {ReadonlyVec2} a vector to clone
         * @returns {vec2} a new 2D vector
         */

        function vec2_clone(a) {
          var out = new ARRAY_TYPE(2);
          out[0] = a[0];
          out[1] = a[1];
          return out;
        }
        /**
         * Creates a new vec2 initialized with the given values
         *
         * @param {Number} x X component
         * @param {Number} y Y component
         * @returns {vec2} a new 2D vector
         */

        function vec2_fromValues(x, y) {
          var out = new ARRAY_TYPE(2);
          out[0] = x;
          out[1] = y;
          return out;
        }
        /**
         * Copy the values from one vec2 to another
         *
         * @param {vec2} out the receiving vector
         * @param {ReadonlyVec2} a the source vector
         * @returns {vec2} out
         */

        function vec2_copy(out, a) {
          out[0] = a[0];
          out[1] = a[1];
          return out;
        }
        /**
         * Set the components of a vec2 to the given values
         *
         * @param {vec2} out the receiving vector
         * @param {Number} x X component
         * @param {Number} y Y component
         * @returns {vec2} out
         */

        function vec2_set(out, x, y) {
          out[0] = x;
          out[1] = y;
          return out;
        }
        /**
         * Adds two vec2's
         *
         * @param {vec2} out the receiving vector
         * @param {ReadonlyVec2} a the first operand
         * @param {ReadonlyVec2} b the second operand
         * @returns {vec2} out
         */

        function vec2_add(out, a, b) {
          out[0] = a[0] + b[0];
          out[1] = a[1] + b[1];
          return out;
        }
        /**
         * Subtracts vector b from vector a
         *
         * @param {vec2} out the receiving vector
         * @param {ReadonlyVec2} a the first operand
         * @param {ReadonlyVec2} b the second operand
         * @returns {vec2} out
         */

        function vec2_subtract(out, a, b) {
          out[0] = a[0] - b[0];
          out[1] = a[1] - b[1];
          return out;
        }
        /**
         * Multiplies two vec2's
         *
         * @param {vec2} out the receiving vector
         * @param {ReadonlyVec2} a the first operand
         * @param {ReadonlyVec2} b the second operand
         * @returns {vec2} out
         */

        function vec2_multiply(out, a, b) {
          out[0] = a[0] * b[0];
          out[1] = a[1] * b[1];
          return out;
        }
        /**
         * Divides two vec2's
         *
         * @param {vec2} out the receiving vector
         * @param {ReadonlyVec2} a the first operand
         * @param {ReadonlyVec2} b the second operand
         * @returns {vec2} out
         */

        function divide(out, a, b) {
          out[0] = a[0] / b[0];
          out[1] = a[1] / b[1];
          return out;
        }
        /**
         * Math.ceil the components of a vec2
         *
         * @param {vec2} out the receiving vector
         * @param {ReadonlyVec2} a vector to ceil
         * @returns {vec2} out
         */

        function ceil(out, a) {
          out[0] = Math.ceil(a[0]);
          out[1] = Math.ceil(a[1]);
          return out;
        }
        /**
         * Math.floor the components of a vec2
         *
         * @param {vec2} out the receiving vector
         * @param {ReadonlyVec2} a vector to floor
         * @returns {vec2} out
         */

        function floor(out, a) {
          out[0] = Math.floor(a[0]);
          out[1] = Math.floor(a[1]);
          return out;
        }
        /**
         * Returns the minimum of two vec2's
         *
         * @param {vec2} out the receiving vector
         * @param {ReadonlyVec2} a the first operand
         * @param {ReadonlyVec2} b the second operand
         * @returns {vec2} out
         */

        function min(out, a, b) {
          out[0] = Math.min(a[0], b[0]);
          out[1] = Math.min(a[1], b[1]);
          return out;
        }
        /**
         * Returns the maximum of two vec2's
         *
         * @param {vec2} out the receiving vector
         * @param {ReadonlyVec2} a the first operand
         * @param {ReadonlyVec2} b the second operand
         * @returns {vec2} out
         */

        function max(out, a, b) {
          out[0] = Math.max(a[0], b[0]);
          out[1] = Math.max(a[1], b[1]);
          return out;
        }
        /**
         * Math.round the components of a vec2
         *
         * @param {vec2} out the receiving vector
         * @param {ReadonlyVec2} a vector to round
         * @returns {vec2} out
         */

        function round(out, a) {
          out[0] = Math.round(a[0]);
          out[1] = Math.round(a[1]);
          return out;
        }
        /**
         * Scales a vec2 by a scalar number
         *
         * @param {vec2} out the receiving vector
         * @param {ReadonlyVec2} a the vector to scale
         * @param {Number} b amount to scale the vector by
         * @returns {vec2} out
         */

        function vec2_scale(out, a, b) {
          out[0] = a[0] * b;
          out[1] = a[1] * b;
          return out;
        }
        /**
         * Adds two vec2's after scaling the second operand by a scalar value
         *
         * @param {vec2} out the receiving vector
         * @param {ReadonlyVec2} a the first operand
         * @param {ReadonlyVec2} b the second operand
         * @param {Number} scale the amount to scale b by before adding
         * @returns {vec2} out
         */

        function scaleAndAdd(out, a, b, scale) {
          out[0] = a[0] + b[0] * scale;
          out[1] = a[1] + b[1] * scale;
          return out;
        }
        /**
         * Calculates the euclidian distance between two vec2's
         *
         * @param {ReadonlyVec2} a the first operand
         * @param {ReadonlyVec2} b the second operand
         * @returns {Number} distance between a and b
         */

        function distance(a, b) {
          var x = b[0] - a[0],
            y = b[1] - a[1];
          return Math.hypot(x, y);
        }
        /**
         * Calculates the squared euclidian distance between two vec2's
         *
         * @param {ReadonlyVec2} a the first operand
         * @param {ReadonlyVec2} b the second operand
         * @returns {Number} squared distance between a and b
         */

        function squaredDistance(a, b) {
          var x = b[0] - a[0],
            y = b[1] - a[1];
          return x * x + y * y;
        }
        /**
         * Calculates the length of a vec2
         *
         * @param {ReadonlyVec2} a vector to calculate length of
         * @returns {Number} length of a
         */

        function vec2_length(a) {
          var x = a[0],
            y = a[1];
          return Math.hypot(x, y);
        }
        /**
         * Calculates the squared length of a vec2
         *
         * @param {ReadonlyVec2} a vector to calculate squared length of
         * @returns {Number} squared length of a
         */

        function squaredLength(a) {
          var x = a[0],
            y = a[1];
          return x * x + y * y;
        }
        /**
         * Negates the components of a vec2
         *
         * @param {vec2} out the receiving vector
         * @param {ReadonlyVec2} a vector to negate
         * @returns {vec2} out
         */

        function negate(out, a) {
          out[0] = -a[0];
          out[1] = -a[1];
          return out;
        }
        /**
         * Returns the inverse of the components of a vec2
         *
         * @param {vec2} out the receiving vector
         * @param {ReadonlyVec2} a vector to invert
         * @returns {vec2} out
         */

        function inverse(out, a) {
          out[0] = 1.0 / a[0];
          out[1] = 1.0 / a[1];
          return out;
        }
        /**
         * Normalize a vec2
         *
         * @param {vec2} out the receiving vector
         * @param {ReadonlyVec2} a vector to normalize
         * @returns {vec2} out
         */

        function normalize(out, a) {
          var x = a[0],
            y = a[1];
          var len = x * x + y * y;

          if (len > 0) {
            //TODO: evaluate use of glm_invsqrt here?
            len = 1 / Math.sqrt(len);
          }

          out[0] = a[0] * len;
          out[1] = a[1] * len;
          return out;
        }
        /**
         * Calculates the dot product of two vec2's
         *
         * @param {ReadonlyVec2} a the first operand
         * @param {ReadonlyVec2} b the second operand
         * @returns {Number} dot product of a and b
         */

        function dot(a, b) {
          return a[0] * b[0] + a[1] * b[1];
        }
        /**
         * Computes the cross product of two vec2's
         * Note that the cross product must by definition produce a 3D vector
         *
         * @param {vec3} out the receiving vector
         * @param {ReadonlyVec2} a the first operand
         * @param {ReadonlyVec2} b the second operand
         * @returns {vec3} out
         */

        function cross(out, a, b) {
          var z = a[0] * b[1] - a[1] * b[0];
          out[0] = out[1] = 0;
          out[2] = z;
          return out;
        }
        /**
         * Performs a linear interpolation between two vec2's
         *
         * @param {vec2} out the receiving vector
         * @param {ReadonlyVec2} a the first operand
         * @param {ReadonlyVec2} b the second operand
         * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
         * @returns {vec2} out
         */

        function lerp(out, a, b, t) {
          var ax = a[0],
            ay = a[1];
          out[0] = ax + t * (b[0] - ax);
          out[1] = ay + t * (b[1] - ay);
          return out;
        }
        /**
         * Generates a random vector with the given scale
         *
         * @param {vec2} out the receiving vector
         * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
         * @returns {vec2} out
         */

        function random(out, scale) {
          scale = scale || 1.0;
          var r = RANDOM() * 2.0 * Math.PI;
          out[0] = Math.cos(r) * scale;
          out[1] = Math.sin(r) * scale;
          return out;
        }
        /**
         * Transforms the vec2 with a mat2
         *
         * @param {vec2} out the receiving vector
         * @param {ReadonlyVec2} a the vector to transform
         * @param {ReadonlyMat2} m matrix to transform with
         * @returns {vec2} out
         */

        function transformMat2(out, a, m) {
          var x = a[0],
            y = a[1];
          out[0] = m[0] * x + m[2] * y;
          out[1] = m[1] * x + m[3] * y;
          return out;
        }
        /**
         * Transforms the vec2 with a mat2d
         *
         * @param {vec2} out the receiving vector
         * @param {ReadonlyVec2} a the vector to transform
         * @param {ReadonlyMat2d} m matrix to transform with
         * @returns {vec2} out
         */

        function transformMat2d(out, a, m) {
          var x = a[0],
            y = a[1];
          out[0] = m[0] * x + m[2] * y + m[4];
          out[1] = m[1] * x + m[3] * y + m[5];
          return out;
        }
        /**
         * Transforms the vec2 with a mat3
         * 3rd vector component is implicitly '1'
         *
         * @param {vec2} out the receiving vector
         * @param {ReadonlyVec2} a the vector to transform
         * @param {ReadonlyMat3} m matrix to transform with
         * @returns {vec2} out
         */

        function transformMat3(out, a, m) {
          var x = a[0],
            y = a[1];
          out[0] = m[0] * x + m[3] * y + m[6];
          out[1] = m[1] * x + m[4] * y + m[7];
          return out;
        }
        /**
         * Transforms the vec2 with a mat4
         * 3rd vector component is implicitly '0'
         * 4th vector component is implicitly '1'
         *
         * @param {vec2} out the receiving vector
         * @param {ReadonlyVec2} a the vector to transform
         * @param {ReadonlyMat4} m matrix to transform with
         * @returns {vec2} out
         */

        function transformMat4(out, a, m) {
          var x = a[0];
          var y = a[1];
          out[0] = m[0] * x + m[4] * y + m[12];
          out[1] = m[1] * x + m[5] * y + m[13];
          return out;
        }
        /**
         * Rotate a 2D vector
         * @param {vec2} out The receiving vec2
         * @param {ReadonlyVec2} a The vec2 point to rotate
         * @param {ReadonlyVec2} b The origin of the rotation
         * @param {Number} rad The angle of rotation in radians
         * @returns {vec2} out
         */

        function vec2_rotate(out, a, b, rad) {
          //Translate point to the origin
          var p0 = a[0] - b[0],
            p1 = a[1] - b[1],
            sinC = Math.sin(rad),
            cosC = Math.cos(rad); //perform rotation and translate to correct position

          out[0] = p0 * cosC - p1 * sinC + b[0];
          out[1] = p0 * sinC + p1 * cosC + b[1];
          return out;
        }
        /**
         * Get the angle between two 2D vectors
         * @param {ReadonlyVec2} a The first operand
         * @param {ReadonlyVec2} b The second operand
         * @returns {Number} The angle in radians
         */

        function angle(a, b) {
          var x1 = a[0],
            y1 = a[1],
            x2 = b[0],
            y2 = b[1],
            // mag is the product of the magnitudes of a and b
            mag = Math.sqrt(x1 * x1 + y1 * y1) * Math.sqrt(x2 * x2 + y2 * y2),
            // mag &&.. short circuits if mag == 0
            cosine = mag && (x1 * x2 + y1 * y2) / mag; // Math.min(Math.max(cosine, -1), 1) clamps the cosine between -1 and 1

          return Math.acos(Math.min(Math.max(cosine, -1), 1));
        }
        /**
         * Set the components of a vec2 to zero
         *
         * @param {vec2} out the receiving vector
         * @returns {vec2} out
         */

        function zero(out) {
          out[0] = 0.0;
          out[1] = 0.0;
          return out;
        }
        /**
         * Returns a string representation of a vector
         *
         * @param {ReadonlyVec2} a vector to represent as a string
         * @returns {String} string representation of the vector
         */

        function vec2_str(a) {
          return "vec2(" + a[0] + ", " + a[1] + ")";
        }
        /**
         * Returns whether or not the vectors exactly have the same elements in the same position (when compared with ===)
         *
         * @param {ReadonlyVec2} a The first vector.
         * @param {ReadonlyVec2} b The second vector.
         * @returns {Boolean} True if the vectors are equal, false otherwise.
         */

        function vec2_exactEquals(a, b) {
          return a[0] === b[0] && a[1] === b[1];
        }
        /**
         * Returns whether or not the vectors have approximately the same elements in the same position.
         *
         * @param {ReadonlyVec2} a The first vector.
         * @param {ReadonlyVec2} b The second vector.
         * @returns {Boolean} True if the vectors are equal, false otherwise.
         */

        function vec2_equals(a, b) {
          var a0 = a[0],
            a1 = a[1];
          var b0 = b[0],
            b1 = b[1];
          return (
            Math.abs(a0 - b0) <=
              EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) &&
            Math.abs(a1 - b1) <=
              EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1))
          );
        }
        /**
         * Alias for {@link vec2.length}
         * @function
         */

        var len = vec2_length;
        /**
         * Alias for {@link vec2.subtract}
         * @function
         */

        var vec2_sub = vec2_subtract;
        /**
         * Alias for {@link vec2.multiply}
         * @function
         */

        var vec2_mul = vec2_multiply;
        /**
         * Alias for {@link vec2.divide}
         * @function
         */

        var div = divide;
        /**
         * Alias for {@link vec2.distance}
         * @function
         */

        var dist = distance;
        /**
         * Alias for {@link vec2.squaredDistance}
         * @function
         */

        var sqrDist = squaredDistance;
        /**
         * Alias for {@link vec2.squaredLength}
         * @function
         */

        var sqrLen = squaredLength;
        /**
         * Perform some operation over an array of vec2s.
         *
         * @param {Array} a the array of vectors to iterate over
         * @param {Number} stride Number of elements between the start of each vec2. If 0 assumes tightly packed
         * @param {Number} offset Number of elements to skip at the beginning of the array
         * @param {Number} count Number of vec2s to iterate over. If 0 iterates over entire array
         * @param {Function} fn Function to call for each vector in the array
         * @param {Object} [arg] additional argument to pass to fn
         * @returns {Array} a
         * @function
         */

        var forEach = (function () {
          var vec = vec2_create();
          return function (a, stride, offset, count, fn, arg) {
            var i, l;

            if (!stride) {
              stride = 2;
            }

            if (!offset) {
              offset = 0;
            }

            if (count) {
              l = Math.min(count * stride + offset, a.length);
            } else {
              l = a.length;
            }

            for (i = offset; i < l; i += stride) {
              vec[0] = a[i];
              vec[1] = a[i + 1];
              fn(vec, vec, arg);
              a[i] = vec[0];
              a[i + 1] = vec[1];
            }

            return a;
          };
        })();
        // CONCATENATED MODULE: ./node_modules/gl-matrix/esm/vec3.js

        /**
         * 3 Dimensional Vector
         * @module vec3
         */

        /**
         * Creates a new, empty vec3
         *
         * @returns {vec3} a new 3D vector
         */

        function vec3_create() {
          var out = new ARRAY_TYPE(3);

          if (ARRAY_TYPE != Float32Array) {
            out[0] = 0;
            out[1] = 0;
            out[2] = 0;
          }

          return out;
        }
        /**
         * Creates a new vec3 initialized with values from an existing vector
         *
         * @param {ReadonlyVec3} a vector to clone
         * @returns {vec3} a new 3D vector
         */

        function vec3_clone(a) {
          var out = new ARRAY_TYPE(3);
          out[0] = a[0];
          out[1] = a[1];
          out[2] = a[2];
          return out;
        }
        /**
         * Calculates the length of a vec3
         *
         * @param {ReadonlyVec3} a vector to calculate length of
         * @returns {Number} length of a
         */

        function vec3_length(a) {
          var x = a[0];
          var y = a[1];
          var z = a[2];
          return Math.hypot(x, y, z);
        }
        /**
         * Creates a new vec3 initialized with the given values
         *
         * @param {Number} x X component
         * @param {Number} y Y component
         * @param {Number} z Z component
         * @returns {vec3} a new 3D vector
         */

        function vec3_fromValues(x, y, z) {
          var out = new ARRAY_TYPE(3);
          out[0] = x;
          out[1] = y;
          out[2] = z;
          return out;
        }
        /**
         * Copy the values from one vec3 to another
         *
         * @param {vec3} out the receiving vector
         * @param {ReadonlyVec3} a the source vector
         * @returns {vec3} out
         */

        function vec3_copy(out, a) {
          out[0] = a[0];
          out[1] = a[1];
          out[2] = a[2];
          return out;
        }
        /**
         * Set the components of a vec3 to the given values
         *
         * @param {vec3} out the receiving vector
         * @param {Number} x X component
         * @param {Number} y Y component
         * @param {Number} z Z component
         * @returns {vec3} out
         */

        function vec3_set(out, x, y, z) {
          out[0] = x;
          out[1] = y;
          out[2] = z;
          return out;
        }
        /**
         * Adds two vec3's
         *
         * @param {vec3} out the receiving vector
         * @param {ReadonlyVec3} a the first operand
         * @param {ReadonlyVec3} b the second operand
         * @returns {vec3} out
         */

        function vec3_add(out, a, b) {
          out[0] = a[0] + b[0];
          out[1] = a[1] + b[1];
          out[2] = a[2] + b[2];
          return out;
        }
        /**
         * Subtracts vector b from vector a
         *
         * @param {vec3} out the receiving vector
         * @param {ReadonlyVec3} a the first operand
         * @param {ReadonlyVec3} b the second operand
         * @returns {vec3} out
         */

        function vec3_subtract(out, a, b) {
          out[0] = a[0] - b[0];
          out[1] = a[1] - b[1];
          out[2] = a[2] - b[2];
          return out;
        }
        /**
         * Multiplies two vec3's
         *
         * @param {vec3} out the receiving vector
         * @param {ReadonlyVec3} a the first operand
         * @param {ReadonlyVec3} b the second operand
         * @returns {vec3} out
         */

        function vec3_multiply(out, a, b) {
          out[0] = a[0] * b[0];
          out[1] = a[1] * b[1];
          out[2] = a[2] * b[2];
          return out;
        }
        /**
         * Divides two vec3's
         *
         * @param {vec3} out the receiving vector
         * @param {ReadonlyVec3} a the first operand
         * @param {ReadonlyVec3} b the second operand
         * @returns {vec3} out
         */

        function vec3_divide(out, a, b) {
          out[0] = a[0] / b[0];
          out[1] = a[1] / b[1];
          out[2] = a[2] / b[2];
          return out;
        }
        /**
         * Math.ceil the components of a vec3
         *
         * @param {vec3} out the receiving vector
         * @param {ReadonlyVec3} a vector to ceil
         * @returns {vec3} out
         */

        function vec3_ceil(out, a) {
          out[0] = Math.ceil(a[0]);
          out[1] = Math.ceil(a[1]);
          out[2] = Math.ceil(a[2]);
          return out;
        }
        /**
         * Math.floor the components of a vec3
         *
         * @param {vec3} out the receiving vector
         * @param {ReadonlyVec3} a vector to floor
         * @returns {vec3} out
         */

        function vec3_floor(out, a) {
          out[0] = Math.floor(a[0]);
          out[1] = Math.floor(a[1]);
          out[2] = Math.floor(a[2]);
          return out;
        }
        /**
         * Returns the minimum of two vec3's
         *
         * @param {vec3} out the receiving vector
         * @param {ReadonlyVec3} a the first operand
         * @param {ReadonlyVec3} b the second operand
         * @returns {vec3} out
         */

        function vec3_min(out, a, b) {
          out[0] = Math.min(a[0], b[0]);
          out[1] = Math.min(a[1], b[1]);
          out[2] = Math.min(a[2], b[2]);
          return out;
        }
        /**
         * Returns the maximum of two vec3's
         *
         * @param {vec3} out the receiving vector
         * @param {ReadonlyVec3} a the first operand
         * @param {ReadonlyVec3} b the second operand
         * @returns {vec3} out
         */

        function vec3_max(out, a, b) {
          out[0] = Math.max(a[0], b[0]);
          out[1] = Math.max(a[1], b[1]);
          out[2] = Math.max(a[2], b[2]);
          return out;
        }
        /**
         * Math.round the components of a vec3
         *
         * @param {vec3} out the receiving vector
         * @param {ReadonlyVec3} a vector to round
         * @returns {vec3} out
         */

        function vec3_round(out, a) {
          out[0] = Math.round(a[0]);
          out[1] = Math.round(a[1]);
          out[2] = Math.round(a[2]);
          return out;
        }
        /**
         * Scales a vec3 by a scalar number
         *
         * @param {vec3} out the receiving vector
         * @param {ReadonlyVec3} a the vector to scale
         * @param {Number} b amount to scale the vector by
         * @returns {vec3} out
         */

        function vec3_scale(out, a, b) {
          out[0] = a[0] * b;
          out[1] = a[1] * b;
          out[2] = a[2] * b;
          return out;
        }
        /**
         * Adds two vec3's after scaling the second operand by a scalar value
         *
         * @param {vec3} out the receiving vector
         * @param {ReadonlyVec3} a the first operand
         * @param {ReadonlyVec3} b the second operand
         * @param {Number} scale the amount to scale b by before adding
         * @returns {vec3} out
         */

        function vec3_scaleAndAdd(out, a, b, scale) {
          out[0] = a[0] + b[0] * scale;
          out[1] = a[1] + b[1] * scale;
          out[2] = a[2] + b[2] * scale;
          return out;
        }
        /**
         * Calculates the euclidian distance between two vec3's
         *
         * @param {ReadonlyVec3} a the first operand
         * @param {ReadonlyVec3} b the second operand
         * @returns {Number} distance between a and b
         */

        function vec3_distance(a, b) {
          var x = b[0] - a[0];
          var y = b[1] - a[1];
          var z = b[2] - a[2];
          return Math.hypot(x, y, z);
        }
        /**
         * Calculates the squared euclidian distance between two vec3's
         *
         * @param {ReadonlyVec3} a the first operand
         * @param {ReadonlyVec3} b the second operand
         * @returns {Number} squared distance between a and b
         */

        function vec3_squaredDistance(a, b) {
          var x = b[0] - a[0];
          var y = b[1] - a[1];
          var z = b[2] - a[2];
          return x * x + y * y + z * z;
        }
        /**
         * Calculates the squared length of a vec3
         *
         * @param {ReadonlyVec3} a vector to calculate squared length of
         * @returns {Number} squared length of a
         */

        function vec3_squaredLength(a) {
          var x = a[0];
          var y = a[1];
          var z = a[2];
          return x * x + y * y + z * z;
        }
        /**
         * Negates the components of a vec3
         *
         * @param {vec3} out the receiving vector
         * @param {ReadonlyVec3} a vector to negate
         * @returns {vec3} out
         */

        function vec3_negate(out, a) {
          out[0] = -a[0];
          out[1] = -a[1];
          out[2] = -a[2];
          return out;
        }
        /**
         * Returns the inverse of the components of a vec3
         *
         * @param {vec3} out the receiving vector
         * @param {ReadonlyVec3} a vector to invert
         * @returns {vec3} out
         */

        function vec3_inverse(out, a) {
          out[0] = 1.0 / a[0];
          out[1] = 1.0 / a[1];
          out[2] = 1.0 / a[2];
          return out;
        }
        /**
         * Normalize a vec3
         *
         * @param {vec3} out the receiving vector
         * @param {ReadonlyVec3} a vector to normalize
         * @returns {vec3} out
         */

        function vec3_normalize(out, a) {
          var x = a[0];
          var y = a[1];
          var z = a[2];
          var len = x * x + y * y + z * z;

          if (len > 0) {
            //TODO: evaluate use of glm_invsqrt here?
            len = 1 / Math.sqrt(len);
          }

          out[0] = a[0] * len;
          out[1] = a[1] * len;
          out[2] = a[2] * len;
          return out;
        }
        /**
         * Calculates the dot product of two vec3's
         *
         * @param {ReadonlyVec3} a the first operand
         * @param {ReadonlyVec3} b the second operand
         * @returns {Number} dot product of a and b
         */

        function vec3_dot(a, b) {
          return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
        }
        /**
         * Computes the cross product of two vec3's
         *
         * @param {vec3} out the receiving vector
         * @param {ReadonlyVec3} a the first operand
         * @param {ReadonlyVec3} b the second operand
         * @returns {vec3} out
         */

        function vec3_cross(out, a, b) {
          var ax = a[0],
            ay = a[1],
            az = a[2];
          var bx = b[0],
            by = b[1],
            bz = b[2];
          out[0] = ay * bz - az * by;
          out[1] = az * bx - ax * bz;
          out[2] = ax * by - ay * bx;
          return out;
        }
        /**
         * Performs a linear interpolation between two vec3's
         *
         * @param {vec3} out the receiving vector
         * @param {ReadonlyVec3} a the first operand
         * @param {ReadonlyVec3} b the second operand
         * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
         * @returns {vec3} out
         */

        function vec3_lerp(out, a, b, t) {
          var ax = a[0];
          var ay = a[1];
          var az = a[2];
          out[0] = ax + t * (b[0] - ax);
          out[1] = ay + t * (b[1] - ay);
          out[2] = az + t * (b[2] - az);
          return out;
        }
        /**
         * Performs a hermite interpolation with two control points
         *
         * @param {vec3} out the receiving vector
         * @param {ReadonlyVec3} a the first operand
         * @param {ReadonlyVec3} b the second operand
         * @param {ReadonlyVec3} c the third operand
         * @param {ReadonlyVec3} d the fourth operand
         * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
         * @returns {vec3} out
         */

        function hermite(out, a, b, c, d, t) {
          var factorTimes2 = t * t;
          var factor1 = factorTimes2 * (2 * t - 3) + 1;
          var factor2 = factorTimes2 * (t - 2) + t;
          var factor3 = factorTimes2 * (t - 1);
          var factor4 = factorTimes2 * (3 - 2 * t);
          out[0] =
            a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;
          out[1] =
            a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;
          out[2] =
            a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;
          return out;
        }
        /**
         * Performs a bezier interpolation with two control points
         *
         * @param {vec3} out the receiving vector
         * @param {ReadonlyVec3} a the first operand
         * @param {ReadonlyVec3} b the second operand
         * @param {ReadonlyVec3} c the third operand
         * @param {ReadonlyVec3} d the fourth operand
         * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
         * @returns {vec3} out
         */

        function bezier(out, a, b, c, d, t) {
          var inverseFactor = 1 - t;
          var inverseFactorTimesTwo = inverseFactor * inverseFactor;
          var factorTimes2 = t * t;
          var factor1 = inverseFactorTimesTwo * inverseFactor;
          var factor2 = 3 * t * inverseFactorTimesTwo;
          var factor3 = 3 * factorTimes2 * inverseFactor;
          var factor4 = factorTimes2 * t;
          out[0] =
            a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;
          out[1] =
            a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;
          out[2] =
            a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;
          return out;
        }
        /**
         * Generates a random vector with the given scale
         *
         * @param {vec3} out the receiving vector
         * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
         * @returns {vec3} out
         */

        function vec3_random(out, scale) {
          scale = scale || 1.0;
          var r = RANDOM() * 2.0 * Math.PI;
          var z = RANDOM() * 2.0 - 1.0;
          var zScale = Math.sqrt(1.0 - z * z) * scale;
          out[0] = Math.cos(r) * zScale;
          out[1] = Math.sin(r) * zScale;
          out[2] = z * scale;
          return out;
        }
        /**
         * Transforms the vec3 with a mat4.
         * 4th vector component is implicitly '1'
         *
         * @param {vec3} out the receiving vector
         * @param {ReadonlyVec3} a the vector to transform
         * @param {ReadonlyMat4} m matrix to transform with
         * @returns {vec3} out
         */

        function vec3_transformMat4(out, a, m) {
          var x = a[0],
            y = a[1],
            z = a[2];
          var w = m[3] * x + m[7] * y + m[11] * z + m[15];
          w = w || 1.0;
          out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w;
          out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w;
          out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w;
          return out;
        }
        /**
         * Transforms the vec3 with a mat3.
         *
         * @param {vec3} out the receiving vector
         * @param {ReadonlyVec3} a the vector to transform
         * @param {ReadonlyMat3} m the 3x3 matrix to transform with
         * @returns {vec3} out
         */

        function vec3_transformMat3(out, a, m) {
          var x = a[0],
            y = a[1],
            z = a[2];
          out[0] = x * m[0] + y * m[3] + z * m[6];
          out[1] = x * m[1] + y * m[4] + z * m[7];
          out[2] = x * m[2] + y * m[5] + z * m[8];
          return out;
        }
        /**
         * Transforms the vec3 with a quat
         * Can also be used for dual quaternions. (Multiply it with the real part)
         *
         * @param {vec3} out the receiving vector
         * @param {ReadonlyVec3} a the vector to transform
         * @param {ReadonlyQuat} q quaternion to transform with
         * @returns {vec3} out
         */

        function transformQuat(out, a, q) {
          // benchmarks: https://jsperf.com/quaternion-transform-vec3-implementations-fixed
          var qx = q[0],
            qy = q[1],
            qz = q[2],
            qw = q[3];
          var x = a[0],
            y = a[1],
            z = a[2]; // var qvec = [qx, qy, qz];
          // var uv = vec3.cross([], qvec, a);

          var uvx = qy * z - qz * y,
            uvy = qz * x - qx * z,
            uvz = qx * y - qy * x; // var uuv = vec3.cross([], qvec, uv);

          var uuvx = qy * uvz - qz * uvy,
            uuvy = qz * uvx - qx * uvz,
            uuvz = qx * uvy - qy * uvx; // vec3.scale(uv, uv, 2 * w);

          var w2 = qw * 2;
          uvx *= w2;
          uvy *= w2;
          uvz *= w2; // vec3.scale(uuv, uuv, 2);

          uuvx *= 2;
          uuvy *= 2;
          uuvz *= 2; // return vec3.add(out, a, vec3.add(out, uv, uuv));

          out[0] = x + uvx + uuvx;
          out[1] = y + uvy + uuvy;
          out[2] = z + uvz + uuvz;
          return out;
        }
        /**
         * Rotate a 3D vector around the x-axis
         * @param {vec3} out The receiving vec3
         * @param {ReadonlyVec3} a The vec3 point to rotate
         * @param {ReadonlyVec3} b The origin of the rotation
         * @param {Number} rad The angle of rotation in radians
         * @returns {vec3} out
         */

        function rotateX(out, a, b, rad) {
          var p = [],
            r = []; //Translate point to the origin

          p[0] = a[0] - b[0];
          p[1] = a[1] - b[1];
          p[2] = a[2] - b[2]; //perform rotation

          r[0] = p[0];
          r[1] = p[1] * Math.cos(rad) - p[2] * Math.sin(rad);
          r[2] = p[1] * Math.sin(rad) + p[2] * Math.cos(rad); //translate to correct position

          out[0] = r[0] + b[0];
          out[1] = r[1] + b[1];
          out[2] = r[2] + b[2];
          return out;
        }
        /**
         * Rotate a 3D vector around the y-axis
         * @param {vec3} out The receiving vec3
         * @param {ReadonlyVec3} a The vec3 point to rotate
         * @param {ReadonlyVec3} b The origin of the rotation
         * @param {Number} rad The angle of rotation in radians
         * @returns {vec3} out
         */

        function rotateY(out, a, b, rad) {
          var p = [],
            r = []; //Translate point to the origin

          p[0] = a[0] - b[0];
          p[1] = a[1] - b[1];
          p[2] = a[2] - b[2]; //perform rotation

          r[0] = p[2] * Math.sin(rad) + p[0] * Math.cos(rad);
          r[1] = p[1];
          r[2] = p[2] * Math.cos(rad) - p[0] * Math.sin(rad); //translate to correct position

          out[0] = r[0] + b[0];
          out[1] = r[1] + b[1];
          out[2] = r[2] + b[2];
          return out;
        }
        /**
         * Rotate a 3D vector around the z-axis
         * @param {vec3} out The receiving vec3
         * @param {ReadonlyVec3} a The vec3 point to rotate
         * @param {ReadonlyVec3} b The origin of the rotation
         * @param {Number} rad The angle of rotation in radians
         * @returns {vec3} out
         */

        function rotateZ(out, a, b, rad) {
          var p = [],
            r = []; //Translate point to the origin

          p[0] = a[0] - b[0];
          p[1] = a[1] - b[1];
          p[2] = a[2] - b[2]; //perform rotation

          r[0] = p[0] * Math.cos(rad) - p[1] * Math.sin(rad);
          r[1] = p[0] * Math.sin(rad) + p[1] * Math.cos(rad);
          r[2] = p[2]; //translate to correct position

          out[0] = r[0] + b[0];
          out[1] = r[1] + b[1];
          out[2] = r[2] + b[2];
          return out;
        }
        /**
         * Get the angle between two 3D vectors
         * @param {ReadonlyVec3} a The first operand
         * @param {ReadonlyVec3} b The second operand
         * @returns {Number} The angle in radians
         */

        function vec3_angle(a, b) {
          var ax = a[0],
            ay = a[1],
            az = a[2],
            bx = b[0],
            by = b[1],
            bz = b[2],
            mag1 = Math.sqrt(ax * ax + ay * ay + az * az),
            mag2 = Math.sqrt(bx * bx + by * by + bz * bz),
            mag = mag1 * mag2,
            cosine = mag && vec3_dot(a, b) / mag;
          return Math.acos(Math.min(Math.max(cosine, -1), 1));
        }
        /**
         * Set the components of a vec3 to zero
         *
         * @param {vec3} out the receiving vector
         * @returns {vec3} out
         */

        function vec3_zero(out) {
          out[0] = 0.0;
          out[1] = 0.0;
          out[2] = 0.0;
          return out;
        }
        /**
         * Returns a string representation of a vector
         *
         * @param {ReadonlyVec3} a vector to represent as a string
         * @returns {String} string representation of the vector
         */

        function vec3_str(a) {
          return "vec3(" + a[0] + ", " + a[1] + ", " + a[2] + ")";
        }
        /**
         * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)
         *
         * @param {ReadonlyVec3} a The first vector.
         * @param {ReadonlyVec3} b The second vector.
         * @returns {Boolean} True if the vectors are equal, false otherwise.
         */

        function vec3_exactEquals(a, b) {
          return a[0] === b[0] && a[1] === b[1] && a[2] === b[2];
        }
        /**
         * Returns whether or not the vectors have approximately the same elements in the same position.
         *
         * @param {ReadonlyVec3} a The first vector.
         * @param {ReadonlyVec3} b The second vector.
         * @returns {Boolean} True if the vectors are equal, false otherwise.
         */

        function vec3_equals(a, b) {
          var a0 = a[0],
            a1 = a[1],
            a2 = a[2];
          var b0 = b[0],
            b1 = b[1],
            b2 = b[2];
          return (
            Math.abs(a0 - b0) <=
              EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) &&
            Math.abs(a1 - b1) <=
              EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) &&
            Math.abs(a2 - b2) <=
              EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2))
          );
        }
        /**
         * Alias for {@link vec3.subtract}
         * @function
         */

        var vec3_sub = vec3_subtract;
        /**
         * Alias for {@link vec3.multiply}
         * @function
         */

        var vec3_mul = vec3_multiply;
        /**
         * Alias for {@link vec3.divide}
         * @function
         */

        var vec3_div = vec3_divide;
        /**
         * Alias for {@link vec3.distance}
         * @function
         */

        var vec3_dist = vec3_distance;
        /**
         * Alias for {@link vec3.squaredDistance}
         * @function
         */

        var vec3_sqrDist = vec3_squaredDistance;
        /**
         * Alias for {@link vec3.length}
         * @function
         */

        var vec3_len = vec3_length;
        /**
         * Alias for {@link vec3.squaredLength}
         * @function
         */

        var vec3_sqrLen = vec3_squaredLength;
        /**
         * Perform some operation over an array of vec3s.
         *
         * @param {Array} a the array of vectors to iterate over
         * @param {Number} stride Number of elements between the start of each vec3. If 0 assumes tightly packed
         * @param {Number} offset Number of elements to skip at the beginning of the array
         * @param {Number} count Number of vec3s to iterate over. If 0 iterates over entire array
         * @param {Function} fn Function to call for each vector in the array
         * @param {Object} [arg] additional argument to pass to fn
         * @returns {Array} a
         * @function
         */

        var vec3_forEach = (function () {
          var vec = vec3_create();
          return function (a, stride, offset, count, fn, arg) {
            var i, l;

            if (!stride) {
              stride = 3;
            }

            if (!offset) {
              offset = 0;
            }

            if (count) {
              l = Math.min(count * stride + offset, a.length);
            } else {
              l = a.length;
            }

            for (i = offset; i < l; i += stride) {
              vec[0] = a[i];
              vec[1] = a[i + 1];
              vec[2] = a[i + 2];
              fn(vec, vec, arg);
              a[i] = vec[0];
              a[i + 1] = vec[1];
              a[i + 2] = vec[2];
            }

            return a;
          };
        })();
        // CONCATENATED MODULE: ./node_modules/gl-matrix/esm/index.js

        /***/
      },
      /* 6 */
      /***/ function (module, exports, __webpack_require__) {
        var _typeof = __webpack_require__(17)["default"];

        var assertThisInitialized = __webpack_require__(1);

        function _possibleConstructorReturn(self, call) {
          if (
            call &&
            (_typeof(call) === "object" || typeof call === "function")
          ) {
            return call;
          } else if (call !== void 0) {
            throw new TypeError(
              "Derived constructors may only return object or undefined"
            );
          }

          return assertThisInitialized(self);
        }

        (module.exports = _possibleConstructorReturn),
          (module.exports.__esModule = true),
          (module.exports["default"] = module.exports);

        /***/
      },
      /* 7 */
      /***/ function (module, exports, __webpack_require__) {
        var setPrototypeOf = __webpack_require__(40);

        function _inherits(subClass, superClass) {
          if (typeof superClass !== "function" && superClass !== null) {
            throw new TypeError(
              "Super expression must either be null or a function"
            );
          }

          subClass.prototype = Object.create(
            superClass && superClass.prototype,
            {
              constructor: {
                value: subClass,
                writable: true,
                configurable: true,
              },
            }
          );
          Object.defineProperty(subClass, "prototype", {
            writable: false,
          });
          if (superClass) setPrototypeOf(subClass, superClass);
        }

        (module.exports = _inherits),
          (module.exports.__esModule = true),
          (module.exports["default"] = module.exports);

        /***/
      },
      /* 8 */
      /***/ function (module, exports, __webpack_require__) {
        // TODO(Babel 8): Remove this file.
        var runtime = __webpack_require__(139)();

        module.exports = runtime; // Copied from https://github.com/facebook/regenerator/blob/main/packages/runtime/runtime.js#L736=

        try {
          regeneratorRuntime = runtime;
        } catch (accidentalStrictMode) {
          if (typeof globalThis === "object") {
            globalThis.regeneratorRuntime = runtime;
          } else {
            Function("r", "regeneratorRuntime = r")(runtime);
          }
        }

        /***/
      },
      /* 9 */
      /***/ function (module, __webpack_exports__, __webpack_require__) {
        "use strict";

        // EXPORTS
        __webpack_require__.d(__webpack_exports__, "h", function () {
          return /* binding */ imageRef;
        });
        __webpack_require__.d(__webpack_exports__, "i", function () {
          return /* binding */ otsuThreshold;
        });
        __webpack_require__.d(__webpack_exports__, "b", function () {
          return /* binding */ cv_utils_cluster;
        });
        __webpack_require__.d(__webpack_exports__, "j", function () {
          return /* binding */ topGeneric;
        });
        __webpack_require__.d(__webpack_exports__, "e", function () {
          return /* binding */ grayAndHalfSampleFromCanvasData;
        });
        __webpack_require__.d(__webpack_exports__, "c", function () {
          return /* binding */ computeGray;
        });
        __webpack_require__.d(__webpack_exports__, "f", function () {
          return /* binding */ halfSample;
        });
        __webpack_require__.d(__webpack_exports__, "g", function () {
          return /* binding */ hsv2rgb;
        });
        __webpack_require__.d(__webpack_exports__, "a", function () {
          return /* binding */ calculatePatchSize;
        });
        __webpack_require__.d(__webpack_exports__, "d", function () {
          return /* binding */ computeImageArea;
        });

        // UNUSED EXPORTS: computeIntegralImage2, computeIntegralImage, thresholdImage, computeHistogram, sharpenLine, determineOtsuThreshold, computeBinaryImage, Tracer, DILATE, ERODE, dilate, erode, subtract, bitwiseOr, countNonZero, grayArrayFromImage, grayArrayFromContext, loadImageArray, _computeDivisors, _parseCSSDimensionValues, _dimensionsConverters

        // EXTERNAL MODULE: ./node_modules/gl-matrix/esm/index.js + 4 modules
        var esm = __webpack_require__(5);

        // EXTERNAL MODULE: ./src/common/array_helper.ts
        var array_helper = __webpack_require__(11);

        // CONCATENATED MODULE: ./src/common/cluster.js
        // TODO: cluster.js and cv_utils.js are pretty tightly intertwined, making for a complex conversion
        // into typescript. be warned. :-)

        esm["a" /* glMatrix */].setMatrixArrayType(Array);
        /**
         * Creates a cluster for grouping similar orientations of datapoints
         */

        /* harmony default export */ var cluster = {
          create: function create(point, threshold) {
            var points = [];
            var center = {
              rad: 0,
              vec: esm["c" /* vec2 */].clone([0, 0]),
            };
            var pointMap = {};

            function _add(pointToAdd) {
              pointMap[pointToAdd.id] = pointToAdd;
              points.push(pointToAdd);
            }

            function updateCenter() {
              var i;
              var sum = 0;

              for (i = 0; i < points.length; i++) {
                sum += points[i].rad;
              }

              center.rad = sum / points.length;
              center.vec = esm["c" /* vec2 */].clone([
                Math.cos(center.rad),
                Math.sin(center.rad),
              ]);
            }

            function init() {
              _add(point);

              updateCenter();
            }

            init();
            return {
              add: function add(pointToAdd) {
                if (!pointMap[pointToAdd.id]) {
                  _add(pointToAdd);

                  updateCenter();
                }
              },
              fits: function fits(otherPoint) {
                // check cosine similarity to center-angle
                var similarity = Math.abs(
                  esm["c" /* vec2 */].dot(otherPoint.point.vec, center.vec)
                );

                if (similarity > threshold) {
                  return true;
                }

                return false;
              },
              getPoints: function getPoints() {
                return points;
              },
              getCenter: function getCenter() {
                return center;
              },
            };
          },
          createPoint: function createPoint(newPoint, id, property) {
            return {
              rad: newPoint[property],
              point: newPoint,
              id: id,
            };
          },
        };
        // CONCATENATED MODULE: ./src/common/cv_utils.js
        /* eslint-disable no-mixed-operators */

        /* eslint-disable no-bitwise */

        esm["a" /* glMatrix */].setMatrixArrayType(Array);
        /**
         * @param x x-coordinate
         * @param y y-coordinate
         * @return ImageReference {x,y} Coordinate
         */

        function imageRef(x, y) {
          var that = {
            x: x,
            y: y,
            toVec2: function toVec2() {
              return esm["c" /* vec2 */].clone([this.x, this.y]);
            },
            toVec3: function toVec3() {
              return esm["d" /* vec3 */].clone([this.x, this.y, 1]);
            },
            round: function round() {
              this.x =
                this.x > 0.0
                  ? Math.floor(this.x + 0.5)
                  : Math.floor(this.x - 0.5);
              this.y =
                this.y > 0.0
                  ? Math.floor(this.y + 0.5)
                  : Math.floor(this.y - 0.5);
              return this;
            },
          };
          return that;
        }
        /**
         * Computes an integral image of a given grayscale image.
         * @param imageDataContainer {ImageDataContainer} the image to be integrated
         */

        function computeIntegralImage2(imageWrapper, integralWrapper) {
          var imageData = imageWrapper.data;
          var width = imageWrapper.size.x;
          var height = imageWrapper.size.y;
          var integralImageData = integralWrapper.data;
          var sum = 0;
          var posA = 0;
          var posB = 0;
          var posC = 0;
          var posD = 0;
          var x;
          var y; // sum up first column

          posB = width;
          sum = 0;

          for (y = 1; y < height; y++) {
            sum += imageData[posA];
            integralImageData[posB] += sum;
            posA += width;
            posB += width;
          }

          posA = 0;
          posB = 1;
          sum = 0;

          for (x = 1; x < width; x++) {
            sum += imageData[posA];
            integralImageData[posB] += sum;
            posA++;
            posB++;
          }

          for (y = 1; y < height; y++) {
            posA = y * width + 1;
            posB = (y - 1) * width + 1;
            posC = y * width;
            posD = (y - 1) * width;

            for (x = 1; x < width; x++) {
              integralImageData[posA] +=
                imageData[posA] +
                integralImageData[posB] +
                integralImageData[posC] -
                integralImageData[posD];
              posA++;
              posB++;
              posC++;
              posD++;
            }
          }
        }
        function computeIntegralImage(imageWrapper, integralWrapper) {
          var imageData = imageWrapper.data;
          var width = imageWrapper.size.x;
          var height = imageWrapper.size.y;
          var integralImageData = integralWrapper.data;
          var sum = 0; // sum up first row

          for (var i = 0; i < width; i++) {
            sum += imageData[i];
            integralImageData[i] = sum;
          }

          for (var v = 1; v < height; v++) {
            sum = 0;

            for (var u = 0; u < width; u++) {
              sum += imageData[v * width + u];
              integralImageData[v * width + u] =
                sum + integralImageData[(v - 1) * width + u];
            }
          }
        }
        function thresholdImage(imageWrapper, threshold, targetWrapper) {
          if (!targetWrapper) {
            // eslint-disable-next-line no-param-reassign
            targetWrapper = imageWrapper;
          }

          var imageData = imageWrapper.data;
          var length = imageData.length;
          var targetData = targetWrapper.data;

          while (length--) {
            targetData[length] = imageData[length] < threshold ? 1 : 0;
          }
        }
        function computeHistogram(imageWrapper, bitsPerPixel) {
          if (!bitsPerPixel) {
            // eslint-disable-next-line no-param-reassign
            bitsPerPixel = 8;
          }

          var imageData = imageWrapper.data;
          var length = imageData.length;
          var bitShift = 8 - bitsPerPixel;
          var bucketCnt = 1 << bitsPerPixel;
          var hist = new Int32Array(bucketCnt);

          while (length--) {
            hist[imageData[length] >> bitShift]++;
          }

          return hist;
        }
        function sharpenLine(line) {
          var i;
          var length = line.length;
          var left = line[0];
          var center = line[1];
          var right;

          for (i = 1; i < length - 1; i++) {
            right = line[i + 1]; //  -1 4 -1 kernel
            // eslint-disable-next-line no-param-reassign

            line[i - 1] = (center * 2 - left - right) & 255;
            left = center;
            center = right;
          }

          return line;
        }
        function determineOtsuThreshold(imageWrapper) {
          var bitsPerPixel =
            arguments.length > 1 && arguments[1] !== undefined
              ? arguments[1]
              : 8;
          var hist;
          var bitShift = 8 - bitsPerPixel;

          function px(init, end) {
            var sum = 0;

            for (var i = init; i <= end; i++) {
              sum += hist[i];
            }

            return sum;
          }

          function mx(init, end) {
            var sum = 0;

            for (var i = init; i <= end; i++) {
              sum += i * hist[i];
            }

            return sum;
          }

          function determineThreshold() {
            var vet = [0];
            var p1;
            var p2;
            var p12;
            var m1;
            var m2;
            var m12;
            var max = (1 << bitsPerPixel) - 1;
            hist = computeHistogram(imageWrapper, bitsPerPixel);

            for (var k = 1; k < max; k++) {
              p1 = px(0, k);
              p2 = px(k + 1, max);
              p12 = p1 * p2;

              if (p12 === 0) {
                p12 = 1;
              }

              m1 = mx(0, k) * p2;
              m2 = mx(k + 1, max) * p1;
              m12 = m1 - m2;
              vet[k] = (m12 * m12) / p12;
            }

            return array_helper["a" /* default */].maxIndex(vet);
          }

          var threshold = determineThreshold();
          return threshold << bitShift;
        }
        function otsuThreshold(imageWrapper, targetWrapper) {
          var threshold = determineOtsuThreshold(imageWrapper);
          thresholdImage(imageWrapper, threshold, targetWrapper);
          return threshold;
        } // local thresholding

        function computeBinaryImage(
          imageWrapper,
          integralWrapper,
          targetWrapper
        ) {
          computeIntegralImage(imageWrapper, integralWrapper);

          if (!targetWrapper) {
            // eslint-disable-next-line no-param-reassign
            targetWrapper = imageWrapper;
          }

          var imageData = imageWrapper.data;
          var targetData = targetWrapper.data;
          var width = imageWrapper.size.x;
          var height = imageWrapper.size.y;
          var integralImageData = integralWrapper.data;
          var sum = 0;
          var v;
          var u;
          var kernel = 3;
          var A;
          var B;
          var C;
          var D;
          var avg;
          var size = (kernel * 2 + 1) * (kernel * 2 + 1); // clear out top & bottom-border

          for (v = 0; v <= kernel; v++) {
            for (u = 0; u < width; u++) {
              targetData[v * width + u] = 0;
              targetData[(height - 1 - v) * width + u] = 0;
            }
          } // clear out left & right border

          for (v = kernel; v < height - kernel; v++) {
            for (u = 0; u <= kernel; u++) {
              targetData[v * width + u] = 0;
              targetData[v * width + (width - 1 - u)] = 0;
            }
          }

          for (v = kernel + 1; v < height - kernel - 1; v++) {
            for (u = kernel + 1; u < width - kernel; u++) {
              A =
                integralImageData[(v - kernel - 1) * width + (u - kernel - 1)];
              B = integralImageData[(v - kernel - 1) * width + (u + kernel)];
              C = integralImageData[(v + kernel) * width + (u - kernel - 1)];
              D = integralImageData[(v + kernel) * width + (u + kernel)];
              sum = D - C - B + A;
              avg = sum / size;
              targetData[v * width + u] =
                imageData[v * width + u] > avg + 5 ? 0 : 1;
            }
          }
        }
        function cv_utils_cluster(points, threshold, property) {
          var i;
          var k;
          var thisCluster;
          var point;
          var clusters = [];

          if (!property) {
            // eslint-disable-next-line no-param-reassign
            property = "rad";
          }

          function addToCluster(newPoint) {
            var found = false;

            for (k = 0; k < clusters.length; k++) {
              thisCluster = clusters[k];

              if (thisCluster.fits(newPoint)) {
                thisCluster.add(newPoint);
                found = true;
              }
            }

            return found;
          } // iterate over each cloud

          for (i = 0; i < points.length; i++) {
            point = cluster.createPoint(points[i], i, property);

            if (!addToCluster(point)) {
              clusters.push(cluster.create(point, threshold));
            }
          }

          return clusters;
        }
        var Tracer = {
          trace: function trace(points, vec) {
            var iteration;
            var maxIterations = 10;
            var top = [];
            var result = [];
            var centerPos = 0;
            var currentPos = 0;

            function trace(idx, forward) {
              var to;
              var toIdx;
              var predictedPos;
              var thresholdX = 1;
              var thresholdY = Math.abs(vec[1] / 10);
              var found = false;

              function match(pos, predicted) {
                if (
                  pos.x > predicted.x - thresholdX &&
                  pos.x < predicted.x + thresholdX &&
                  pos.y > predicted.y - thresholdY &&
                  pos.y < predicted.y + thresholdY
                ) {
                  return true;
                }

                return false;
              } // check if the next index is within the vec specifications
              // if not, check as long as the threshold is met

              var from = points[idx];

              if (forward) {
                predictedPos = {
                  x: from.x + vec[0],
                  y: from.y + vec[1],
                };
              } else {
                predictedPos = {
                  x: from.x - vec[0],
                  y: from.y - vec[1],
                };
              }

              toIdx = forward ? idx + 1 : idx - 1;
              to = points[toIdx]; // eslint-disable-next-line no-cond-assign

              while (
                to &&
                (found = match(to, predictedPos)) !== true &&
                Math.abs(to.y - from.y) < vec[1]
              ) {
                toIdx = forward ? toIdx + 1 : toIdx - 1;
                to = points[toIdx];
              }

              return found ? toIdx : null;
            }

            for (iteration = 0; iteration < maxIterations; iteration++) {
              // randomly select point to start with
              centerPos = Math.floor(Math.random() * points.length); // trace forward

              top = [];
              currentPos = centerPos;
              top.push(points[currentPos]); // eslint-disable-next-line no-cond-assign

              while ((currentPos = trace(currentPos, true)) !== null) {
                top.push(points[currentPos]);
              }

              if (centerPos > 0) {
                currentPos = centerPos; // eslint-disable-next-line no-cond-assign

                while ((currentPos = trace(currentPos, false)) !== null) {
                  top.push(points[currentPos]);
                }
              }

              if (top.length > result.length) {
                result = top;
              }
            }

            return result;
          },
        };
        var DILATE = 1;
        var ERODE = 2;
        function dilate(inImageWrapper, outImageWrapper) {
          var v;
          var u;
          var inImageData = inImageWrapper.data;
          var outImageData = outImageWrapper.data;
          var height = inImageWrapper.size.y;
          var width = inImageWrapper.size.x;
          var sum;
          var yStart1;
          var yStart2;
          var xStart1;
          var xStart2;

          for (v = 1; v < height - 1; v++) {
            for (u = 1; u < width - 1; u++) {
              yStart1 = v - 1;
              yStart2 = v + 1;
              xStart1 = u - 1;
              xStart2 = u + 1;
              sum =
                inImageData[yStart1 * width + xStart1] +
                inImageData[yStart1 * width + xStart2] +
                inImageData[v * width + u] +
                inImageData[yStart2 * width + xStart1] +
                inImageData[yStart2 * width + xStart2];
              outImageData[v * width + u] = sum > 0 ? 1 : 0;
            }
          }
        }
        function erode(inImageWrapper, outImageWrapper) {
          var v;
          var u;
          var inImageData = inImageWrapper.data;
          var outImageData = outImageWrapper.data;
          var height = inImageWrapper.size.y;
          var width = inImageWrapper.size.x;
          var sum;
          var yStart1;
          var yStart2;
          var xStart1;
          var xStart2;

          for (v = 1; v < height - 1; v++) {
            for (u = 1; u < width - 1; u++) {
              yStart1 = v - 1;
              yStart2 = v + 1;
              xStart1 = u - 1;
              xStart2 = u + 1;
              sum =
                inImageData[yStart1 * width + xStart1] +
                inImageData[yStart1 * width + xStart2] +
                inImageData[v * width + u] +
                inImageData[yStart2 * width + xStart1] +
                inImageData[yStart2 * width + xStart2];
              outImageData[v * width + u] = sum === 5 ? 1 : 0;
            }
          }
        }
        function subtract(aImageWrapper, bImageWrapper, resultImageWrapper) {
          if (!resultImageWrapper) {
            // eslint-disable-next-line no-param-reassign
            resultImageWrapper = aImageWrapper;
          }

          var length = aImageWrapper.data.length;
          var aImageData = aImageWrapper.data;
          var bImageData = bImageWrapper.data;
          var cImageData = resultImageWrapper.data;

          while (length--) {
            cImageData[length] = aImageData[length] - bImageData[length];
          }
        }
        function bitwiseOr(aImageWrapper, bImageWrapper, resultImageWrapper) {
          if (!resultImageWrapper) {
            // eslint-disable-next-line no-param-reassign
            resultImageWrapper = aImageWrapper;
          }

          var length = aImageWrapper.data.length;
          var aImageData = aImageWrapper.data;
          var bImageData = bImageWrapper.data;
          var cImageData = resultImageWrapper.data;

          while (length--) {
            cImageData[length] = aImageData[length] || bImageData[length];
          }
        }
        function countNonZero(imageWrapper) {
          var length = imageWrapper.data.length;
          var data = imageWrapper.data;
          var sum = 0;

          while (length--) {
            sum += data[length];
          }

          return sum;
        }
        function topGeneric(list, top, scoreFunc) {
          var i;
          var minIdx = 0;
          var min = 0;
          var queue = [];
          var score;
          var hit;
          var pos;

          for (i = 0; i < top; i++) {
            queue[i] = {
              score: 0,
              item: null,
            };
          }

          for (i = 0; i < list.length; i++) {
            score = scoreFunc.apply(this, [list[i]]);

            if (score > min) {
              hit = queue[minIdx];
              hit.score = score;
              hit.item = list[i];
              min = Number.MAX_VALUE;

              for (pos = 0; pos < top; pos++) {
                if (queue[pos].score < min) {
                  min = queue[pos].score;
                  minIdx = pos;
                }
              }
            }
          }

          return queue;
        }
        function grayArrayFromImage(htmlImage, offsetX, ctx, array) {
          ctx.drawImage(
            htmlImage,
            offsetX,
            0,
            htmlImage.width,
            htmlImage.height
          );
          var ctxData = ctx.getImageData(
            offsetX,
            0,
            htmlImage.width,
            htmlImage.height
          ).data;
          computeGray(ctxData, array);
        }
        function grayArrayFromContext(ctx, size, offset, array) {
          var ctxData = ctx.getImageData(
            offset.x,
            offset.y,
            size.x,
            size.y
          ).data;
          computeGray(ctxData, array);
        }
        function grayAndHalfSampleFromCanvasData(canvasData, size, outArray) {
          var topRowIdx = 0;
          var bottomRowIdx = size.x;
          var endIdx = Math.floor(canvasData.length / 4);
          var outWidth = size.x / 2;
          var outImgIdx = 0;
          var inWidth = size.x;
          var i;

          while (bottomRowIdx < endIdx) {
            for (i = 0; i < outWidth; i++) {
              // eslint-disable-next-line no-param-reassign
              outArray[outImgIdx] =
                (0.299 * canvasData[topRowIdx * 4 + 0] +
                  0.587 * canvasData[topRowIdx * 4 + 1] +
                  0.114 * canvasData[topRowIdx * 4 + 2] +
                  (0.299 * canvasData[(topRowIdx + 1) * 4 + 0] +
                    0.587 * canvasData[(topRowIdx + 1) * 4 + 1] +
                    0.114 * canvasData[(topRowIdx + 1) * 4 + 2]) +
                  (0.299 * canvasData[bottomRowIdx * 4 + 0] +
                    0.587 * canvasData[bottomRowIdx * 4 + 1] +
                    0.114 * canvasData[bottomRowIdx * 4 + 2]) +
                  (0.299 * canvasData[(bottomRowIdx + 1) * 4 + 0] +
                    0.587 * canvasData[(bottomRowIdx + 1) * 4 + 1] +
                    0.114 * canvasData[(bottomRowIdx + 1) * 4 + 2])) /
                4;
              outImgIdx++;
              topRowIdx += 2;
              bottomRowIdx += 2;
            }

            topRowIdx += inWidth;
            bottomRowIdx += inWidth;
          }
        }
        function computeGray(imageData, outArray, config) {
          var l = (imageData.length / 4) | 0;
          var singleChannel = config && config.singleChannel === true;

          if (singleChannel) {
            for (var i = 0; i < l; i++) {
              // eslint-disable-next-line no-param-reassign
              outArray[i] = imageData[i * 4 + 0];
            }
          } else {
            for (var _i = 0; _i < l; _i++) {
              // eslint-disable-next-line no-param-reassign
              outArray[_i] =
                0.299 * imageData[_i * 4 + 0] +
                0.587 * imageData[_i * 4 + 1] +
                0.114 * imageData[_i * 4 + 2];
            }
          }
        }
        function loadImageArray(src, callback) {
          var canvas =
            arguments.length > 2 && arguments[2] !== undefined
              ? arguments[2]
              : document && document.createElement("canvas");
          var img = new Image();
          img.callback = callback;

          img.onload = function () {
            // eslint-disable-next-line no-param-reassign
            canvas.width = this.width; // eslint-disable-next-line no-param-reassign

            canvas.height = this.height;
            var ctx = canvas.getContext("2d");
            ctx.drawImage(this, 0, 0);
            var array = new Uint8Array(this.width * this.height);
            ctx.drawImage(this, 0, 0);

            var _ctx$getImageData = ctx.getImageData(
                0,
                0,
                this.width,
                this.height
              ),
              data = _ctx$getImageData.data;

            computeGray(data, array);
            this.callback(
              array,
              {
                x: this.width,
                y: this.height,
              },
              this
            );
          };

          img.src = src;
        }
        /**
         * @param inImg {ImageWrapper} input image to be sampled
         * @param outImg {ImageWrapper} to be stored in
         */

        function halfSample(inImgWrapper, outImgWrapper) {
          var inImg = inImgWrapper.data;
          var inWidth = inImgWrapper.size.x;
          var outImg = outImgWrapper.data;
          var topRowIdx = 0;
          var bottomRowIdx = inWidth;
          var endIdx = inImg.length;
          var outWidth = inWidth / 2;
          var outImgIdx = 0;

          while (bottomRowIdx < endIdx) {
            for (var i = 0; i < outWidth; i++) {
              outImg[outImgIdx] = Math.floor(
                (inImg[topRowIdx] +
                  inImg[topRowIdx + 1] +
                  inImg[bottomRowIdx] +
                  inImg[bottomRowIdx + 1]) /
                  4
              );
              outImgIdx++;
              topRowIdx += 2;
              bottomRowIdx += 2;
            }

            topRowIdx += inWidth;
            bottomRowIdx += inWidth;
          }
        }
        function hsv2rgb(hsv) {
          var rgb =
            arguments.length > 1 && arguments[1] !== undefined
              ? arguments[1]
              : [0, 0, 0];
          var h = hsv[0];
          var s = hsv[1];
          var v = hsv[2];
          var c = v * s;
          var x = c * (1 - Math.abs(((h / 60) % 2) - 1));
          var m = v - c;
          var r = 0;
          var g = 0;
          var b = 0;

          if (h < 60) {
            r = c;
            g = x;
          } else if (h < 120) {
            r = x;
            g = c;
          } else if (h < 180) {
            g = c;
            b = x;
          } else if (h < 240) {
            g = x;
            b = c;
          } else if (h < 300) {
            r = x;
            b = c;
          } else if (h < 360) {
            r = c;
            b = x;
          } // eslint-disable-next-line no-param-reassign

          rgb[0] = ((r + m) * 255) | 0; // eslint-disable-next-line no-param-reassign

          rgb[1] = ((g + m) * 255) | 0; // eslint-disable-next-line no-param-reassign

          rgb[2] = ((b + m) * 255) | 0;
          return rgb;
        }
        function _computeDivisors(n) {
          var largeDivisors = [];
          var divisors = [];

          for (var i = 1; i < Math.sqrt(n) + 1; i++) {
            if (n % i === 0) {
              divisors.push(i);

              if (i !== n / i) {
                largeDivisors.unshift(Math.floor(n / i));
              }
            }
          }

          return divisors.concat(largeDivisors);
        }

        function _computeIntersection(arr1, arr2) {
          var i = 0;
          var j = 0;
          var result = [];

          while (i < arr1.length && j < arr2.length) {
            if (arr1[i] === arr2[j]) {
              result.push(arr1[i]);
              i++;
              j++;
            } else if (arr1[i] > arr2[j]) {
              j++;
            } else {
              i++;
            }
          }

          return result;
        }

        function calculatePatchSize(patchSize, imgSize) {
          var divisorsX = _computeDivisors(imgSize.x);

          var divisorsY = _computeDivisors(imgSize.y);

          var wideSide = Math.max(imgSize.x, imgSize.y);

          var common = _computeIntersection(divisorsX, divisorsY);

          var nrOfPatchesList = [8, 10, 15, 20, 32, 60, 80];
          var nrOfPatchesMap = {
            "x-small": 5,
            small: 4,
            medium: 3,
            large: 2,
            "x-large": 1,
          };
          var nrOfPatchesIdx =
            nrOfPatchesMap[patchSize] || nrOfPatchesMap.medium;
          var nrOfPatches = nrOfPatchesList[nrOfPatchesIdx];
          var desiredPatchSize = Math.floor(wideSide / nrOfPatches);
          var optimalPatchSize;

          function findPatchSizeForDivisors(divisors) {
            var i = 0;
            var found = divisors[Math.floor(divisors.length / 2)];

            while (i < divisors.length - 1 && divisors[i] < desiredPatchSize) {
              i++;
            }

            if (i > 0) {
              if (
                Math.abs(divisors[i] - desiredPatchSize) >
                Math.abs(divisors[i - 1] - desiredPatchSize)
              ) {
                found = divisors[i - 1];
              } else {
                found = divisors[i];
              }
            }

            if (
              desiredPatchSize / found <
                nrOfPatchesList[nrOfPatchesIdx + 1] /
                  nrOfPatchesList[nrOfPatchesIdx] &&
              desiredPatchSize / found >
                nrOfPatchesList[nrOfPatchesIdx - 1] /
                  nrOfPatchesList[nrOfPatchesIdx]
            ) {
              return {
                x: found,
                y: found,
              };
            }

            return null;
          }

          optimalPatchSize = findPatchSizeForDivisors(common);

          if (!optimalPatchSize) {
            optimalPatchSize = findPatchSizeForDivisors(
              _computeDivisors(wideSide)
            );

            if (!optimalPatchSize) {
              optimalPatchSize = findPatchSizeForDivisors(
                _computeDivisors(desiredPatchSize * nrOfPatches)
              );
            }
          }

          return optimalPatchSize;
        }
        function _parseCSSDimensionValues(value) {
          var dimension = {
            value: parseFloat(value),
            unit: value.indexOf("%") === value.length - 1 ? "%" : "%",
          };
          return dimension;
        }
        var _dimensionsConverters = {
          top: function top(dimension, context) {
            return dimension.unit === "%"
              ? Math.floor(context.height * (dimension.value / 100))
              : null;
          },
          right: function right(dimension, context) {
            return dimension.unit === "%"
              ? Math.floor(
                  context.width - context.width * (dimension.value / 100)
                )
              : null;
          },
          bottom: function bottom(dimension, context) {
            return dimension.unit === "%"
              ? Math.floor(
                  context.height - context.height * (dimension.value / 100)
                )
              : null;
          },
          left: function left(dimension, context) {
            return dimension.unit === "%"
              ? Math.floor(context.width * (dimension.value / 100))
              : null;
          },
        };
        function computeImageArea(inputWidth, inputHeight, area) {
          var context = {
            width: inputWidth,
            height: inputHeight,
          };
          var parsedArea = Object.keys(area).reduce(function (result, key) {
            var value = area[key];

            var parsed = _parseCSSDimensionValues(value);

            var calculated = _dimensionsConverters[key](parsed, context); // eslint-disable-next-line no-param-reassign

            result[key] = calculated;
            return result;
          }, {});
          return {
            sx: parsedArea.left,
            sy: parsedArea.top,
            sw: parsedArea.right - parsedArea.left,
            sh: parsedArea.bottom - parsedArea.top,
          };
        }

        /***/
      },
      /* 10 */
      /***/ function (module, __webpack_exports__, __webpack_require__) {
        "use strict";
        // TODO: XYPosition should be an XYObject, but that breaks XYDefinition, which breaks drawPath() below.
        // XYDefinition tells us which component of a given array or object is the "X" and which is the "Y".
        // Usually this is 0 for X and 1 for Y, but might be used as 'x' for x and 'y' for Y.
        /* harmony default export */ __webpack_exports__["a"] = {
          drawRect: function drawRect(pos, size, ctx, style) {
            ctx.strokeStyle = style.color;
            ctx.fillStyle = style.color;
            ctx.lineWidth = style.lineWidth || 1;
            ctx.beginPath();
            ctx.strokeRect(pos.x, pos.y, size.x, size.y);
          },
          drawPath: function drawPath(path, def, ctx, style) {
            ctx.strokeStyle = style.color;
            ctx.fillStyle = style.color;
            ctx.lineWidth = style.lineWidth;
            ctx.beginPath();
            ctx.moveTo(path[0][def.x], path[0][def.y]);

            for (var j = 1; j < path.length; j++) {
              ctx.lineTo(path[j][def.x], path[j][def.y]);
            }

            ctx.closePath();
            ctx.stroke();
          },
          drawImage: function drawImage(imageData, size, ctx) {
            var canvasData = ctx.getImageData(0, 0, size.x, size.y);
            var data = canvasData.data;
            var canvasDataPos = data.length;
            var imageDataPos = imageData.length;

            if (canvasDataPos / imageDataPos !== 4) {
              return false;
            }

            while (imageDataPos--) {
              var value = imageData[imageDataPos];
              data[--canvasDataPos] = 255;
              data[--canvasDataPos] = value;
              data[--canvasDataPos] = value;
              data[--canvasDataPos] = value;
            }

            ctx.putImageData(canvasData, 0, 0);
            return true;
          },
        };

        /***/
      },
      /* 11 */
      /***/ function (module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* eslint-disable no-param-reassign */
        /* harmony default export */ __webpack_exports__["a"] = {
          init: function init(arr, val) {
            arr.fill(val);
          },

          /**
           * IN-PLACE Shuffles the content of an array
           */
          shuffle: function shuffle(arr) {
            // Durstenfeld shuffle algorithm
            // https://stackoverflow.com/questions/2450954/how-to-randomize-shuffle-a-javascript-array
            for (var i = arr.length - 1; i > 0; i--) {
              var j = Math.floor(Math.random() * (i + 1));
              var _ref = [arr[j], arr[i]];
              arr[i] = _ref[0];
              arr[j] = _ref[1];
            }

            return arr;
          },
          toPointList: function toPointList(arr) {
            var rows = arr.reduce(function (p, n) {
              var row = "[".concat(n.join(","), "]");
              p.push(row);
              return p;
            }, []);
            return "[".concat(rows.join(",\r\n"), "]");
          },

          /**
           * returns the elements which's score is bigger than the threshold
           */
          // eslint-disable-next-line no-unused-vars
          threshold: function threshold(arr, _threshold, scoreFunc) {
            var queue = arr.reduce(function (prev, next) {
              if (scoreFunc.apply(arr, [next]) >= _threshold) {
                prev.push(next);
              }

              return prev;
            }, []);
            return queue;
          },
          maxIndex: function maxIndex(arr) {
            var max = 0;

            for (var i = 0; i < arr.length; i++) {
              if (arr[i] > arr[max]) {
                max = i;
              }
            }

            return max;
          },
          max: function max(arr) {
            var max = 0;

            for (var i = 0; i < arr.length; i++) {
              if (arr[i] > max) {
                max = arr[i];
              }
            }

            return max;
          },
          sum: function sum(arr) {
            var length = arr.length;
            var sum = 0;

            while (length--) {
              sum += arr[length];
            }

            return sum;
          },
        };

        /***/
      },
      /* 12 */
      /***/ function (module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony import */ var _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_0__ =
          __webpack_require__(61);
        /* harmony import */ var _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_0___default =
          /*#__PURE__*/ __webpack_require__.n(
            _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_0__
          );
        /* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1__ =
          __webpack_require__(3);
        /* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1___default =
          /*#__PURE__*/ __webpack_require__.n(
            _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1__
          );
        /* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2__ =
          __webpack_require__(4);
        /* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2___default =
          /*#__PURE__*/ __webpack_require__.n(
            _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2__
          );
        /* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_3__ =
          __webpack_require__(0);
        /* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_3___default =
          /*#__PURE__*/ __webpack_require__.n(
            _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_3__
          );
        /* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_4__ =
          __webpack_require__(5);
        /* harmony import */ var _array_helper__WEBPACK_IMPORTED_MODULE_5__ =
          __webpack_require__(11);
        /* harmony import */ var _cv_utils__WEBPACK_IMPORTED_MODULE_6__ =
          __webpack_require__(9);

        gl_matrix__WEBPACK_IMPORTED_MODULE_4__[
          /* glMatrix */ "a"
        ].setMatrixArrayType(Array);

        function assertNumberPositive(val) {
          if (val < 0) {
            throw new Error("expected positive number, received ".concat(val));
          }
        }

        var ImageWrapper = /*#__PURE__*/ (function () {
          // Represents a basic image combining the data and size. In addition, some methods for
          // manipulation are contained within.
          function ImageWrapper(size, data) {
            var ArrayType =
              arguments.length > 2 && arguments[2] !== undefined
                ? arguments[2]
                : Uint8Array;
            var initialize = arguments.length > 3 ? arguments[3] : undefined;

            _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1___default()(
              this,
              ImageWrapper
            );

            _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_3___default()(
              this,
              "data",
              void 0
            );

            _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_3___default()(
              this,
              "size",
              void 0
            );

            _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_3___default()(
              this,
              "indexMapping",
              void 0
            );

            if (!data) {
              this.data = new ArrayType(size.x * size.y);

              if (initialize) {
                _array_helper__WEBPACK_IMPORTED_MODULE_5__[
                  /* default */ "a"
                ].init(this.data, 0);
              }
            } else {
              this.data = data;
            }

            this.size = size;
          } // tests if a position is within the image, extended out by a border on each side

          _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2___default()(
            ImageWrapper,
            [
              {
                key: "inImageWithBorder",
                value: function inImageWithBorder(imgRef) {
                  var border =
                    arguments.length > 1 && arguments[1] !== undefined
                      ? arguments[1]
                      : 0;
                  assertNumberPositive(border);
                  return (
                    imgRef.x >= 0 &&
                    imgRef.y >= 0 &&
                    imgRef.x < this.size.x + border * 2 &&
                    imgRef.y < this.size.y + border * 2
                  );
                }, // Copy from THIS ImageWrapper to the new imageWrapper parameter, starting at from, stopping at
                // end of new imageWrapper size.
              },
              {
                key: "subImageAsCopy",
                value: function subImageAsCopy(imageWrapper, from) {
                  assertNumberPositive(from.x);
                  assertNumberPositive(from.y);
                  var _imageWrapper$size = imageWrapper.size,
                    sizeX = _imageWrapper$size.x,
                    sizeY = _imageWrapper$size.y;

                  for (var x = 0; x < sizeX; x++) {
                    for (var y = 0; y < sizeY; y++) {
                      // eslint-disable-next-line no-param-reassign
                      imageWrapper.data[y * sizeX + x] =
                        this.data[(from.y + y) * this.size.x + from.x + x];
                    }
                  }

                  return imageWrapper; // TODO: this function really probably should call into ImageWrapper somewhere to make
                  // sure that all of it's parameters are set properly, something like
                  // ImageWrapper.UpdateFrom()
                  // that might take a provided data and size, and make sure there's no invalid indexMapping
                  // hanging around, and such.
                }, // Retrieve a grayscale value at the given pixel position of the image
              },
              {
                key: "get",
                value: function get(x, y) {
                  return this.data[y * this.size.x + x];
                }, // Retrieve a grayscale value at the given pixel position of the image (safe, whatever that
                // means)
              },
              {
                key: "getSafe",
                value: function getSafe(x, y) {
                  // cache indexMapping because if we're using it once, we'll probably need it a bunch more
                  // too
                  if (!this.indexMapping) {
                    this.indexMapping = {
                      x: [],
                      y: [],
                    };

                    for (var i = 0; i < this.size.x; i++) {
                      this.indexMapping.x[i] = i;
                      this.indexMapping.x[i + this.size.x] = i;
                    }

                    for (var _i = 0; _i < this.size.y; _i++) {
                      this.indexMapping.y[_i] = _i;
                      this.indexMapping.y[_i + this.size.y] = _i;
                    }
                  }

                  return this.data[
                    this.indexMapping.y[y + this.size.y] * this.size.x +
                      this.indexMapping.x[x + this.size.x]
                  ];
                }, // Sets a given pixel position in the image to the given grayscale value
              },
              {
                key: "set",
                value: function set(x, y, value) {
                  this.data[y * this.size.x + x] = value;
                  delete this.indexMapping;
                  return this;
                }, // Sets the border of the image (1 pixel) to zero
              },
              {
                key: "zeroBorder",
                value: function zeroBorder() {
                  var _this$size = this.size,
                    width = _this$size.x,
                    height = _this$size.y;

                  for (var i = 0; i < width; i++) {
                    // eslint-disable-next-line no-multi-assign
                    this.data[i] = this.data[(height - 1) * width + i] = 0;
                  }

                  for (var _i2 = 1; _i2 < height - 1; _i2++) {
                    // eslint-disable-next-line no-multi-assign
                    this.data[_i2 * width] = this.data[
                      _i2 * width + (width - 1)
                    ] = 0;
                  }

                  delete this.indexMapping;
                  return this;
                }, // TODO: this function is entirely too large for me to reason out right at this moment that i'm handling
                // all the rest of it, so this is a verbatim copy of the javascript source, with only tweaks
                // necessary to get it to run, no thought put into it yet.
              },
              {
                key: "moments",
                value: function moments(labelCount) {
                  var data = this.data;
                  var x;
                  var y;
                  var height = this.size.y;
                  var width = this.size.x;
                  var val;
                  var ysq;
                  var labelSum = [];
                  var i;
                  var label;
                  var mu11;
                  var mu02;
                  var mu20;
                  var x_;
                  var y_;
                  var tmp;
                  var result = [];
                  var PI = Math.PI;
                  var PI_4 = PI / 4;

                  if (labelCount <= 0) {
                    return result;
                  }

                  for (i = 0; i < labelCount; i++) {
                    labelSum[i] = {
                      m00: 0,
                      m01: 0,
                      m10: 0,
                      m11: 0,
                      m02: 0,
                      m20: 0,
                      theta: 0,
                      rad: 0,
                    };
                  }

                  for (y = 0; y < height; y++) {
                    ysq = y * y;

                    for (x = 0; x < width; x++) {
                      val = data[y * width + x];

                      if (val > 0) {
                        label = labelSum[val - 1];
                        label.m00 += 1;
                        label.m01 += y;
                        label.m10 += x;
                        label.m11 += x * y;
                        label.m02 += ysq;
                        label.m20 += x * x;
                      }
                    }
                  }

                  for (i = 0; i < labelCount; i++) {
                    label = labelSum[i]; // eslint-disable-next-line no-restricted-globals

                    if (!isNaN(label.m00) && label.m00 !== 0) {
                      x_ = label.m10 / label.m00;
                      y_ = label.m01 / label.m00;
                      mu11 = label.m11 / label.m00 - x_ * y_;
                      mu02 = label.m02 / label.m00 - y_ * y_;
                      mu20 = label.m20 / label.m00 - x_ * x_;
                      tmp = (mu02 - mu20) / (2 * mu11);
                      tmp =
                        0.5 * Math.atan(tmp) + (mu11 >= 0 ? PI_4 : -PI_4) + PI; // eslint-disable-next-line no-mixed-operators

                      label.theta = (((tmp * 180) / PI + 90) % 180) - 90;

                      if (label.theta < 0) {
                        label.theta += 180;
                      }

                      label.rad = tmp > PI ? tmp - PI : tmp;
                      label.vec = gl_matrix__WEBPACK_IMPORTED_MODULE_4__[
                        /* vec2 */ "c"
                      ].clone([Math.cos(tmp), Math.sin(tmp)]);
                      result.push(label);
                    }
                  }

                  return result;
                }, // return a Uint8ClampedArray containing this grayscale image converted to RGBA form
              },
              {
                key: "getAsRGBA",
                value: function getAsRGBA() {
                  var scale =
                    arguments.length > 0 && arguments[0] !== undefined
                      ? arguments[0]
                      : 1.0;
                  var ret = new Uint8ClampedArray(
                    4 * this.size.x * this.size.y
                  );

                  for (var y = 0; y < this.size.y; y++) {
                    for (var x = 0; x < this.size.x; x++) {
                      var pixel = y * this.size.x + x;
                      var current = this.get(x, y) * scale;
                      ret[pixel * 4 + 0] = current;
                      ret[pixel * 4 + 1] = current;
                      ret[pixel * 4 + 2] = current;
                      ret[pixel * 4 + 3] = 255;
                    }
                  }

                  return ret;
                }, // Display this ImageWrapper in a given Canvas element at the specified scale
              },
              {
                key: "show",
                value: function show(canvas) {
                  var scale =
                    arguments.length > 1 && arguments[1] !== undefined
                      ? arguments[1]
                      : 1.0;
                  var ctx = canvas.getContext("2d");

                  if (!ctx) {
                    throw new Error("Unable to get canvas context");
                  }

                  var frame = ctx.getImageData(
                    0,
                    0,
                    canvas.width,
                    canvas.height
                  );
                  var data = this.getAsRGBA(scale); // eslint-disable-next-line no-param-reassign

                  canvas.width = this.size.x; // eslint-disable-next-line no-param-reassign

                  canvas.height = this.size.y;
                  var newFrame = new ImageData(data, frame.width, frame.height);
                  ctx.putImageData(newFrame, 0, 0);
                }, // Displays a specified SubImage area in a given canvas. This differs drastically from
                // creating a new SubImage and using it's show() method. Why? I don't have the answer to that
                // yet.  I suspect the HSV/RGB operations involved here are making it significantly different,
                // but until I can visualize these functions side by side, I'm just going to copy the existing
                // implementation.
              },
              {
                key: "overlay",
                value: function overlay(canvas, inScale, from) {
                  var adjustedScale =
                    inScale < 0 || inScale > 360 ? 360 : inScale;
                  var hsv = [0, 1, 1];
                  var rgb = [0, 0, 0];
                  var whiteRgb = [255, 255, 255];
                  var blackRgb = [0, 0, 0];
                  var result = [];
                  var ctx = canvas.getContext("2d");

                  if (!ctx) {
                    throw new Error("Unable to get canvas context");
                  }

                  var frame = ctx.getImageData(
                    from.x,
                    from.y,
                    this.size.x,
                    this.size.y
                  );
                  var data = frame.data;
                  var length = this.data.length;

                  while (length--) {
                    hsv[0] = this.data[length] * adjustedScale; // eslint-disable-next-line no-nested-ternary

                    result =
                      hsv[0] <= 0
                        ? whiteRgb
                        : hsv[0] >= 360
                        ? blackRgb
                        : Object(
                            _cv_utils__WEBPACK_IMPORTED_MODULE_6__[
                              /* hsv2rgb */ "g"
                            ]
                          )(hsv, rgb);
                    var pos = length * 4;
                    var _result = result;

                    var _result2 =
                      _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_0___default()(
                        _result,
                        3
                      );

                    data[pos] = _result2[0];
                    data[pos + 1] = _result2[1];
                    data[pos + 2] = _result2[2];
                    data[pos + 3] = 255;
                  }

                  ctx.putImageData(frame, from.x, from.y);
                },
              },
            ]
          );

          return ImageWrapper;
        })();

        /* harmony default export */ __webpack_exports__["a"] = ImageWrapper;

        /***/
      },
      /* 13 */
      /***/ function (module, exports) {
        function asyncGeneratorStep(
          gen,
          resolve,
          reject,
          _next,
          _throw,
          key,
          arg
        ) {
          try {
            var info = gen[key](arg);
            var value = info.value;
          } catch (error) {
            reject(error);
            return;
          }

          if (info.done) {
            resolve(value);
          } else {
            Promise.resolve(value).then(_next, _throw);
          }
        }

        function _asyncToGenerator(fn) {
          return function () {
            var self = this,
              args = arguments;
            return new Promise(function (resolve, reject) {
              var gen = fn.apply(self, args);

              function _next(value) {
                asyncGeneratorStep(
                  gen,
                  resolve,
                  reject,
                  _next,
                  _throw,
                  "next",
                  value
                );
              }

              function _throw(err) {
                asyncGeneratorStep(
                  gen,
                  resolve,
                  reject,
                  _next,
                  _throw,
                  "throw",
                  err
                );
              }

              _next(undefined);
            });
          };
        }

        (module.exports = _asyncToGenerator),
          (module.exports.__esModule = true),
          (module.exports["default"] = module.exports);

        /***/
      },
      /* 14 */
      /***/ function (module, exports, __webpack_require__) {
        var superPropBase = __webpack_require__(140);

        function _get() {
          if (typeof Reflect !== "undefined" && Reflect.get) {
            (module.exports = _get = Reflect.get.bind()),
              (module.exports.__esModule = true),
              (module.exports["default"] = module.exports);
          } else {
            (module.exports = _get =
              function _get(target, property, receiver) {
                var base = superPropBase(target, property);
                if (!base) return;
                var desc = Object.getOwnPropertyDescriptor(base, property);

                if (desc.get) {
                  return desc.get.call(
                    arguments.length < 3 ? target : receiver
                  );
                }

                return desc.value;
              }),
              (module.exports.__esModule = true),
              (module.exports["default"] = module.exports);
          }

          return _get.apply(this, arguments);
        }

        (module.exports = _get),
          (module.exports.__esModule = true),
          (module.exports["default"] = module.exports);

        /***/
      },
      /* 15 */
      /***/ function (module, exports) {
        /**
         * Checks if `value` is the
         * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
         * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is an object, else `false`.
         * @example
         *
         * _.isObject({});
         * // => true
         *
         * _.isObject([1, 2, 3]);
         * // => true
         *
         * _.isObject(_.noop);
         * // => true
         *
         * _.isObject(null);
         * // => false
         */
        function isObject(value) {
          var type = typeof value;
          return value != null && (type == "object" || type == "function");
        }

        module.exports = isObject;

        /***/
      },
      /* 16 */
      /***/ function (module, exports) {
        /**
         * Checks if `value` is classified as an `Array` object.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is an array, else `false`.
         * @example
         *
         * _.isArray([1, 2, 3]);
         * // => true
         *
         * _.isArray(document.body.children);
         * // => false
         *
         * _.isArray('abc');
         * // => false
         *
         * _.isArray(_.noop);
         * // => false
         */
        var isArray = Array.isArray;
        module.exports = isArray;

        /***/
      },
      /* 17 */
      /***/ function (module, exports) {
        function _typeof(obj) {
          "@babel/helpers - typeof";

          return (
            ((module.exports = _typeof =
              "function" == typeof Symbol && "symbol" == typeof Symbol.iterator
                ? function (obj) {
                    return typeof obj;
                  }
                : function (obj) {
                    return obj &&
                      "function" == typeof Symbol &&
                      obj.constructor === Symbol &&
                      obj !== Symbol.prototype
                      ? "symbol"
                      : typeof obj;
                  }),
            (module.exports.__esModule = true),
            (module.exports["default"] = module.exports)),
            _typeof(obj)
          );
        }

        (module.exports = _typeof),
          (module.exports.__esModule = true),
          (module.exports["default"] = module.exports);

        /***/
      },
      /* 18 */
      /***/ function (module, exports, __webpack_require__) {
        var baseMerge = __webpack_require__(73),
          createAssigner = __webpack_require__(128);
        /**
         * This method is like `_.assign` except that it recursively merges own and
         * inherited enumerable string keyed properties of source objects into the
         * destination object. Source properties that resolve to `undefined` are
         * skipped if a destination value exists. Array and plain object properties
         * are merged recursively. Other objects and value types are overridden by
         * assignment. Source objects are applied from left to right. Subsequent
         * sources overwrite property assignments of previous sources.
         *
         * **Note:** This method mutates `object`.
         *
         * @static
         * @memberOf _
         * @since 0.5.0
         * @category Object
         * @param {Object} object The destination object.
         * @param {...Object} [sources] The source objects.
         * @returns {Object} Returns `object`.
         * @example
         *
         * var object = {
         *   'a': [{ 'b': 2 }, { 'd': 4 }]
         * };
         *
         * var other = {
         *   'a': [{ 'c': 3 }, { 'e': 5 }]
         * };
         *
         * _.merge(object, other);
         * // => { 'a': [{ 'b': 2, 'c': 3 }, { 'd': 4, 'e': 5 }] }
         */

        var merge = createAssigner(function (object, source, srcIndex) {
          baseMerge(object, source, srcIndex);
        });
        module.exports = merge;

        /***/
      },
      /* 19 */
      /***/ function (module, exports, __webpack_require__) {
        var freeGlobal = __webpack_require__(44);
        /** Detect free variable `self`. */

        var freeSelf =
          typeof self == "object" && self && self.Object === Object && self;
        /** Used as a reference to the global object. */

        var root = freeGlobal || freeSelf || Function("return this")();
        module.exports = root;

        /***/
      },
      /* 20 */
      /***/ function (module, exports) {
        /**
         * Checks if `value` is object-like. A value is object-like if it's not `null`
         * and has a `typeof` result of "object".
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
         * @example
         *
         * _.isObjectLike({});
         * // => true
         *
         * _.isObjectLike([1, 2, 3]);
         * // => true
         *
         * _.isObjectLike(_.noop);
         * // => false
         *
         * _.isObjectLike(null);
         * // => false
         */
        function isObjectLike(value) {
          return value != null && typeof value == "object";
        }

        module.exports = isObjectLike;

        /***/
      },
      /* 21 */
      /***/ function (module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /**
         * http://www.codeproject.com/Tips/407172/Connected-Component-Labeling-and-Vectorization
         */
        var Tracer = {
          searchDirections: [
            [0, 1],
            [1, 1],
            [1, 0],
            [1, -1],
            [0, -1],
            [-1, -1],
            [-1, 0],
            [-1, 1],
          ],
          create: function create(imageWrapper, labelWrapper) {
            var imageData = imageWrapper.data;
            var labelData = labelWrapper.data;
            var searchDirections = this.searchDirections;
            var width = imageWrapper.size.x;
            var pos;

            function _trace(current, color, label, edgelabel) {
              var i;
              var y;
              var x;

              for (i = 0; i < searchDirections.length; i++) {
                y = current.cy + searchDirections[current.dir][0];
                x = current.cx + searchDirections[current.dir][1];
                pos = y * width + x;

                if (
                  imageData[pos] === color &&
                  (labelData[pos] === 0 || labelData[pos] === label)
                ) {
                  labelData[pos] = label;
                  current.cy = y;
                  current.cx = x;
                  return true;
                }

                if (labelData[pos] === 0) {
                  labelData[pos] = edgelabel;
                }

                current.dir = (current.dir + 1) % 8;
              }

              return false;
            }

            function vertex2D(x, y, dir) {
              return {
                dir: dir,
                x: x,
                y: y,
                next: null,
                prev: null,
              };
            }

            function _contourTracing(sy, sx, label, color, edgelabel) {
              var Fv = null;
              var Cv;
              var P;
              var ldir;
              var current = {
                cx: sx,
                cy: sy,
                dir: 0,
              };

              if (_trace(current, color, label, edgelabel)) {
                Fv = vertex2D(sx, sy, current.dir);
                Cv = Fv;
                ldir = current.dir;
                P = vertex2D(current.cx, current.cy, 0);
                P.prev = Cv;
                Cv.next = P;
                P.next = null;
                Cv = P;
                var totalPixelCount = imageWrapper.size.x * imageWrapper.size.y;
                var pixelCounter = 0;

                do {
                  current.dir = (current.dir + 6) % 8;

                  _trace(current, color, label, edgelabel);

                  if (ldir !== current.dir) {
                    Cv.dir = current.dir;
                    P = vertex2D(current.cx, current.cy, 0);
                    P.prev = Cv;
                    Cv.next = P;
                    P.next = null;
                    Cv = P;
                  } else {
                    Cv.dir = ldir;
                    Cv.x = current.cx;
                    Cv.y = current.cy;
                  }

                  ldir = current.dir;
                } while (
                  (current.cx !== sx || current.cy !== sy) &&
                  ++pixelCounter < totalPixelCount
                );

                Fv.prev = Cv.prev;
                Cv.prev.next = Fv;
              }

              return Fv;
            }

            return {
              trace: function trace(current, color, label, edgelabel) {
                return _trace(current, color, label, edgelabel);
              },
              contourTracing: function contourTracing(
                sy,
                sx,
                label,
                color,
                edgelabel
              ) {
                return _contourTracing(sy, sx, label, color, edgelabel);
              },
            };
          },
        };
        /* harmony default export */ __webpack_exports__["a"] = Tracer;

        /***/
      },
      /* 22 */
      /***/ function (module, exports, __webpack_require__) {
        var Symbol = __webpack_require__(27),
          getRawTag = __webpack_require__(86),
          objectToString = __webpack_require__(87);
        /** `Object#toString` result references. */

        var nullTag = "[object Null]",
          undefinedTag = "[object Undefined]";
        /** Built-in value references. */

        var symToStringTag = Symbol ? Symbol.toStringTag : undefined;
        /**
         * The base implementation of `getTag` without fallbacks for buggy environments.
         *
         * @private
         * @param {*} value The value to query.
         * @returns {string} Returns the `toStringTag`.
         */

        function baseGetTag(value) {
          if (value == null) {
            return value === undefined ? undefinedTag : nullTag;
          }

          return symToStringTag && symToStringTag in Object(value)
            ? getRawTag(value)
            : objectToString(value);
        }

        module.exports = baseGetTag;

        /***/
      },
      /* 23 */
      /***/ function (module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* WEBPACK VAR INJECTION */ (function (global) {
          /* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_0__ =
            __webpack_require__(5);
          /* harmony import */ var _common_image_wrapper__WEBPACK_IMPORTED_MODULE_1__ =
            __webpack_require__(12);
          /* harmony import */ var _common_cv_utils__WEBPACK_IMPORTED_MODULE_2__ =
            __webpack_require__(9);
          /* harmony import */ var _common_array_helper__WEBPACK_IMPORTED_MODULE_3__ =
            __webpack_require__(11);
          /* harmony import */ var _common_image_debug__WEBPACK_IMPORTED_MODULE_4__ =
            __webpack_require__(10);
          /* harmony import */ var _rasterizer__WEBPACK_IMPORTED_MODULE_5__ =
            __webpack_require__(64);
          /* harmony import */ var _tracer__WEBPACK_IMPORTED_MODULE_6__ =
            __webpack_require__(21);
          /* harmony import */ var _skeletonizer__WEBPACK_IMPORTED_MODULE_7__ =
            __webpack_require__(65);

          gl_matrix__WEBPACK_IMPORTED_MODULE_0__[
            /* glMatrix */ "a"
          ].setMatrixArrayType(Array);

          var _config;

          var _currentImageWrapper;

          var _skelImageWrapper;

          var _subImageWrapper;

          var _labelImageWrapper;

          var _patchGrid;

          var _patchLabelGrid;

          var _imageToPatchGrid;

          var _binaryImageWrapper;

          var _patchSize;

          var _canvasContainer = {
            ctx: {
              binary: null,
            },
            dom: {
              binary: null,
            },
          };
          var _numPatches = {
            x: 0,
            y: 0,
          };

          var _inputImageWrapper;

          var _skeletonizer;

          function initBuffers() {
            if (_config.halfSample) {
              _currentImageWrapper =
                new _common_image_wrapper__WEBPACK_IMPORTED_MODULE_1__[
                  /* default */ "a"
                ]({
                  // eslint-disable-next-line no-bitwise
                  x: (_inputImageWrapper.size.x / 2) | 0,
                  // eslint-disable-next-line no-bitwise
                  y: (_inputImageWrapper.size.y / 2) | 0,
                });
            } else {
              _currentImageWrapper = _inputImageWrapper;
            }

            _patchSize = Object(
              _common_cv_utils__WEBPACK_IMPORTED_MODULE_2__[
                /* calculatePatchSize */ "a"
              ]
            )(_config.patchSize, _currentImageWrapper.size); // eslint-disable-next-line no-bitwise

            _numPatches.x = (_currentImageWrapper.size.x / _patchSize.x) | 0; // eslint-disable-next-line no-bitwise

            _numPatches.y = (_currentImageWrapper.size.y / _patchSize.y) | 0;
            _binaryImageWrapper =
              new _common_image_wrapper__WEBPACK_IMPORTED_MODULE_1__[
                /* default */ "a"
              ](_currentImageWrapper.size, undefined, Uint8Array, false);
            _labelImageWrapper =
              new _common_image_wrapper__WEBPACK_IMPORTED_MODULE_1__[
                /* default */ "a"
              ](_patchSize, undefined, Array, true);
            var skeletonImageData = new ArrayBuffer(64 * 1024);
            _subImageWrapper =
              new _common_image_wrapper__WEBPACK_IMPORTED_MODULE_1__[
                /* default */ "a"
              ](
                _patchSize,
                new Uint8Array(
                  skeletonImageData,
                  0,
                  _patchSize.x * _patchSize.y
                )
              );
            _skelImageWrapper =
              new _common_image_wrapper__WEBPACK_IMPORTED_MODULE_1__[
                /* default */ "a"
              ](
                _patchSize,
                new Uint8Array(
                  skeletonImageData,
                  _patchSize.x * _patchSize.y * 3,
                  _patchSize.x * _patchSize.y
                ),
                undefined,
                true
              );
            _skeletonizer = Object(
              _skeletonizer__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"]
            )(
              typeof window !== "undefined"
                ? window
                : typeof self !== "undefined"
                ? self
                : global,
              {
                size: _patchSize.x,
              },
              skeletonImageData
            );
            _imageToPatchGrid =
              new _common_image_wrapper__WEBPACK_IMPORTED_MODULE_1__[
                /* default */ "a"
              ](
                {
                  // eslint-disable-next-line no-bitwise
                  x:
                    (_currentImageWrapper.size.x / _subImageWrapper.size.x) | 0,
                  // eslint-disable-next-line no-bitwise
                  y:
                    (_currentImageWrapper.size.y / _subImageWrapper.size.y) | 0,
                },
                undefined,
                Array,
                true
              );
            _patchGrid = new _common_image_wrapper__WEBPACK_IMPORTED_MODULE_1__[
              /* default */ "a"
            ](_imageToPatchGrid.size, undefined, undefined, true);
            _patchLabelGrid =
              new _common_image_wrapper__WEBPACK_IMPORTED_MODULE_1__[
                /* default */ "a"
              ](_imageToPatchGrid.size, undefined, Int32Array, true);
          }

          function initCanvas() {
            if (_config.useWorker || typeof document === "undefined") {
              return;
            }

            _canvasContainer.dom.binary = document.createElement("canvas");
            _canvasContainer.dom.binary.className = "binaryBuffer";

            if (true && _config.debug.showCanvas === true) {
              document
                .querySelector("#debug")
                .appendChild(_canvasContainer.dom.binary);
            }

            _canvasContainer.ctx.binary =
              _canvasContainer.dom.binary.getContext("2d");
            _canvasContainer.dom.binary.width = _binaryImageWrapper.size.x;
            _canvasContainer.dom.binary.height = _binaryImageWrapper.size.y;
          }
          /**
           * Creates a bounding box which encloses all the given patches
           * @returns {Array} The minimal bounding box
           */

          function boxFromPatches(patches) {
            var overAvg;
            var i;
            var j;
            var patch;
            var transMat;
            var minx = _binaryImageWrapper.size.x;
            var miny = _binaryImageWrapper.size.y;
            var maxx = -_binaryImageWrapper.size.x;
            var maxy = -_binaryImageWrapper.size.y;
            var box;
            var scale; // draw all patches which are to be taken into consideration

            overAvg = 0;

            for (i = 0; i < patches.length; i++) {
              patch = patches[i];
              overAvg += patch.rad;

              if (true && _config.debug.showPatches) {
                _common_image_debug__WEBPACK_IMPORTED_MODULE_4__[
                  /* default */ "a"
                ].drawRect(
                  patch.pos,
                  _subImageWrapper.size,
                  _canvasContainer.ctx.binary,
                  {
                    color: "red",
                  }
                );
              }
            }

            overAvg /= patches.length;
            overAvg = (((overAvg * 180) / Math.PI + 90) % 180) - 90;

            if (overAvg < 0) {
              overAvg += 180;
            }

            overAvg = ((180 - overAvg) * Math.PI) / 180;
            transMat = gl_matrix__WEBPACK_IMPORTED_MODULE_0__[
              /* mat2 */ "b"
            ].copy(
              gl_matrix__WEBPACK_IMPORTED_MODULE_0__[/* mat2 */ "b"].create(),
              [
                Math.cos(overAvg),
                Math.sin(overAvg),
                -Math.sin(overAvg),
                Math.cos(overAvg),
              ]
            ); // iterate over patches and rotate by angle

            for (i = 0; i < patches.length; i++) {
              patch = patches[i];

              for (j = 0; j < 4; j++) {
                gl_matrix__WEBPACK_IMPORTED_MODULE_0__[
                  /* vec2 */ "c"
                ].transformMat2(patch.box[j], patch.box[j], transMat);
              }

              if (true && _config.debug.boxFromPatches.showTransformed) {
                _common_image_debug__WEBPACK_IMPORTED_MODULE_4__[
                  /* default */ "a"
                ].drawPath(
                  patch.box,
                  {
                    x: 0,
                    y: 1,
                  },
                  _canvasContainer.ctx.binary,
                  {
                    color: "#99ff00",
                    lineWidth: 2,
                  }
                );
              }
            } // find bounding box

            for (i = 0; i < patches.length; i++) {
              patch = patches[i];

              for (j = 0; j < 4; j++) {
                if (patch.box[j][0] < minx) {
                  minx = patch.box[j][0];
                }

                if (patch.box[j][0] > maxx) {
                  maxx = patch.box[j][0];
                }

                if (patch.box[j][1] < miny) {
                  miny = patch.box[j][1];
                }

                if (patch.box[j][1] > maxy) {
                  maxy = patch.box[j][1];
                }
              }
            }

            box = [
              [minx, miny],
              [maxx, miny],
              [maxx, maxy],
              [minx, maxy],
            ];

            if (true && _config.debug.boxFromPatches.showTransformedBox) {
              _common_image_debug__WEBPACK_IMPORTED_MODULE_4__[
                /* default */ "a"
              ].drawPath(
                box,
                {
                  x: 0,
                  y: 1,
                },
                _canvasContainer.ctx.binary,
                {
                  color: "#ff0000",
                  lineWidth: 2,
                }
              );
            }

            scale = _config.halfSample ? 2 : 1; // reverse rotation;

            transMat = gl_matrix__WEBPACK_IMPORTED_MODULE_0__[
              /* mat2 */ "b"
            ].invert(transMat, transMat);

            for (j = 0; j < 4; j++) {
              gl_matrix__WEBPACK_IMPORTED_MODULE_0__[
                /* vec2 */ "c"
              ].transformMat2(box[j], box[j], transMat);
            }

            if (true && _config.debug.boxFromPatches.showBB) {
              _common_image_debug__WEBPACK_IMPORTED_MODULE_4__[
                /* default */ "a"
              ].drawPath(
                box,
                {
                  x: 0,
                  y: 1,
                },
                _canvasContainer.ctx.binary,
                {
                  color: "#ff0000",
                  lineWidth: 2,
                }
              );
            }

            for (j = 0; j < 4; j++) {
              gl_matrix__WEBPACK_IMPORTED_MODULE_0__[/* vec2 */ "c"].scale(
                box[j],
                box[j],
                scale
              );
            }

            return box;
          }
          /**
           * Creates a binary image of the current image
           */

          function binarizeImage() {
            Object(
              _common_cv_utils__WEBPACK_IMPORTED_MODULE_2__[
                /* otsuThreshold */ "i"
              ]
            )(_currentImageWrapper, _binaryImageWrapper);

            _binaryImageWrapper.zeroBorder();

            if (true && _config.debug.showCanvas) {
              _binaryImageWrapper.show(_canvasContainer.dom.binary, 255);
            }
          }
          /**
           * Iterate over the entire image
           * extract patches
           */

          function findPatches() {
            var i;
            var j;
            var x;
            var y;
            var moments;
            var patchesFound = [];
            var rasterizer;
            var rasterResult;
            var patch;

            for (i = 0; i < _numPatches.x; i++) {
              for (j = 0; j < _numPatches.y; j++) {
                x = _subImageWrapper.size.x * i;
                y = _subImageWrapper.size.y * j; // seperate parts

                skeletonize(x, y); // Rasterize, find individual bars

                _skelImageWrapper.zeroBorder();

                _common_array_helper__WEBPACK_IMPORTED_MODULE_3__[
                  /* default */ "a"
                ].init(_labelImageWrapper.data, 0);
                rasterizer = _rasterizer__WEBPACK_IMPORTED_MODULE_5__[
                  /* default */ "a"
                ].create(_skelImageWrapper, _labelImageWrapper);
                rasterResult = rasterizer.rasterize(0);

                if (true && _config.debug.showLabels) {
                  _labelImageWrapper.overlay(
                    _canvasContainer.dom.binary,
                    Math.floor(360 / rasterResult.count),
                    {
                      x: x,
                      y: y,
                    }
                  );
                } // calculate moments from the skeletonized patch

                moments = _labelImageWrapper.moments(rasterResult.count); // extract eligible patches

                patchesFound = patchesFound.concat(
                  describePatch(moments, [i, j], x, y)
                );
              }
            }

            if (true && _config.debug.showFoundPatches) {
              for (i = 0; i < patchesFound.length; i++) {
                patch = patchesFound[i];
                _common_image_debug__WEBPACK_IMPORTED_MODULE_4__[
                  /* default */ "a"
                ].drawRect(
                  patch.pos,
                  _subImageWrapper.size,
                  _canvasContainer.ctx.binary,
                  {
                    color: "#99ff00",
                    lineWidth: 2,
                  }
                );
              }
            }

            return patchesFound;
          }
          /**
           * Finds those connected areas which contain at least 6 patches
           * and returns them ordered DESC by the number of contained patches
           * @param {Number} maxLabel
           */

          function findBiggestConnectedAreas(maxLabel) {
            var i;
            var sum;
            var labelHist = [];
            var topLabels = [];

            for (i = 0; i < maxLabel; i++) {
              labelHist.push(0);
            }

            sum = _patchLabelGrid.data.length;

            while (sum--) {
              if (_patchLabelGrid.data[sum] > 0) {
                labelHist[_patchLabelGrid.data[sum] - 1]++;
              }
            }

            labelHist = labelHist.map(function (val, idx) {
              return {
                val: val,
                label: idx + 1,
              };
            });
            labelHist.sort(function (a, b) {
              return b.val - a.val;
            }); // extract top areas with at least 6 patches present

            topLabels = labelHist.filter(function (el) {
              return el.val >= 5;
            });
            return topLabels;
          }
          /**
           *
           */

          function findBoxes(topLabels, maxLabel) {
            var i;
            var j;
            var sum;
            var patches = [];
            var patch;
            var box;
            var boxes = [];
            var hsv = [0, 1, 1];
            var rgb = [0, 0, 0];

            for (i = 0; i < topLabels.length; i++) {
              sum = _patchLabelGrid.data.length;
              patches.length = 0;

              while (sum--) {
                if (_patchLabelGrid.data[sum] === topLabels[i].label) {
                  patch = _imageToPatchGrid.data[sum];
                  patches.push(patch);
                }
              }

              box = boxFromPatches(patches);

              if (box) {
                boxes.push(box); // draw patch-labels if requested

                if (true && _config.debug.showRemainingPatchLabels) {
                  for (j = 0; j < patches.length; j++) {
                    patch = patches[j];
                    hsv[0] = (topLabels[i].label / (maxLabel + 1)) * 360;
                    Object(
                      _common_cv_utils__WEBPACK_IMPORTED_MODULE_2__[
                        /* hsv2rgb */ "g"
                      ]
                    )(hsv, rgb);
                    _common_image_debug__WEBPACK_IMPORTED_MODULE_4__[
                      /* default */ "a"
                    ].drawRect(
                      patch.pos,
                      _subImageWrapper.size,
                      _canvasContainer.ctx.binary,
                      {
                        color: "rgb(".concat(rgb.join(","), ")"),
                        lineWidth: 2,
                      }
                    );
                  }
                }
              }
            }

            return boxes;
          }
          /**
           * Find similar moments (via cluster)
           * @param {Object} moments
           */

          function similarMoments(moments) {
            var clusters = Object(
              _common_cv_utils__WEBPACK_IMPORTED_MODULE_2__[/* cluster */ "b"]
            )(moments, 0.9);
            var topCluster = Object(
              _common_cv_utils__WEBPACK_IMPORTED_MODULE_2__[
                /* topGeneric */ "j"
              ]
            )(clusters, 1, function (e) {
              return e.getPoints().length;
            });
            var points = [];
            var result = [];

            if (topCluster.length === 1) {
              points = topCluster[0].item.getPoints();

              for (var i = 0; i < points.length; i++) {
                result.push(points[i].point);
              }
            }

            return result;
          }

          function skeletonize(x, y) {
            _binaryImageWrapper.subImageAsCopy(
              _subImageWrapper,
              Object(
                _common_cv_utils__WEBPACK_IMPORTED_MODULE_2__[
                  /* imageRef */ "h"
                ]
              )(x, y)
            );

            _skeletonizer.skeletonize(); // Show skeleton if requested

            if (true && _config.debug.showSkeleton) {
              _skelImageWrapper.overlay(
                _canvasContainer.dom.binary,
                360,
                Object(
                  _common_cv_utils__WEBPACK_IMPORTED_MODULE_2__[
                    /* imageRef */ "h"
                  ]
                )(x, y)
              );
            }
          }
          /**
           * Extracts and describes those patches which seem to contain a barcode pattern
           * @param {Array} moments
           * @param {Object} patchPos,
           * @param {Number} x
           * @param {Number} y
           * @returns {Array} list of patches
           */

          function describePatch(moments, patchPos, x, y) {
            var k;
            var avg;
            var eligibleMoments = [];
            var matchingMoments;
            var patch;
            var patchesFound = [];
            var minComponentWeight = Math.ceil(_patchSize.x / 3);

            if (moments.length >= 2) {
              // only collect moments which's area covers at least minComponentWeight pixels.
              for (k = 0; k < moments.length; k++) {
                if (moments[k].m00 > minComponentWeight) {
                  eligibleMoments.push(moments[k]);
                }
              } // if at least 2 moments are found which have at least minComponentWeights covered

              if (eligibleMoments.length >= 2) {
                matchingMoments = similarMoments(eligibleMoments);
                avg = 0; // determine the similarity of the moments

                for (k = 0; k < matchingMoments.length; k++) {
                  var _matchingMoments$k$ra, _matchingMoments$k;

                  avg +=
                    (_matchingMoments$k$ra =
                      (_matchingMoments$k = matchingMoments[k]) === null ||
                      _matchingMoments$k === void 0
                        ? void 0
                        : _matchingMoments$k.rad) !== null &&
                    _matchingMoments$k$ra !== void 0
                      ? _matchingMoments$k$ra
                      : 0;
                } // Only two of the moments are allowed not to fit into the equation
                // add the patch to the set

                if (
                  matchingMoments.length > 1 &&
                  matchingMoments.length >= (eligibleMoments.length / 4) * 3 &&
                  matchingMoments.length > moments.length / 4
                ) {
                  avg /= matchingMoments.length;
                  patch = {
                    index: patchPos[1] * _numPatches.x + patchPos[0],
                    pos: {
                      x: x,
                      y: y,
                    },
                    box: [
                      gl_matrix__WEBPACK_IMPORTED_MODULE_0__[
                        /* vec2 */ "c"
                      ].clone([x, y]),
                      gl_matrix__WEBPACK_IMPORTED_MODULE_0__[
                        /* vec2 */ "c"
                      ].clone([x + _subImageWrapper.size.x, y]),
                      gl_matrix__WEBPACK_IMPORTED_MODULE_0__[
                        /* vec2 */ "c"
                      ].clone([
                        x + _subImageWrapper.size.x,
                        y + _subImageWrapper.size.y,
                      ]),
                      gl_matrix__WEBPACK_IMPORTED_MODULE_0__[
                        /* vec2 */ "c"
                      ].clone([x, y + _subImageWrapper.size.y]),
                    ],
                    moments: matchingMoments,
                    rad: avg,
                    vec: gl_matrix__WEBPACK_IMPORTED_MODULE_0__[
                      /* vec2 */ "c"
                    ].clone([Math.cos(avg), Math.sin(avg)]),
                  };
                  patchesFound.push(patch);
                }
              }
            }

            return patchesFound;
          }
          /**
           * finds patches which are connected and share the same orientation
           * @param {Object} patchesFound
           */

          function rasterizeAngularSimilarity(patchesFound) {
            var label = 0;
            var threshold = 0.95;
            var currIdx = 0;
            var j;
            var patch;
            var hsv = [0, 1, 1];
            var rgb = [0, 0, 0];

            function notYetProcessed() {
              var i;

              for (i = 0; i < _patchLabelGrid.data.length; i++) {
                if (_patchLabelGrid.data[i] === 0 && _patchGrid.data[i] === 1) {
                  return i;
                }
              }

              return _patchLabelGrid.data.length;
            }

            function trace(currentIdx) {
              var x;
              var y;
              var currentPatch;
              var idx;
              var dir;
              var current = {
                x: currentIdx % _patchLabelGrid.size.x,
                y: (currentIdx / _patchLabelGrid.size.x) | 0,
              };
              var similarity;

              if (currentIdx < _patchLabelGrid.data.length) {
                currentPatch = _imageToPatchGrid.data[currentIdx]; // assign label

                _patchLabelGrid.data[currentIdx] = label;

                for (
                  dir = 0;
                  dir <
                  _tracer__WEBPACK_IMPORTED_MODULE_6__[/* default */ "a"]
                    .searchDirections.length;
                  dir++
                ) {
                  y =
                    current.y +
                    _tracer__WEBPACK_IMPORTED_MODULE_6__[/* default */ "a"]
                      .searchDirections[dir][0];
                  x =
                    current.x +
                    _tracer__WEBPACK_IMPORTED_MODULE_6__[/* default */ "a"]
                      .searchDirections[dir][1];
                  idx = y * _patchLabelGrid.size.x + x; // continue if patch empty

                  if (_patchGrid.data[idx] === 0) {
                    _patchLabelGrid.data[idx] = Number.MAX_VALUE; // eslint-disable-next-line no-continue

                    continue;
                  }

                  if (_patchLabelGrid.data[idx] === 0) {
                    similarity = Math.abs(
                      gl_matrix__WEBPACK_IMPORTED_MODULE_0__[
                        /* vec2 */ "c"
                      ].dot(_imageToPatchGrid.data[idx].vec, currentPatch.vec)
                    );

                    if (similarity > threshold) {
                      trace(idx);
                    }
                  }
                }
              }
            } // prepare for finding the right patches

            _common_array_helper__WEBPACK_IMPORTED_MODULE_3__[
              /* default */ "a"
            ].init(_patchGrid.data, 0);
            _common_array_helper__WEBPACK_IMPORTED_MODULE_3__[
              /* default */ "a"
            ].init(_patchLabelGrid.data, 0);
            _common_array_helper__WEBPACK_IMPORTED_MODULE_3__[
              /* default */ "a"
            ].init(_imageToPatchGrid.data, null);

            for (j = 0; j < patchesFound.length; j++) {
              patch = patchesFound[j];
              _imageToPatchGrid.data[patch.index] = patch;
              _patchGrid.data[patch.index] = 1;
            } // rasterize the patches found to determine area

            _patchGrid.zeroBorder(); // eslint-disable-next-line no-cond-assign

            while (
              (currIdx = notYetProcessed()) < _patchLabelGrid.data.length
            ) {
              label++;
              trace(currIdx);
            } // draw patch-labels if requested

            if (true && _config.debug.showPatchLabels) {
              for (j = 0; j < _patchLabelGrid.data.length; j++) {
                if (
                  _patchLabelGrid.data[j] > 0 &&
                  _patchLabelGrid.data[j] <= label
                ) {
                  patch = _imageToPatchGrid.data[j];
                  hsv[0] = (_patchLabelGrid.data[j] / (label + 1)) * 360;
                  Object(
                    _common_cv_utils__WEBPACK_IMPORTED_MODULE_2__[
                      /* hsv2rgb */ "g"
                    ]
                  )(hsv, rgb);
                  _common_image_debug__WEBPACK_IMPORTED_MODULE_4__[
                    /* default */ "a"
                  ].drawRect(
                    patch.pos,
                    _subImageWrapper.size,
                    _canvasContainer.ctx.binary,
                    {
                      color: "rgb(".concat(rgb.join(","), ")"),
                      lineWidth: 2,
                    }
                  );
                }
              }
            }

            return label;
          }

          /* harmony default export */ __webpack_exports__["a"] = {
            init: function init(inputImageWrapper, config) {
              _config = config;
              _inputImageWrapper = inputImageWrapper;
              initBuffers();
              initCanvas();
            },
            locate: function locate() {
              if (_config.halfSample) {
                Object(
                  _common_cv_utils__WEBPACK_IMPORTED_MODULE_2__[
                    /* halfSample */ "f"
                  ]
                )(_inputImageWrapper, _currentImageWrapper);
              }

              binarizeImage();
              var patchesFound = findPatches(); // return unless 5% or more patches are found

              if (patchesFound.length < _numPatches.x * _numPatches.y * 0.05) {
                return null;
              } // rasterrize area by comparing angular similarity;

              var maxLabel = rasterizeAngularSimilarity(patchesFound);

              if (maxLabel < 1) {
                return null;
              } // search for area with the most patches (biggest connected area)

              var topLabels = findBiggestConnectedAreas(maxLabel);

              if (topLabels.length === 0) {
                return null;
              }

              var boxes = findBoxes(topLabels, maxLabel);
              return boxes;
            },
            checkImageConstraints: function checkImageConstraints(
              inputStream,
              config
            ) {
              var patchSize;
              var width = inputStream.getWidth();
              var height = inputStream.getHeight();
              var thisHalfSample = config.halfSample ? 0.5 : 1;
              var area; // calculate width and height based on area

              if (inputStream.getConfig().area) {
                area = Object(
                  _common_cv_utils__WEBPACK_IMPORTED_MODULE_2__[
                    /* computeImageArea */ "d"
                  ]
                )(width, height, inputStream.getConfig().area);
                inputStream.setTopRight({
                  x: area.sx,
                  y: area.sy,
                });
                inputStream.setCanvasSize({
                  x: width,
                  y: height,
                });
                width = area.sw;
                height = area.sh;
              }

              var size = {
                x: Math.floor(width * thisHalfSample),
                y: Math.floor(height * thisHalfSample),
              };
              patchSize = Object(
                _common_cv_utils__WEBPACK_IMPORTED_MODULE_2__[
                  /* calculatePatchSize */ "a"
                ]
              )(config.patchSize, size);

              if (true) {
                console.log("Patch-Size: ".concat(JSON.stringify(patchSize)));
              }

              inputStream.setWidth(
                Math.floor(
                  Math.floor(size.x / patchSize.x) *
                    (1 / thisHalfSample) *
                    patchSize.x
                )
              );
              inputStream.setHeight(
                Math.floor(
                  Math.floor(size.y / patchSize.y) *
                    (1 / thisHalfSample) *
                    patchSize.y
                )
              );

              if (
                inputStream.getWidth() % patchSize.x === 0 &&
                inputStream.getHeight() % patchSize.y === 0
              ) {
                return true;
              }

              throw new Error(
                "Image dimensions do not comply with the current settings: Width ("
                  .concat(width, " )and height (")
                  .concat(height, ") must a multiple of ")
                  .concat(patchSize.x)
              );
            },
          };
          /* WEBPACK VAR INJECTION */
        }.call(this, __webpack_require__(45)));

        /***/
      },
      /* 24 */
      /***/ function (module, exports, __webpack_require__) {
        var listCacheClear = __webpack_require__(75),
          listCacheDelete = __webpack_require__(76),
          listCacheGet = __webpack_require__(77),
          listCacheHas = __webpack_require__(78),
          listCacheSet = __webpack_require__(79);
        /**
         * Creates an list cache object.
         *
         * @private
         * @constructor
         * @param {Array} [entries] The key-value pairs to cache.
         */

        function ListCache(entries) {
          var index = -1,
            length = entries == null ? 0 : entries.length;
          this.clear();

          while (++index < length) {
            var entry = entries[index];
            this.set(entry[0], entry[1]);
          }
        } // Add methods to `ListCache`.

        ListCache.prototype.clear = listCacheClear;
        ListCache.prototype["delete"] = listCacheDelete;
        ListCache.prototype.get = listCacheGet;
        ListCache.prototype.has = listCacheHas;
        ListCache.prototype.set = listCacheSet;
        module.exports = ListCache;

        /***/
      },
      /* 25 */
      /***/ function (module, exports, __webpack_require__) {
        var eq = __webpack_require__(26);
        /**
         * Gets the index at which the `key` is found in `array` of key-value pairs.
         *
         * @private
         * @param {Array} array The array to inspect.
         * @param {*} key The key to search for.
         * @returns {number} Returns the index of the matched value, else `-1`.
         */

        function assocIndexOf(array, key) {
          var length = array.length;

          while (length--) {
            if (eq(array[length][0], key)) {
              return length;
            }
          }

          return -1;
        }

        module.exports = assocIndexOf;

        /***/
      },
      /* 26 */
      /***/ function (module, exports) {
        /**
         * Performs a
         * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
         * comparison between two values to determine if they are equivalent.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Lang
         * @param {*} value The value to compare.
         * @param {*} other The other value to compare.
         * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
         * @example
         *
         * var object = { 'a': 1 };
         * var other = { 'a': 1 };
         *
         * _.eq(object, object);
         * // => true
         *
         * _.eq(object, other);
         * // => false
         *
         * _.eq('a', 'a');
         * // => true
         *
         * _.eq('a', Object('a'));
         * // => false
         *
         * _.eq(NaN, NaN);
         * // => true
         */
        function eq(value, other) {
          return value === other || (value !== value && other !== other);
        }

        module.exports = eq;

        /***/
      },
      /* 27 */
      /***/ function (module, exports, __webpack_require__) {
        var root = __webpack_require__(19);
        /** Built-in value references. */

        var Symbol = root.Symbol;
        module.exports = Symbol;

        /***/
      },
      /* 28 */
      /***/ function (module, exports, __webpack_require__) {
        var getNative = __webpack_require__(34);
        /* Built-in method references that are verified to be native. */

        var nativeCreate = getNative(Object, "create");
        module.exports = nativeCreate;

        /***/
      },
      /* 29 */
      /***/ function (module, exports, __webpack_require__) {
        var isKeyable = __webpack_require__(100);
        /**
         * Gets the data for `map`.
         *
         * @private
         * @param {Object} map The map to query.
         * @param {string} key The reference key.
         * @returns {*} Returns the map data.
         */

        function getMapData(map, key) {
          var data = map.__data__;
          return isKeyable(key)
            ? data[typeof key == "string" ? "string" : "hash"]
            : data.map;
        }

        module.exports = getMapData;

        /***/
      },
      /* 30 */
      /***/ function (module, exports, __webpack_require__) {
        var baseIsArguments = __webpack_require__(115),
          isObjectLike = __webpack_require__(20);
        /** Used for built-in method references. */

        var objectProto = Object.prototype;
        /** Used to check objects for own properties. */

        var hasOwnProperty = objectProto.hasOwnProperty;
        /** Built-in value references. */

        var propertyIsEnumerable = objectProto.propertyIsEnumerable;
        /**
         * Checks if `value` is likely an `arguments` object.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is an `arguments` object,
         *  else `false`.
         * @example
         *
         * _.isArguments(function() { return arguments; }());
         * // => true
         *
         * _.isArguments([1, 2, 3]);
         * // => false
         */

        var isArguments = baseIsArguments(
          (function () {
            return arguments;
          })()
        )
          ? baseIsArguments
          : function (value) {
              return (
                isObjectLike(value) &&
                hasOwnProperty.call(value, "callee") &&
                !propertyIsEnumerable.call(value, "callee")
              );
            };
        module.exports = isArguments;

        /***/
      },
      /* 31 */
      /***/ function (module, exports) {
        /** Used as references for various `Number` constants. */
        var MAX_SAFE_INTEGER = 9007199254740991;
        /** Used to detect unsigned integer values. */

        var reIsUint = /^(?:0|[1-9]\d*)$/;
        /**
         * Checks if `value` is a valid array-like index.
         *
         * @private
         * @param {*} value The value to check.
         * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
         * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
         */

        function isIndex(value, length) {
          var type = typeof value;
          length = length == null ? MAX_SAFE_INTEGER : length;
          return (
            !!length &&
            (type == "number" || (type != "symbol" && reIsUint.test(value))) &&
            value > -1 &&
            value % 1 == 0 &&
            value < length
          );
        }

        module.exports = isIndex;

        /***/
      },
      /* 32 */
      /***/ function (module, exports, __webpack_require__) {
        var isArray = __webpack_require__(16),
          isKey = __webpack_require__(147),
          stringToPath = __webpack_require__(148),
          toString = __webpack_require__(151);
        /**
         * Casts `value` to a path array if it's not one.
         *
         * @private
         * @param {*} value The value to inspect.
         * @param {Object} [object] The object to query keys on.
         * @returns {Array} Returns the cast property path array.
         */

        function castPath(value, object) {
          if (isArray(value)) {
            return value;
          }

          return isKey(value, object) ? [value] : stringToPath(toString(value));
        }

        module.exports = castPath;

        /***/
      },
      /* 33 */
      /***/ function (module, exports, __webpack_require__) {
        var arrayWithoutHoles = __webpack_require__(141);

        var iterableToArray = __webpack_require__(142);

        var unsupportedIterableToArray = __webpack_require__(59);

        var nonIterableSpread = __webpack_require__(143);

        function _toConsumableArray(arr) {
          return (
            arrayWithoutHoles(arr) ||
            iterableToArray(arr) ||
            unsupportedIterableToArray(arr) ||
            nonIterableSpread()
          );
        }

        (module.exports = _toConsumableArray),
          (module.exports.__esModule = true),
          (module.exports["default"] = module.exports);

        /***/
      },
      /* 34 */
      /***/ function (module, exports, __webpack_require__) {
        var baseIsNative = __webpack_require__(85),
          getValue = __webpack_require__(91);
        /**
         * Gets the native function at `key` of `object`.
         *
         * @private
         * @param {Object} object The object to query.
         * @param {string} key The key of the method to get.
         * @returns {*} Returns the function if it's native, else `undefined`.
         */

        function getNative(object, key) {
          var value = getValue(object, key);
          return baseIsNative(value) ? value : undefined;
        }

        module.exports = getNative;

        /***/
      },
      /* 35 */
      /***/ function (module, exports, __webpack_require__) {
        var baseGetTag = __webpack_require__(22),
          isObject = __webpack_require__(15);
        /** `Object#toString` result references. */

        var asyncTag = "[object AsyncFunction]",
          funcTag = "[object Function]",
          genTag = "[object GeneratorFunction]",
          proxyTag = "[object Proxy]";
        /**
         * Checks if `value` is classified as a `Function` object.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a function, else `false`.
         * @example
         *
         * _.isFunction(_);
         * // => true
         *
         * _.isFunction(/abc/);
         * // => false
         */

        function isFunction(value) {
          if (!isObject(value)) {
            return false;
          } // The use of `Object#toString` avoids issues with the `typeof` operator
          // in Safari 9 which returns 'object' for typed arrays and other constructors.

          var tag = baseGetTag(value);
          return (
            tag == funcTag ||
            tag == genTag ||
            tag == asyncTag ||
            tag == proxyTag
          );
        }

        module.exports = isFunction;

        /***/
      },
      /* 36 */
      /***/ function (module, exports, __webpack_require__) {
        var defineProperty = __webpack_require__(48);
        /**
         * The base implementation of `assignValue` and `assignMergeValue` without
         * value checks.
         *
         * @private
         * @param {Object} object The object to modify.
         * @param {string} key The key of the property to assign.
         * @param {*} value The value to assign.
         */

        function baseAssignValue(object, key, value) {
          if (key == "__proto__" && defineProperty) {
            defineProperty(object, key, {
              configurable: true,
              enumerable: true,
              value: value,
              writable: true,
            });
          } else {
            object[key] = value;
          }
        }

        module.exports = baseAssignValue;

        /***/
      },
      /* 37 */
      /***/ function (module, exports) {
        module.exports = function (module) {
          if (!module.webpackPolyfill) {
            module.deprecate = function () {};

            module.paths = []; // module.parent = undefined by default

            if (!module.children) module.children = [];
            Object.defineProperty(module, "loaded", {
              enumerable: true,
              get: function () {
                return module.l;
              },
            });
            Object.defineProperty(module, "id", {
              enumerable: true,
              get: function () {
                return module.i;
              },
            });
            module.webpackPolyfill = 1;
          }

          return module;
        };

        /***/
      },
      /* 38 */
      /***/ function (module, exports, __webpack_require__) {
        var isFunction = __webpack_require__(35),
          isLength = __webpack_require__(39);
        /**
         * Checks if `value` is array-like. A value is considered array-like if it's
         * not a function and has a `value.length` that's an integer greater than or
         * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
         * @example
         *
         * _.isArrayLike([1, 2, 3]);
         * // => true
         *
         * _.isArrayLike(document.body.children);
         * // => true
         *
         * _.isArrayLike('abc');
         * // => true
         *
         * _.isArrayLike(_.noop);
         * // => false
         */

        function isArrayLike(value) {
          return value != null && isLength(value.length) && !isFunction(value);
        }

        module.exports = isArrayLike;

        /***/
      },
      /* 39 */
      /***/ function (module, exports) {
        /** Used as references for various `Number` constants. */
        var MAX_SAFE_INTEGER = 9007199254740991;
        /**
         * Checks if `value` is a valid array-like length.
         *
         * **Note:** This method is loosely based on
         * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
         * @example
         *
         * _.isLength(3);
         * // => true
         *
         * _.isLength(Number.MIN_VALUE);
         * // => false
         *
         * _.isLength(Infinity);
         * // => false
         *
         * _.isLength('3');
         * // => false
         */

        function isLength(value) {
          return (
            typeof value == "number" &&
            value > -1 &&
            value % 1 == 0 &&
            value <= MAX_SAFE_INTEGER
          );
        }

        module.exports = isLength;

        /***/
      },
      /* 40 */
      /***/ function (module, exports) {
        function _setPrototypeOf(o, p) {
          (module.exports = _setPrototypeOf =
            Object.setPrototypeOf
              ? Object.setPrototypeOf.bind()
              : function _setPrototypeOf(o, p) {
                  o.__proto__ = p;
                  return o;
                }),
            (module.exports.__esModule = true),
            (module.exports["default"] = module.exports);
          return _setPrototypeOf(o, p);
        }

        (module.exports = _setPrototypeOf),
          (module.exports.__esModule = true),
          (module.exports["default"] = module.exports);

        /***/
      },
      /* 41 */
      /***/ function (module, exports, __webpack_require__) {
        var baseGetTag = __webpack_require__(22),
          isObjectLike = __webpack_require__(20);
        /** `Object#toString` result references. */

        var symbolTag = "[object Symbol]";
        /**
         * Checks if `value` is classified as a `Symbol` primitive or object.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
         * @example
         *
         * _.isSymbol(Symbol.iterator);
         * // => true
         *
         * _.isSymbol('abc');
         * // => false
         */

        function isSymbol(value) {
          return (
            typeof value == "symbol" ||
            (isObjectLike(value) && baseGetTag(value) == symbolTag)
          );
        }

        module.exports = isSymbol;

        /***/
      },
      /* 42 */
      /***/ function (module, exports, __webpack_require__) {
        var isSymbol = __webpack_require__(41);
        /** Used as references for various `Number` constants. */

        var INFINITY = 1 / 0;
        /**
         * Converts `value` to a string key if it's not a string or symbol.
         *
         * @private
         * @param {*} value The value to inspect.
         * @returns {string|symbol} Returns the key.
         */

        function toKey(value) {
          if (typeof value == "string" || isSymbol(value)) {
            return value;
          }

          var result = value + "";
          return result == "0" && 1 / value == -INFINITY ? "-0" : result;
        }

        module.exports = toKey;

        /***/
      },
      /* 43 */
      /***/ function (module, exports, __webpack_require__) {
        var getNative = __webpack_require__(34),
          root = __webpack_require__(19);
        /* Built-in method references that are verified to be native. */

        var Map = getNative(root, "Map");
        module.exports = Map;

        /***/
      },
      /* 44 */
      /***/ function (module, exports, __webpack_require__) {
        /* WEBPACK VAR INJECTION */ (function (global) {
          /** Detect free variable `global` from Node.js. */
          var freeGlobal =
            typeof global == "object" &&
            global &&
            global.Object === Object &&
            global;
          module.exports = freeGlobal;
          /* WEBPACK VAR INJECTION */
        }.call(this, __webpack_require__(45)));

        /***/
      },
      /* 45 */
      /***/ function (module, exports) {
        var g; // This works in non-strict mode

        g = (function () {
          return this;
        })();

        try {
          // This works if eval is allowed (see CSP)
          g = g || new Function("return this")();
        } catch (e) {
          // This works if the window reference is available
          if (typeof window === "object") g = window;
        } // g can still be undefined, but nothing to do about it...
        // We return undefined, instead of nothing here, so it's
        // easier to handle this case. if(!global) { ...}

        module.exports = g;

        /***/
      },
      /* 46 */
      /***/ function (module, exports, __webpack_require__) {
        var mapCacheClear = __webpack_require__(92),
          mapCacheDelete = __webpack_require__(99),
          mapCacheGet = __webpack_require__(101),
          mapCacheHas = __webpack_require__(102),
          mapCacheSet = __webpack_require__(103);
        /**
         * Creates a map cache object to store key-value pairs.
         *
         * @private
         * @constructor
         * @param {Array} [entries] The key-value pairs to cache.
         */

        function MapCache(entries) {
          var index = -1,
            length = entries == null ? 0 : entries.length;
          this.clear();

          while (++index < length) {
            var entry = entries[index];
            this.set(entry[0], entry[1]);
          }
        } // Add methods to `MapCache`.

        MapCache.prototype.clear = mapCacheClear;
        MapCache.prototype["delete"] = mapCacheDelete;
        MapCache.prototype.get = mapCacheGet;
        MapCache.prototype.has = mapCacheHas;
        MapCache.prototype.set = mapCacheSet;
        module.exports = MapCache;

        /***/
      },
      /* 47 */
      /***/ function (module, exports, __webpack_require__) {
        var baseAssignValue = __webpack_require__(36),
          eq = __webpack_require__(26);
        /**
         * This function is like `assignValue` except that it doesn't assign
         * `undefined` values.
         *
         * @private
         * @param {Object} object The object to modify.
         * @param {string} key The key of the property to assign.
         * @param {*} value The value to assign.
         */

        function assignMergeValue(object, key, value) {
          if (
            (value !== undefined && !eq(object[key], value)) ||
            (value === undefined && !(key in object))
          ) {
            baseAssignValue(object, key, value);
          }
        }

        module.exports = assignMergeValue;

        /***/
      },
      /* 48 */
      /***/ function (module, exports, __webpack_require__) {
        var getNative = __webpack_require__(34);

        var defineProperty = (function () {
          try {
            var func = getNative(Object, "defineProperty");
            func({}, "", {});
            return func;
          } catch (e) {}
        })();

        module.exports = defineProperty;

        /***/
      },
      /* 49 */
      /***/ function (module, exports, __webpack_require__) {
        var overArg = __webpack_require__(114);
        /** Built-in value references. */

        var getPrototype = overArg(Object.getPrototypeOf, Object);
        module.exports = getPrototype;

        /***/
      },
      /* 50 */
      /***/ function (module, exports) {
        /** Used for built-in method references. */
        var objectProto = Object.prototype;
        /**
         * Checks if `value` is likely a prototype object.
         *
         * @private
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
         */

        function isPrototype(value) {
          var Ctor = value && value.constructor,
            proto =
              (typeof Ctor == "function" && Ctor.prototype) || objectProto;
          return value === proto;
        }

        module.exports = isPrototype;

        /***/
      },
      /* 51 */
      /***/ function (module, exports, __webpack_require__) {
        /* WEBPACK VAR INJECTION */ (function (module) {
          var root = __webpack_require__(19),
            stubFalse = __webpack_require__(117);
          /** Detect free variable `exports`. */

          var freeExports = true && exports && !exports.nodeType && exports;
          /** Detect free variable `module`. */

          var freeModule =
            freeExports &&
            typeof module == "object" &&
            module &&
            !module.nodeType &&
            module;
          /** Detect the popular CommonJS extension `module.exports`. */

          var moduleExports = freeModule && freeModule.exports === freeExports;
          /** Built-in value references. */

          var Buffer = moduleExports ? root.Buffer : undefined;
          /* Built-in method references for those with the same name as other `lodash` methods. */

          var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;
          /**
           * Checks if `value` is a buffer.
           *
           * @static
           * @memberOf _
           * @since 4.3.0
           * @category Lang
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
           * @example
           *
           * _.isBuffer(new Buffer(2));
           * // => true
           *
           * _.isBuffer(new Uint8Array(2));
           * // => false
           */

          var isBuffer = nativeIsBuffer || stubFalse;
          module.exports = isBuffer;
          /* WEBPACK VAR INJECTION */
        }.call(this, __webpack_require__(37)(module)));

        /***/
      },
      /* 52 */
      /***/ function (module, exports, __webpack_require__) {
        var baseIsTypedArray = __webpack_require__(119),
          baseUnary = __webpack_require__(120),
          nodeUtil = __webpack_require__(121);
        /* Node.js helper references. */

        var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
        /**
         * Checks if `value` is classified as a typed array.
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
         * @example
         *
         * _.isTypedArray(new Uint8Array);
         * // => true
         *
         * _.isTypedArray([]);
         * // => false
         */

        var isTypedArray = nodeIsTypedArray
          ? baseUnary(nodeIsTypedArray)
          : baseIsTypedArray;
        module.exports = isTypedArray;

        /***/
      },
      /* 53 */
      /***/ function (module, exports) {
        /**
         * Gets the value at `key`, unless `key` is "__proto__" or "constructor".
         *
         * @private
         * @param {Object} object The object to query.
         * @param {string} key The key of the property to get.
         * @returns {*} Returns the property value.
         */
        function safeGet(object, key) {
          if (key === "constructor" && typeof object[key] === "function") {
            return;
          }

          if (key == "__proto__") {
            return;
          }

          return object[key];
        }

        module.exports = safeGet;

        /***/
      },
      /* 54 */
      /***/ function (module, exports, __webpack_require__) {
        var baseAssignValue = __webpack_require__(36),
          eq = __webpack_require__(26);
        /** Used for built-in method references. */

        var objectProto = Object.prototype;
        /** Used to check objects for own properties. */

        var hasOwnProperty = objectProto.hasOwnProperty;
        /**
         * Assigns `value` to `key` of `object` if the existing value is not equivalent
         * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
         * for equality comparisons.
         *
         * @private
         * @param {Object} object The object to modify.
         * @param {string} key The key of the property to assign.
         * @param {*} value The value to assign.
         */

        function assignValue(object, key, value) {
          var objValue = object[key];

          if (
            !(hasOwnProperty.call(object, key) && eq(objValue, value)) ||
            (value === undefined && !(key in object))
          ) {
            baseAssignValue(object, key, value);
          }
        }

        module.exports = assignValue;

        /***/
      },
      /* 55 */
      /***/ function (module, exports, __webpack_require__) {
        var arrayLikeKeys = __webpack_require__(124),
          baseKeysIn = __webpack_require__(126),
          isArrayLike = __webpack_require__(38);
        /**
         * Creates an array of the own and inherited enumerable property names of `object`.
         *
         * **Note:** Non-object values are coerced to objects.
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category Object
         * @param {Object} object The object to query.
         * @returns {Array} Returns the array of property names.
         * @example
         *
         * function Foo() {
         *   this.a = 1;
         *   this.b = 2;
         * }
         *
         * Foo.prototype.c = 3;
         *
         * _.keysIn(new Foo);
         * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
         */

        function keysIn(object) {
          return isArrayLike(object)
            ? arrayLikeKeys(object, true)
            : baseKeysIn(object);
        }

        module.exports = keysIn;

        /***/
      },
      /* 56 */
      /***/ function (module, exports) {
        /**
         * This method returns the first argument it receives.
         *
         * @static
         * @since 0.1.0
         * @memberOf _
         * @category Util
         * @param {*} value Any value.
         * @returns {*} Returns `value`.
         * @example
         *
         * var object = { 'a': 1 };
         *
         * console.log(_.identity(object) === object);
         * // => true
         */
        function identity(value) {
          return value;
        }

        module.exports = identity;

        /***/
      },
      /* 57 */
      /***/ function (module, exports, __webpack_require__) {
        var apply = __webpack_require__(130);
        /* Built-in method references for those with the same name as other `lodash` methods. */

        var nativeMax = Math.max;
        /**
         * A specialized version of `baseRest` which transforms the rest array.
         *
         * @private
         * @param {Function} func The function to apply a rest parameter to.
         * @param {number} [start=func.length-1] The start position of the rest parameter.
         * @param {Function} transform The rest array transform.
         * @returns {Function} Returns the new function.
         */

        function overRest(func, start, transform) {
          start = nativeMax(start === undefined ? func.length - 1 : start, 0);
          return function () {
            var args = arguments,
              index = -1,
              length = nativeMax(args.length - start, 0),
              array = Array(length);

            while (++index < length) {
              array[index] = args[start + index];
            }

            index = -1;
            var otherArgs = Array(start + 1);

            while (++index < start) {
              otherArgs[index] = args[index];
            }

            otherArgs[start] = transform(array);
            return apply(func, this, otherArgs);
          };
        }

        module.exports = overRest;

        /***/
      },
      /* 58 */
      /***/ function (module, exports, __webpack_require__) {
        var baseSetToString = __webpack_require__(131),
          shortOut = __webpack_require__(133);
        /**
         * Sets the `toString` method of `func` to return `string`.
         *
         * @private
         * @param {Function} func The function to modify.
         * @param {Function} string The `toString` result.
         * @returns {Function} Returns `func`.
         */

        var setToString = shortOut(baseSetToString);
        module.exports = setToString;

        /***/
      },
      /* 59 */
      /***/ function (module, exports, __webpack_require__) {
        var arrayLikeToArray = __webpack_require__(60);

        function _unsupportedIterableToArray(o, minLen) {
          if (!o) return;
          if (typeof o === "string") return arrayLikeToArray(o, minLen);
          var n = Object.prototype.toString.call(o).slice(8, -1);
          if (n === "Object" && o.constructor) n = o.constructor.name;
          if (n === "Map" || n === "Set") return Array.from(o);
          if (
            n === "Arguments" ||
            /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)
          )
            return arrayLikeToArray(o, minLen);
        }

        (module.exports = _unsupportedIterableToArray),
          (module.exports.__esModule = true),
          (module.exports["default"] = module.exports);

        /***/
      },
      /* 60 */
      /***/ function (module, exports) {
        function _arrayLikeToArray(arr, len) {
          if (len == null || len > arr.length) len = arr.length;

          for (var i = 0, arr2 = new Array(len); i < len; i++) {
            arr2[i] = arr[i];
          }

          return arr2;
        }

        (module.exports = _arrayLikeToArray),
          (module.exports.__esModule = true),
          (module.exports["default"] = module.exports);

        /***/
      },
      /* 61 */
      /***/ function (module, exports, __webpack_require__) {
        var arrayWithHoles = __webpack_require__(136);

        var iterableToArrayLimit = __webpack_require__(137);

        var unsupportedIterableToArray = __webpack_require__(59);

        var nonIterableRest = __webpack_require__(138);

        function _slicedToArray(arr, i) {
          return (
            arrayWithHoles(arr) ||
            iterableToArrayLimit(arr, i) ||
            unsupportedIterableToArray(arr, i) ||
            nonIterableRest()
          );
        }

        (module.exports = _slicedToArray),
          (module.exports.__esModule = true),
          (module.exports["default"] = module.exports);

        /***/
      },
      /* 62 */
      /***/ function (module, exports, __webpack_require__) {
        var basePick = __webpack_require__(144),
          flatRest = __webpack_require__(158);
        /**
         * Creates an object composed of the picked `object` properties.
         *
         * @static
         * @since 0.1.0
         * @memberOf _
         * @category Object
         * @param {Object} object The source object.
         * @param {...(string|string[])} [paths] The property paths to pick.
         * @returns {Object} Returns the new object.
         * @example
         *
         * var object = { 'a': 1, 'b': '2', 'c': 3 };
         *
         * _.pick(object, ['a', 'c']);
         * // => { 'a': 1, 'c': 3 }
         */

        var pick = flatRest(function (object, paths) {
          return object == null ? {} : basePick(object, paths);
        });
        module.exports = pick;

        /***/
      },
      /* 63 */
      /***/ function (module, exports, __webpack_require__) {
        var getPrototypeOf = __webpack_require__(2);

        var setPrototypeOf = __webpack_require__(40);

        var isNativeFunction = __webpack_require__(163);

        var construct = __webpack_require__(164);

        function _wrapNativeSuper(Class) {
          var _cache = typeof Map === "function" ? new Map() : undefined;

          (module.exports = _wrapNativeSuper =
            function _wrapNativeSuper(Class) {
              if (Class === null || !isNativeFunction(Class)) return Class;

              if (typeof Class !== "function") {
                throw new TypeError(
                  "Super expression must either be null or a function"
                );
              }

              if (typeof _cache !== "undefined") {
                if (_cache.has(Class)) return _cache.get(Class);

                _cache.set(Class, Wrapper);
              }

              function Wrapper() {
                return construct(
                  Class,
                  arguments,
                  getPrototypeOf(this).constructor
                );
              }

              Wrapper.prototype = Object.create(Class.prototype, {
                constructor: {
                  value: Wrapper,
                  enumerable: false,
                  writable: true,
                  configurable: true,
                },
              });
              return setPrototypeOf(Wrapper, Class);
            }),
            (module.exports.__esModule = true),
            (module.exports["default"] = module.exports);
          return _wrapNativeSuper(Class);
        }

        (module.exports = _wrapNativeSuper),
          (module.exports.__esModule = true),
          (module.exports["default"] = module.exports);

        /***/
      },
      /* 64 */
      /***/ function (module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony import */ var _tracer__WEBPACK_IMPORTED_MODULE_0__ =
          __webpack_require__(21);

        /**
         * http://www.codeproject.com/Tips/407172/Connected-Component-Labeling-and-Vectorization
         */

        var Rasterizer = {
          createContour2D: function createContour2D() {
            return {
              dir: null,
              index: null,
              firstVertex: null,
              insideContours: null,
              nextpeer: null,
              prevpeer: null,
            };
          },
          CONTOUR_DIR: {
            CW_DIR: 0,
            CCW_DIR: 1,
            UNKNOWN_DIR: 2,
          },
          DIR: {
            OUTSIDE_EDGE: -32767,
            INSIDE_EDGE: -32766,
          },
          create: function create(imageWrapper, labelWrapper) {
            var imageData = imageWrapper.data;
            var labelData = labelWrapper.data;
            var width = imageWrapper.size.x;
            var height = imageWrapper.size.y;
            var tracer = _tracer__WEBPACK_IMPORTED_MODULE_0__[
              /* default */ "a"
            ].create(imageWrapper, labelWrapper);
            return {
              rasterize: function rasterize(depthlabel) {
                var color;
                var bc;
                var lc;
                var labelindex;
                var cx;
                var cy;
                var colorMap = [];
                var vertex;
                var p;
                var cc;
                var sc;
                var pos;
                var connectedCount = 0;
                var i;

                for (i = 0; i < 400; i++) {
                  colorMap[i] = 0;
                }

                colorMap[0] = imageData[0];
                cc = null;

                for (cy = 1; cy < height - 1; cy++) {
                  labelindex = 0;
                  bc = colorMap[0];

                  for (cx = 1; cx < width - 1; cx++) {
                    pos = cy * width + cx;

                    if (labelData[pos] === 0) {
                      color = imageData[pos];

                      if (color !== bc) {
                        if (labelindex === 0) {
                          lc = connectedCount + 1;
                          colorMap[lc] = color;
                          bc = color;
                          vertex = tracer.contourTracing(
                            cy,
                            cx,
                            lc,
                            color,
                            Rasterizer.DIR.OUTSIDE_EDGE
                          );

                          if (vertex !== null) {
                            connectedCount++;
                            labelindex = lc;
                            p = Rasterizer.createContour2D();
                            p.dir = Rasterizer.CONTOUR_DIR.CW_DIR;
                            p.index = labelindex;
                            p.firstVertex = vertex;
                            p.nextpeer = cc;
                            p.insideContours = null;

                            if (cc !== null) {
                              cc.prevpeer = p;
                            }

                            cc = p;
                          }
                        } else {
                          vertex = tracer.contourTracing(
                            cy,
                            cx,
                            Rasterizer.DIR.INSIDE_EDGE,
                            color,
                            labelindex
                          );

                          if (vertex !== null) {
                            p = Rasterizer.createContour2D();
                            p.firstVertex = vertex;
                            p.insideContours = null;

                            if (depthlabel === 0) {
                              p.dir = Rasterizer.CONTOUR_DIR.CCW_DIR;
                            } else {
                              p.dir = Rasterizer.CONTOUR_DIR.CW_DIR;
                            }

                            p.index = depthlabel;
                            sc = cc;

                            while (sc !== null && sc.index !== labelindex) {
                              sc = sc.nextpeer;
                            }

                            if (sc !== null) {
                              p.nextpeer = sc.insideContours;

                              if (sc.insideContours !== null) {
                                sc.insideContours.prevpeer = p;
                              }

                              sc.insideContours = p;
                            }
                          }
                        }
                      } else {
                        labelData[pos] = labelindex;
                      }
                    } else if (
                      labelData[pos] === Rasterizer.DIR.OUTSIDE_EDGE ||
                      labelData[pos] === Rasterizer.DIR.INSIDE_EDGE
                    ) {
                      labelindex = 0;

                      if (labelData[pos] === Rasterizer.DIR.INSIDE_EDGE) {
                        bc = imageData[pos];
                      } else {
                        bc = colorMap[0];
                      }
                    } else {
                      labelindex = labelData[pos];
                      bc = colorMap[labelindex];
                    }
                  }
                }

                sc = cc;

                while (sc !== null) {
                  sc.index = depthlabel;
                  sc = sc.nextpeer;
                }

                return {
                  cc: cc,
                  count: connectedCount,
                };
              },
              debug: {
                drawContour: function drawContour(canvas, firstContour) {
                  var ctx = canvas.getContext("2d");
                  var pq = firstContour;
                  var iq;
                  var q;
                  var p;
                  ctx.strokeStyle = "red";
                  ctx.fillStyle = "red";
                  ctx.lineWidth = 1;

                  if (pq !== null) {
                    iq = pq.insideContours;
                  } else {
                    iq = null;
                  }

                  while (pq !== null) {
                    if (iq !== null) {
                      q = iq;
                      iq = iq.nextpeer;
                    } else {
                      q = pq;
                      pq = pq.nextpeer;

                      if (pq !== null) {
                        iq = pq.insideContours;
                      } else {
                        iq = null;
                      }
                    }

                    switch (q.dir) {
                      case Rasterizer.CONTOUR_DIR.CW_DIR:
                        ctx.strokeStyle = "red";
                        break;

                      case Rasterizer.CONTOUR_DIR.CCW_DIR:
                        ctx.strokeStyle = "blue";
                        break;

                      case Rasterizer.CONTOUR_DIR.UNKNOWN_DIR:
                        ctx.strokeStyle = "green";
                        break;
                    }

                    p = q.firstVertex;
                    ctx.beginPath();
                    ctx.moveTo(p.x, p.y);

                    do {
                      p = p.next;
                      ctx.lineTo(p.x, p.y);
                    } while (p !== q.firstVertex);

                    ctx.stroke();
                  }
                },
              },
            };
          },
        };
        /* harmony default export */ __webpack_exports__["a"] = Rasterizer;

        /***/
      },
      /* 65 */
      /***/ function (module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* eslint-disable no-param-reassign */

        /* eslint-disable no-bitwise */

        /* eslint-disable eqeqeq */

        /* @preserve ASM BEGIN */
        function Skeletonizer(stdlib, foreign, buffer) {
          "use asm";

          var images = new stdlib.Uint8Array(buffer);
          var size = foreign.size | 0;
          var imul = stdlib.Math.imul;

          function erode(inImagePtr, outImagePtr) {
            inImagePtr |= 0;
            outImagePtr |= 0;
            var v = 0;
            var u = 0;
            var sum = 0;
            var yStart1 = 0;
            var yStart2 = 0;
            var xStart1 = 0;
            var xStart2 = 0;
            var offset = 0;

            for (v = 1; (v | 0) < ((size - 1) | 0); v = (v + 1) | 0) {
              offset = (offset + size) | 0;

              for (u = 1; (u | 0) < ((size - 1) | 0); u = (u + 1) | 0) {
                yStart1 = (offset - size) | 0;
                yStart2 = (offset + size) | 0;
                xStart1 = (u - 1) | 0;
                xStart2 = (u + 1) | 0;
                sum =
                  ((images[(inImagePtr + yStart1 + xStart1) | 0] | 0) +
                    (images[(inImagePtr + yStart1 + xStart2) | 0] | 0) +
                    (images[(inImagePtr + offset + u) | 0] | 0) +
                    (images[(inImagePtr + yStart2 + xStart1) | 0] | 0) +
                    (images[(inImagePtr + yStart2 + xStart2) | 0] | 0)) |
                  0;

                if ((sum | 0) == (5 | 0)) {
                  images[(outImagePtr + offset + u) | 0] = 1;
                } else {
                  images[(outImagePtr + offset + u) | 0] = 0;
                }
              }
            }
          }

          function subtract(aImagePtr, bImagePtr, outImagePtr) {
            aImagePtr |= 0;
            bImagePtr |= 0;
            outImagePtr |= 0;
            var length = 0;
            length = imul(size, size) | 0;

            while ((length | 0) > 0) {
              length = (length - 1) | 0;
              images[(outImagePtr + length) | 0] =
                ((images[(aImagePtr + length) | 0] | 0) -
                  (images[(bImagePtr + length) | 0] | 0)) |
                0;
            }
          }

          function bitwiseOr(aImagePtr, bImagePtr, outImagePtr) {
            aImagePtr |= 0;
            bImagePtr |= 0;
            outImagePtr |= 0;
            var length = 0;
            length = imul(size, size) | 0;

            while ((length | 0) > 0) {
              length = (length - 1) | 0;
              images[(outImagePtr + length) | 0] =
                images[(aImagePtr + length) | 0] |
                0 |
                (images[(bImagePtr + length) | 0] | 0) |
                0;
            }
          }

          function countNonZero(imagePtr) {
            imagePtr |= 0;
            var sum = 0;
            var length = 0;
            length = imul(size, size) | 0;

            while ((length | 0) > 0) {
              length = (length - 1) | 0;
              sum = ((sum | 0) + (images[(imagePtr + length) | 0] | 0)) | 0;
            }

            return sum | 0;
          }

          function init(imagePtr, value) {
            imagePtr |= 0;
            value |= 0;
            var length = 0;
            length = imul(size, size) | 0;

            while ((length | 0) > 0) {
              length = (length - 1) | 0;
              images[(imagePtr + length) | 0] = value;
            }
          }

          function dilate(inImagePtr, outImagePtr) {
            inImagePtr |= 0;
            outImagePtr |= 0;
            var v = 0;
            var u = 0;
            var sum = 0;
            var yStart1 = 0;
            var yStart2 = 0;
            var xStart1 = 0;
            var xStart2 = 0;
            var offset = 0;

            for (v = 1; (v | 0) < ((size - 1) | 0); v = (v + 1) | 0) {
              offset = (offset + size) | 0;

              for (u = 1; (u | 0) < ((size - 1) | 0); u = (u + 1) | 0) {
                yStart1 = (offset - size) | 0;
                yStart2 = (offset + size) | 0;
                xStart1 = (u - 1) | 0;
                xStart2 = (u + 1) | 0;
                sum =
                  ((images[(inImagePtr + yStart1 + xStart1) | 0] | 0) +
                    (images[(inImagePtr + yStart1 + xStart2) | 0] | 0) +
                    (images[(inImagePtr + offset + u) | 0] | 0) +
                    (images[(inImagePtr + yStart2 + xStart1) | 0] | 0) +
                    (images[(inImagePtr + yStart2 + xStart2) | 0] | 0)) |
                  0;

                if ((sum | 0) > (0 | 0)) {
                  images[(outImagePtr + offset + u) | 0] = 1;
                } else {
                  images[(outImagePtr + offset + u) | 0] = 0;
                }
              }
            }
          }

          function memcpy(srcImagePtr, dstImagePtr) {
            srcImagePtr |= 0;
            dstImagePtr |= 0;
            var length = 0;
            length = imul(size, size) | 0;

            while ((length | 0) > 0) {
              length = (length - 1) | 0;
              images[(dstImagePtr + length) | 0] =
                images[(srcImagePtr + length) | 0] | 0;
            }
          }

          function zeroBorder(imagePtr) {
            imagePtr |= 0;
            var x = 0;
            var y = 0;

            for (x = 0; (x | 0) < ((size - 1) | 0); x = (x + 1) | 0) {
              images[(imagePtr + x) | 0] = 0;
              images[(imagePtr + y) | 0] = 0;
              y = (y + size - 1) | 0;
              images[(imagePtr + y) | 0] = 0;
              y = (y + 1) | 0;
            }

            for (x = 0; (x | 0) < (size | 0); x = (x + 1) | 0) {
              images[(imagePtr + y) | 0] = 0;
              y = (y + 1) | 0;
            }
          }

          function skeletonize() {
            var subImagePtr = 0;
            var erodedImagePtr = 0;
            var tempImagePtr = 0;
            var skelImagePtr = 0;
            var sum = 0;
            var done = 0;
            erodedImagePtr = imul(size, size) | 0;
            tempImagePtr = (erodedImagePtr + erodedImagePtr) | 0;
            skelImagePtr = (tempImagePtr + erodedImagePtr) | 0; // init skel-image

            init(skelImagePtr, 0);
            zeroBorder(subImagePtr);

            do {
              erode(subImagePtr, erodedImagePtr);
              dilate(erodedImagePtr, tempImagePtr);
              subtract(subImagePtr, tempImagePtr, tempImagePtr);
              bitwiseOr(skelImagePtr, tempImagePtr, skelImagePtr);
              memcpy(erodedImagePtr, subImagePtr);
              sum = countNonZero(subImagePtr) | 0;
              done = ((sum | 0) == 0) | 0;
            } while (!done);
          }

          return {
            skeletonize: skeletonize,
          };
        }
        /* @preserve ASM END */

        /* harmony default export */ __webpack_exports__["a"] = Skeletonizer;
        /* eslint-enable eqeqeq */

        /***/
      },
      ,
      ,
      ,
      ,
      ,
      ,
      /* 66 */ /* 67 */ /* 68 */ /* 69 */ /* 70 */ /* 71 */ /* 72 */
      /***/ function (module, exports, __webpack_require__) {
        module.exports = __webpack_require__(166);

        /***/
      },
      /* 73 */
      /***/ function (module, exports, __webpack_require__) {
        var Stack = __webpack_require__(74),
          assignMergeValue = __webpack_require__(47),
          baseFor = __webpack_require__(104),
          baseMergeDeep = __webpack_require__(106),
          isObject = __webpack_require__(15),
          keysIn = __webpack_require__(55),
          safeGet = __webpack_require__(53);
        /**
         * The base implementation of `_.merge` without support for multiple sources.
         *
         * @private
         * @param {Object} object The destination object.
         * @param {Object} source The source object.
         * @param {number} srcIndex The index of `source`.
         * @param {Function} [customizer] The function to customize merged values.
         * @param {Object} [stack] Tracks traversed source values and their merged
         *  counterparts.
         */

        function baseMerge(object, source, srcIndex, customizer, stack) {
          if (object === source) {
            return;
          }

          baseFor(
            source,
            function (srcValue, key) {
              stack || (stack = new Stack());

              if (isObject(srcValue)) {
                baseMergeDeep(
                  object,
                  source,
                  key,
                  srcIndex,
                  baseMerge,
                  customizer,
                  stack
                );
              } else {
                var newValue = customizer
                  ? customizer(
                      safeGet(object, key),
                      srcValue,
                      key + "",
                      object,
                      source,
                      stack
                    )
                  : undefined;

                if (newValue === undefined) {
                  newValue = srcValue;
                }

                assignMergeValue(object, key, newValue);
              }
            },
            keysIn
          );
        }

        module.exports = baseMerge;

        /***/
      },
      /* 74 */
      /***/ function (module, exports, __webpack_require__) {
        var ListCache = __webpack_require__(24),
          stackClear = __webpack_require__(80),
          stackDelete = __webpack_require__(81),
          stackGet = __webpack_require__(82),
          stackHas = __webpack_require__(83),
          stackSet = __webpack_require__(84);
        /**
         * Creates a stack cache object to store key-value pairs.
         *
         * @private
         * @constructor
         * @param {Array} [entries] The key-value pairs to cache.
         */

        function Stack(entries) {
          var data = (this.__data__ = new ListCache(entries));
          this.size = data.size;
        } // Add methods to `Stack`.

        Stack.prototype.clear = stackClear;
        Stack.prototype["delete"] = stackDelete;
        Stack.prototype.get = stackGet;
        Stack.prototype.has = stackHas;
        Stack.prototype.set = stackSet;
        module.exports = Stack;

        /***/
      },
      /* 75 */
      /***/ function (module, exports) {
        /**
         * Removes all key-value entries from the list cache.
         *
         * @private
         * @name clear
         * @memberOf ListCache
         */
        function listCacheClear() {
          this.__data__ = [];
          this.size = 0;
        }

        module.exports = listCacheClear;

        /***/
      },
      /* 76 */
      /***/ function (module, exports, __webpack_require__) {
        var assocIndexOf = __webpack_require__(25);
        /** Used for built-in method references. */

        var arrayProto = Array.prototype;
        /** Built-in value references. */

        var splice = arrayProto.splice;
        /**
         * Removes `key` and its value from the list cache.
         *
         * @private
         * @name delete
         * @memberOf ListCache
         * @param {string} key The key of the value to remove.
         * @returns {boolean} Returns `true` if the entry was removed, else `false`.
         */

        function listCacheDelete(key) {
          var data = this.__data__,
            index = assocIndexOf(data, key);

          if (index < 0) {
            return false;
          }

          var lastIndex = data.length - 1;

          if (index == lastIndex) {
            data.pop();
          } else {
            splice.call(data, index, 1);
          }

          --this.size;
          return true;
        }

        module.exports = listCacheDelete;

        /***/
      },
      /* 77 */
      /***/ function (module, exports, __webpack_require__) {
        var assocIndexOf = __webpack_require__(25);
        /**
         * Gets the list cache value for `key`.
         *
         * @private
         * @name get
         * @memberOf ListCache
         * @param {string} key The key of the value to get.
         * @returns {*} Returns the entry value.
         */

        function listCacheGet(key) {
          var data = this.__data__,
            index = assocIndexOf(data, key);
          return index < 0 ? undefined : data[index][1];
        }

        module.exports = listCacheGet;

        /***/
      },
      /* 78 */
      /***/ function (module, exports, __webpack_require__) {
        var assocIndexOf = __webpack_require__(25);
        /**
         * Checks if a list cache value for `key` exists.
         *
         * @private
         * @name has
         * @memberOf ListCache
         * @param {string} key The key of the entry to check.
         * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
         */

        function listCacheHas(key) {
          return assocIndexOf(this.__data__, key) > -1;
        }

        module.exports = listCacheHas;

        /***/
      },
      /* 79 */
      /***/ function (module, exports, __webpack_require__) {
        var assocIndexOf = __webpack_require__(25);
        /**
         * Sets the list cache `key` to `value`.
         *
         * @private
         * @name set
         * @memberOf ListCache
         * @param {string} key The key of the value to set.
         * @param {*} value The value to set.
         * @returns {Object} Returns the list cache instance.
         */

        function listCacheSet(key, value) {
          var data = this.__data__,
            index = assocIndexOf(data, key);

          if (index < 0) {
            ++this.size;
            data.push([key, value]);
          } else {
            data[index][1] = value;
          }

          return this;
        }

        module.exports = listCacheSet;

        /***/
      },
      /* 80 */
      /***/ function (module, exports, __webpack_require__) {
        var ListCache = __webpack_require__(24);
        /**
         * Removes all key-value entries from the stack.
         *
         * @private
         * @name clear
         * @memberOf Stack
         */

        function stackClear() {
          this.__data__ = new ListCache();
          this.size = 0;
        }

        module.exports = stackClear;

        /***/
      },
      /* 81 */
      /***/ function (module, exports) {
        /**
         * Removes `key` and its value from the stack.
         *
         * @private
         * @name delete
         * @memberOf Stack
         * @param {string} key The key of the value to remove.
         * @returns {boolean} Returns `true` if the entry was removed, else `false`.
         */
        function stackDelete(key) {
          var data = this.__data__,
            result = data["delete"](key);
          this.size = data.size;
          return result;
        }

        module.exports = stackDelete;

        /***/
      },
      /* 82 */
      /***/ function (module, exports) {
        /**
         * Gets the stack value for `key`.
         *
         * @private
         * @name get
         * @memberOf Stack
         * @param {string} key The key of the value to get.
         * @returns {*} Returns the entry value.
         */
        function stackGet(key) {
          return this.__data__.get(key);
        }

        module.exports = stackGet;

        /***/
      },
      /* 83 */
      /***/ function (module, exports) {
        /**
         * Checks if a stack value for `key` exists.
         *
         * @private
         * @name has
         * @memberOf Stack
         * @param {string} key The key of the entry to check.
         * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
         */
        function stackHas(key) {
          return this.__data__.has(key);
        }

        module.exports = stackHas;

        /***/
      },
      /* 84 */
      /***/ function (module, exports, __webpack_require__) {
        var ListCache = __webpack_require__(24),
          Map = __webpack_require__(43),
          MapCache = __webpack_require__(46);
        /** Used as the size to enable large array optimizations. */

        var LARGE_ARRAY_SIZE = 200;
        /**
         * Sets the stack `key` to `value`.
         *
         * @private
         * @name set
         * @memberOf Stack
         * @param {string} key The key of the value to set.
         * @param {*} value The value to set.
         * @returns {Object} Returns the stack cache instance.
         */

        function stackSet(key, value) {
          var data = this.__data__;

          if (data instanceof ListCache) {
            var pairs = data.__data__;

            if (!Map || pairs.length < LARGE_ARRAY_SIZE - 1) {
              pairs.push([key, value]);
              this.size = ++data.size;
              return this;
            }

            data = this.__data__ = new MapCache(pairs);
          }

          data.set(key, value);
          this.size = data.size;
          return this;
        }

        module.exports = stackSet;

        /***/
      },
      /* 85 */
      /***/ function (module, exports, __webpack_require__) {
        var isFunction = __webpack_require__(35),
          isMasked = __webpack_require__(88),
          isObject = __webpack_require__(15),
          toSource = __webpack_require__(90);
        /**
         * Used to match `RegExp`
         * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
         */

        var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
        /** Used to detect host constructors (Safari). */

        var reIsHostCtor = /^\[object .+?Constructor\]$/;
        /** Used for built-in method references. */

        var funcProto = Function.prototype,
          objectProto = Object.prototype;
        /** Used to resolve the decompiled source of functions. */

        var funcToString = funcProto.toString;
        /** Used to check objects for own properties. */

        var hasOwnProperty = objectProto.hasOwnProperty;
        /** Used to detect if a method is native. */

        var reIsNative = RegExp(
          "^" +
            funcToString
              .call(hasOwnProperty)
              .replace(reRegExpChar, "\\$&")
              .replace(
                /hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,
                "$1.*?"
              ) +
            "$"
        );
        /**
         * The base implementation of `_.isNative` without bad shim checks.
         *
         * @private
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a native function,
         *  else `false`.
         */

        function baseIsNative(value) {
          if (!isObject(value) || isMasked(value)) {
            return false;
          }

          var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
          return pattern.test(toSource(value));
        }

        module.exports = baseIsNative;

        /***/
      },
      /* 86 */
      /***/ function (module, exports, __webpack_require__) {
        var Symbol = __webpack_require__(27);
        /** Used for built-in method references. */

        var objectProto = Object.prototype;
        /** Used to check objects for own properties. */

        var hasOwnProperty = objectProto.hasOwnProperty;
        /**
         * Used to resolve the
         * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
         * of values.
         */

        var nativeObjectToString = objectProto.toString;
        /** Built-in value references. */

        var symToStringTag = Symbol ? Symbol.toStringTag : undefined;
        /**
         * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
         *
         * @private
         * @param {*} value The value to query.
         * @returns {string} Returns the raw `toStringTag`.
         */

        function getRawTag(value) {
          var isOwn = hasOwnProperty.call(value, symToStringTag),
            tag = value[symToStringTag];

          try {
            value[symToStringTag] = undefined;
            var unmasked = true;
          } catch (e) {}

          var result = nativeObjectToString.call(value);

          if (unmasked) {
            if (isOwn) {
              value[symToStringTag] = tag;
            } else {
              delete value[symToStringTag];
            }
          }

          return result;
        }

        module.exports = getRawTag;

        /***/
      },
      /* 87 */
      /***/ function (module, exports) {
        /** Used for built-in method references. */
        var objectProto = Object.prototype;
        /**
         * Used to resolve the
         * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
         * of values.
         */

        var nativeObjectToString = objectProto.toString;
        /**
         * Converts `value` to a string using `Object.prototype.toString`.
         *
         * @private
         * @param {*} value The value to convert.
         * @returns {string} Returns the converted string.
         */

        function objectToString(value) {
          return nativeObjectToString.call(value);
        }

        module.exports = objectToString;

        /***/
      },
      /* 88 */
      /***/ function (module, exports, __webpack_require__) {
        var coreJsData = __webpack_require__(89);
        /** Used to detect methods masquerading as native. */

        var maskSrcKey = (function () {
          var uid = /[^.]+$/.exec(
            (coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO) || ""
          );
          return uid ? "Symbol(src)_1." + uid : "";
        })();
        /**
         * Checks if `func` has its source masked.
         *
         * @private
         * @param {Function} func The function to check.
         * @returns {boolean} Returns `true` if `func` is masked, else `false`.
         */

        function isMasked(func) {
          return !!maskSrcKey && maskSrcKey in func;
        }

        module.exports = isMasked;

        /***/
      },
      /* 89 */
      /***/ function (module, exports, __webpack_require__) {
        var root = __webpack_require__(19);
        /** Used to detect overreaching core-js shims. */

        var coreJsData = root["__core-js_shared__"];
        module.exports = coreJsData;

        /***/
      },
      /* 90 */
      /***/ function (module, exports) {
        /** Used for built-in method references. */
        var funcProto = Function.prototype;
        /** Used to resolve the decompiled source of functions. */

        var funcToString = funcProto.toString;
        /**
         * Converts `func` to its source code.
         *
         * @private
         * @param {Function} func The function to convert.
         * @returns {string} Returns the source code.
         */

        function toSource(func) {
          if (func != null) {
            try {
              return funcToString.call(func);
            } catch (e) {}

            try {
              return func + "";
            } catch (e) {}
          }

          return "";
        }

        module.exports = toSource;

        /***/
      },
      /* 91 */
      /***/ function (module, exports) {
        /**
         * Gets the value at `key` of `object`.
         *
         * @private
         * @param {Object} [object] The object to query.
         * @param {string} key The key of the property to get.
         * @returns {*} Returns the property value.
         */
        function getValue(object, key) {
          return object == null ? undefined : object[key];
        }

        module.exports = getValue;

        /***/
      },
      /* 92 */
      /***/ function (module, exports, __webpack_require__) {
        var Hash = __webpack_require__(93),
          ListCache = __webpack_require__(24),
          Map = __webpack_require__(43);
        /**
         * Removes all key-value entries from the map.
         *
         * @private
         * @name clear
         * @memberOf MapCache
         */

        function mapCacheClear() {
          this.size = 0;
          this.__data__ = {
            hash: new Hash(),
            map: new (Map || ListCache)(),
            string: new Hash(),
          };
        }

        module.exports = mapCacheClear;

        /***/
      },
      /* 93 */
      /***/ function (module, exports, __webpack_require__) {
        var hashClear = __webpack_require__(94),
          hashDelete = __webpack_require__(95),
          hashGet = __webpack_require__(96),
          hashHas = __webpack_require__(97),
          hashSet = __webpack_require__(98);
        /**
         * Creates a hash object.
         *
         * @private
         * @constructor
         * @param {Array} [entries] The key-value pairs to cache.
         */

        function Hash(entries) {
          var index = -1,
            length = entries == null ? 0 : entries.length;
          this.clear();

          while (++index < length) {
            var entry = entries[index];
            this.set(entry[0], entry[1]);
          }
        } // Add methods to `Hash`.

        Hash.prototype.clear = hashClear;
        Hash.prototype["delete"] = hashDelete;
        Hash.prototype.get = hashGet;
        Hash.prototype.has = hashHas;
        Hash.prototype.set = hashSet;
        module.exports = Hash;

        /***/
      },
      /* 94 */
      /***/ function (module, exports, __webpack_require__) {
        var nativeCreate = __webpack_require__(28);
        /**
         * Removes all key-value entries from the hash.
         *
         * @private
         * @name clear
         * @memberOf Hash
         */

        function hashClear() {
          this.__data__ = nativeCreate ? nativeCreate(null) : {};
          this.size = 0;
        }

        module.exports = hashClear;

        /***/
      },
      /* 95 */
      /***/ function (module, exports) {
        /**
         * Removes `key` and its value from the hash.
         *
         * @private
         * @name delete
         * @memberOf Hash
         * @param {Object} hash The hash to modify.
         * @param {string} key The key of the value to remove.
         * @returns {boolean} Returns `true` if the entry was removed, else `false`.
         */
        function hashDelete(key) {
          var result = this.has(key) && delete this.__data__[key];
          this.size -= result ? 1 : 0;
          return result;
        }

        module.exports = hashDelete;

        /***/
      },
      /* 96 */
      /***/ function (module, exports, __webpack_require__) {
        var nativeCreate = __webpack_require__(28);
        /** Used to stand-in for `undefined` hash values. */

        var HASH_UNDEFINED = "__lodash_hash_undefined__";
        /** Used for built-in method references. */

        var objectProto = Object.prototype;
        /** Used to check objects for own properties. */

        var hasOwnProperty = objectProto.hasOwnProperty;
        /**
         * Gets the hash value for `key`.
         *
         * @private
         * @name get
         * @memberOf Hash
         * @param {string} key The key of the value to get.
         * @returns {*} Returns the entry value.
         */

        function hashGet(key) {
          var data = this.__data__;

          if (nativeCreate) {
            var result = data[key];
            return result === HASH_UNDEFINED ? undefined : result;
          }

          return hasOwnProperty.call(data, key) ? data[key] : undefined;
        }

        module.exports = hashGet;

        /***/
      },
      /* 97 */
      /***/ function (module, exports, __webpack_require__) {
        var nativeCreate = __webpack_require__(28);
        /** Used for built-in method references. */

        var objectProto = Object.prototype;
        /** Used to check objects for own properties. */

        var hasOwnProperty = objectProto.hasOwnProperty;
        /**
         * Checks if a hash value for `key` exists.
         *
         * @private
         * @name has
         * @memberOf Hash
         * @param {string} key The key of the entry to check.
         * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
         */

        function hashHas(key) {
          var data = this.__data__;
          return nativeCreate
            ? data[key] !== undefined
            : hasOwnProperty.call(data, key);
        }

        module.exports = hashHas;

        /***/
      },
      /* 98 */
      /***/ function (module, exports, __webpack_require__) {
        var nativeCreate = __webpack_require__(28);
        /** Used to stand-in for `undefined` hash values. */

        var HASH_UNDEFINED = "__lodash_hash_undefined__";
        /**
         * Sets the hash `key` to `value`.
         *
         * @private
         * @name set
         * @memberOf Hash
         * @param {string} key The key of the value to set.
         * @param {*} value The value to set.
         * @returns {Object} Returns the hash instance.
         */

        function hashSet(key, value) {
          var data = this.__data__;
          this.size += this.has(key) ? 0 : 1;
          data[key] =
            nativeCreate && value === undefined ? HASH_UNDEFINED : value;
          return this;
        }

        module.exports = hashSet;

        /***/
      },
      /* 99 */
      /***/ function (module, exports, __webpack_require__) {
        var getMapData = __webpack_require__(29);
        /**
         * Removes `key` and its value from the map.
         *
         * @private
         * @name delete
         * @memberOf MapCache
         * @param {string} key The key of the value to remove.
         * @returns {boolean} Returns `true` if the entry was removed, else `false`.
         */

        function mapCacheDelete(key) {
          var result = getMapData(this, key)["delete"](key);
          this.size -= result ? 1 : 0;
          return result;
        }

        module.exports = mapCacheDelete;

        /***/
      },
      /* 100 */
      /***/ function (module, exports) {
        /**
         * Checks if `value` is suitable for use as unique object key.
         *
         * @private
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
         */
        function isKeyable(value) {
          var type = typeof value;
          return type == "string" ||
            type == "number" ||
            type == "symbol" ||
            type == "boolean"
            ? value !== "__proto__"
            : value === null;
        }

        module.exports = isKeyable;

        /***/
      },
      /* 101 */
      /***/ function (module, exports, __webpack_require__) {
        var getMapData = __webpack_require__(29);
        /**
         * Gets the map value for `key`.
         *
         * @private
         * @name get
         * @memberOf MapCache
         * @param {string} key The key of the value to get.
         * @returns {*} Returns the entry value.
         */

        function mapCacheGet(key) {
          return getMapData(this, key).get(key);
        }

        module.exports = mapCacheGet;

        /***/
      },
      /* 102 */
      /***/ function (module, exports, __webpack_require__) {
        var getMapData = __webpack_require__(29);
        /**
         * Checks if a map value for `key` exists.
         *
         * @private
         * @name has
         * @memberOf MapCache
         * @param {string} key The key of the entry to check.
         * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
         */

        function mapCacheHas(key) {
          return getMapData(this, key).has(key);
        }

        module.exports = mapCacheHas;

        /***/
      },
      /* 103 */
      /***/ function (module, exports, __webpack_require__) {
        var getMapData = __webpack_require__(29);
        /**
         * Sets the map `key` to `value`.
         *
         * @private
         * @name set
         * @memberOf MapCache
         * @param {string} key The key of the value to set.
         * @param {*} value The value to set.
         * @returns {Object} Returns the map cache instance.
         */

        function mapCacheSet(key, value) {
          var data = getMapData(this, key),
            size = data.size;
          data.set(key, value);
          this.size += data.size == size ? 0 : 1;
          return this;
        }

        module.exports = mapCacheSet;

        /***/
      },
      /* 104 */
      /***/ function (module, exports, __webpack_require__) {
        var createBaseFor = __webpack_require__(105);
        /**
         * The base implementation of `baseForOwn` which iterates over `object`
         * properties returned by `keysFunc` and invokes `iteratee` for each property.
         * Iteratee functions may exit iteration early by explicitly returning `false`.
         *
         * @private
         * @param {Object} object The object to iterate over.
         * @param {Function} iteratee The function invoked per iteration.
         * @param {Function} keysFunc The function to get the keys of `object`.
         * @returns {Object} Returns `object`.
         */

        var baseFor = createBaseFor();
        module.exports = baseFor;

        /***/
      },
      /* 105 */
      /***/ function (module, exports) {
        /**
         * Creates a base function for methods like `_.forIn` and `_.forOwn`.
         *
         * @private
         * @param {boolean} [fromRight] Specify iterating from right to left.
         * @returns {Function} Returns the new base function.
         */
        function createBaseFor(fromRight) {
          return function (object, iteratee, keysFunc) {
            var index = -1,
              iterable = Object(object),
              props = keysFunc(object),
              length = props.length;

            while (length--) {
              var key = props[fromRight ? length : ++index];

              if (iteratee(iterable[key], key, iterable) === false) {
                break;
              }
            }

            return object;
          };
        }

        module.exports = createBaseFor;

        /***/
      },
      /* 106 */
      /***/ function (module, exports, __webpack_require__) {
        var assignMergeValue = __webpack_require__(47),
          cloneBuffer = __webpack_require__(107),
          cloneTypedArray = __webpack_require__(108),
          copyArray = __webpack_require__(111),
          initCloneObject = __webpack_require__(112),
          isArguments = __webpack_require__(30),
          isArray = __webpack_require__(16),
          isArrayLikeObject = __webpack_require__(116),
          isBuffer = __webpack_require__(51),
          isFunction = __webpack_require__(35),
          isObject = __webpack_require__(15),
          isPlainObject = __webpack_require__(118),
          isTypedArray = __webpack_require__(52),
          safeGet = __webpack_require__(53),
          toPlainObject = __webpack_require__(122);
        /**
         * A specialized version of `baseMerge` for arrays and objects which performs
         * deep merges and tracks traversed objects enabling objects with circular
         * references to be merged.
         *
         * @private
         * @param {Object} object The destination object.
         * @param {Object} source The source object.
         * @param {string} key The key of the value to merge.
         * @param {number} srcIndex The index of `source`.
         * @param {Function} mergeFunc The function to merge values.
         * @param {Function} [customizer] The function to customize assigned values.
         * @param {Object} [stack] Tracks traversed source values and their merged
         *  counterparts.
         */

        function baseMergeDeep(
          object,
          source,
          key,
          srcIndex,
          mergeFunc,
          customizer,
          stack
        ) {
          var objValue = safeGet(object, key),
            srcValue = safeGet(source, key),
            stacked = stack.get(srcValue);

          if (stacked) {
            assignMergeValue(object, key, stacked);
            return;
          }

          var newValue = customizer
            ? customizer(objValue, srcValue, key + "", object, source, stack)
            : undefined;
          var isCommon = newValue === undefined;

          if (isCommon) {
            var isArr = isArray(srcValue),
              isBuff = !isArr && isBuffer(srcValue),
              isTyped = !isArr && !isBuff && isTypedArray(srcValue);
            newValue = srcValue;

            if (isArr || isBuff || isTyped) {
              if (isArray(objValue)) {
                newValue = objValue;
              } else if (isArrayLikeObject(objValue)) {
                newValue = copyArray(objValue);
              } else if (isBuff) {
                isCommon = false;
                newValue = cloneBuffer(srcValue, true);
              } else if (isTyped) {
                isCommon = false;
                newValue = cloneTypedArray(srcValue, true);
              } else {
                newValue = [];
              }
            } else if (isPlainObject(srcValue) || isArguments(srcValue)) {
              newValue = objValue;

              if (isArguments(objValue)) {
                newValue = toPlainObject(objValue);
              } else if (!isObject(objValue) || isFunction(objValue)) {
                newValue = initCloneObject(srcValue);
              }
            } else {
              isCommon = false;
            }
          }

          if (isCommon) {
            // Recursively merge objects and arrays (susceptible to call stack limits).
            stack.set(srcValue, newValue);
            mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
            stack["delete"](srcValue);
          }

          assignMergeValue(object, key, newValue);
        }

        module.exports = baseMergeDeep;

        /***/
      },
      /* 107 */
      /***/ function (module, exports, __webpack_require__) {
        /* WEBPACK VAR INJECTION */ (function (module) {
          var root = __webpack_require__(19);
          /** Detect free variable `exports`. */

          var freeExports = true && exports && !exports.nodeType && exports;
          /** Detect free variable `module`. */

          var freeModule =
            freeExports &&
            typeof module == "object" &&
            module &&
            !module.nodeType &&
            module;
          /** Detect the popular CommonJS extension `module.exports`. */

          var moduleExports = freeModule && freeModule.exports === freeExports;
          /** Built-in value references. */

          var Buffer = moduleExports ? root.Buffer : undefined,
            allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined;
          /**
           * Creates a clone of  `buffer`.
           *
           * @private
           * @param {Buffer} buffer The buffer to clone.
           * @param {boolean} [isDeep] Specify a deep clone.
           * @returns {Buffer} Returns the cloned buffer.
           */

          function cloneBuffer(buffer, isDeep) {
            if (isDeep) {
              return buffer.slice();
            }

            var length = buffer.length,
              result = allocUnsafe
                ? allocUnsafe(length)
                : new buffer.constructor(length);
            buffer.copy(result);
            return result;
          }

          module.exports = cloneBuffer;
          /* WEBPACK VAR INJECTION */
        }.call(this, __webpack_require__(37)(module)));

        /***/
      },
      /* 108 */
      /***/ function (module, exports, __webpack_require__) {
        var cloneArrayBuffer = __webpack_require__(109);
        /**
         * Creates a clone of `typedArray`.
         *
         * @private
         * @param {Object} typedArray The typed array to clone.
         * @param {boolean} [isDeep] Specify a deep clone.
         * @returns {Object} Returns the cloned typed array.
         */

        function cloneTypedArray(typedArray, isDeep) {
          var buffer = isDeep
            ? cloneArrayBuffer(typedArray.buffer)
            : typedArray.buffer;
          return new typedArray.constructor(
            buffer,
            typedArray.byteOffset,
            typedArray.length
          );
        }

        module.exports = cloneTypedArray;

        /***/
      },
      /* 109 */
      /***/ function (module, exports, __webpack_require__) {
        var Uint8Array = __webpack_require__(110);
        /**
         * Creates a clone of `arrayBuffer`.
         *
         * @private
         * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
         * @returns {ArrayBuffer} Returns the cloned array buffer.
         */

        function cloneArrayBuffer(arrayBuffer) {
          var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
          new Uint8Array(result).set(new Uint8Array(arrayBuffer));
          return result;
        }

        module.exports = cloneArrayBuffer;

        /***/
      },
      /* 110 */
      /***/ function (module, exports, __webpack_require__) {
        var root = __webpack_require__(19);
        /** Built-in value references. */

        var Uint8Array = root.Uint8Array;
        module.exports = Uint8Array;

        /***/
      },
      /* 111 */
      /***/ function (module, exports) {
        /**
         * Copies the values of `source` to `array`.
         *
         * @private
         * @param {Array} source The array to copy values from.
         * @param {Array} [array=[]] The array to copy values to.
         * @returns {Array} Returns `array`.
         */
        function copyArray(source, array) {
          var index = -1,
            length = source.length;
          array || (array = Array(length));

          while (++index < length) {
            array[index] = source[index];
          }

          return array;
        }

        module.exports = copyArray;

        /***/
      },
      /* 112 */
      /***/ function (module, exports, __webpack_require__) {
        var baseCreate = __webpack_require__(113),
          getPrototype = __webpack_require__(49),
          isPrototype = __webpack_require__(50);
        /**
         * Initializes an object clone.
         *
         * @private
         * @param {Object} object The object to clone.
         * @returns {Object} Returns the initialized clone.
         */

        function initCloneObject(object) {
          return typeof object.constructor == "function" && !isPrototype(object)
            ? baseCreate(getPrototype(object))
            : {};
        }

        module.exports = initCloneObject;

        /***/
      },
      /* 113 */
      /***/ function (module, exports, __webpack_require__) {
        var isObject = __webpack_require__(15);
        /** Built-in value references. */

        var objectCreate = Object.create;
        /**
         * The base implementation of `_.create` without support for assigning
         * properties to the created object.
         *
         * @private
         * @param {Object} proto The object to inherit from.
         * @returns {Object} Returns the new object.
         */

        var baseCreate = (function () {
          function object() {}

          return function (proto) {
            if (!isObject(proto)) {
              return {};
            }

            if (objectCreate) {
              return objectCreate(proto);
            }

            object.prototype = proto;
            var result = new object();
            object.prototype = undefined;
            return result;
          };
        })();

        module.exports = baseCreate;

        /***/
      },
      /* 114 */
      /***/ function (module, exports) {
        /**
         * Creates a unary function that invokes `func` with its argument transformed.
         *
         * @private
         * @param {Function} func The function to wrap.
         * @param {Function} transform The argument transform.
         * @returns {Function} Returns the new function.
         */
        function overArg(func, transform) {
          return function (arg) {
            return func(transform(arg));
          };
        }

        module.exports = overArg;

        /***/
      },
      /* 115 */
      /***/ function (module, exports, __webpack_require__) {
        var baseGetTag = __webpack_require__(22),
          isObjectLike = __webpack_require__(20);
        /** `Object#toString` result references. */

        var argsTag = "[object Arguments]";
        /**
         * The base implementation of `_.isArguments`.
         *
         * @private
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is an `arguments` object,
         */

        function baseIsArguments(value) {
          return isObjectLike(value) && baseGetTag(value) == argsTag;
        }

        module.exports = baseIsArguments;

        /***/
      },
      /* 116 */
      /***/ function (module, exports, __webpack_require__) {
        var isArrayLike = __webpack_require__(38),
          isObjectLike = __webpack_require__(20);
        /**
         * This method is like `_.isArrayLike` except that it also checks if `value`
         * is an object.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is an array-like object,
         *  else `false`.
         * @example
         *
         * _.isArrayLikeObject([1, 2, 3]);
         * // => true
         *
         * _.isArrayLikeObject(document.body.children);
         * // => true
         *
         * _.isArrayLikeObject('abc');
         * // => false
         *
         * _.isArrayLikeObject(_.noop);
         * // => false
         */

        function isArrayLikeObject(value) {
          return isObjectLike(value) && isArrayLike(value);
        }

        module.exports = isArrayLikeObject;

        /***/
      },
      /* 117 */
      /***/ function (module, exports) {
        /**
         * This method returns `false`.
         *
         * @static
         * @memberOf _
         * @since 4.13.0
         * @category Util
         * @returns {boolean} Returns `false`.
         * @example
         *
         * _.times(2, _.stubFalse);
         * // => [false, false]
         */
        function stubFalse() {
          return false;
        }

        module.exports = stubFalse;

        /***/
      },
      /* 118 */
      /***/ function (module, exports, __webpack_require__) {
        var baseGetTag = __webpack_require__(22),
          getPrototype = __webpack_require__(49),
          isObjectLike = __webpack_require__(20);
        /** `Object#toString` result references. */

        var objectTag = "[object Object]";
        /** Used for built-in method references. */

        var funcProto = Function.prototype,
          objectProto = Object.prototype;
        /** Used to resolve the decompiled source of functions. */

        var funcToString = funcProto.toString;
        /** Used to check objects for own properties. */

        var hasOwnProperty = objectProto.hasOwnProperty;
        /** Used to infer the `Object` constructor. */

        var objectCtorString = funcToString.call(Object);
        /**
         * Checks if `value` is a plain object, that is, an object created by the
         * `Object` constructor or one with a `[[Prototype]]` of `null`.
         *
         * @static
         * @memberOf _
         * @since 0.8.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
         * @example
         *
         * function Foo() {
         *   this.a = 1;
         * }
         *
         * _.isPlainObject(new Foo);
         * // => false
         *
         * _.isPlainObject([1, 2, 3]);
         * // => false
         *
         * _.isPlainObject({ 'x': 0, 'y': 0 });
         * // => true
         *
         * _.isPlainObject(Object.create(null));
         * // => true
         */

        function isPlainObject(value) {
          if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
            return false;
          }

          var proto = getPrototype(value);

          if (proto === null) {
            return true;
          }

          var Ctor =
            hasOwnProperty.call(proto, "constructor") && proto.constructor;
          return (
            typeof Ctor == "function" &&
            Ctor instanceof Ctor &&
            funcToString.call(Ctor) == objectCtorString
          );
        }

        module.exports = isPlainObject;

        /***/
      },
      /* 119 */
      /***/ function (module, exports, __webpack_require__) {
        var baseGetTag = __webpack_require__(22),
          isLength = __webpack_require__(39),
          isObjectLike = __webpack_require__(20);
        /** `Object#toString` result references. */

        var argsTag = "[object Arguments]",
          arrayTag = "[object Array]",
          boolTag = "[object Boolean]",
          dateTag = "[object Date]",
          errorTag = "[object Error]",
          funcTag = "[object Function]",
          mapTag = "[object Map]",
          numberTag = "[object Number]",
          objectTag = "[object Object]",
          regexpTag = "[object RegExp]",
          setTag = "[object Set]",
          stringTag = "[object String]",
          weakMapTag = "[object WeakMap]";
        var arrayBufferTag = "[object ArrayBuffer]",
          dataViewTag = "[object DataView]",
          float32Tag = "[object Float32Array]",
          float64Tag = "[object Float64Array]",
          int8Tag = "[object Int8Array]",
          int16Tag = "[object Int16Array]",
          int32Tag = "[object Int32Array]",
          uint8Tag = "[object Uint8Array]",
          uint8ClampedTag = "[object Uint8ClampedArray]",
          uint16Tag = "[object Uint16Array]",
          uint32Tag = "[object Uint32Array]";
        /** Used to identify `toStringTag` values of typed arrays. */

        var typedArrayTags = {};
        typedArrayTags[float32Tag] =
          typedArrayTags[float64Tag] =
          typedArrayTags[int8Tag] =
          typedArrayTags[int16Tag] =
          typedArrayTags[int32Tag] =
          typedArrayTags[uint8Tag] =
          typedArrayTags[uint8ClampedTag] =
          typedArrayTags[uint16Tag] =
          typedArrayTags[uint32Tag] =
            true;
        typedArrayTags[argsTag] =
          typedArrayTags[arrayTag] =
          typedArrayTags[arrayBufferTag] =
          typedArrayTags[boolTag] =
          typedArrayTags[dataViewTag] =
          typedArrayTags[dateTag] =
          typedArrayTags[errorTag] =
          typedArrayTags[funcTag] =
          typedArrayTags[mapTag] =
          typedArrayTags[numberTag] =
          typedArrayTags[objectTag] =
          typedArrayTags[regexpTag] =
          typedArrayTags[setTag] =
          typedArrayTags[stringTag] =
          typedArrayTags[weakMapTag] =
            false;
        /**
         * The base implementation of `_.isTypedArray` without Node.js optimizations.
         *
         * @private
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
         */

        function baseIsTypedArray(value) {
          return (
            isObjectLike(value) &&
            isLength(value.length) &&
            !!typedArrayTags[baseGetTag(value)]
          );
        }

        module.exports = baseIsTypedArray;

        /***/
      },
      /* 120 */
      /***/ function (module, exports) {
        /**
         * The base implementation of `_.unary` without support for storing metadata.
         *
         * @private
         * @param {Function} func The function to cap arguments for.
         * @returns {Function} Returns the new capped function.
         */
        function baseUnary(func) {
          return function (value) {
            return func(value);
          };
        }

        module.exports = baseUnary;

        /***/
      },
      /* 121 */
      /***/ function (module, exports, __webpack_require__) {
        /* WEBPACK VAR INJECTION */ (function (module) {
          var freeGlobal = __webpack_require__(44);
          /** Detect free variable `exports`. */

          var freeExports = true && exports && !exports.nodeType && exports;
          /** Detect free variable `module`. */

          var freeModule =
            freeExports &&
            typeof module == "object" &&
            module &&
            !module.nodeType &&
            module;
          /** Detect the popular CommonJS extension `module.exports`. */

          var moduleExports = freeModule && freeModule.exports === freeExports;
          /** Detect free variable `process` from Node.js. */

          var freeProcess = moduleExports && freeGlobal.process;
          /** Used to access faster Node.js helpers. */

          var nodeUtil = (function () {
            try {
              // Use `util.types` for Node.js 10+.
              var types =
                freeModule &&
                freeModule.require &&
                freeModule.require("util").types;

              if (types) {
                return types;
              } // Legacy `process.binding('util')` for Node.js < 10.

              return (
                freeProcess &&
                freeProcess.binding &&
                freeProcess.binding("util")
              );
            } catch (e) {}
          })();

          module.exports = nodeUtil;
          /* WEBPACK VAR INJECTION */
        }.call(this, __webpack_require__(37)(module)));

        /***/
      },
      /* 122 */
      /***/ function (module, exports, __webpack_require__) {
        var copyObject = __webpack_require__(123),
          keysIn = __webpack_require__(55);
        /**
         * Converts `value` to a plain object flattening inherited enumerable string
         * keyed properties of `value` to own properties of the plain object.
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category Lang
         * @param {*} value The value to convert.
         * @returns {Object} Returns the converted plain object.
         * @example
         *
         * function Foo() {
         *   this.b = 2;
         * }
         *
         * Foo.prototype.c = 3;
         *
         * _.assign({ 'a': 1 }, new Foo);
         * // => { 'a': 1, 'b': 2 }
         *
         * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
         * // => { 'a': 1, 'b': 2, 'c': 3 }
         */

        function toPlainObject(value) {
          return copyObject(value, keysIn(value));
        }

        module.exports = toPlainObject;

        /***/
      },
      /* 123 */
      /***/ function (module, exports, __webpack_require__) {
        var assignValue = __webpack_require__(54),
          baseAssignValue = __webpack_require__(36);
        /**
         * Copies properties of `source` to `object`.
         *
         * @private
         * @param {Object} source The object to copy properties from.
         * @param {Array} props The property identifiers to copy.
         * @param {Object} [object={}] The object to copy properties to.
         * @param {Function} [customizer] The function to customize copied values.
         * @returns {Object} Returns `object`.
         */

        function copyObject(source, props, object, customizer) {
          var isNew = !object;
          object || (object = {});
          var index = -1,
            length = props.length;

          while (++index < length) {
            var key = props[index];
            var newValue = customizer
              ? customizer(object[key], source[key], key, object, source)
              : undefined;

            if (newValue === undefined) {
              newValue = source[key];
            }

            if (isNew) {
              baseAssignValue(object, key, newValue);
            } else {
              assignValue(object, key, newValue);
            }
          }

          return object;
        }

        module.exports = copyObject;

        /***/
      },
      /* 124 */
      /***/ function (module, exports, __webpack_require__) {
        var baseTimes = __webpack_require__(125),
          isArguments = __webpack_require__(30),
          isArray = __webpack_require__(16),
          isBuffer = __webpack_require__(51),
          isIndex = __webpack_require__(31),
          isTypedArray = __webpack_require__(52);
        /** Used for built-in method references. */

        var objectProto = Object.prototype;
        /** Used to check objects for own properties. */

        var hasOwnProperty = objectProto.hasOwnProperty;
        /**
         * Creates an array of the enumerable property names of the array-like `value`.
         *
         * @private
         * @param {*} value The value to query.
         * @param {boolean} inherited Specify returning inherited property names.
         * @returns {Array} Returns the array of property names.
         */

        function arrayLikeKeys(value, inherited) {
          var isArr = isArray(value),
            isArg = !isArr && isArguments(value),
            isBuff = !isArr && !isArg && isBuffer(value),
            isType = !isArr && !isArg && !isBuff && isTypedArray(value),
            skipIndexes = isArr || isArg || isBuff || isType,
            result = skipIndexes ? baseTimes(value.length, String) : [],
            length = result.length;

          for (var key in value) {
            if (
              (inherited || hasOwnProperty.call(value, key)) &&
              !(
                skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
                (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
                  (isBuff && (key == "offset" || key == "parent")) || // PhantomJS 2 has enumerable non-index properties on typed arrays.
                  (isType &&
                    (key == "buffer" ||
                      key == "byteLength" ||
                      key == "byteOffset")) || // Skip index properties.
                  isIndex(key, length))
              )
            ) {
              result.push(key);
            }
          }

          return result;
        }

        module.exports = arrayLikeKeys;

        /***/
      },
      /* 125 */
      /***/ function (module, exports) {
        /**
         * The base implementation of `_.times` without support for iteratee shorthands
         * or max array length checks.
         *
         * @private
         * @param {number} n The number of times to invoke `iteratee`.
         * @param {Function} iteratee The function invoked per iteration.
         * @returns {Array} Returns the array of results.
         */
        function baseTimes(n, iteratee) {
          var index = -1,
            result = Array(n);

          while (++index < n) {
            result[index] = iteratee(index);
          }

          return result;
        }

        module.exports = baseTimes;

        /***/
      },
      /* 126 */
      /***/ function (module, exports, __webpack_require__) {
        var isObject = __webpack_require__(15),
          isPrototype = __webpack_require__(50),
          nativeKeysIn = __webpack_require__(127);
        /** Used for built-in method references. */

        var objectProto = Object.prototype;
        /** Used to check objects for own properties. */

        var hasOwnProperty = objectProto.hasOwnProperty;
        /**
         * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
         *
         * @private
         * @param {Object} object The object to query.
         * @returns {Array} Returns the array of property names.
         */

        function baseKeysIn(object) {
          if (!isObject(object)) {
            return nativeKeysIn(object);
          }

          var isProto = isPrototype(object),
            result = [];

          for (var key in object) {
            if (
              !(
                key == "constructor" &&
                (isProto || !hasOwnProperty.call(object, key))
              )
            ) {
              result.push(key);
            }
          }

          return result;
        }

        module.exports = baseKeysIn;

        /***/
      },
      /* 127 */
      /***/ function (module, exports) {
        /**
         * This function is like
         * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
         * except that it includes inherited enumerable properties.
         *
         * @private
         * @param {Object} object The object to query.
         * @returns {Array} Returns the array of property names.
         */
        function nativeKeysIn(object) {
          var result = [];

          if (object != null) {
            for (var key in Object(object)) {
              result.push(key);
            }
          }

          return result;
        }

        module.exports = nativeKeysIn;

        /***/
      },
      /* 128 */
      /***/ function (module, exports, __webpack_require__) {
        var baseRest = __webpack_require__(129),
          isIterateeCall = __webpack_require__(134);
        /**
         * Creates a function like `_.assign`.
         *
         * @private
         * @param {Function} assigner The function to assign values.
         * @returns {Function} Returns the new assigner function.
         */

        function createAssigner(assigner) {
          return baseRest(function (object, sources) {
            var index = -1,
              length = sources.length,
              customizer = length > 1 ? sources[length - 1] : undefined,
              guard = length > 2 ? sources[2] : undefined;
            customizer =
              assigner.length > 3 && typeof customizer == "function"
                ? (length--, customizer)
                : undefined;

            if (guard && isIterateeCall(sources[0], sources[1], guard)) {
              customizer = length < 3 ? undefined : customizer;
              length = 1;
            }

            object = Object(object);

            while (++index < length) {
              var source = sources[index];

              if (source) {
                assigner(object, source, index, customizer);
              }
            }

            return object;
          });
        }

        module.exports = createAssigner;

        /***/
      },
      /* 129 */
      /***/ function (module, exports, __webpack_require__) {
        var identity = __webpack_require__(56),
          overRest = __webpack_require__(57),
          setToString = __webpack_require__(58);
        /**
         * The base implementation of `_.rest` which doesn't validate or coerce arguments.
         *
         * @private
         * @param {Function} func The function to apply a rest parameter to.
         * @param {number} [start=func.length-1] The start position of the rest parameter.
         * @returns {Function} Returns the new function.
         */

        function baseRest(func, start) {
          return setToString(overRest(func, start, identity), func + "");
        }

        module.exports = baseRest;

        /***/
      },
      /* 130 */
      /***/ function (module, exports) {
        /**
         * A faster alternative to `Function#apply`, this function invokes `func`
         * with the `this` binding of `thisArg` and the arguments of `args`.
         *
         * @private
         * @param {Function} func The function to invoke.
         * @param {*} thisArg The `this` binding of `func`.
         * @param {Array} args The arguments to invoke `func` with.
         * @returns {*} Returns the result of `func`.
         */
        function apply(func, thisArg, args) {
          switch (args.length) {
            case 0:
              return func.call(thisArg);

            case 1:
              return func.call(thisArg, args[0]);

            case 2:
              return func.call(thisArg, args[0], args[1]);

            case 3:
              return func.call(thisArg, args[0], args[1], args[2]);
          }

          return func.apply(thisArg, args);
        }

        module.exports = apply;

        /***/
      },
      /* 131 */
      /***/ function (module, exports, __webpack_require__) {
        var constant = __webpack_require__(132),
          defineProperty = __webpack_require__(48),
          identity = __webpack_require__(56);
        /**
         * The base implementation of `setToString` without support for hot loop shorting.
         *
         * @private
         * @param {Function} func The function to modify.
         * @param {Function} string The `toString` result.
         * @returns {Function} Returns `func`.
         */

        var baseSetToString = !defineProperty
          ? identity
          : function (func, string) {
              return defineProperty(func, "toString", {
                configurable: true,
                enumerable: false,
                value: constant(string),
                writable: true,
              });
            };
        module.exports = baseSetToString;

        /***/
      },
      /* 132 */
      /***/ function (module, exports) {
        /**
         * Creates a function that returns `value`.
         *
         * @static
         * @memberOf _
         * @since 2.4.0
         * @category Util
         * @param {*} value The value to return from the new function.
         * @returns {Function} Returns the new constant function.
         * @example
         *
         * var objects = _.times(2, _.constant({ 'a': 1 }));
         *
         * console.log(objects);
         * // => [{ 'a': 1 }, { 'a': 1 }]
         *
         * console.log(objects[0] === objects[1]);
         * // => true
         */
        function constant(value) {
          return function () {
            return value;
          };
        }

        module.exports = constant;

        /***/
      },
      /* 133 */
      /***/ function (module, exports) {
        /** Used to detect hot functions by number of calls within a span of milliseconds. */
        var HOT_COUNT = 800,
          HOT_SPAN = 16;
        /* Built-in method references for those with the same name as other `lodash` methods. */

        var nativeNow = Date.now;
        /**
         * Creates a function that'll short out and invoke `identity` instead
         * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
         * milliseconds.
         *
         * @private
         * @param {Function} func The function to restrict.
         * @returns {Function} Returns the new shortable function.
         */

        function shortOut(func) {
          var count = 0,
            lastCalled = 0;
          return function () {
            var stamp = nativeNow(),
              remaining = HOT_SPAN - (stamp - lastCalled);
            lastCalled = stamp;

            if (remaining > 0) {
              if (++count >= HOT_COUNT) {
                return arguments[0];
              }
            } else {
              count = 0;
            }

            return func.apply(undefined, arguments);
          };
        }

        module.exports = shortOut;

        /***/
      },
      /* 134 */
      /***/ function (module, exports, __webpack_require__) {
        var eq = __webpack_require__(26),
          isArrayLike = __webpack_require__(38),
          isIndex = __webpack_require__(31),
          isObject = __webpack_require__(15);
        /**
         * Checks if the given arguments are from an iteratee call.
         *
         * @private
         * @param {*} value The potential iteratee value argument.
         * @param {*} index The potential iteratee index or key argument.
         * @param {*} object The potential iteratee object argument.
         * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
         *  else `false`.
         */

        function isIterateeCall(value, index, object) {
          if (!isObject(object)) {
            return false;
          }

          var type = typeof index;

          if (
            type == "number"
              ? isArrayLike(object) && isIndex(index, object.length)
              : type == "string" && index in object
          ) {
            return eq(object[index], value);
          }

          return false;
        }

        module.exports = isIterateeCall;

        /***/
      },
      /* 135 */
      /***/ function (module, exports) {
        /*
         * typedefs.js
         * Normalizes browser-specific prefixes and provide some basic polyfills
         */
        if (typeof window !== "undefined") {
          if (!window.requestAnimationFrame) {
            window.requestAnimationFrame = (function () {
              return (
                window.webkitRequestAnimationFrame ||
                window.mozRequestAnimationFrame ||
                window.oRequestAnimationFrame ||
                window.msRequestAnimationFrame ||
                function (
                  /* function FrameRequestCallback */
                  callback
                ) {
                  window.setTimeout(callback, 1000 / 60);
                }
              );
            })();
          }
        }

        if (typeof Math.imul !== "function") {
          /* eslint-disable no-bitwise */
          Math.imul = function (a, b) {
            var ah = (a >>> 16) & 0xffff;
            var al = a & 0xffff;
            var bh = (b >>> 16) & 0xffff;
            var bl = b & 0xffff; // the shift by 0 fixes the sign on the high part
            // the final |0 converts the unsigned value into a signed value

            return (al * bl + (((ah * bl + al * bh) << 16) >>> 0)) | 0;
          };
          /* eslint-enable no-bitwise */
        }

        if (typeof Object.assign !== "function") {
          Object.assign = function (target) {
            // .length of function is 2
            "use strict";

            if (target === null) {
              // TypeError if undefined or null
              throw new TypeError("Cannot convert undefined or null to object");
            }

            var to = Object(target);

            for (var index = 1; index < arguments.length; index++) {
              // eslint-disable-next-line prefer-rest-params
              var nextSource = arguments[index];

              if (nextSource !== null) {
                // Skip over if undefined or null
                // eslint-disable-next-line no-restricted-syntax
                for (var nextKey in nextSource) {
                  // Avoid bugs when hasOwnProperty is shadowed
                  if (
                    Object.prototype.hasOwnProperty.call(nextSource, nextKey)
                  ) {
                    to[nextKey] = nextSource[nextKey];
                  }
                }
              }
            }

            return to;
          };
        }

        /***/
      },
      /* 136 */
      /***/ function (module, exports) {
        function _arrayWithHoles(arr) {
          if (Array.isArray(arr)) return arr;
        }

        (module.exports = _arrayWithHoles),
          (module.exports.__esModule = true),
          (module.exports["default"] = module.exports);

        /***/
      },
      /* 137 */
      /***/ function (module, exports) {
        function _iterableToArrayLimit(arr, i) {
          var _i =
            arr == null
              ? null
              : (typeof Symbol !== "undefined" && arr[Symbol.iterator]) ||
                arr["@@iterator"];

          if (_i == null) return;
          var _arr = [];
          var _n = true;
          var _d = false;

          var _s, _e;

          try {
            for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
              _arr.push(_s.value);

              if (i && _arr.length === i) break;
            }
          } catch (err) {
            _d = true;
            _e = err;
          } finally {
            try {
              if (!_n && _i["return"] != null) _i["return"]();
            } finally {
              if (_d) throw _e;
            }
          }

          return _arr;
        }

        (module.exports = _iterableToArrayLimit),
          (module.exports.__esModule = true),
          (module.exports["default"] = module.exports);

        /***/
      },
      /* 138 */
      /***/ function (module, exports) {
        function _nonIterableRest() {
          throw new TypeError(
            "Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."
          );
        }

        (module.exports = _nonIterableRest),
          (module.exports.__esModule = true),
          (module.exports["default"] = module.exports);

        /***/
      },
      /* 139 */
      /***/ function (module, exports, __webpack_require__) {
        var _typeof = __webpack_require__(17)["default"];

        function _regeneratorRuntime() {
          "use strict";
          /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */

          (module.exports = _regeneratorRuntime =
            function _regeneratorRuntime() {
              return exports;
            }),
            (module.exports.__esModule = true),
            (module.exports["default"] = module.exports);
          var exports = {},
            Op = Object.prototype,
            hasOwn = Op.hasOwnProperty,
            $Symbol = "function" == typeof Symbol ? Symbol : {},
            iteratorSymbol = $Symbol.iterator || "@@iterator",
            asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator",
            toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

          function define(obj, key, value) {
            return (
              Object.defineProperty(obj, key, {
                value: value,
                enumerable: !0,
                configurable: !0,
                writable: !0,
              }),
              obj[key]
            );
          }

          try {
            define({}, "");
          } catch (err) {
            define = function define(obj, key, value) {
              return (obj[key] = value);
            };
          }

          function wrap(innerFn, outerFn, self, tryLocsList) {
            var protoGenerator =
                outerFn && outerFn.prototype instanceof Generator
                  ? outerFn
                  : Generator,
              generator = Object.create(protoGenerator.prototype),
              context = new Context(tryLocsList || []);
            return (
              (generator._invoke = (function (innerFn, self, context) {
                var state = "suspendedStart";
                return function (method, arg) {
                  if ("executing" === state)
                    throw new Error("Generator is already running");

                  if ("completed" === state) {
                    if ("throw" === method) throw arg;
                    return doneResult();
                  }

                  for (context.method = method, context.arg = arg; ; ) {
                    var delegate = context.delegate;

                    if (delegate) {
                      var delegateResult = maybeInvokeDelegate(
                        delegate,
                        context
                      );

                      if (delegateResult) {
                        if (delegateResult === ContinueSentinel) continue;
                        return delegateResult;
                      }
                    }

                    if ("next" === context.method)
                      context.sent = context._sent = context.arg;
                    else if ("throw" === context.method) {
                      if ("suspendedStart" === state)
                        throw ((state = "completed"), context.arg);
                      context.dispatchException(context.arg);
                    } else
                      "return" === context.method &&
                        context.abrupt("return", context.arg);
                    state = "executing";
                    var record = tryCatch(innerFn, self, context);

                    if ("normal" === record.type) {
                      if (
                        ((state = context.done
                          ? "completed"
                          : "suspendedYield"),
                        record.arg === ContinueSentinel)
                      )
                        continue;
                      return {
                        value: record.arg,
                        done: context.done,
                      };
                    }

                    "throw" === record.type &&
                      ((state = "completed"),
                      (context.method = "throw"),
                      (context.arg = record.arg));
                  }
                };
              })(innerFn, self, context)),
              generator
            );
          }

          function tryCatch(fn, obj, arg) {
            try {
              return {
                type: "normal",
                arg: fn.call(obj, arg),
              };
            } catch (err) {
              return {
                type: "throw",
                arg: err,
              };
            }
          }

          exports.wrap = wrap;
          var ContinueSentinel = {};

          function Generator() {}

          function GeneratorFunction() {}

          function GeneratorFunctionPrototype() {}

          var IteratorPrototype = {};
          define(IteratorPrototype, iteratorSymbol, function () {
            return this;
          });
          var getProto = Object.getPrototypeOf,
            NativeIteratorPrototype =
              getProto && getProto(getProto(values([])));
          NativeIteratorPrototype &&
            NativeIteratorPrototype !== Op &&
            hasOwn.call(NativeIteratorPrototype, iteratorSymbol) &&
            (IteratorPrototype = NativeIteratorPrototype);
          var Gp =
            (GeneratorFunctionPrototype.prototype =
            Generator.prototype =
              Object.create(IteratorPrototype));

          function defineIteratorMethods(prototype) {
            ["next", "throw", "return"].forEach(function (method) {
              define(prototype, method, function (arg) {
                return this._invoke(method, arg);
              });
            });
          }

          function AsyncIterator(generator, PromiseImpl) {
            function invoke(method, arg, resolve, reject) {
              var record = tryCatch(generator[method], generator, arg);

              if ("throw" !== record.type) {
                var result = record.arg,
                  value = result.value;
                return value &&
                  "object" == _typeof(value) &&
                  hasOwn.call(value, "__await")
                  ? PromiseImpl.resolve(value.__await).then(
                      function (value) {
                        invoke("next", value, resolve, reject);
                      },
                      function (err) {
                        invoke("throw", err, resolve, reject);
                      }
                    )
                  : PromiseImpl.resolve(value).then(
                      function (unwrapped) {
                        (result.value = unwrapped), resolve(result);
                      },
                      function (error) {
                        return invoke("throw", error, resolve, reject);
                      }
                    );
              }

              reject(record.arg);
            }

            var previousPromise;

            this._invoke = function (method, arg) {
              function callInvokeWithMethodAndArg() {
                return new PromiseImpl(function (resolve, reject) {
                  invoke(method, arg, resolve, reject);
                });
              }

              return (previousPromise = previousPromise
                ? previousPromise.then(
                    callInvokeWithMethodAndArg,
                    callInvokeWithMethodAndArg
                  )
                : callInvokeWithMethodAndArg());
            };
          }

          function maybeInvokeDelegate(delegate, context) {
            var method = delegate.iterator[context.method];

            if (undefined === method) {
              if (((context.delegate = null), "throw" === context.method)) {
                if (
                  delegate.iterator["return"] &&
                  ((context.method = "return"),
                  (context.arg = undefined),
                  maybeInvokeDelegate(delegate, context),
                  "throw" === context.method)
                )
                  return ContinueSentinel;
                (context.method = "throw"),
                  (context.arg = new TypeError(
                    "The iterator does not provide a 'throw' method"
                  ));
              }

              return ContinueSentinel;
            }

            var record = tryCatch(method, delegate.iterator, context.arg);
            if ("throw" === record.type)
              return (
                (context.method = "throw"),
                (context.arg = record.arg),
                (context.delegate = null),
                ContinueSentinel
              );
            var info = record.arg;
            return info
              ? info.done
                ? ((context[delegate.resultName] = info.value),
                  (context.next = delegate.nextLoc),
                  "return" !== context.method &&
                    ((context.method = "next"), (context.arg = undefined)),
                  (context.delegate = null),
                  ContinueSentinel)
                : info
              : ((context.method = "throw"),
                (context.arg = new TypeError(
                  "iterator result is not an object"
                )),
                (context.delegate = null),
                ContinueSentinel);
          }

          function pushTryEntry(locs) {
            var entry = {
              tryLoc: locs[0],
            };
            1 in locs && (entry.catchLoc = locs[1]),
              2 in locs &&
                ((entry.finallyLoc = locs[2]), (entry.afterLoc = locs[3])),
              this.tryEntries.push(entry);
          }

          function resetTryEntry(entry) {
            var record = entry.completion || {};
            (record.type = "normal"),
              delete record.arg,
              (entry.completion = record);
          }

          function Context(tryLocsList) {
            (this.tryEntries = [
              {
                tryLoc: "root",
              },
            ]),
              tryLocsList.forEach(pushTryEntry, this),
              this.reset(!0);
          }

          function values(iterable) {
            if (iterable) {
              var iteratorMethod = iterable[iteratorSymbol];
              if (iteratorMethod) return iteratorMethod.call(iterable);
              if ("function" == typeof iterable.next) return iterable;

              if (!isNaN(iterable.length)) {
                var i = -1,
                  next = function next() {
                    for (; ++i < iterable.length; ) {
                      if (hasOwn.call(iterable, i))
                        return (
                          (next.value = iterable[i]), (next.done = !1), next
                        );
                    }

                    return (next.value = undefined), (next.done = !0), next;
                  };

                return (next.next = next);
              }
            }

            return {
              next: doneResult,
            };
          }

          function doneResult() {
            return {
              value: undefined,
              done: !0,
            };
          }

          return (
            (GeneratorFunction.prototype = GeneratorFunctionPrototype),
            define(Gp, "constructor", GeneratorFunctionPrototype),
            define(
              GeneratorFunctionPrototype,
              "constructor",
              GeneratorFunction
            ),
            (GeneratorFunction.displayName = define(
              GeneratorFunctionPrototype,
              toStringTagSymbol,
              "GeneratorFunction"
            )),
            (exports.isGeneratorFunction = function (genFun) {
              var ctor = "function" == typeof genFun && genFun.constructor;
              return (
                !!ctor &&
                (ctor === GeneratorFunction ||
                  "GeneratorFunction" === (ctor.displayName || ctor.name))
              );
            }),
            (exports.mark = function (genFun) {
              return (
                Object.setPrototypeOf
                  ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype)
                  : ((genFun.__proto__ = GeneratorFunctionPrototype),
                    define(genFun, toStringTagSymbol, "GeneratorFunction")),
                (genFun.prototype = Object.create(Gp)),
                genFun
              );
            }),
            (exports.awrap = function (arg) {
              return {
                __await: arg,
              };
            }),
            defineIteratorMethods(AsyncIterator.prototype),
            define(AsyncIterator.prototype, asyncIteratorSymbol, function () {
              return this;
            }),
            (exports.AsyncIterator = AsyncIterator),
            (exports.async = function (
              innerFn,
              outerFn,
              self,
              tryLocsList,
              PromiseImpl
            ) {
              void 0 === PromiseImpl && (PromiseImpl = Promise);
              var iter = new AsyncIterator(
                wrap(innerFn, outerFn, self, tryLocsList),
                PromiseImpl
              );
              return exports.isGeneratorFunction(outerFn)
                ? iter
                : iter.next().then(function (result) {
                    return result.done ? result.value : iter.next();
                  });
            }),
            defineIteratorMethods(Gp),
            define(Gp, toStringTagSymbol, "Generator"),
            define(Gp, iteratorSymbol, function () {
              return this;
            }),
            define(Gp, "toString", function () {
              return "[object Generator]";
            }),
            (exports.keys = function (object) {
              var keys = [];

              for (var key in object) {
                keys.push(key);
              }

              return (
                keys.reverse(),
                function next() {
                  for (; keys.length; ) {
                    var key = keys.pop();
                    if (key in object)
                      return (next.value = key), (next.done = !1), next;
                  }

                  return (next.done = !0), next;
                }
              );
            }),
            (exports.values = values),
            (Context.prototype = {
              constructor: Context,
              reset: function reset(skipTempReset) {
                if (
                  ((this.prev = 0),
                  (this.next = 0),
                  (this.sent = this._sent = undefined),
                  (this.done = !1),
                  (this.delegate = null),
                  (this.method = "next"),
                  (this.arg = undefined),
                  this.tryEntries.forEach(resetTryEntry),
                  !skipTempReset)
                )
                  for (var name in this) {
                    "t" === name.charAt(0) &&
                      hasOwn.call(this, name) &&
                      !isNaN(+name.slice(1)) &&
                      (this[name] = undefined);
                  }
              },
              stop: function stop() {
                this.done = !0;
                var rootRecord = this.tryEntries[0].completion;
                if ("throw" === rootRecord.type) throw rootRecord.arg;
                return this.rval;
              },
              dispatchException: function dispatchException(exception) {
                if (this.done) throw exception;
                var context = this;

                function handle(loc, caught) {
                  return (
                    (record.type = "throw"),
                    (record.arg = exception),
                    (context.next = loc),
                    caught &&
                      ((context.method = "next"), (context.arg = undefined)),
                    !!caught
                  );
                }

                for (var i = this.tryEntries.length - 1; i >= 0; --i) {
                  var entry = this.tryEntries[i],
                    record = entry.completion;
                  if ("root" === entry.tryLoc) return handle("end");

                  if (entry.tryLoc <= this.prev) {
                    var hasCatch = hasOwn.call(entry, "catchLoc"),
                      hasFinally = hasOwn.call(entry, "finallyLoc");

                    if (hasCatch && hasFinally) {
                      if (this.prev < entry.catchLoc)
                        return handle(entry.catchLoc, !0);
                      if (this.prev < entry.finallyLoc)
                        return handle(entry.finallyLoc);
                    } else if (hasCatch) {
                      if (this.prev < entry.catchLoc)
                        return handle(entry.catchLoc, !0);
                    } else {
                      if (!hasFinally)
                        throw new Error(
                          "try statement without catch or finally"
                        );
                      if (this.prev < entry.finallyLoc)
                        return handle(entry.finallyLoc);
                    }
                  }
                }
              },
              abrupt: function abrupt(type, arg) {
                for (var i = this.tryEntries.length - 1; i >= 0; --i) {
                  var entry = this.tryEntries[i];

                  if (
                    entry.tryLoc <= this.prev &&
                    hasOwn.call(entry, "finallyLoc") &&
                    this.prev < entry.finallyLoc
                  ) {
                    var finallyEntry = entry;
                    break;
                  }
                }

                finallyEntry &&
                  ("break" === type || "continue" === type) &&
                  finallyEntry.tryLoc <= arg &&
                  arg <= finallyEntry.finallyLoc &&
                  (finallyEntry = null);
                var record = finallyEntry ? finallyEntry.completion : {};
                return (
                  (record.type = type),
                  (record.arg = arg),
                  finallyEntry
                    ? ((this.method = "next"),
                      (this.next = finallyEntry.finallyLoc),
                      ContinueSentinel)
                    : this.complete(record)
                );
              },
              complete: function complete(record, afterLoc) {
                if ("throw" === record.type) throw record.arg;
                return (
                  "break" === record.type || "continue" === record.type
                    ? (this.next = record.arg)
                    : "return" === record.type
                    ? ((this.rval = this.arg = record.arg),
                      (this.method = "return"),
                      (this.next = "end"))
                    : "normal" === record.type &&
                      afterLoc &&
                      (this.next = afterLoc),
                  ContinueSentinel
                );
              },
              finish: function finish(finallyLoc) {
                for (var i = this.tryEntries.length - 1; i >= 0; --i) {
                  var entry = this.tryEntries[i];
                  if (entry.finallyLoc === finallyLoc)
                    return (
                      this.complete(entry.completion, entry.afterLoc),
                      resetTryEntry(entry),
                      ContinueSentinel
                    );
                }
              },
              catch: function _catch(tryLoc) {
                for (var i = this.tryEntries.length - 1; i >= 0; --i) {
                  var entry = this.tryEntries[i];

                  if (entry.tryLoc === tryLoc) {
                    var record = entry.completion;

                    if ("throw" === record.type) {
                      var thrown = record.arg;
                      resetTryEntry(entry);
                    }

                    return thrown;
                  }
                }

                throw new Error("illegal catch attempt");
              },
              delegateYield: function delegateYield(
                iterable,
                resultName,
                nextLoc
              ) {
                return (
                  (this.delegate = {
                    iterator: values(iterable),
                    resultName: resultName,
                    nextLoc: nextLoc,
                  }),
                  "next" === this.method && (this.arg = undefined),
                  ContinueSentinel
                );
              },
            }),
            exports
          );
        }

        (module.exports = _regeneratorRuntime),
          (module.exports.__esModule = true),
          (module.exports["default"] = module.exports);

        /***/
      },
      /* 140 */
      /***/ function (module, exports, __webpack_require__) {
        var getPrototypeOf = __webpack_require__(2);

        function _superPropBase(object, property) {
          while (!Object.prototype.hasOwnProperty.call(object, property)) {
            object = getPrototypeOf(object);
            if (object === null) break;
          }

          return object;
        }

        (module.exports = _superPropBase),
          (module.exports.__esModule = true),
          (module.exports["default"] = module.exports);

        /***/
      },
      /* 141 */
      /***/ function (module, exports, __webpack_require__) {
        var arrayLikeToArray = __webpack_require__(60);

        function _arrayWithoutHoles(arr) {
          if (Array.isArray(arr)) return arrayLikeToArray(arr);
        }

        (module.exports = _arrayWithoutHoles),
          (module.exports.__esModule = true),
          (module.exports["default"] = module.exports);

        /***/
      },
      /* 142 */
      /***/ function (module, exports) {
        function _iterableToArray(iter) {
          if (
            (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null) ||
            iter["@@iterator"] != null
          )
            return Array.from(iter);
        }

        (module.exports = _iterableToArray),
          (module.exports.__esModule = true),
          (module.exports["default"] = module.exports);

        /***/
      },
      /* 143 */
      /***/ function (module, exports) {
        function _nonIterableSpread() {
          throw new TypeError(
            "Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."
          );
        }

        (module.exports = _nonIterableSpread),
          (module.exports.__esModule = true),
          (module.exports["default"] = module.exports);

        /***/
      },
      /* 144 */
      /***/ function (module, exports, __webpack_require__) {
        var basePickBy = __webpack_require__(145),
          hasIn = __webpack_require__(155);
        /**
         * The base implementation of `_.pick` without support for individual
         * property identifiers.
         *
         * @private
         * @param {Object} object The source object.
         * @param {string[]} paths The property paths to pick.
         * @returns {Object} Returns the new object.
         */

        function basePick(object, paths) {
          return basePickBy(object, paths, function (value, path) {
            return hasIn(object, path);
          });
        }

        module.exports = basePick;

        /***/
      },
      /* 145 */
      /***/ function (module, exports, __webpack_require__) {
        var baseGet = __webpack_require__(146),
          baseSet = __webpack_require__(154),
          castPath = __webpack_require__(32);
        /**
         * The base implementation of  `_.pickBy` without support for iteratee shorthands.
         *
         * @private
         * @param {Object} object The source object.
         * @param {string[]} paths The property paths to pick.
         * @param {Function} predicate The function invoked per property.
         * @returns {Object} Returns the new object.
         */

        function basePickBy(object, paths, predicate) {
          var index = -1,
            length = paths.length,
            result = {};

          while (++index < length) {
            var path = paths[index],
              value = baseGet(object, path);

            if (predicate(value, path)) {
              baseSet(result, castPath(path, object), value);
            }
          }

          return result;
        }

        module.exports = basePickBy;

        /***/
      },
      /* 146 */
      /***/ function (module, exports, __webpack_require__) {
        var castPath = __webpack_require__(32),
          toKey = __webpack_require__(42);
        /**
         * The base implementation of `_.get` without support for default values.
         *
         * @private
         * @param {Object} object The object to query.
         * @param {Array|string} path The path of the property to get.
         * @returns {*} Returns the resolved value.
         */

        function baseGet(object, path) {
          path = castPath(path, object);
          var index = 0,
            length = path.length;

          while (object != null && index < length) {
            object = object[toKey(path[index++])];
          }

          return index && index == length ? object : undefined;
        }

        module.exports = baseGet;

        /***/
      },
      /* 147 */
      /***/ function (module, exports, __webpack_require__) {
        var isArray = __webpack_require__(16),
          isSymbol = __webpack_require__(41);
        /** Used to match property names within property paths. */

        var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
          reIsPlainProp = /^\w*$/;
        /**
         * Checks if `value` is a property name and not a property path.
         *
         * @private
         * @param {*} value The value to check.
         * @param {Object} [object] The object to query keys on.
         * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
         */

        function isKey(value, object) {
          if (isArray(value)) {
            return false;
          }

          var type = typeof value;

          if (
            type == "number" ||
            type == "symbol" ||
            type == "boolean" ||
            value == null ||
            isSymbol(value)
          ) {
            return true;
          }

          return (
            reIsPlainProp.test(value) ||
            !reIsDeepProp.test(value) ||
            (object != null && value in Object(object))
          );
        }

        module.exports = isKey;

        /***/
      },
      /* 148 */
      /***/ function (module, exports, __webpack_require__) {
        var memoizeCapped = __webpack_require__(149);
        /** Used to match property names within property paths. */

        var rePropName =
          /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
        /** Used to match backslashes in property paths. */

        var reEscapeChar = /\\(\\)?/g;
        /**
         * Converts `string` to a property path array.
         *
         * @private
         * @param {string} string The string to convert.
         * @returns {Array} Returns the property path array.
         */

        var stringToPath = memoizeCapped(function (string) {
          var result = [];

          if (
            string.charCodeAt(0) === 46
            /* . */
          ) {
            result.push("");
          }

          string.replace(
            rePropName,
            function (match, number, quote, subString) {
              result.push(
                quote ? subString.replace(reEscapeChar, "$1") : number || match
              );
            }
          );
          return result;
        });
        module.exports = stringToPath;

        /***/
      },
      /* 149 */
      /***/ function (module, exports, __webpack_require__) {
        var memoize = __webpack_require__(150);
        /** Used as the maximum memoize cache size. */

        var MAX_MEMOIZE_SIZE = 500;
        /**
         * A specialized version of `_.memoize` which clears the memoized function's
         * cache when it exceeds `MAX_MEMOIZE_SIZE`.
         *
         * @private
         * @param {Function} func The function to have its output memoized.
         * @returns {Function} Returns the new memoized function.
         */

        function memoizeCapped(func) {
          var result = memoize(func, function (key) {
            if (cache.size === MAX_MEMOIZE_SIZE) {
              cache.clear();
            }

            return key;
          });
          var cache = result.cache;
          return result;
        }

        module.exports = memoizeCapped;

        /***/
      },
      /* 150 */
      /***/ function (module, exports, __webpack_require__) {
        var MapCache = __webpack_require__(46);
        /** Error message constants. */

        var FUNC_ERROR_TEXT = "Expected a function";
        /**
         * Creates a function that memoizes the result of `func`. If `resolver` is
         * provided, it determines the cache key for storing the result based on the
         * arguments provided to the memoized function. By default, the first argument
         * provided to the memoized function is used as the map cache key. The `func`
         * is invoked with the `this` binding of the memoized function.
         *
         * **Note:** The cache is exposed as the `cache` property on the memoized
         * function. Its creation may be customized by replacing the `_.memoize.Cache`
         * constructor with one whose instances implement the
         * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
         * method interface of `clear`, `delete`, `get`, `has`, and `set`.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Function
         * @param {Function} func The function to have its output memoized.
         * @param {Function} [resolver] The function to resolve the cache key.
         * @returns {Function} Returns the new memoized function.
         * @example
         *
         * var object = { 'a': 1, 'b': 2 };
         * var other = { 'c': 3, 'd': 4 };
         *
         * var values = _.memoize(_.values);
         * values(object);
         * // => [1, 2]
         *
         * values(other);
         * // => [3, 4]
         *
         * object.a = 2;
         * values(object);
         * // => [1, 2]
         *
         * // Modify the result cache.
         * values.cache.set(object, ['a', 'b']);
         * values(object);
         * // => ['a', 'b']
         *
         * // Replace `_.memoize.Cache`.
         * _.memoize.Cache = WeakMap;
         */

        function memoize(func, resolver) {
          if (
            typeof func != "function" ||
            (resolver != null && typeof resolver != "function")
          ) {
            throw new TypeError(FUNC_ERROR_TEXT);
          }

          var memoized = function () {
            var args = arguments,
              key = resolver ? resolver.apply(this, args) : args[0],
              cache = memoized.cache;

            if (cache.has(key)) {
              return cache.get(key);
            }

            var result = func.apply(this, args);
            memoized.cache = cache.set(key, result) || cache;
            return result;
          };

          memoized.cache = new (memoize.Cache || MapCache)();
          return memoized;
        } // Expose `MapCache`.

        memoize.Cache = MapCache;
        module.exports = memoize;

        /***/
      },
      /* 151 */
      /***/ function (module, exports, __webpack_require__) {
        var baseToString = __webpack_require__(152);
        /**
         * Converts `value` to a string. An empty string is returned for `null`
         * and `undefined` values. The sign of `-0` is preserved.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Lang
         * @param {*} value The value to convert.
         * @returns {string} Returns the converted string.
         * @example
         *
         * _.toString(null);
         * // => ''
         *
         * _.toString(-0);
         * // => '-0'
         *
         * _.toString([1, 2, 3]);
         * // => '1,2,3'
         */

        function toString(value) {
          return value == null ? "" : baseToString(value);
        }

        module.exports = toString;

        /***/
      },
      /* 152 */
      /***/ function (module, exports, __webpack_require__) {
        var Symbol = __webpack_require__(27),
          arrayMap = __webpack_require__(153),
          isArray = __webpack_require__(16),
          isSymbol = __webpack_require__(41);
        /** Used as references for various `Number` constants. */

        var INFINITY = 1 / 0;
        /** Used to convert symbols to primitives and strings. */

        var symbolProto = Symbol ? Symbol.prototype : undefined,
          symbolToString = symbolProto ? symbolProto.toString : undefined;
        /**
         * The base implementation of `_.toString` which doesn't convert nullish
         * values to empty strings.
         *
         * @private
         * @param {*} value The value to process.
         * @returns {string} Returns the string.
         */

        function baseToString(value) {
          // Exit early for strings to avoid a performance hit in some environments.
          if (typeof value == "string") {
            return value;
          }

          if (isArray(value)) {
            // Recursively convert values (susceptible to call stack limits).
            return arrayMap(value, baseToString) + "";
          }

          if (isSymbol(value)) {
            return symbolToString ? symbolToString.call(value) : "";
          }

          var result = value + "";
          return result == "0" && 1 / value == -INFINITY ? "-0" : result;
        }

        module.exports = baseToString;

        /***/
      },
      /* 153 */
      /***/ function (module, exports) {
        /**
         * A specialized version of `_.map` for arrays without support for iteratee
         * shorthands.
         *
         * @private
         * @param {Array} [array] The array to iterate over.
         * @param {Function} iteratee The function invoked per iteration.
         * @returns {Array} Returns the new mapped array.
         */
        function arrayMap(array, iteratee) {
          var index = -1,
            length = array == null ? 0 : array.length,
            result = Array(length);

          while (++index < length) {
            result[index] = iteratee(array[index], index, array);
          }

          return result;
        }

        module.exports = arrayMap;

        /***/
      },
      /* 154 */
      /***/ function (module, exports, __webpack_require__) {
        var assignValue = __webpack_require__(54),
          castPath = __webpack_require__(32),
          isIndex = __webpack_require__(31),
          isObject = __webpack_require__(15),
          toKey = __webpack_require__(42);
        /**
         * The base implementation of `_.set`.
         *
         * @private
         * @param {Object} object The object to modify.
         * @param {Array|string} path The path of the property to set.
         * @param {*} value The value to set.
         * @param {Function} [customizer] The function to customize path creation.
         * @returns {Object} Returns `object`.
         */

        function baseSet(object, path, value, customizer) {
          if (!isObject(object)) {
            return object;
          }

          path = castPath(path, object);
          var index = -1,
            length = path.length,
            lastIndex = length - 1,
            nested = object;

          while (nested != null && ++index < length) {
            var key = toKey(path[index]),
              newValue = value;

            if (
              key === "__proto__" ||
              key === "constructor" ||
              key === "prototype"
            ) {
              return object;
            }

            if (index != lastIndex) {
              var objValue = nested[key];
              newValue = customizer
                ? customizer(objValue, key, nested)
                : undefined;

              if (newValue === undefined) {
                newValue = isObject(objValue)
                  ? objValue
                  : isIndex(path[index + 1])
                  ? []
                  : {};
              }
            }

            assignValue(nested, key, newValue);
            nested = nested[key];
          }

          return object;
        }

        module.exports = baseSet;

        /***/
      },
      /* 155 */
      /***/ function (module, exports, __webpack_require__) {
        var baseHasIn = __webpack_require__(156),
          hasPath = __webpack_require__(157);
        /**
         * Checks if `path` is a direct or inherited property of `object`.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Object
         * @param {Object} object The object to query.
         * @param {Array|string} path The path to check.
         * @returns {boolean} Returns `true` if `path` exists, else `false`.
         * @example
         *
         * var object = _.create({ 'a': _.create({ 'b': 2 }) });
         *
         * _.hasIn(object, 'a');
         * // => true
         *
         * _.hasIn(object, 'a.b');
         * // => true
         *
         * _.hasIn(object, ['a', 'b']);
         * // => true
         *
         * _.hasIn(object, 'b');
         * // => false
         */

        function hasIn(object, path) {
          return object != null && hasPath(object, path, baseHasIn);
        }

        module.exports = hasIn;

        /***/
      },
      /* 156 */
      /***/ function (module, exports) {
        /**
         * The base implementation of `_.hasIn` without support for deep paths.
         *
         * @private
         * @param {Object} [object] The object to query.
         * @param {Array|string} key The key to check.
         * @returns {boolean} Returns `true` if `key` exists, else `false`.
         */
        function baseHasIn(object, key) {
          return object != null && key in Object(object);
        }

        module.exports = baseHasIn;

        /***/
      },
      /* 157 */
      /***/ function (module, exports, __webpack_require__) {
        var castPath = __webpack_require__(32),
          isArguments = __webpack_require__(30),
          isArray = __webpack_require__(16),
          isIndex = __webpack_require__(31),
          isLength = __webpack_require__(39),
          toKey = __webpack_require__(42);
        /**
         * Checks if `path` exists on `object`.
         *
         * @private
         * @param {Object} object The object to query.
         * @param {Array|string} path The path to check.
         * @param {Function} hasFunc The function to check properties.
         * @returns {boolean} Returns `true` if `path` exists, else `false`.
         */

        function hasPath(object, path, hasFunc) {
          path = castPath(path, object);
          var index = -1,
            length = path.length,
            result = false;

          while (++index < length) {
            var key = toKey(path[index]);

            if (!(result = object != null && hasFunc(object, key))) {
              break;
            }

            object = object[key];
          }

          if (result || ++index != length) {
            return result;
          }

          length = object == null ? 0 : object.length;
          return (
            !!length &&
            isLength(length) &&
            isIndex(key, length) &&
            (isArray(object) || isArguments(object))
          );
        }

        module.exports = hasPath;

        /***/
      },
      /* 158 */
      /***/ function (module, exports, __webpack_require__) {
        var flatten = __webpack_require__(159),
          overRest = __webpack_require__(57),
          setToString = __webpack_require__(58);
        /**
         * A specialized version of `baseRest` which flattens the rest array.
         *
         * @private
         * @param {Function} func The function to apply a rest parameter to.
         * @returns {Function} Returns the new function.
         */

        function flatRest(func) {
          return setToString(overRest(func, undefined, flatten), func + "");
        }

        module.exports = flatRest;

        /***/
      },
      /* 159 */
      /***/ function (module, exports, __webpack_require__) {
        var baseFlatten = __webpack_require__(160);
        /**
         * Flattens `array` a single level deep.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Array
         * @param {Array} array The array to flatten.
         * @returns {Array} Returns the new flattened array.
         * @example
         *
         * _.flatten([1, [2, [3, [4]], 5]]);
         * // => [1, 2, [3, [4]], 5]
         */

        function flatten(array) {
          var length = array == null ? 0 : array.length;
          return length ? baseFlatten(array, 1) : [];
        }

        module.exports = flatten;

        /***/
      },
      /* 160 */
      /***/ function (module, exports, __webpack_require__) {
        var arrayPush = __webpack_require__(161),
          isFlattenable = __webpack_require__(162);
        /**
         * The base implementation of `_.flatten` with support for restricting flattening.
         *
         * @private
         * @param {Array} array The array to flatten.
         * @param {number} depth The maximum recursion depth.
         * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.
         * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.
         * @param {Array} [result=[]] The initial result value.
         * @returns {Array} Returns the new flattened array.
         */

        function baseFlatten(array, depth, predicate, isStrict, result) {
          var index = -1,
            length = array.length;
          predicate || (predicate = isFlattenable);
          result || (result = []);

          while (++index < length) {
            var value = array[index];

            if (depth > 0 && predicate(value)) {
              if (depth > 1) {
                // Recursively flatten arrays (susceptible to call stack limits).
                baseFlatten(value, depth - 1, predicate, isStrict, result);
              } else {
                arrayPush(result, value);
              }
            } else if (!isStrict) {
              result[result.length] = value;
            }
          }

          return result;
        }

        module.exports = baseFlatten;

        /***/
      },
      /* 161 */
      /***/ function (module, exports) {
        /**
         * Appends the elements of `values` to `array`.
         *
         * @private
         * @param {Array} array The array to modify.
         * @param {Array} values The values to append.
         * @returns {Array} Returns `array`.
         */
        function arrayPush(array, values) {
          var index = -1,
            length = values.length,
            offset = array.length;

          while (++index < length) {
            array[offset + index] = values[index];
          }

          return array;
        }

        module.exports = arrayPush;

        /***/
      },
      /* 162 */
      /***/ function (module, exports, __webpack_require__) {
        var Symbol = __webpack_require__(27),
          isArguments = __webpack_require__(30),
          isArray = __webpack_require__(16);
        /** Built-in value references. */

        var spreadableSymbol = Symbol ? Symbol.isConcatSpreadable : undefined;
        /**
         * Checks if `value` is a flattenable `arguments` object or array.
         *
         * @private
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.
         */

        function isFlattenable(value) {
          return (
            isArray(value) ||
            isArguments(value) ||
            !!(spreadableSymbol && value && value[spreadableSymbol])
          );
        }

        module.exports = isFlattenable;

        /***/
      },
      /* 163 */
      /***/ function (module, exports) {
        function _isNativeFunction(fn) {
          return Function.toString.call(fn).indexOf("[native code]") !== -1;
        }

        (module.exports = _isNativeFunction),
          (module.exports.__esModule = true),
          (module.exports["default"] = module.exports);

        /***/
      },
      /* 164 */
      /***/ function (module, exports, __webpack_require__) {
        var setPrototypeOf = __webpack_require__(40);

        var isNativeReflectConstruct = __webpack_require__(165);

        function _construct(Parent, args, Class) {
          if (isNativeReflectConstruct()) {
            (module.exports = _construct = Reflect.construct.bind()),
              (module.exports.__esModule = true),
              (module.exports["default"] = module.exports);
          } else {
            (module.exports = _construct =
              function _construct(Parent, args, Class) {
                var a = [null];
                a.push.apply(a, args);
                var Constructor = Function.bind.apply(Parent, a);
                var instance = new Constructor();
                if (Class) setPrototypeOf(instance, Class.prototype);
                return instance;
              }),
              (module.exports.__esModule = true),
              (module.exports["default"] = module.exports);
          }

          return _construct.apply(null, arguments);
        }

        (module.exports = _construct),
          (module.exports.__esModule = true),
          (module.exports["default"] = module.exports);

        /***/
      },
      /* 165 */
      /***/ function (module, exports) {
        function _isNativeReflectConstruct() {
          if (typeof Reflect === "undefined" || !Reflect.construct)
            return false;
          if (Reflect.construct.sham) return false;
          if (typeof Proxy === "function") return true;

          try {
            Boolean.prototype.valueOf.call(
              Reflect.construct(Boolean, [], function () {})
            );
            return true;
          } catch (e) {
            return false;
          }
        }

        (module.exports = _isNativeReflectConstruct),
          (module.exports.__esModule = true),
          (module.exports["default"] = module.exports);

        /***/
      },
      /* 166 */
      /***/ function (module, __webpack_exports__, __webpack_require__) {
        "use strict";
        // ESM COMPAT FLAG
        __webpack_require__.r(__webpack_exports__);

        // EXPORTS
        __webpack_require__.d(
          __webpack_exports__,
          "BarcodeDecoder",
          function () {
            return /* reexport */ barcode_decoder;
          }
        );
        __webpack_require__.d(__webpack_exports__, "Readers", function () {
          return /* reexport */ reader_namespaceObject;
        });
        __webpack_require__.d(__webpack_exports__, "CameraAccess", function () {
          return /* reexport */ camera_access;
        });
        __webpack_require__.d(__webpack_exports__, "ImageDebug", function () {
          return /* reexport */ image_debug["a" /* default */];
        });
        __webpack_require__.d(__webpack_exports__, "ImageWrapper", function () {
          return /* reexport */ image_wrapper["a" /* default */];
        });
        __webpack_require__.d(
          __webpack_exports__,
          "ResultCollector",
          function () {
            return /* reexport */ result_collector;
          }
        );

        // NAMESPACE OBJECT: ./src/reader/index.ts
        var reader_namespaceObject = {};
        __webpack_require__.r(reader_namespaceObject);
        __webpack_require__.d(
          reader_namespaceObject,
          "BarcodeReader",
          function () {
            return barcode_reader;
          }
        );
        __webpack_require__.d(
          reader_namespaceObject,
          "TwoOfFiveReader",
          function () {
            return _2of5_reader;
          }
        );
        __webpack_require__.d(
          reader_namespaceObject,
          "NewCodabarReader",
          function () {
            return codabar_reader;
          }
        );
        __webpack_require__.d(
          reader_namespaceObject,
          "Code128Reader",
          function () {
            return code_128_reader;
          }
        );
        __webpack_require__.d(
          reader_namespaceObject,
          "Code32Reader",
          function () {
            return code_32_reader;
          }
        );
        __webpack_require__.d(
          reader_namespaceObject,
          "Code39Reader",
          function () {
            return code_39_reader;
          }
        );
        __webpack_require__.d(
          reader_namespaceObject,
          "Code39VINReader",
          function () {
            return code_39_vin_reader;
          }
        );
        __webpack_require__.d(
          reader_namespaceObject,
          "Code93Reader",
          function () {
            return code_93_reader;
          }
        );
        __webpack_require__.d(
          reader_namespaceObject,
          "EAN2Reader",
          function () {
            return ean_2_reader;
          }
        );
        __webpack_require__.d(
          reader_namespaceObject,
          "EAN5Reader",
          function () {
            return ean_5_reader;
          }
        );
        __webpack_require__.d(
          reader_namespaceObject,
          "EAN8Reader",
          function () {
            return ean_8_reader;
          }
        );
        __webpack_require__.d(reader_namespaceObject, "EANReader", function () {
          return ean_reader;
        });
        __webpack_require__.d(
          reader_namespaceObject,
          "I2of5Reader",
          function () {
            return i2of5_reader;
          }
        );
        __webpack_require__.d(
          reader_namespaceObject,
          "UPCEReader",
          function () {
            return upc_e_reader;
          }
        );
        __webpack_require__.d(reader_namespaceObject, "UPCReader", function () {
          return upc_reader;
        });

        // EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/typeof.js
        var helpers_typeof = __webpack_require__(17);
        var typeof_default =
          /*#__PURE__*/ __webpack_require__.n(helpers_typeof);

        // EXTERNAL MODULE: ./node_modules/lodash/merge.js
        var merge = __webpack_require__(18);
        var merge_default = /*#__PURE__*/ __webpack_require__.n(merge);

        // EXTERNAL MODULE: ./src/common/typedefs.js
        var typedefs = __webpack_require__(135);

        // EXTERNAL MODULE: ./src/common/image_wrapper.ts
        var image_wrapper = __webpack_require__(12);

        // EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/asyncToGenerator.js
        var asyncToGenerator = __webpack_require__(13);
        var asyncToGenerator_default =
          /*#__PURE__*/ __webpack_require__.n(asyncToGenerator);

        // EXTERNAL MODULE: ./node_modules/@babel/runtime/regenerator/index.js
        var regenerator = __webpack_require__(8);
        var regenerator_default =
          /*#__PURE__*/ __webpack_require__.n(regenerator);

        // EXTERNAL MODULE: ./src/common/image_debug.ts
        var image_debug = __webpack_require__(10);

        // EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/classCallCheck.js
        var classCallCheck = __webpack_require__(3);
        var classCallCheck_default =
          /*#__PURE__*/ __webpack_require__.n(classCallCheck);

        // EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/createClass.js
        var createClass = __webpack_require__(4);
        var createClass_default =
          /*#__PURE__*/ __webpack_require__.n(createClass);

        // EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/assertThisInitialized.js
        var assertThisInitialized = __webpack_require__(1);
        var assertThisInitialized_default = /*#__PURE__*/ __webpack_require__.n(
          assertThisInitialized
        );

        // EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/inherits.js
        var inherits = __webpack_require__(7);
        var inherits_default = /*#__PURE__*/ __webpack_require__.n(inherits);

        // EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js
        var possibleConstructorReturn = __webpack_require__(6);
        var possibleConstructorReturn_default =
          /*#__PURE__*/ __webpack_require__.n(possibleConstructorReturn);

        // EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/getPrototypeOf.js
        var getPrototypeOf = __webpack_require__(2);
        var getPrototypeOf_default =
          /*#__PURE__*/ __webpack_require__.n(getPrototypeOf);

        // EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/defineProperty.js
        var defineProperty = __webpack_require__(0);
        var defineProperty_default =
          /*#__PURE__*/ __webpack_require__.n(defineProperty);

        // EXTERNAL MODULE: ./src/common/array_helper.ts
        var array_helper = __webpack_require__(11);

        // CONCATENATED MODULE: ./src/reader/barcode_reader.ts

        /* eslint-disable no-unused-vars */

        /* eslint-disable class-methods-use-this */
        // eslint-disable-next-line import/no-cycle
        // for some reason this throws a shadow error on itself?!
        // eslint-disable-next-line no-shadow

        var BarcodeDirection;

        (function (BarcodeDirection) {
          BarcodeDirection[(BarcodeDirection["Forward"] = 1)] = "Forward";
          BarcodeDirection[(BarcodeDirection["Reverse"] = -1)] = "Reverse";
        })(BarcodeDirection || (BarcodeDirection = {}));

        var barcode_reader_BarcodeReader = /*#__PURE__*/ (function () {
          function BarcodeReader(config, supplements) {
            classCallCheck_default()(this, BarcodeReader);

            defineProperty_default()(this, "_row", []);

            defineProperty_default()(this, "config", {});

            defineProperty_default()(this, "supplements", []);

            defineProperty_default()(this, "SINGLE_CODE_ERROR", 0);

            defineProperty_default()(this, "FORMAT", "unknown");

            defineProperty_default()(this, "CONFIG_KEYS", {});

            this._row = [];
            this.config = config || {};

            if (supplements) {
              this.supplements = supplements;
            }
          }

          createClass_default()(
            BarcodeReader,
            [
              {
                key: "_nextUnset",
                value: function _nextUnset(line) {
                  var start =
                    arguments.length > 1 && arguments[1] !== undefined
                      ? arguments[1]
                      : 0;

                  for (var i = start; i < line.length; i++) {
                    if (!line[i]) return i;
                  }

                  return line.length;
                },
              },
              {
                key: "_matchPattern",
                value: function _matchPattern(counter, code) {
                  var maxSingleError =
                    arguments.length > 2 && arguments[2] !== undefined
                      ? arguments[2]
                      : this.SINGLE_CODE_ERROR || 1;
                  var error = 0;
                  var singleError = 0;
                  var sum = 0;
                  var modulo = 0;
                  var barWidth = 0;
                  var count = 0;
                  var scaled = 0;

                  for (var i = 0; i < counter.length; i++) {
                    sum += counter[i];
                    modulo += code[i];
                  }

                  if (sum < modulo) {
                    return Number.MAX_VALUE;
                  }

                  barWidth = sum / modulo; // eslint-disable-next-line no-param-reassign

                  maxSingleError *= barWidth;

                  for (var _i = 0; _i < counter.length; _i++) {
                    count = counter[_i];
                    scaled = code[_i] * barWidth;
                    singleError = Math.abs(count - scaled) / scaled;

                    if (singleError > maxSingleError) {
                      return Number.MAX_VALUE;
                    }

                    error += singleError;
                  }

                  return error / modulo;
                },
              },
              {
                key: "_nextSet",
                value: function _nextSet(line) {
                  var offset =
                    arguments.length > 1 && arguments[1] !== undefined
                      ? arguments[1]
                      : 0;

                  for (var i = offset; i < line.length; i++) {
                    if (line[i]) return i;
                  }

                  return line.length;
                },
              },
              {
                key: "_correctBars",
                value: function _correctBars(counter, correction, indices) {
                  var length = indices.length;
                  var tmp = 0;

                  while (length--) {
                    tmp = counter[indices[length]] * (1 - (1 - correction) / 2);

                    if (tmp > 1) {
                      // eslint-disable-next-line no-param-reassign
                      counter[indices[length]] = tmp;
                    }
                  }
                },
              },
              {
                key: "decodePattern",
                value: function decodePattern(pattern) {
                  // console.warn('* decodePattern', pattern);
                  this._row = pattern; // console.warn('* decodePattern calling decode', typeof this, this.constructor, this.FORMAT, JSON.stringify(this));

                  var result = this.decode(); // console.warn('* first result=', result);

                  if (result === null) {
                    this._row.reverse();

                    result = this.decode(); // console.warn('* reversed result=', result);

                    if (result) {
                      result.direction = BarcodeDirection.Reverse;
                      result.start = this._row.length - result.start;
                      result.end = this._row.length - result.end;
                    }
                  } else {
                    result.direction = BarcodeDirection.Forward;
                  }

                  if (result) {
                    result.format = this.FORMAT;
                  } // console.warn('* returning', result);

                  return result;
                },
              },
              {
                key: "_matchRange",
                value: function _matchRange(start, end, value) {
                  // eslint-disable-next-line no-param-reassign
                  start = start < 0 ? 0 : start;
                  var i;

                  for (i = start; i < end; i++) {
                    if (this._row[i] !== value) {
                      return false;
                    }
                  }

                  return true;
                },
              },
              {
                key: "_fillCounters",
                value: function _fillCounters() {
                  var offset =
                    arguments.length > 0 && arguments[0] !== undefined
                      ? arguments[0]
                      : this._nextUnset(this._row);
                  var end =
                    arguments.length > 1 && arguments[1] !== undefined
                      ? arguments[1]
                      : this._row.length;
                  var isWhite =
                    arguments.length > 2 && arguments[2] !== undefined
                      ? arguments[2]
                      : true;
                  var counters = [];
                  var counterPos = 0;
                  counters[counterPos] = 0;

                  for (var i = offset; i < end; i++) {
                    // eslint-disable-next-line no-bitwise
                    if (this._row[i] ^ (isWhite ? 1 : 0)) {
                      counters[counterPos]++;
                    } else {
                      counterPos++;
                      counters[counterPos] = 1; // eslint-disable-next-line no-param-reassign

                      isWhite = !isWhite;
                    }
                  }

                  return counters;
                },
              },
              {
                key: "_toCounters",
                value: function _toCounters(start, counters) {
                  var numCounters = counters.length;
                  var end = this._row.length;
                  var isWhite = !this._row[start];
                  var counterPos = 0;
                  array_helper["a" /* default */].init(counters, 0);

                  for (var i = start; i < end; i++) {
                    // eslint-disable-next-line no-bitwise
                    if (this._row[i] ^ (isWhite ? 1 : 0)) {
                      // eslint-disable-next-line no-param-reassign
                      counters[counterPos]++;
                    } else {
                      counterPos++;

                      if (counterPos === numCounters) {
                        break;
                      } else {
                        // eslint-disable-next-line no-param-reassign
                        counters[counterPos] = 1;
                        isWhite = !isWhite;
                      }
                    }
                  }

                  return counters;
                }, // override/implement this in your custom readers.
              },
              {
                key: "decodeImage",
                value: function decodeImage(imageWrapper) {
                  // eslint-disable-next-line no-void
                  void imageWrapper;
                  return null;
                },
              },
            ],
            [
              {
                key: "Exception",
                get: function get() {
                  return {
                    StartNotFoundException: "Start-Info was not found!",
                    CodeNotFoundException: "Code could not be found!",
                    PatternNotFoundException: "Pattern could not be found!",
                  };
                },
              },
            ]
          );

          return BarcodeReader;
        })();
        /* harmony default export */ var barcode_reader =
          barcode_reader_BarcodeReader;
        // CONCATENATED MODULE: ./src/reader/2of5_reader.ts

        function _createSuper(Derived) {
          var hasNativeReflectConstruct = _isNativeReflectConstruct();
          return function _createSuperInternal() {
            var Super = getPrototypeOf_default()(Derived),
              result;
            if (hasNativeReflectConstruct) {
              var NewTarget = getPrototypeOf_default()(this).constructor;
              result = Reflect.construct(Super, arguments, NewTarget);
            } else {
              result = Super.apply(this, arguments);
            }
            return possibleConstructorReturn_default()(this, result);
          };
        }

        function _isNativeReflectConstruct() {
          if (typeof Reflect === "undefined" || !Reflect.construct)
            return false;
          if (Reflect.construct.sham) return false;
          if (typeof Proxy === "function") return true;
          try {
            Boolean.prototype.valueOf.call(
              Reflect.construct(Boolean, [], function () {})
            );
            return true;
          } catch (e) {
            return false;
          }
        }

        var N = 1;
        var W = 3;
        var START_PATTERN = [W, N, W, N, N, N];
        var STOP_PATTERN = [W, N, N, N, W];
        var CODE_PATTERN = [
          [N, N, W, W, N],
          [W, N, N, N, W],
          [N, W, N, N, W],
          [W, W, N, N, N],
          [N, N, W, N, W],
          [W, N, W, N, N],
          [N, W, W, N, N],
          [N, N, N, W, W],
          [W, N, N, W, N],
          [N, W, N, W, N],
        ];
        var START_PATTERN_LENGTH = START_PATTERN.reduce(function (sum, val) {
          return sum + val;
        }, 0);

        var _2of5_reader_TwoOfFiveReader = /*#__PURE__*/ (function (
          _BarcodeReader
        ) {
          inherits_default()(TwoOfFiveReader, _BarcodeReader);

          var _super = _createSuper(TwoOfFiveReader);

          function TwoOfFiveReader() {
            var _this;

            classCallCheck_default()(this, TwoOfFiveReader);

            for (
              var _len = arguments.length, args = new Array(_len), _key = 0;
              _key < _len;
              _key++
            ) {
              args[_key] = arguments[_key];
            }

            _this = _super.call.apply(_super, [this].concat(args));

            defineProperty_default()(
              assertThisInitialized_default()(_this),
              "barSpaceRatio",
              [1, 1]
            );

            defineProperty_default()(
              assertThisInitialized_default()(_this),
              "FORMAT",
              "2of5"
            );

            defineProperty_default()(
              assertThisInitialized_default()(_this),
              "SINGLE_CODE_ERROR",
              0.78
            );

            defineProperty_default()(
              assertThisInitialized_default()(_this),
              "AVG_CODE_ERROR",
              0.3
            );

            return _this;
          }

          createClass_default()(TwoOfFiveReader, [
            {
              key: "_findPattern",
              value: function _findPattern(pattern, offset) {
                var isWhite =
                  arguments.length > 2 && arguments[2] !== undefined
                    ? arguments[2]
                    : false;
                var tryHarder =
                  arguments.length > 3 && arguments[3] !== undefined
                    ? arguments[3]
                    : false;
                var counter = [];
                var counterPos = 0;
                var bestMatch = {
                  error: Number.MAX_VALUE,
                  code: -1,
                  start: 0,
                  end: 0,
                };
                var sum = 0;
                var error = 0;
                var epsilon = this.AVG_CODE_ERROR;

                if (!offset) {
                  offset = this._nextSet(this._row);
                }

                for (var i = 0; i < pattern.length; i++) {
                  counter[i] = 0;
                }

                for (var _i = offset; _i < this._row.length; _i++) {
                  if (this._row[_i] ^ (isWhite ? 1 : 0)) {
                    counter[counterPos]++;
                  } else {
                    if (counterPos === counter.length - 1) {
                      sum = 0;

                      for (var j = 0; j < counter.length; j++) {
                        sum += counter[j];
                      }

                      error = this._matchPattern(counter, pattern);

                      if (error < epsilon) {
                        bestMatch.error = error;
                        bestMatch.start = _i - sum;
                        bestMatch.end = _i;
                        return bestMatch;
                      }

                      if (tryHarder) {
                        for (var _j = 0; _j < counter.length - 2; _j++) {
                          counter[_j] = counter[_j + 2];
                        }

                        counter[counter.length - 2] = 0;
                        counter[counter.length - 1] = 0;
                        counterPos--;
                      } else {
                        return null;
                      }
                    } else {
                      counterPos++;
                    }

                    counter[counterPos] = 1;
                    isWhite = !isWhite;
                  }
                }

                return null;
              },
            },
            {
              key: "_findStart",
              value: function _findStart() {
                var startInfo = null;

                var offset = this._nextSet(this._row);

                var narrowBarWidth = 1;
                var leadingWhitespaceStart = 0;

                while (!startInfo) {
                  startInfo = this._findPattern(
                    START_PATTERN,
                    offset,
                    false,
                    true
                  );

                  if (!startInfo) {
                    return null;
                  }

                  narrowBarWidth = Math.floor(
                    (startInfo.end - startInfo.start) / START_PATTERN_LENGTH
                  );
                  leadingWhitespaceStart = startInfo.start - narrowBarWidth * 5;

                  if (leadingWhitespaceStart >= 0) {
                    if (
                      this._matchRange(
                        leadingWhitespaceStart,
                        startInfo.start,
                        0
                      )
                    ) {
                      return startInfo;
                    }
                  }

                  offset = startInfo.end;
                  startInfo = null;
                }

                return startInfo;
              },
            },
            {
              key: "_verifyTrailingWhitespace",
              value: function _verifyTrailingWhitespace(endInfo) {
                var trailingWhitespaceEnd =
                  endInfo.end + (endInfo.end - endInfo.start) / 2;

                if (trailingWhitespaceEnd < this._row.length) {
                  if (this._matchRange(endInfo.end, trailingWhitespaceEnd, 0)) {
                    return endInfo;
                  }
                }

                return null;
              },
            },
            {
              key: "_findEnd",
              value: function _findEnd() {
                // TODO: reverse, followed by some calcs, followed by another reverse? really?
                this._row.reverse();

                var offset = this._nextSet(this._row);

                var endInfo = this._findPattern(
                  STOP_PATTERN,
                  offset,
                  false,
                  true
                );

                this._row.reverse();

                if (endInfo === null) {
                  return null;
                } // reverse numbers

                var tmp = endInfo.start;
                endInfo.start = this._row.length - endInfo.end;
                endInfo.end = this._row.length - tmp;
                return endInfo !== null
                  ? this._verifyTrailingWhitespace(endInfo)
                  : null;
              },
            },
            {
              key: "_verifyCounterLength",
              value: function _verifyCounterLength(counters) {
                return counters.length % 10 === 0;
              },
            },
            {
              key: "_decodeCode",
              value: function _decodeCode(counter) {
                var epsilon = this.AVG_CODE_ERROR;
                var bestMatch = {
                  error: Number.MAX_VALUE,
                  code: -1,
                  start: 0,
                  end: 0,
                };

                for (var code = 0; code < CODE_PATTERN.length; code++) {
                  var error = this._matchPattern(counter, CODE_PATTERN[code]);

                  if (error < bestMatch.error) {
                    bestMatch.code = code;
                    bestMatch.error = error;
                  }
                }

                if (bestMatch.error < epsilon) {
                  return bestMatch;
                }

                return null;
              },
            },
            {
              key: "_decodePayload",
              value: function _decodePayload(counters, result, decodedCodes) {
                var pos = 0;
                var counterLength = counters.length;
                var counter = [0, 0, 0, 0, 0];
                var code = null;

                while (pos < counterLength) {
                  for (var i = 0; i < 5; i++) {
                    counter[i] = counters[pos] * this.barSpaceRatio[0];
                    pos += 2;
                  }

                  code = this._decodeCode(counter);

                  if (!code) {
                    return null;
                  }

                  result.push("".concat(code.code));
                  decodedCodes.push(code);
                }

                return code;
              },
            },
            {
              key: "decode",
              value: function decode(row, start) {
                var startInfo = this._findStart();

                if (!startInfo) {
                  return null;
                }

                var endInfo = this._findEnd();

                if (!endInfo) {
                  return null;
                }

                var counters = this._fillCounters(
                  startInfo.end,
                  endInfo.start,
                  false
                );

                if (!this._verifyCounterLength(counters)) {
                  return null;
                }

                var decodedCodes = [];
                decodedCodes.push(startInfo);
                var result = [];

                var code = this._decodePayload(counters, result, decodedCodes);

                if (!code) {
                  return null;
                }

                if (result.length < 5) {
                  return null;
                }

                decodedCodes.push(endInfo);
                return {
                  code: result.join(""),
                  start: startInfo.start,
                  end: endInfo.end,
                  startInfo: startInfo,
                  decodedCodes: decodedCodes,
                  format: this.FORMAT,
                };
              },
            },
          ]);

          return TwoOfFiveReader;
        })(barcode_reader);

        /* harmony default export */ var _2of5_reader =
          _2of5_reader_TwoOfFiveReader;
        // CONCATENATED MODULE: ./src/reader/codabar_reader.ts

        function codabar_reader_createSuper(Derived) {
          var hasNativeReflectConstruct =
            codabar_reader_isNativeReflectConstruct();
          return function _createSuperInternal() {
            var Super = getPrototypeOf_default()(Derived),
              result;
            if (hasNativeReflectConstruct) {
              var NewTarget = getPrototypeOf_default()(this).constructor;
              result = Reflect.construct(Super, arguments, NewTarget);
            } else {
              result = Super.apply(this, arguments);
            }
            return possibleConstructorReturn_default()(this, result);
          };
        }

        function codabar_reader_isNativeReflectConstruct() {
          if (typeof Reflect === "undefined" || !Reflect.construct)
            return false;
          if (Reflect.construct.sham) return false;
          if (typeof Proxy === "function") return true;
          try {
            Boolean.prototype.valueOf.call(
              Reflect.construct(Boolean, [], function () {})
            );
            return true;
          } catch (e) {
            return false;
          }
        }

        // const ALPHABETH_STRING = '0123456789-$:/.+ABCD';

        var ALPHABET = [
          48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 45, 36, 58, 47, 46, 43, 65,
          66, 67, 68,
        ];
        var CHARACTER_ENCODINGS = [
          0x003, 0x006, 0x009, 0x060, 0x012, 0x042, 0x021, 0x024, 0x030, 0x048,
          0x00c, 0x018, 0x045, 0x051, 0x054, 0x015, 0x01a, 0x029, 0x00b, 0x00e,
        ];
        var START_END = [0x01a, 0x029, 0x00b, 0x00e];
        var MIN_ENCODED_CHARS = 4;
        var MAX_ACCEPTABLE = 2.0;
        var PADDING = 1.5;
        var codabar_reader_NewCodabarReader = /*#__PURE__*/ (function (
          _BarcodeReader
        ) {
          inherits_default()(NewCodabarReader, _BarcodeReader);

          var _super = codabar_reader_createSuper(NewCodabarReader);

          function NewCodabarReader() {
            var _this;

            classCallCheck_default()(this, NewCodabarReader);

            for (
              var _len = arguments.length, args = new Array(_len), _key = 0;
              _key < _len;
              _key++
            ) {
              args[_key] = arguments[_key];
            }

            _this = _super.call.apply(_super, [this].concat(args));

            defineProperty_default()(
              assertThisInitialized_default()(_this),
              "_counters",
              []
            );

            defineProperty_default()(
              assertThisInitialized_default()(_this),
              "FORMAT",
              "codabar"
            );

            return _this;
          }

          createClass_default()(NewCodabarReader, [
            {
              key: "_computeAlternatingThreshold",
              value: function _computeAlternatingThreshold(offset, end) {
                var min = Number.MAX_VALUE;
                var max = 0;
                var counter = 0;

                for (var i = offset; i < end; i += 2) {
                  counter = this._counters[i];

                  if (counter > max) {
                    max = counter;
                  }

                  if (counter < min) {
                    min = counter;
                  }
                }

                return ((min + max) / 2.0) | 0;
              },
            },
            {
              key: "_toPattern",
              value: function _toPattern(offset) {
                var numCounters = 7;
                var end = offset + numCounters;

                if (end > this._counters.length) {
                  return -1;
                }

                var barThreshold = this._computeAlternatingThreshold(
                  offset,
                  end
                );

                var spaceThreshold = this._computeAlternatingThreshold(
                  offset + 1,
                  end
                );

                var bitmask = 1 << (numCounters - 1);
                var threshold = 0;
                var pattern = 0;

                for (var i = 0; i < numCounters; i++) {
                  threshold = (i & 1) === 0 ? barThreshold : spaceThreshold;

                  if (this._counters[offset + i] > threshold) {
                    pattern |= bitmask;
                  }

                  bitmask >>= 1;
                }

                return pattern;
              },
            },
            {
              key: "_isStartEnd",
              value: function _isStartEnd(pattern) {
                for (var i = 0; i < START_END.length; i++) {
                  if (START_END[i] === pattern) {
                    return true;
                  }
                }

                return false;
              },
            },
            {
              key: "_sumCounters",
              value: function _sumCounters(start, end) {
                var sum = 0;

                for (var i = start; i < end; i++) {
                  sum += this._counters[i];
                }

                return sum;
              },
            },
            {
              key: "_findStart",
              value: function _findStart() {
                var start = this._nextUnset(this._row);

                var end = start;

                for (var i = 1; i < this._counters.length; i++) {
                  var pattern = this._toPattern(i);

                  if (pattern !== -1 && this._isStartEnd(pattern)) {
                    // TODO: Look for whitespace ahead
                    start += this._sumCounters(0, i);
                    end = start + this._sumCounters(i, i + 8);
                    return {
                      start: start,
                      end: end,
                      startCounter: i,
                      endCounter: i + 8,
                    };
                  }
                }

                return null;
              },
            },
            {
              key: "_patternToChar",
              value: function _patternToChar(pattern) {
                for (var i = 0; i < CHARACTER_ENCODINGS.length; i++) {
                  if (CHARACTER_ENCODINGS[i] === pattern) {
                    return String.fromCharCode(ALPHABET[i]);
                  }
                }

                return null;
              },
            },
            {
              key: "_calculatePatternLength",
              value: function _calculatePatternLength(offset) {
                var sum = 0;

                for (var i = offset; i < offset + 7; i++) {
                  sum += this._counters[i];
                }

                return sum;
              },
            },
            {
              key: "_verifyWhitespace",
              value: function _verifyWhitespace(startCounter, endCounter) {
                if (
                  startCounter - 1 <= 0 ||
                  this._counters[startCounter - 1] >=
                    this._calculatePatternLength(startCounter) / 2.0
                ) {
                  if (
                    endCounter + 8 >= this._counters.length ||
                    this._counters[endCounter + 7] >=
                      this._calculatePatternLength(endCounter) / 2.0
                  ) {
                    return true;
                  }
                }

                return false;
              },
            },
            {
              key: "_charToPattern",
              value: function _charToPattern(_char) {
                var charCode = _char.charCodeAt(0);

                for (var i = 0; i < ALPHABET.length; i++) {
                  if (ALPHABET[i] === charCode) {
                    return CHARACTER_ENCODINGS[i];
                  }
                }

                return 0x0;
              },
            },
            {
              key: "_thresholdResultPattern",
              value: function _thresholdResultPattern(result, startCounter) {
                var categorization = {
                  space: {
                    narrow: {
                      size: 0,
                      counts: 0,
                      min: 0,
                      max: Number.MAX_VALUE,
                    },
                    wide: {
                      size: 0,
                      counts: 0,
                      min: 0,
                      max: Number.MAX_VALUE,
                    },
                  },
                  bar: {
                    narrow: {
                      size: 0,
                      counts: 0,
                      min: 0,
                      max: Number.MAX_VALUE,
                    },
                    wide: {
                      size: 0,
                      counts: 0,
                      min: 0,
                      max: Number.MAX_VALUE,
                    },
                  },
                };
                var pos = startCounter;
                var pattern;

                for (var i = 0; i < result.length; i++) {
                  pattern = this._charToPattern(result[i]);

                  for (var j = 6; j >= 0; j--) {
                    var kind =
                      (j & 1) === 2 ? categorization.bar : categorization.space;
                    var cat = (pattern & 1) === 1 ? kind.wide : kind.narrow;
                    cat.size += this._counters[pos + j];
                    cat.counts++;
                    pattern >>= 1;
                  }

                  pos += 8;
                }

                ["space", "bar"].forEach(function (key) {
                  var newkind = categorization[key];
                  newkind.wide.min = Math.floor(
                    (newkind.narrow.size / newkind.narrow.counts +
                      newkind.wide.size / newkind.wide.counts) /
                      2
                  );
                  newkind.narrow.max = Math.ceil(newkind.wide.min);
                  newkind.wide.max = Math.ceil(
                    (newkind.wide.size * MAX_ACCEPTABLE + PADDING) /
                      newkind.wide.counts
                  );
                });
                return categorization;
              },
            },
            {
              key: "_validateResult",
              value: function _validateResult(result, startCounter) {
                var thresholds = this._thresholdResultPattern(
                  result,
                  startCounter
                );

                var pos = startCounter;
                var pattern;

                for (var i = 0; i < result.length; i++) {
                  pattern = this._charToPattern(result[i]);

                  for (var j = 6; j >= 0; j--) {
                    var kind =
                      (j & 1) === 0 ? thresholds.bar : thresholds.space;
                    var cat = (pattern & 1) === 1 ? kind.wide : kind.narrow;
                    var size = this._counters[pos + j];

                    if (size < cat.min || size > cat.max) {
                      return false;
                    }

                    pattern >>= 1;
                  }

                  pos += 8;
                }

                return true;
              },
            },
            {
              key: "decode",
              value: function decode(row, start) {
                this._counters = this._fillCounters();
                start = this._findStart();

                if (!start) {
                  return null;
                }

                var nextStart = start.startCounter;
                var result = [];
                var pattern;

                do {
                  pattern = this._toPattern(nextStart);

                  if (pattern < 0) {
                    return null;
                  }

                  var decodedChar = this._patternToChar(pattern);

                  if (decodedChar === null) {
                    return null;
                  }

                  result.push(decodedChar);
                  nextStart += 8;

                  if (result.length > 1 && this._isStartEnd(pattern)) {
                    break;
                  }
                } while (nextStart < this._counters.length); // verify end

                if (
                  result.length - 2 < MIN_ENCODED_CHARS ||
                  !this._isStartEnd(pattern)
                ) {
                  return null;
                } // verify end white space

                if (
                  !this._verifyWhitespace(start.startCounter, nextStart - 8)
                ) {
                  return null;
                }

                if (!this._validateResult(result, start.startCounter)) {
                  return null;
                }

                nextStart =
                  nextStart > this._counters.length
                    ? this._counters.length
                    : nextStart;

                var end =
                  start.start +
                  this._sumCounters(start.startCounter, nextStart - 8);

                return {
                  code: result.join(""),
                  start: start.start,
                  end: end,
                  startInfo: start,
                  decodedCodes: result,
                  format: this.FORMAT, // TODO: i think it should not be required to return format from this, as barcode_reader force sets the format anyway
                };
              },
            },
          ]);

          return NewCodabarReader;
        })(barcode_reader);

        /* harmony default export */ var codabar_reader =
          codabar_reader_NewCodabarReader;
        // CONCATENATED MODULE: ./src/reader/code_128_reader.ts

        function code_128_reader_createSuper(Derived) {
          var hasNativeReflectConstruct =
            code_128_reader_isNativeReflectConstruct();
          return function _createSuperInternal() {
            var Super = getPrototypeOf_default()(Derived),
              result;
            if (hasNativeReflectConstruct) {
              var NewTarget = getPrototypeOf_default()(this).constructor;
              result = Reflect.construct(Super, arguments, NewTarget);
            } else {
              result = Super.apply(this, arguments);
            }
            return possibleConstructorReturn_default()(this, result);
          };
        }

        function code_128_reader_isNativeReflectConstruct() {
          if (typeof Reflect === "undefined" || !Reflect.construct)
            return false;
          if (Reflect.construct.sham) return false;
          if (typeof Proxy === "function") return true;
          try {
            Boolean.prototype.valueOf.call(
              Reflect.construct(Boolean, [], function () {})
            );
            return true;
          } catch (e) {
            return false;
          }
        }

        var code_128_reader_Code128Reader = /*#__PURE__*/ (function (
          _BarcodeReader
        ) {
          inherits_default()(Code128Reader, _BarcodeReader);

          var _super = code_128_reader_createSuper(Code128Reader);

          function Code128Reader() {
            var _this;

            classCallCheck_default()(this, Code128Reader);

            for (
              var _len = arguments.length, args = new Array(_len), _key = 0;
              _key < _len;
              _key++
            ) {
              args[_key] = arguments[_key];
            }

            _this = _super.call.apply(_super, [this].concat(args));

            defineProperty_default()(
              assertThisInitialized_default()(_this),
              "CODE_SHIFT",
              98
            );

            defineProperty_default()(
              assertThisInitialized_default()(_this),
              "CODE_C",
              99
            );

            defineProperty_default()(
              assertThisInitialized_default()(_this),
              "CODE_B",
              100
            );

            defineProperty_default()(
              assertThisInitialized_default()(_this),
              "CODE_A",
              101
            );

            defineProperty_default()(
              assertThisInitialized_default()(_this),
              "START_CODE_A",
              103
            );

            defineProperty_default()(
              assertThisInitialized_default()(_this),
              "START_CODE_B",
              104
            );

            defineProperty_default()(
              assertThisInitialized_default()(_this),
              "START_CODE_C",
              105
            );

            defineProperty_default()(
              assertThisInitialized_default()(_this),
              "STOP_CODE",
              106
            );

            defineProperty_default()(
              assertThisInitialized_default()(_this),
              "CODE_PATTERN",
              [
                [2, 1, 2, 2, 2, 2],
                [2, 2, 2, 1, 2, 2],
                [2, 2, 2, 2, 2, 1],
                [1, 2, 1, 2, 2, 3],
                [1, 2, 1, 3, 2, 2],
                [1, 3, 1, 2, 2, 2],
                [1, 2, 2, 2, 1, 3],
                [1, 2, 2, 3, 1, 2],
                [1, 3, 2, 2, 1, 2],
                [2, 2, 1, 2, 1, 3],
                [2, 2, 1, 3, 1, 2],
                [2, 3, 1, 2, 1, 2],
                [1, 1, 2, 2, 3, 2],
                [1, 2, 2, 1, 3, 2],
                [1, 2, 2, 2, 3, 1],
                [1, 1, 3, 2, 2, 2],
                [1, 2, 3, 1, 2, 2],
                [1, 2, 3, 2, 2, 1],
                [2, 2, 3, 2, 1, 1],
                [2, 2, 1, 1, 3, 2],
                [2, 2, 1, 2, 3, 1],
                [2, 1, 3, 2, 1, 2],
                [2, 2, 3, 1, 1, 2],
                [3, 1, 2, 1, 3, 1],
                [3, 1, 1, 2, 2, 2],
                [3, 2, 1, 1, 2, 2],
                [3, 2, 1, 2, 2, 1],
                [3, 1, 2, 2, 1, 2],
                [3, 2, 2, 1, 1, 2],
                [3, 2, 2, 2, 1, 1],
                [2, 1, 2, 1, 2, 3],
                [2, 1, 2, 3, 2, 1],
                [2, 3, 2, 1, 2, 1],
                [1, 1, 1, 3, 2, 3],
                [1, 3, 1, 1, 2, 3],
                [1, 3, 1, 3, 2, 1],
                [1, 1, 2, 3, 1, 3],
                [1, 3, 2, 1, 1, 3],
                [1, 3, 2, 3, 1, 1],
                [2, 1, 1, 3, 1, 3],
                [2, 3, 1, 1, 1, 3],
                [2, 3, 1, 3, 1, 1],
                [1, 1, 2, 1, 3, 3],
                [1, 1, 2, 3, 3, 1],
                [1, 3, 2, 1, 3, 1],
                [1, 1, 3, 1, 2, 3],
                [1, 1, 3, 3, 2, 1],
                [1, 3, 3, 1, 2, 1],
                [3, 1, 3, 1, 2, 1],
                [2, 1, 1, 3, 3, 1],
                [2, 3, 1, 1, 3, 1],
                [2, 1, 3, 1, 1, 3],
                [2, 1, 3, 3, 1, 1],
                [2, 1, 3, 1, 3, 1],
                [3, 1, 1, 1, 2, 3],
                [3, 1, 1, 3, 2, 1],
                [3, 3, 1, 1, 2, 1],
                [3, 1, 2, 1, 1, 3],
                [3, 1, 2, 3, 1, 1],
                [3, 3, 2, 1, 1, 1],
                [3, 1, 4, 1, 1, 1],
                [2, 2, 1, 4, 1, 1],
                [4, 3, 1, 1, 1, 1],
                [1, 1, 1, 2, 2, 4],
                [1, 1, 1, 4, 2, 2],
                [1, 2, 1, 1, 2, 4],
                [1, 2, 1, 4, 2, 1],
                [1, 4, 1, 1, 2, 2],
                [1, 4, 1, 2, 2, 1],
                [1, 1, 2, 2, 1, 4],
                [1, 1, 2, 4, 1, 2],
                [1, 2, 2, 1, 1, 4],
                [1, 2, 2, 4, 1, 1],
                [1, 4, 2, 1, 1, 2],
                [1, 4, 2, 2, 1, 1],
                [2, 4, 1, 2, 1, 1],
                [2, 2, 1, 1, 1, 4],
                [4, 1, 3, 1, 1, 1],
                [2, 4, 1, 1, 1, 2],
                [1, 3, 4, 1, 1, 1],
                [1, 1, 1, 2, 4, 2],
                [1, 2, 1, 1, 4, 2],
                [1, 2, 1, 2, 4, 1],
                [1, 1, 4, 2, 1, 2],
                [1, 2, 4, 1, 1, 2],
                [1, 2, 4, 2, 1, 1],
                [4, 1, 1, 2, 1, 2],
                [4, 2, 1, 1, 1, 2],
                [4, 2, 1, 2, 1, 1],
                [2, 1, 2, 1, 4, 1],
                [2, 1, 4, 1, 2, 1],
                [4, 1, 2, 1, 2, 1],
                [1, 1, 1, 1, 4, 3],
                [1, 1, 1, 3, 4, 1],
                [1, 3, 1, 1, 4, 1],
                [1, 1, 4, 1, 1, 3],
                [1, 1, 4, 3, 1, 1],
                [4, 1, 1, 1, 1, 3],
                [4, 1, 1, 3, 1, 1],
                [1, 1, 3, 1, 4, 1],
                [1, 1, 4, 1, 3, 1],
                [3, 1, 1, 1, 4, 1],
                [4, 1, 1, 1, 3, 1],
                [2, 1, 1, 4, 1, 2],
                [2, 1, 1, 2, 1, 4],
                [2, 1, 1, 2, 3, 2],
                [2, 3, 3, 1, 1, 1, 2],
              ]
            );

            defineProperty_default()(
              assertThisInitialized_default()(_this),
              "SINGLE_CODE_ERROR",
              0.64
            );

            defineProperty_default()(
              assertThisInitialized_default()(_this),
              "AVG_CODE_ERROR",
              0.3
            );

            defineProperty_default()(
              assertThisInitialized_default()(_this),
              "FORMAT",
              "code_128"
            );

            defineProperty_default()(
              assertThisInitialized_default()(_this),
              "MODULE_INDICES",
              {
                bar: [0, 2, 4],
                space: [1, 3, 5],
              }
            );

            return _this;
          }

          createClass_default()(Code128Reader, [
            {
              key: "_decodeCode",
              value: function _decodeCode(start, correction) {
                var bestMatch = {
                  error: Number.MAX_VALUE,
                  code: -1,
                  start: start,
                  end: start,
                  correction: {
                    bar: 1,
                    space: 1,
                  },
                };
                var counter = [0, 0, 0, 0, 0, 0];
                var offset = start;
                var isWhite = !this._row[offset];
                var counterPos = 0;

                for (var i = offset; i < this._row.length; i++) {
                  if (this._row[i] ^ (isWhite ? 1 : 0)) {
                    counter[counterPos]++;
                  } else {
                    if (counterPos === counter.length - 1) {
                      if (correction) {
                        this._correct(counter, correction);
                      }

                      for (
                        var code = 0;
                        code < this.CODE_PATTERN.length;
                        code++
                      ) {
                        var error = this._matchPattern(
                          counter,
                          this.CODE_PATTERN[code]
                        );

                        if (error < bestMatch.error) {
                          bestMatch.code = code;
                          bestMatch.error = error;
                        }
                      }

                      bestMatch.end = i;

                      if (
                        bestMatch.code === -1 ||
                        bestMatch.error > this.AVG_CODE_ERROR
                      ) {
                        return null;
                      }

                      if (this.CODE_PATTERN[bestMatch.code]) {
                        bestMatch.correction.bar = this.calculateCorrection(
                          this.CODE_PATTERN[bestMatch.code],
                          counter,
                          this.MODULE_INDICES.bar
                        );
                        bestMatch.correction.space = this.calculateCorrection(
                          this.CODE_PATTERN[bestMatch.code],
                          counter,
                          this.MODULE_INDICES.space
                        );
                      }

                      return bestMatch;
                    } else {
                      counterPos++;
                    }

                    counter[counterPos] = 1;
                    isWhite = !isWhite;
                  }
                }

                return null;
              },
            },
            {
              key: "_correct",
              value: function _correct(counter, correction) {
                this._correctBars(
                  counter,
                  correction.bar,
                  this.MODULE_INDICES.bar
                );

                this._correctBars(
                  counter,
                  correction.space,
                  this.MODULE_INDICES.space
                );
              },
            },
            {
              key: "_findStart",
              // TODO: _findStart and decodeCode share similar code, can we re-use some?
              value: function _findStart() {
                var counter = [0, 0, 0, 0, 0, 0];

                var offset = this._nextSet(this._row);

                var bestMatch = {
                  error: Number.MAX_VALUE,
                  code: -1,
                  start: 0,
                  end: 0,
                  correction: {
                    bar: 1,
                    space: 1,
                  },
                };
                var isWhite = false;
                var counterPos = 0;

                for (var i = offset; i < this._row.length; i++) {
                  if (this._row[i] ^ (isWhite ? 1 : 0)) {
                    counter[counterPos]++;
                  } else {
                    if (counterPos === counter.length - 1) {
                      var sum = counter.reduce(function (prev, next) {
                        return prev + next;
                      }, 0);

                      for (
                        var code = this.START_CODE_A;
                        code <= this.START_CODE_C;
                        code++
                      ) {
                        var error = this._matchPattern(
                          counter,
                          this.CODE_PATTERN[code]
                        );

                        if (error < bestMatch.error) {
                          bestMatch.code = code;
                          bestMatch.error = error;
                        }
                      }

                      if (bestMatch.error < this.AVG_CODE_ERROR) {
                        bestMatch.start = i - sum;
                        bestMatch.end = i;
                        bestMatch.correction.bar = this.calculateCorrection(
                          this.CODE_PATTERN[bestMatch.code],
                          counter,
                          this.MODULE_INDICES.bar
                        );
                        bestMatch.correction.space = this.calculateCorrection(
                          this.CODE_PATTERN[bestMatch.code],
                          counter,
                          this.MODULE_INDICES.space
                        );
                        return bestMatch;
                      }

                      for (var j = 0; j < 4; j++) {
                        counter[j] = counter[j + 2];
                      }

                      counter[4] = 0;
                      counter[5] = 0;
                      counterPos--;
                    } else {
                      counterPos++;
                    }

                    counter[counterPos] = 1;
                    isWhite = !isWhite;
                  }
                }

                return null;
              },
            },
            {
              key: "decode",
              value: function decode(row, start) {
                var _this2 = this;

                var startInfo = this._findStart();

                if (startInfo === null) {
                  return null;
                } // var self = this,
                //     done = false,
                //     result = [],
                //     multiplier = 0,
                //     checksum = 0,
                //     codeset,
                //     rawResult = [],
                //     decodedCodes = [],
                //     shiftNext = false,
                //     unshift,
                //     removeLastCharacter = true;

                var code = {
                  code: startInfo.code,
                  start: startInfo.start,
                  end: startInfo.end,
                  correction: {
                    bar: startInfo.correction.bar,
                    space: startInfo.correction.space,
                  },
                };
                var decodedCodes = [];
                decodedCodes.push(code);
                var checksum = code.code;

                var codeset = (function (c) {
                  switch (c) {
                    case _this2.START_CODE_A:
                      return _this2.CODE_A;

                    case _this2.START_CODE_B:
                      return _this2.CODE_B;

                    case _this2.START_CODE_C:
                      return _this2.CODE_C;

                    default:
                      return null;
                  }
                })(code.code);

                var done = false;
                var shiftNext = false;
                var unshift = shiftNext;
                var removeLastCharacter = true;
                var multiplier = 0;
                var rawResult = [];
                var result = []; // TODO: i think this should be string only, but it creates problems if it is

                while (!done) {
                  unshift = shiftNext;
                  shiftNext = false;
                  code = this._decodeCode(code.end, code.correction);

                  if (code !== null) {
                    if (code.code !== this.STOP_CODE) {
                      removeLastCharacter = true;
                    }

                    if (code.code !== this.STOP_CODE) {
                      rawResult.push(code.code);
                      multiplier++;
                      checksum += multiplier * code.code;
                    }

                    decodedCodes.push(code);

                    switch (codeset) {
                      case this.CODE_A:
                        if (code.code < 64) {
                          result.push(String.fromCharCode(32 + code.code));
                        } else if (code.code < 96) {
                          result.push(String.fromCharCode(code.code - 64));
                        } else {
                          if (code.code !== this.STOP_CODE) {
                            removeLastCharacter = false;
                          }

                          switch (code.code) {
                            case this.CODE_SHIFT:
                              shiftNext = true;
                              codeset = this.CODE_B;
                              break;

                            case this.CODE_B:
                              codeset = this.CODE_B;
                              break;

                            case this.CODE_C:
                              codeset = this.CODE_C;
                              break;

                            case this.STOP_CODE:
                              done = true;
                              break;
                          }
                        }

                        break;

                      case this.CODE_B:
                        if (code.code < 96) {
                          result.push(String.fromCharCode(32 + code.code));
                        } else {
                          if (code.code !== this.STOP_CODE) {
                            removeLastCharacter = false;
                          }

                          switch (code.code) {
                            case this.CODE_SHIFT:
                              shiftNext = true;
                              codeset = this.CODE_A;
                              break;

                            case this.CODE_A:
                              codeset = this.CODE_A;
                              break;

                            case this.CODE_C:
                              codeset = this.CODE_C;
                              break;

                            case this.STOP_CODE:
                              done = true;
                              break;
                          }
                        }

                        break;

                      case this.CODE_C:
                        if (code.code < 100) {
                          result.push(
                            code.code < 10 ? "0" + code.code : code.code
                          );
                        } else {
                          if (code.code !== this.STOP_CODE) {
                            removeLastCharacter = false;
                          }

                          switch (code.code) {
                            case this.CODE_A:
                              codeset = this.CODE_A;
                              break;

                            case this.CODE_B:
                              codeset = this.CODE_B;
                              break;

                            case this.STOP_CODE:
                              done = true;
                              break;
                          }
                        }

                        break;
                    }
                  } else {
                    done = true;
                  }

                  if (unshift) {
                    codeset =
                      codeset === this.CODE_A ? this.CODE_B : this.CODE_A;
                  }
                }

                if (code === null) {
                  return null;
                }

                code.end = this._nextUnset(this._row, code.end);

                if (!this._verifyTrailingWhitespace(code)) {
                  return null;
                }

                checksum -= multiplier * rawResult[rawResult.length - 1];

                if (checksum % 103 !== rawResult[rawResult.length - 1]) {
                  return null;
                }

                if (!result.length) {
                  return null;
                } // remove last code from result (checksum)

                if (removeLastCharacter) {
                  result.splice(result.length - 1, 1);
                }

                return {
                  code: result.join(""),
                  start: startInfo.start,
                  end: code.end,
                  codeset: codeset,
                  startInfo: startInfo,
                  decodedCodes: decodedCodes,
                  endInfo: code,
                  format: this.FORMAT,
                };
              },
            },
            {
              key: "_verifyTrailingWhitespace",
              value: function _verifyTrailingWhitespace(endInfo) {
                var self = this,
                  trailingWhitespaceEnd;
                trailingWhitespaceEnd =
                  endInfo.end + (endInfo.end - endInfo.start) / 2;

                if (trailingWhitespaceEnd < self._row.length) {
                  if (self._matchRange(endInfo.end, trailingWhitespaceEnd, 0)) {
                    return endInfo;
                  }
                }

                return null;
              },
            },
            {
              key: "calculateCorrection",
              value: function calculateCorrection(
                expected,
                normalized,
                indices
              ) {
                var length = indices.length,
                  sumNormalized = 0,
                  sumExpected = 0;

                while (length--) {
                  sumExpected += expected[indices[length]];
                  sumNormalized += normalized[indices[length]];
                }

                return sumExpected / sumNormalized;
              },
            },
          ]);

          return Code128Reader;
        })(barcode_reader);

        /* harmony default export */ var code_128_reader =
          code_128_reader_Code128Reader;
        // EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/get.js
        var get = __webpack_require__(14);
        var get_default = /*#__PURE__*/ __webpack_require__.n(get);

        // EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/toConsumableArray.js
        var toConsumableArray = __webpack_require__(33);
        var toConsumableArray_default =
          /*#__PURE__*/ __webpack_require__.n(toConsumableArray);

        // CONCATENATED MODULE: ./src/reader/code_39_reader.ts

        function code_39_reader_createSuper(Derived) {
          var hasNativeReflectConstruct =
            code_39_reader_isNativeReflectConstruct();
          return function _createSuperInternal() {
            var Super = getPrototypeOf_default()(Derived),
              result;
            if (hasNativeReflectConstruct) {
              var NewTarget = getPrototypeOf_default()(this).constructor;
              result = Reflect.construct(Super, arguments, NewTarget);
            } else {
              result = Super.apply(this, arguments);
            }
            return possibleConstructorReturn_default()(this, result);
          };
        }

        function code_39_reader_isNativeReflectConstruct() {
          if (typeof Reflect === "undefined" || !Reflect.construct)
            return false;
          if (Reflect.construct.sham) return false;
          if (typeof Proxy === "function") return true;
          try {
            Boolean.prototype.valueOf.call(
              Reflect.construct(Boolean, [], function () {})
            );
            return true;
          } catch (e) {
            return false;
          }
        }

        /* eslint-disable class-methods-use-this */

        var ALPHABETH_STRING = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ-. *$/+%";
        var code_39_reader_ALPHABET = new Uint16Array(
          toConsumableArray_default()(ALPHABETH_STRING).map(function (_char) {
            return _char.charCodeAt(0);
          })
        );
        var code_39_reader_CHARACTER_ENCODINGS = new Uint16Array([
          0x034, 0x121, 0x061, 0x160, 0x031, 0x130, 0x070, 0x025, 0x124, 0x064,
          0x109, 0x049, 0x148, 0x019, 0x118, 0x058, 0x00d, 0x10c, 0x04c, 0x01c,
          0x103, 0x043, 0x142, 0x013, 0x112, 0x052, 0x007, 0x106, 0x046, 0x016,
          0x181, 0x0c1, 0x1c0, 0x091, 0x190, 0x0d0, 0x085, 0x184, 0x0c4, 0x094,
          0x0a8, 0x0a2, 0x08a, 0x02a,
        ]);
        var ASTERISK = 0x094;

        var code_39_reader_Code39Reader = /*#__PURE__*/ (function (
          _BarcodeReader
        ) {
          inherits_default()(Code39Reader, _BarcodeReader);

          var _super = code_39_reader_createSuper(Code39Reader);

          function Code39Reader() {
            var _this;

            classCallCheck_default()(this, Code39Reader);

            for (
              var _len = arguments.length, args = new Array(_len), _key = 0;
              _key < _len;
              _key++
            ) {
              args[_key] = arguments[_key];
            }

            _this = _super.call.apply(_super, [this].concat(args));

            defineProperty_default()(
              assertThisInitialized_default()(_this),
              "FORMAT",
              "code_39"
            );

            return _this;
          }

          createClass_default()(Code39Reader, [
            {
              key: "_findStart",
              value: function _findStart() {
                var offset = this._nextSet(this._row);

                var patternStart = offset;
                var counter = new Uint16Array([0, 0, 0, 0, 0, 0, 0, 0, 0]);
                var counterPos = 0;
                var isWhite = false;

                for (var i = offset; i < this._row.length; i++) {
                  // eslint-disable-next-line no-bitwise
                  if (this._row[i] ^ (isWhite ? 1 : 0)) {
                    counter[counterPos]++;
                  } else {
                    if (counterPos === counter.length - 1) {
                      // find start pattern
                      if (this._toPattern(counter) === ASTERISK) {
                        var whiteSpaceMustStart = Math.floor(
                          Math.max(0, patternStart - (i - patternStart) / 4)
                        );

                        if (
                          this._matchRange(whiteSpaceMustStart, patternStart, 0)
                        ) {
                          return {
                            start: patternStart,
                            end: i,
                          };
                        }
                      }

                      patternStart += counter[0] + counter[1];

                      for (var j = 0; j < 7; j++) {
                        counter[j] = counter[j + 2];
                      }

                      counter[7] = 0;
                      counter[8] = 0;
                      counterPos--;
                    } else {
                      counterPos++;
                    }

                    counter[counterPos] = 1;
                    isWhite = !isWhite;
                  }
                }

                return null;
              },
            },
            {
              key: "_toPattern",
              value: function _toPattern(counters) {
                var numCounters = counters.length;
                var maxNarrowWidth = 0;
                var numWideBars = numCounters;
                var wideBarWidth = 0;

                while (numWideBars > 3) {
                  maxNarrowWidth = this._findNextWidth(
                    counters,
                    maxNarrowWidth
                  );
                  numWideBars = 0;
                  var pattern = 0;

                  for (var i = 0; i < numCounters; i++) {
                    if (counters[i] > maxNarrowWidth) {
                      // eslint-disable-next-line no-bitwise
                      pattern |= 1 << (numCounters - 1 - i);
                      numWideBars++;
                      wideBarWidth += counters[i];
                    }
                  }

                  if (numWideBars === 3) {
                    for (
                      var _i = 0;
                      _i < numCounters && numWideBars > 0;
                      _i++
                    ) {
                      if (counters[_i] > maxNarrowWidth) {
                        numWideBars--;

                        if (counters[_i] * 2 >= wideBarWidth) {
                          return -1;
                        }
                      }
                    }

                    return pattern;
                  }
                }

                return -1;
              },
            },
            {
              key: "_findNextWidth",
              value: function _findNextWidth(counters, current) {
                var minWidth = Number.MAX_VALUE;

                for (var i = 0; i < counters.length; i++) {
                  if (counters[i] < minWidth && counters[i] > current) {
                    minWidth = counters[i];
                  }
                }

                return minWidth;
              },
            },
            {
              key: "_patternToChar",
              value: function _patternToChar(pattern) {
                for (
                  var i = 0;
                  i < code_39_reader_CHARACTER_ENCODINGS.length;
                  i++
                ) {
                  if (code_39_reader_CHARACTER_ENCODINGS[i] === pattern) {
                    return String.fromCharCode(code_39_reader_ALPHABET[i]);
                  }
                }

                return null;
              },
            },
            {
              key: "_verifyTrailingWhitespace",
              value: function _verifyTrailingWhitespace(
                lastStart,
                nextStart,
                counters
              ) {
                var patternSize = array_helper["a" /* default */].sum(counters);
                var trailingWhitespaceEnd = nextStart - lastStart - patternSize;

                if (trailingWhitespaceEnd * 3 >= patternSize) {
                  return true;
                }

                return false;
              },
            },
            {
              key: "decode",
              value: function decode() {
                var counters = new Uint16Array([0, 0, 0, 0, 0, 0, 0, 0, 0]);
                var result = [];

                var start = this._findStart();

                if (!start) {
                  return null;
                }

                var nextStart = this._nextSet(this._row, start.end);

                var decodedChar;
                var lastStart;

                do {
                  counters = this._toCounters(nextStart, counters);

                  var pattern = this._toPattern(counters);

                  if (pattern < 0) {
                    return null;
                  }

                  decodedChar = this._patternToChar(pattern);

                  if (decodedChar === null) {
                    return null;
                  }

                  result.push(decodedChar);
                  lastStart = nextStart;
                  nextStart += array_helper["a" /* default */].sum(counters);
                  nextStart = this._nextSet(this._row, nextStart);
                } while (decodedChar !== "*");

                result.pop();

                if (!result.length) {
                  return null;
                }

                if (
                  !this._verifyTrailingWhitespace(
                    lastStart,
                    nextStart,
                    counters
                  )
                ) {
                  return null;
                }

                return {
                  code: result.join(""),
                  start: start.start,
                  end: nextStart,
                  startInfo: start,
                  decodedCodes: result,
                  format: this.FORMAT,
                };
              },
            },
          ]);

          return Code39Reader;
        })(barcode_reader);

        /* harmony default export */ var code_39_reader =
          code_39_reader_Code39Reader;
        // CONCATENATED MODULE: ./src/reader/code_32_reader.ts

        function code_32_reader_createSuper(Derived) {
          var hasNativeReflectConstruct =
            code_32_reader_isNativeReflectConstruct();
          return function _createSuperInternal() {
            var Super = getPrototypeOf_default()(Derived),
              result;
            if (hasNativeReflectConstruct) {
              var NewTarget = getPrototypeOf_default()(this).constructor;
              result = Reflect.construct(Super, arguments, NewTarget);
            } else {
              result = Super.apply(this, arguments);
            }
            return possibleConstructorReturn_default()(this, result);
          };
        }

        function code_32_reader_isNativeReflectConstruct() {
          if (typeof Reflect === "undefined" || !Reflect.construct)
            return false;
          if (Reflect.construct.sham) return false;
          if (typeof Proxy === "function") return true;
          try {
            Boolean.prototype.valueOf.call(
              Reflect.construct(Boolean, [], function () {})
            );
            return true;
          } catch (e) {
            return false;
          }
        }

        var patterns = {
          AEIO: /[AEIO]/g,
          AZ09: /[A-Z0-9]/,
        };
        var code32set = "0123456789BCDFGHJKLMNPQRSTUVWXYZ";

        var code_32_reader_Code32Reader = /*#__PURE__*/ (function (
          _Code39Reader
        ) {
          inherits_default()(Code32Reader, _Code39Reader);

          var _super = code_32_reader_createSuper(Code32Reader);

          function Code32Reader() {
            var _this;

            classCallCheck_default()(this, Code32Reader);

            for (
              var _len = arguments.length, args = new Array(_len), _key = 0;
              _key < _len;
              _key++
            ) {
              args[_key] = arguments[_key];
            }

            _this = _super.call.apply(_super, [this].concat(args));

            defineProperty_default()(
              assertThisInitialized_default()(_this),
              "FORMAT",
              "code_32_reader"
            );

            return _this;
          }

          createClass_default()(Code32Reader, [
            {
              key: "_decodeCode32",
              value: function _decodeCode32(code) {
                if (/[^0-9BCDFGHJKLMNPQRSTUVWXYZ]/.test(code)) {
                  return null;
                }

                var res = 0;

                for (var i = 0; i < code.length; i++) {
                  res = res * 32 + code32set.indexOf(code[i]);
                }

                var code32 = "".concat(res);

                if (code32.length < 9) {
                  code32 = ("000000000" + code32).slice(-9);
                }

                return "A" + code32;
              }, // TODO (this was todo in original repo, no text was there. sorry.)
            },
            {
              key: "_checkChecksum",
              value: function _checkChecksum(code) {
                return !!code;
              },
            },
            {
              key: "decode",
              value: function decode() {
                var result = get_default()(
                  getPrototypeOf_default()(Code32Reader.prototype),
                  "decode",
                  this
                ).call(this);

                if (!result) {
                  return null;
                }

                var code = result.code;

                if (!code) {
                  return null;
                }

                code = code.replace(patterns.AEIO, "");

                if (!this._checkChecksum(code)) {
                  return null;
                }

                var code32 = this._decodeCode32(code);

                if (!code32) {
                  return null;
                }

                result.code = code32;
                return result;
              },
            },
          ]);

          return Code32Reader;
        })(code_39_reader);

        /* harmony default export */ var code_32_reader =
          code_32_reader_Code32Reader;
        // CONCATENATED MODULE: ./src/reader/code_39_vin_reader.ts

        function code_39_vin_reader_createSuper(Derived) {
          var hasNativeReflectConstruct =
            code_39_vin_reader_isNativeReflectConstruct();
          return function _createSuperInternal() {
            var Super = getPrototypeOf_default()(Derived),
              result;
            if (hasNativeReflectConstruct) {
              var NewTarget = getPrototypeOf_default()(this).constructor;
              result = Reflect.construct(Super, arguments, NewTarget);
            } else {
              result = Super.apply(this, arguments);
            }
            return possibleConstructorReturn_default()(this, result);
          };
        }

        function code_39_vin_reader_isNativeReflectConstruct() {
          if (typeof Reflect === "undefined" || !Reflect.construct)
            return false;
          if (Reflect.construct.sham) return false;
          if (typeof Proxy === "function") return true;
          try {
            Boolean.prototype.valueOf.call(
              Reflect.construct(Boolean, [], function () {})
            );
            return true;
          } catch (e) {
            return false;
          }
        }

        /* eslint-disable class-methods-use-this */

        var code_39_vin_reader_patterns = {
          IOQ: /[IOQ]/g,
          AZ09: /[A-Z0-9]{17}/,
        };

        var code_39_vin_reader_Code39VINReader = /*#__PURE__*/ (function (
          _Code39Reader
        ) {
          inherits_default()(Code39VINReader, _Code39Reader);

          var _super = code_39_vin_reader_createSuper(Code39VINReader);

          function Code39VINReader() {
            var _this;

            classCallCheck_default()(this, Code39VINReader);

            for (
              var _len = arguments.length, args = new Array(_len), _key = 0;
              _key < _len;
              _key++
            ) {
              args[_key] = arguments[_key];
            }

            _this = _super.call.apply(_super, [this].concat(args));

            defineProperty_default()(
              assertThisInitialized_default()(_this),
              "FORMAT",
              "code_39_vin"
            );

            return _this;
          }

          createClass_default()(Code39VINReader, [
            {
              key: "_checkChecksum",
              // TODO (this was todo in original repo, no text was there. sorry.)
              value: function _checkChecksum(code) {
                return !!code;
              }, // Cribbed from:
              // https://github.com/zxing/zxing/blob/master/core/src/main/java/com/google/zxing/client/result/VINResultParser.java
            },
            {
              key: "decode",
              value: function decode() {
                var result = get_default()(
                  getPrototypeOf_default()(Code39VINReader.prototype),
                  "decode",
                  this
                ).call(this);

                if (!result) {
                  return null;
                }

                var code = result.code;

                if (!code) {
                  return null;
                }

                code = code.replace(code_39_vin_reader_patterns.IOQ, "");

                if (!code.match(code_39_vin_reader_patterns.AZ09)) {
                  if (true) {
                    console.log("Failed AZ09 pattern code:", code);
                  }

                  return null;
                }

                if (!this._checkChecksum(code)) {
                  return null;
                }

                result.code = code;
                return result;
              },
            },
          ]);

          return Code39VINReader;
        })(code_39_reader);

        /* harmony default export */ var code_39_vin_reader =
          code_39_vin_reader_Code39VINReader;
        // CONCATENATED MODULE: ./src/reader/code_93_reader.ts

        function code_93_reader_createSuper(Derived) {
          var hasNativeReflectConstruct =
            code_93_reader_isNativeReflectConstruct();
          return function _createSuperInternal() {
            var Super = getPrototypeOf_default()(Derived),
              result;
            if (hasNativeReflectConstruct) {
              var NewTarget = getPrototypeOf_default()(this).constructor;
              result = Reflect.construct(Super, arguments, NewTarget);
            } else {
              result = Super.apply(this, arguments);
            }
            return possibleConstructorReturn_default()(this, result);
          };
        }

        function code_93_reader_isNativeReflectConstruct() {
          if (typeof Reflect === "undefined" || !Reflect.construct)
            return false;
          if (Reflect.construct.sham) return false;
          if (typeof Proxy === "function") return true;
          try {
            Boolean.prototype.valueOf.call(
              Reflect.construct(Boolean, [], function () {})
            );
            return true;
          } catch (e) {
            return false;
          }
        }

        var code_93_reader_ALPHABETH_STRING =
          "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ-. $/+%abcd*";
        var code_93_reader_ALPHABET = new Uint16Array(
          toConsumableArray_default()(code_93_reader_ALPHABETH_STRING).map(
            function (_char) {
              return _char.charCodeAt(0);
            }
          )
        );
        var code_93_reader_CHARACTER_ENCODINGS = new Uint16Array([
          0x114, 0x148, 0x144, 0x142, 0x128, 0x124, 0x122, 0x150, 0x112, 0x10a,
          0x1a8, 0x1a4, 0x1a2, 0x194, 0x192, 0x18a, 0x168, 0x164, 0x162, 0x134,
          0x11a, 0x158, 0x14c, 0x146, 0x12c, 0x116, 0x1b4, 0x1b2, 0x1ac, 0x1a6,
          0x196, 0x19a, 0x16c, 0x166, 0x136, 0x13a, 0x12e, 0x1d4, 0x1d2, 0x1ca,
          0x16e, 0x176, 0x1ae, 0x126, 0x1da, 0x1d6, 0x132, 0x15e,
        ]);
        var code_93_reader_ASTERISK = 0x15e;

        var code_93_reader_Code93Reader = /*#__PURE__*/ (function (
          _BarcodeReader
        ) {
          inherits_default()(Code93Reader, _BarcodeReader);

          var _super = code_93_reader_createSuper(Code93Reader);

          function Code93Reader() {
            var _this;

            classCallCheck_default()(this, Code93Reader);

            for (
              var _len = arguments.length, args = new Array(_len), _key = 0;
              _key < _len;
              _key++
            ) {
              args[_key] = arguments[_key];
            }

            _this = _super.call.apply(_super, [this].concat(args));

            defineProperty_default()(
              assertThisInitialized_default()(_this),
              "FORMAT",
              "code_93"
            );

            return _this;
          }

          createClass_default()(Code93Reader, [
            {
              key: "_patternToChar",
              value: function _patternToChar(pattern) {
                for (
                  var i = 0;
                  i < code_93_reader_CHARACTER_ENCODINGS.length;
                  i++
                ) {
                  if (code_93_reader_CHARACTER_ENCODINGS[i] === pattern) {
                    return String.fromCharCode(code_93_reader_ALPHABET[i]);
                  }
                }

                return null;
              },
            },
            {
              key: "_toPattern",
              value: function _toPattern(counters) {
                var numCounters = counters.length;
                var sum = counters.reduce(function (prev, next) {
                  return prev + next;
                }, 0);
                var pattern = 0;

                for (var i = 0; i < numCounters; i++) {
                  var normalized = Math.round((counters[i] * 9) / sum);

                  if (normalized < 1 || normalized > 4) {
                    return -1;
                  }

                  if ((i & 1) === 0) {
                    for (var j = 0; j < normalized; j++) {
                      pattern = (pattern << 1) | 1;
                    }
                  } else {
                    pattern <<= normalized;
                  }
                }

                return pattern;
              },
            },
            {
              key: "_findStart",
              value: function _findStart() {
                var offset = this._nextSet(this._row);

                var patternStart = offset;
                var counter = new Uint16Array([0, 0, 0, 0, 0, 0]);
                var counterPos = 0;
                var isWhite = false;

                for (var i = offset; i < this._row.length; i++) {
                  if (this._row[i] ^ (isWhite ? 1 : 0)) {
                    counter[counterPos]++;
                  } else {
                    if (counterPos === counter.length - 1) {
                      // find start pattern
                      if (
                        this._toPattern(counter) === code_93_reader_ASTERISK
                      ) {
                        var whiteSpaceMustStart = Math.floor(
                          Math.max(0, patternStart - (i - patternStart) / 4)
                        );

                        if (
                          this._matchRange(whiteSpaceMustStart, patternStart, 0)
                        ) {
                          return {
                            start: patternStart,
                            end: i,
                          };
                        }
                      }

                      patternStart += counter[0] + counter[1];

                      for (var j = 0; j < 4; j++) {
                        counter[j] = counter[j + 2];
                      }

                      counter[4] = 0;
                      counter[5] = 0;
                      counterPos--;
                    } else {
                      counterPos++;
                    }

                    counter[counterPos] = 1;
                    isWhite = !isWhite;
                  }
                }

                return null;
              },
            },
            {
              key: "_verifyEnd",
              value: function _verifyEnd(lastStart, nextStart) {
                if (lastStart === nextStart || !this._row[nextStart]) {
                  return false;
                }

                return true;
              },
            },
            {
              key: "_decodeExtended",
              value: function _decodeExtended(charArray) {
                var length = charArray.length;
                var result = [];

                for (var i = 0; i < length; i++) {
                  var _char2 = charArray[i];

                  if (_char2 >= "a" && _char2 <= "d") {
                    if (i > length - 2) {
                      return null;
                    }

                    var nextChar = charArray[++i];
                    var nextCharCode = nextChar.charCodeAt(0);
                    var decodedChar = void 0;

                    switch (_char2) {
                      case "a":
                        if (nextChar >= "A" && nextChar <= "Z") {
                          decodedChar = String.fromCharCode(nextCharCode - 64);
                        } else {
                          return null;
                        }

                        break;

                      case "b":
                        if (nextChar >= "A" && nextChar <= "E") {
                          decodedChar = String.fromCharCode(nextCharCode - 38);
                        } else if (nextChar >= "F" && nextChar <= "J") {
                          decodedChar = String.fromCharCode(nextCharCode - 11);
                        } else if (nextChar >= "K" && nextChar <= "O") {
                          decodedChar = String.fromCharCode(nextCharCode + 16);
                        } else if (nextChar >= "P" && nextChar <= "S") {
                          decodedChar = String.fromCharCode(nextCharCode + 43);
                        } else if (nextChar >= "T" && nextChar <= "Z") {
                          decodedChar = String.fromCharCode(127);
                        } else {
                          return null;
                        }

                        break;

                      case "c":
                        if (nextChar >= "A" && nextChar <= "O") {
                          decodedChar = String.fromCharCode(nextCharCode - 32);
                        } else if (nextChar === "Z") {
                          decodedChar = ":";
                        } else {
                          return null;
                        }

                        break;

                      case "d":
                        if (nextChar >= "A" && nextChar <= "Z") {
                          decodedChar = String.fromCharCode(nextCharCode + 32);
                        } else {
                          return null;
                        }

                        break;

                      default:
                        console.warn(
                          "* code_93_reader _decodeExtended hit default case, this may be an error",
                          decodedChar
                        );
                        return null;
                    }

                    result.push(decodedChar);
                  } else {
                    result.push(_char2);
                  }
                }

                return result;
              },
            },
            {
              key: "_matchCheckChar",
              value: function _matchCheckChar(charArray, index, maxWeight) {
                var arrayToCheck = charArray.slice(0, index);
                var length = arrayToCheck.length;
                var weightedSums = arrayToCheck.reduce(function (
                  sum,
                  _char3,
                  i
                ) {
                  var weight = ((i * -1 + (length - 1)) % maxWeight) + 1;
                  var value = code_93_reader_ALPHABET.indexOf(
                    _char3.charCodeAt(0)
                  );
                  return sum + weight * value;
                },
                0);
                var checkChar = code_93_reader_ALPHABET[weightedSums % 47];
                return checkChar === charArray[index].charCodeAt(0);
              },
            },
            {
              key: "_verifyChecksums",
              value: function _verifyChecksums(charArray) {
                return (
                  this._matchCheckChar(charArray, charArray.length - 2, 20) &&
                  this._matchCheckChar(charArray, charArray.length - 1, 15)
                );
              },
            },
            {
              key: "decode",
              value: function decode(row, start) {
                start = this._findStart();

                if (!start) {
                  return null;
                }

                var counters = new Uint16Array([0, 0, 0, 0, 0, 0]);
                var result = [];

                var nextStart = this._nextSet(this._row, start.end);

                var lastStart;
                var decodedChar;

                do {
                  counters = this._toCounters(nextStart, counters);

                  var pattern = this._toPattern(counters);

                  if (pattern < 0) {
                    return null;
                  }

                  decodedChar = this._patternToChar(pattern);

                  if (decodedChar === null) {
                    return null;
                  }

                  result.push(decodedChar);
                  lastStart = nextStart;
                  nextStart += array_helper["a" /* default */].sum(counters);
                  nextStart = this._nextSet(this._row, nextStart);
                } while (decodedChar !== "*");

                result.pop();

                if (!result.length) {
                  return null;
                }

                if (!this._verifyEnd(lastStart, nextStart)) {
                  return null;
                }

                if (!this._verifyChecksums(result)) {
                  return null;
                }

                result = result.slice(0, result.length - 2); // yes, this is an assign inside an if.

                if ((result = this._decodeExtended(result)) === null) {
                  return null;
                }

                return {
                  code: result.join(""),
                  start: start.start,
                  end: nextStart,
                  startInfo: start,
                  decodedCodes: result,
                  format: this.FORMAT,
                };
              },
            },
          ]);

          return Code93Reader;
        })(barcode_reader);

        /* harmony default export */ var code_93_reader =
          code_93_reader_Code93Reader;
        // CONCATENATED MODULE: ./src/reader/ean_reader.ts

        function ownKeys(object, enumerableOnly) {
          var keys = Object.keys(object);
          if (Object.getOwnPropertySymbols) {
            var symbols = Object.getOwnPropertySymbols(object);
            enumerableOnly &&
              (symbols = symbols.filter(function (sym) {
                return Object.getOwnPropertyDescriptor(object, sym).enumerable;
              })),
              keys.push.apply(keys, symbols);
          }
          return keys;
        }

        function _objectSpread(target) {
          for (var i = 1; i < arguments.length; i++) {
            var source = null != arguments[i] ? arguments[i] : {};
            i % 2
              ? ownKeys(Object(source), !0).forEach(function (key) {
                  defineProperty_default()(target, key, source[key]);
                })
              : Object.getOwnPropertyDescriptors
              ? Object.defineProperties(
                  target,
                  Object.getOwnPropertyDescriptors(source)
                )
              : ownKeys(Object(source)).forEach(function (key) {
                  Object.defineProperty(
                    target,
                    key,
                    Object.getOwnPropertyDescriptor(source, key)
                  );
                });
          }
          return target;
        }

        function ean_reader_createSuper(Derived) {
          var hasNativeReflectConstruct = ean_reader_isNativeReflectConstruct();
          return function _createSuperInternal() {
            var Super = getPrototypeOf_default()(Derived),
              result;
            if (hasNativeReflectConstruct) {
              var NewTarget = getPrototypeOf_default()(this).constructor;
              result = Reflect.construct(Super, arguments, NewTarget);
            } else {
              result = Super.apply(this, arguments);
            }
            return possibleConstructorReturn_default()(this, result);
          };
        }

        function ean_reader_isNativeReflectConstruct() {
          if (typeof Reflect === "undefined" || !Reflect.construct)
            return false;
          if (Reflect.construct.sham) return false;
          if (typeof Proxy === "function") return true;
          try {
            Boolean.prototype.valueOf.call(
              Reflect.construct(Boolean, [], function () {})
            );
            return true;
          } catch (e) {
            return false;
          }
        }

        // const CODE_L_START = 0;

        var CODE_G_START = 10;

        var ean_reader_START_PATTERN = [1, 1, 1];
        var MIDDLE_PATTERN = [1, 1, 1, 1, 1];

        var EXTENSION_START_PATTERN = [1, 1, 2];
        var ean_reader_CODE_PATTERN = [
          [3, 2, 1, 1],
          [2, 2, 2, 1],
          [2, 1, 2, 2],
          [1, 4, 1, 1],
          [1, 1, 3, 2],
          [1, 2, 3, 1],
          [1, 1, 1, 4],
          [1, 3, 1, 2],
          [1, 2, 1, 3],
          [3, 1, 1, 2],
          [1, 1, 2, 3],
          [1, 2, 2, 2],
          [2, 2, 1, 2],
          [1, 1, 4, 1],
          [2, 3, 1, 1],
          [1, 3, 2, 1],
          [4, 1, 1, 1],
          [2, 1, 3, 1],
          [3, 1, 2, 1],
          [2, 1, 1, 3],
        ];
        var CODE_FREQUENCY = [0, 11, 13, 14, 19, 25, 28, 21, 22, 26]; // const SINGLE_CODE_ERROR = 0.70;

        var AVG_CODE_ERROR = 0.48;

        var ean_reader_EANReader = /*#__PURE__*/ (function (_BarcodeReader) {
          inherits_default()(EANReader, _BarcodeReader);

          var _super = ean_reader_createSuper(EANReader);

          // TODO: does this need to be in the class?
          function EANReader(config, supplements) {
            var _this;

            classCallCheck_default()(this, EANReader);

            _this = _super.call(
              this,
              merge_default()(
                {
                  supplements: [],
                },
                config
              ),
              supplements
            );

            defineProperty_default()(
              assertThisInitialized_default()(_this),
              "FORMAT",
              "ean_13"
            );

            defineProperty_default()(
              assertThisInitialized_default()(_this),
              "SINGLE_CODE_ERROR",
              0.7
            );

            defineProperty_default()(
              assertThisInitialized_default()(_this),
              "STOP_PATTERN",
              [1, 1, 1]
            );

            return _this;
          }

          createClass_default()(EANReader, [
            {
              key: "_findPattern",
              value: function _findPattern(
                pattern,
                offset,
                isWhite,
                tryHarder
              ) {
                var counter = new Array(pattern.length).fill(0);
                var bestMatch = {
                  error: Number.MAX_VALUE,
                  start: 0,
                  end: 0,
                };
                var epsilon = AVG_CODE_ERROR; // console.warn('* findPattern', pattern, offset, isWhite, tryHarder, epsilon);

                var counterPos = 0;

                if (!offset) {
                  offset = this._nextSet(this._row);
                }

                var found = false;

                for (var i = offset; i < this._row.length; i++) {
                  // console.warn(`* loop i=${offset} len=${this._row.length} isWhite=${isWhite} counterPos=${counterPos}`);
                  if (this._row[i] ^ (isWhite ? 1 : 0)) {
                    counter[counterPos] += 1;
                  } else {
                    if (counterPos === counter.length - 1) {
                      var error = this._matchPattern(counter, pattern); // console.warn('* matchPattern', error, counter, pattern);

                      if (
                        error < epsilon &&
                        bestMatch.error &&
                        error < bestMatch.error
                      ) {
                        found = true;
                        bestMatch.error = error;
                        bestMatch.start =
                          i -
                          counter.reduce(function (sum, value) {
                            return sum + value;
                          }, 0);
                        bestMatch.end = i; // console.warn('* return bestMatch', JSON.stringify(bestMatch));

                        return bestMatch;
                      }

                      if (tryHarder) {
                        for (var j = 0; j < counter.length - 2; j++) {
                          counter[j] = counter[j + 2];
                        }

                        counter[counter.length - 2] = 0;
                        counter[counter.length - 1] = 0;
                        counterPos--;
                      }
                    } else {
                      counterPos++;
                    }

                    counter[counterPos] = 1;
                    isWhite = !isWhite;
                  }
                }

                if (found) {
                  // console.warn('* return bestMatch', JSON.stringify(bestMatch));
                } else {
                  // console.warn('* return null');
                }

                return found ? bestMatch : null;
              }, // TODO: findPattern and decodeCode appear to share quite similar code, can it be reduced?
            },
            {
              key: "_decodeCode",
              value: function _decodeCode(start, coderange) {
                // console.warn('* decodeCode', start, coderange);
                var counter = [0, 0, 0, 0];
                var offset = start;
                var bestMatch = {
                  error: Number.MAX_VALUE,
                  code: -1,
                  start: start,
                  end: start,
                };
                var epsilon = AVG_CODE_ERROR;
                var isWhite = !this._row[offset];
                var counterPos = 0;

                if (!coderange) {
                  // console.warn('* decodeCode before length');
                  coderange = ean_reader_CODE_PATTERN.length; // console.warn('* decodeCode after length');
                }

                var found = false;

                for (var i = offset; i < this._row.length; i++) {
                  if (this._row[i] ^ (isWhite ? 1 : 0)) {
                    counter[counterPos]++;
                  } else {
                    if (counterPos === counter.length - 1) {
                      for (var code = 0; code < coderange; code++) {
                        var error = this._matchPattern(
                          counter,
                          ean_reader_CODE_PATTERN[code]
                        );

                        bestMatch.end = i;

                        if (error < bestMatch.error) {
                          bestMatch.code = code;
                          bestMatch.error = error;
                        }
                      }

                      if (bestMatch.error > epsilon) {
                        // console.warn('* return null');
                        return null;
                      } // console.warn('* return bestMatch', JSON.stringify(bestMatch));

                      return bestMatch;
                    } else {
                      counterPos++;
                    }

                    counter[counterPos] = 1;
                    isWhite = !isWhite;
                  }
                }

                return found ? bestMatch : null;
              },
            },
            {
              key: "_findStart",
              value: function _findStart() {
                // console.warn('* findStart');
                var offset = this._nextSet(this._row);

                var startInfo = null;

                while (!startInfo) {
                  startInfo = this._findPattern(
                    ean_reader_START_PATTERN,
                    offset,
                    false,
                    true
                  ); // console.warn('* startInfo=', JSON.stringify(startInfo));

                  if (!startInfo) {
                    return null;
                  }

                  var leadingWhitespaceStart =
                    startInfo.start - (startInfo.end - startInfo.start);

                  if (leadingWhitespaceStart >= 0) {
                    if (
                      this._matchRange(
                        leadingWhitespaceStart,
                        startInfo.start,
                        0
                      )
                    ) {
                      // console.warn('* returning startInfo');
                      return startInfo;
                    }
                  }

                  offset = startInfo.end;
                  startInfo = null;
                } // console.warn('* returning null');

                return null;
              },
            },
            {
              key: "_calculateFirstDigit",
              value: function _calculateFirstDigit(codeFrequency) {
                // console.warn('* calculateFirstDigit', codeFrequency);
                for (var i = 0; i < CODE_FREQUENCY.length; i++) {
                  if (codeFrequency === CODE_FREQUENCY[i]) {
                    // console.warn('* returning', i);
                    return i;
                  }
                } // console.warn('* return null');

                return null;
              },
            },
            {
              key: "_decodePayload",
              value: function _decodePayload(inCode, result, decodedCodes) {
                // console.warn('* decodePayload', inCode, result, decodedCodes);
                var outCode = _objectSpread({}, inCode);

                var codeFrequency = 0x0;

                for (var i = 0; i < 6; i++) {
                  outCode = this._decodeCode(outCode.end); // console.warn('* decodeCode=', outCode);

                  if (!outCode) {
                    // console.warn('* return null');
                    return null;
                  }

                  if (outCode.code >= CODE_G_START) {
                    outCode.code -= CODE_G_START;
                    codeFrequency |= 1 << (5 - i);
                  } else {
                    codeFrequency |= 0 << (5 - i);
                  }

                  result.push(outCode.code);
                  decodedCodes.push(outCode);
                }

                var firstDigit = this._calculateFirstDigit(codeFrequency); // console.warn('* firstDigit=', firstDigit);

                if (firstDigit === null) {
                  // console.warn('* return null');
                  return null;
                }

                result.unshift(firstDigit);

                var middlePattern = this._findPattern(
                  MIDDLE_PATTERN,
                  outCode.end,
                  true,
                  false
                ); // console.warn('* findPattern=', JSON.stringify(middlePattern));

                if (middlePattern === null || !middlePattern.end) {
                  // console.warn('* return null');
                  return null;
                }

                decodedCodes.push(middlePattern);

                for (var _i = 0; _i < 6; _i++) {
                  middlePattern = this._decodeCode(
                    middlePattern.end,
                    CODE_G_START
                  ); // console.warn('* decodeCode=', JSON.stringify(middlePattern));

                  if (!middlePattern) {
                    // console.warn('* return null');
                    return null;
                  }

                  decodedCodes.push(middlePattern);
                  result.push(middlePattern.code);
                } // console.warn('* end code=', JSON.stringify(middlePattern));
                // console.warn('* end result=', JSON.stringify(result));
                // console.warn('* end decodedCodes=', decodedCodes);

                return middlePattern;
              },
            },
            {
              key: "_verifyTrailingWhitespace",
              value: function _verifyTrailingWhitespace(endInfo) {
                // console.warn('* verifyTrailingWhitespace', JSON.stringify(endInfo));
                var trailingWhitespaceEnd =
                  endInfo.end + (endInfo.end - endInfo.start);

                if (trailingWhitespaceEnd < this._row.length) {
                  if (this._matchRange(endInfo.end, trailingWhitespaceEnd, 0)) {
                    // console.warn('* returning', JSON.stringify(endInfo));
                    return endInfo;
                  }
                } // console.warn('* return null');

                return null;
              },
            },
            {
              key: "_findEnd",
              value: function _findEnd(offset, isWhite) {
                // console.warn('* findEnd', offset, isWhite);
                var endInfo = this._findPattern(
                  this.STOP_PATTERN,
                  offset,
                  isWhite,
                  false
                );

                return endInfo !== null
                  ? this._verifyTrailingWhitespace(endInfo)
                  : null;
              },
            },
            {
              key: "_checksum",
              value: function _checksum(result) {
                // console.warn('* _checksum', result);
                var sum = 0;

                for (var i = result.length - 2; i >= 0; i -= 2) {
                  sum += result[i];
                }

                sum *= 3;

                for (var _i2 = result.length - 1; _i2 >= 0; _i2 -= 2) {
                  sum += result[_i2];
                } // console.warn('* end checksum', sum % 10 === 0);

                return sum % 10 === 0;
              },
            },
            {
              key: "_decodeExtensions",
              value: function _decodeExtensions(offset) {
                var start = this._nextSet(this._row, offset);

                var startInfo = this._findPattern(
                  EXTENSION_START_PATTERN,
                  start,
                  false,
                  false
                );

                if (startInfo === null) {
                  return null;
                } // console.warn('* decodeExtensions', this.supplements);
                // console.warn('* there are ', this.supplements.length, ' supplements');

                for (var i = 0; i < this.supplements.length; i++) {
                  // console.warn('* extensions loop', i, this.supplements[i], this.supplements[i]._decode);
                  try {
                    var result = this.supplements[i].decode(
                      this._row,
                      startInfo.end
                    ); // console.warn('* decode result=', result);

                    if (result !== null) {
                      return {
                        code: result.code,
                        start: start,
                        startInfo: startInfo,
                        end: result.end,
                        decodedCodes: result.decodedCodes,
                        format: this.supplements[i].FORMAT,
                      };
                    }
                  } catch (err) {
                    console.error(
                      "* decodeExtensions error in ",
                      this.supplements[i],
                      ": ",
                      err
                    );
                  }
                } // console.warn('* end decodeExtensions');

                return null;
              },
            },
            {
              key: "decode",
              value: function decode(row, start) {
                // console.warn('* decode', row);
                // console.warn('* decode', start);
                var result = new Array();
                var decodedCodes = new Array();
                var resultInfo = {};

                var startInfo = this._findStart();

                if (!startInfo) {
                  return null;
                }

                var code = {
                  start: startInfo.start,
                  end: startInfo.end,
                };
                decodedCodes.push(code);
                code = this._decodePayload(code, result, decodedCodes);

                if (!code) {
                  return null;
                }

                code = this._findEnd(code.end, false);

                if (!code) {
                  return null;
                }

                decodedCodes.push(code); // Checksum

                if (!this._checksum(result)) {
                  return null;
                } // console.warn('* this.supplements=', this.supplements);

                if (this.supplements.length > 0) {
                  var supplement = this._decodeExtensions(code.end); // console.warn('* decodeExtensions returns', supplement);

                  if (!supplement) {
                    return null;
                  }

                  if (!supplement.decodedCodes) {
                    return null;
                  }

                  var lastCode =
                    supplement.decodedCodes[supplement.decodedCodes.length - 1];
                  var endInfo = {
                    start:
                      lastCode.start +
                      (((lastCode.end - lastCode.start) / 2) | 0),
                    end: lastCode.end,
                  };

                  if (!this._verifyTrailingWhitespace(endInfo)) {
                    return null;
                  }

                  resultInfo = {
                    supplement: supplement,
                    code: result.join("") + supplement.code,
                  };
                }

                return _objectSpread(
                  _objectSpread(
                    {
                      code: result.join(""),
                      start: startInfo.start,
                      end: code.end,
                      startInfo: startInfo,
                      decodedCodes: decodedCodes,
                    },
                    resultInfo
                  ),
                  {},
                  {
                    format: this.FORMAT,
                  }
                );
              },
            },
          ]);

          return EANReader;
        })(barcode_reader);

        /* harmony default export */ var ean_reader = ean_reader_EANReader;
        // CONCATENATED MODULE: ./src/reader/ean_2_reader.ts

        function ean_2_reader_createSuper(Derived) {
          var hasNativeReflectConstruct =
            ean_2_reader_isNativeReflectConstruct();
          return function _createSuperInternal() {
            var Super = getPrototypeOf_default()(Derived),
              result;
            if (hasNativeReflectConstruct) {
              var NewTarget = getPrototypeOf_default()(this).constructor;
              result = Reflect.construct(Super, arguments, NewTarget);
            } else {
              result = Super.apply(this, arguments);
            }
            return possibleConstructorReturn_default()(this, result);
          };
        }

        function ean_2_reader_isNativeReflectConstruct() {
          if (typeof Reflect === "undefined" || !Reflect.construct)
            return false;
          if (Reflect.construct.sham) return false;
          if (typeof Proxy === "function") return true;
          try {
            Boolean.prototype.valueOf.call(
              Reflect.construct(Boolean, [], function () {})
            );
            return true;
          } catch (e) {
            return false;
          }
        }

        var ean_2_reader_EAN2Reader = /*#__PURE__*/ (function (_EANReader) {
          inherits_default()(EAN2Reader, _EANReader);

          var _super = ean_2_reader_createSuper(EAN2Reader);

          function EAN2Reader() {
            var _this;

            classCallCheck_default()(this, EAN2Reader);

            for (
              var _len = arguments.length, args = new Array(_len), _key = 0;
              _key < _len;
              _key++
            ) {
              args[_key] = arguments[_key];
            }

            _this = _super.call.apply(_super, [this].concat(args));

            defineProperty_default()(
              assertThisInitialized_default()(_this),
              "FORMAT",
              "ean_2"
            );

            return _this;
          }

          createClass_default()(EAN2Reader, [
            {
              key: "decode",
              value: function decode(row, start) {
                if (row) {
                  this._row = row;
                }

                var codeFrequency = 0;
                var offset = start;
                var end = this._row.length;
                var result = [];
                var decodedCodes = [];
                var code = null;

                if (offset === undefined) {
                  return null;
                }

                for (var i = 0; i < 2 && offset < end; i++) {
                  code = this._decodeCode(offset);

                  if (!code) {
                    return null;
                  }

                  decodedCodes.push(code);
                  result.push(code.code % 10);

                  if (code.code >= CODE_G_START) {
                    codeFrequency |= 1 << (1 - i);
                  }

                  if (i !== 1) {
                    offset = this._nextSet(this._row, code.end);
                    offset = this._nextUnset(this._row, offset);
                  }
                }

                if (
                  result.length !== 2 ||
                  parseInt(result.join("")) % 4 !== codeFrequency
                ) {
                  return null;
                }

                var startInfo = this._findStart();

                return {
                  code: result.join(""),
                  decodedCodes: decodedCodes,
                  end: code.end,
                  format: this.FORMAT,
                  startInfo: startInfo,
                  start: startInfo.start,
                };
              },
            },
          ]);

          return EAN2Reader;
        })(ean_reader);

        /* harmony default export */ var ean_2_reader = ean_2_reader_EAN2Reader;
        // CONCATENATED MODULE: ./src/reader/ean_5_reader.ts

        function ean_5_reader_createSuper(Derived) {
          var hasNativeReflectConstruct =
            ean_5_reader_isNativeReflectConstruct();
          return function _createSuperInternal() {
            var Super = getPrototypeOf_default()(Derived),
              result;
            if (hasNativeReflectConstruct) {
              var NewTarget = getPrototypeOf_default()(this).constructor;
              result = Reflect.construct(Super, arguments, NewTarget);
            } else {
              result = Super.apply(this, arguments);
            }
            return possibleConstructorReturn_default()(this, result);
          };
        }

        function ean_5_reader_isNativeReflectConstruct() {
          if (typeof Reflect === "undefined" || !Reflect.construct)
            return false;
          if (Reflect.construct.sham) return false;
          if (typeof Proxy === "function") return true;
          try {
            Boolean.prototype.valueOf.call(
              Reflect.construct(Boolean, [], function () {})
            );
            return true;
          } catch (e) {
            return false;
          }
        }

        var CHECK_DIGIT_ENCODINGS = [24, 20, 18, 17, 12, 6, 3, 10, 9, 5];

        function determineCheckDigit(codeFrequency) {
          for (var i = 0; i < 10; i++) {
            if (codeFrequency === CHECK_DIGIT_ENCODINGS[i]) {
              return i;
            }
          }

          return null;
        }

        function extensionChecksum(result) {
          var length = result.length;
          var sum = 0;

          for (var i = length - 2; i >= 0; i -= 2) {
            sum += result[i];
          }

          sum *= 3;

          for (var _i = length - 1; _i >= 0; _i -= 2) {
            sum += result[_i];
          }

          sum *= 3;
          return sum % 10;
        }

        var ean_5_reader_EAN5Reader = /*#__PURE__*/ (function (_EANReader) {
          inherits_default()(EAN5Reader, _EANReader);

          var _super = ean_5_reader_createSuper(EAN5Reader);

          function EAN5Reader() {
            var _this;

            classCallCheck_default()(this, EAN5Reader);

            for (
              var _len = arguments.length, args = new Array(_len), _key = 0;
              _key < _len;
              _key++
            ) {
              args[_key] = arguments[_key];
            }

            _this = _super.call.apply(_super, [this].concat(args));

            defineProperty_default()(
              assertThisInitialized_default()(_this),
              "FORMAT",
              "ean_5"
            );

            return _this;
          }

          createClass_default()(EAN5Reader, [
            {
              key: "decode",
              value: function decode(row, start) {
                if (start === undefined) {
                  return null;
                }

                if (row) {
                  this._row = row;
                }

                var codeFrequency = 0;
                var offset = start;
                var end = this._row.length;
                var code = null;
                var result = [];
                var decodedCodes = [];

                for (var i = 0; i < 5 && offset < end; i++) {
                  code = this._decodeCode(offset);

                  if (!code) {
                    return null;
                  }

                  decodedCodes.push(code);
                  result.push(code.code % 10);

                  if (code.code >= CODE_G_START) {
                    codeFrequency |= 1 << (4 - i);
                  }

                  if (i !== 4) {
                    offset = this._nextSet(this._row, code.end);
                    offset = this._nextUnset(this._row, offset);
                  }
                }

                if (result.length !== 5) {
                  return null;
                }

                if (
                  extensionChecksum(result) !==
                  determineCheckDigit(codeFrequency)
                ) {
                  return null;
                }

                var startInfo = this._findStart();

                return {
                  code: result.join(""),
                  decodedCodes: decodedCodes,
                  end: code.end,
                  format: this.FORMAT,
                  startInfo: startInfo,
                  start: startInfo.start,
                };
              },
            },
          ]);

          return EAN5Reader;
        })(ean_reader);

        /* harmony default export */ var ean_5_reader = ean_5_reader_EAN5Reader;
        // CONCATENATED MODULE: ./src/reader/ean_8_reader.ts

        function ean_8_reader_createSuper(Derived) {
          var hasNativeReflectConstruct =
            ean_8_reader_isNativeReflectConstruct();
          return function _createSuperInternal() {
            var Super = getPrototypeOf_default()(Derived),
              result;
            if (hasNativeReflectConstruct) {
              var NewTarget = getPrototypeOf_default()(this).constructor;
              result = Reflect.construct(Super, arguments, NewTarget);
            } else {
              result = Super.apply(this, arguments);
            }
            return possibleConstructorReturn_default()(this, result);
          };
        }

        function ean_8_reader_isNativeReflectConstruct() {
          if (typeof Reflect === "undefined" || !Reflect.construct)
            return false;
          if (Reflect.construct.sham) return false;
          if (typeof Proxy === "function") return true;
          try {
            Boolean.prototype.valueOf.call(
              Reflect.construct(Boolean, [], function () {})
            );
            return true;
          } catch (e) {
            return false;
          }
        }

        var ean_8_reader_EAN8Reader = /*#__PURE__*/ (function (_EANReader) {
          inherits_default()(EAN8Reader, _EANReader);

          var _super = ean_8_reader_createSuper(EAN8Reader);

          function EAN8Reader() {
            var _this;

            classCallCheck_default()(this, EAN8Reader);

            for (
              var _len = arguments.length, args = new Array(_len), _key = 0;
              _key < _len;
              _key++
            ) {
              args[_key] = arguments[_key];
            }

            _this = _super.call.apply(_super, [this].concat(args));

            defineProperty_default()(
              assertThisInitialized_default()(_this),
              "FORMAT",
              "ean_8"
            );

            return _this;
          }

          createClass_default()(EAN8Reader, [
            {
              key: "_decodePayload",
              value: function _decodePayload(inCode, result, decodedCodes) {
                var code = inCode;

                for (var i = 0; i < 4; i++) {
                  code = this._decodeCode(code.end, CODE_G_START);

                  if (!code) {
                    return null;
                  }

                  result.push(code.code);
                  decodedCodes.push(code);
                }

                code = this._findPattern(MIDDLE_PATTERN, code.end, true, false);

                if (code === null) {
                  return null;
                }

                decodedCodes.push(code);

                for (var _i = 0; _i < 4; _i++) {
                  code = this._decodeCode(code.end, CODE_G_START);

                  if (!code) {
                    return null;
                  }

                  decodedCodes.push(code);
                  result.push(code.code);
                }

                return code;
              },
            },
          ]);

          return EAN8Reader;
        })(ean_reader);

        /* harmony default export */ var ean_8_reader = ean_8_reader_EAN8Reader;
        // CONCATENATED MODULE: ./src/reader/i2of5_reader.ts

        function i2of5_reader_createSuper(Derived) {
          var hasNativeReflectConstruct =
            i2of5_reader_isNativeReflectConstruct();
          return function _createSuperInternal() {
            var Super = getPrototypeOf_default()(Derived),
              result;
            if (hasNativeReflectConstruct) {
              var NewTarget = getPrototypeOf_default()(this).constructor;
              result = Reflect.construct(Super, arguments, NewTarget);
            } else {
              result = Super.apply(this, arguments);
            }
            return possibleConstructorReturn_default()(this, result);
          };
        }

        function i2of5_reader_isNativeReflectConstruct() {
          if (typeof Reflect === "undefined" || !Reflect.construct)
            return false;
          if (Reflect.construct.sham) return false;
          if (typeof Proxy === "function") return true;
          try {
            Boolean.prototype.valueOf.call(
              Reflect.construct(Boolean, [], function () {})
            );
            return true;
          } catch (e) {
            return false;
          }
        }

        // TODO: i2of5_reader and 2of5_reader share very similar code, make use of that

        var i2of5_reader_N = 1;
        var i2of5_reader_W = 3;

        var i2of5_reader_I2of5Reader = /*#__PURE__*/ (function (
          _BarcodeReader
        ) {
          inherits_default()(I2of5Reader, _BarcodeReader);

          var _super = i2of5_reader_createSuper(I2of5Reader);

          function I2of5Reader(opts) {
            var _this;

            classCallCheck_default()(this, I2of5Reader);

            _this = _super.call(
              this,
              merge_default()(
                {
                  normalizeBarSpaceWidth: false,
                },
                opts
              )
            );

            defineProperty_default()(
              assertThisInitialized_default()(_this),
              "barSpaceRatio",
              [1, 1]
            );

            defineProperty_default()(
              assertThisInitialized_default()(_this),
              "SINGLE_CODE_ERROR",
              0.78
            );

            defineProperty_default()(
              assertThisInitialized_default()(_this),
              "AVG_CODE_ERROR",
              0.38
            );

            defineProperty_default()(
              assertThisInitialized_default()(_this),
              "START_PATTERN",
              [i2of5_reader_N, i2of5_reader_N, i2of5_reader_N, i2of5_reader_N]
            );

            defineProperty_default()(
              assertThisInitialized_default()(_this),
              "STOP_PATTERN",
              [i2of5_reader_N, i2of5_reader_N, i2of5_reader_W]
            );

            defineProperty_default()(
              assertThisInitialized_default()(_this),
              "CODE_PATTERN",
              [
                [
                  i2of5_reader_N,
                  i2of5_reader_N,
                  i2of5_reader_W,
                  i2of5_reader_W,
                  i2of5_reader_N,
                ],
                [
                  i2of5_reader_W,
                  i2of5_reader_N,
                  i2of5_reader_N,
                  i2of5_reader_N,
                  i2of5_reader_W,
                ],
                [
                  i2of5_reader_N,
                  i2of5_reader_W,
                  i2of5_reader_N,
                  i2of5_reader_N,
                  i2of5_reader_W,
                ],
                [
                  i2of5_reader_W,
                  i2of5_reader_W,
                  i2of5_reader_N,
                  i2of5_reader_N,
                  i2of5_reader_N,
                ],
                [
                  i2of5_reader_N,
                  i2of5_reader_N,
                  i2of5_reader_W,
                  i2of5_reader_N,
                  i2of5_reader_W,
                ],
                [
                  i2of5_reader_W,
                  i2of5_reader_N,
                  i2of5_reader_W,
                  i2of5_reader_N,
                  i2of5_reader_N,
                ],
                [
                  i2of5_reader_N,
                  i2of5_reader_W,
                  i2of5_reader_W,
                  i2of5_reader_N,
                  i2of5_reader_N,
                ],
                [
                  i2of5_reader_N,
                  i2of5_reader_N,
                  i2of5_reader_N,
                  i2of5_reader_W,
                  i2of5_reader_W,
                ],
                [
                  i2of5_reader_W,
                  i2of5_reader_N,
                  i2of5_reader_N,
                  i2of5_reader_W,
                  i2of5_reader_N,
                ],
                [
                  i2of5_reader_N,
                  i2of5_reader_W,
                  i2of5_reader_N,
                  i2of5_reader_W,
                  i2of5_reader_N,
                ],
              ]
            );

            defineProperty_default()(
              assertThisInitialized_default()(_this),
              "MAX_CORRECTION_FACTOR",
              5
            );

            defineProperty_default()(
              assertThisInitialized_default()(_this),
              "FORMAT",
              "i2of5"
            );

            if (opts.normalizeBarSpaceWidth) {
              _this.SINGLE_CODE_ERROR = 0.38;
              _this.AVG_CODE_ERROR = 0.09;
            }

            _this.config = opts;
            return possibleConstructorReturn_default()(
              _this,
              assertThisInitialized_default()(_this)
            );
          }

          createClass_default()(I2of5Reader, [
            {
              key: "_matchPattern",
              value: function _matchPattern(counter, code) {
                if (this.config.normalizeBarSpaceWidth) {
                  var counterSum = [0, 0];
                  var codeSum = [0, 0];
                  var correction = [0, 0];
                  var correctionRatio = this.MAX_CORRECTION_FACTOR;
                  var correctionRatioInverse = 1 / correctionRatio;

                  for (var i = 0; i < counter.length; i++) {
                    counterSum[i % 2] += counter[i];
                    codeSum[i % 2] += code[i];
                  }

                  correction[0] = codeSum[0] / counterSum[0];
                  correction[1] = codeSum[1] / counterSum[1];
                  correction[0] = Math.max(
                    Math.min(correction[0], correctionRatio),
                    correctionRatioInverse
                  );
                  correction[1] = Math.max(
                    Math.min(correction[1], correctionRatio),
                    correctionRatioInverse
                  );
                  this.barSpaceRatio = correction;

                  for (var _i = 0; _i < counter.length; _i++) {
                    counter[_i] *= this.barSpaceRatio[_i % 2];
                  }
                }

                return get_default()(
                  getPrototypeOf_default()(I2of5Reader.prototype),
                  "_matchPattern",
                  this
                ).call(this, counter, code);
              },
            },
            {
              key: "_findPattern",
              value: function _findPattern(pattern, offset) {
                var isWhite =
                  arguments.length > 2 && arguments[2] !== undefined
                    ? arguments[2]
                    : false;
                var tryHarder =
                  arguments.length > 3 && arguments[3] !== undefined
                    ? arguments[3]
                    : false;
                var counter = new Array(pattern.length).fill(0);
                var counterPos = 0;
                var bestMatch = {
                  error: Number.MAX_VALUE,
                  start: 0,
                  end: 0,
                };
                var epsilon = this.AVG_CODE_ERROR;
                isWhite = isWhite || false;
                tryHarder = tryHarder || false;

                if (!offset) {
                  offset = this._nextSet(this._row);
                }

                for (var i = offset; i < this._row.length; i++) {
                  if (this._row[i] ^ (isWhite ? 1 : 0)) {
                    counter[counterPos]++;
                  } else {
                    if (counterPos === counter.length - 1) {
                      var sum = counter.reduce(function (prev, next) {
                        return prev + next;
                      }, 0);

                      var error = this._matchPattern(counter, pattern);

                      if (error < epsilon) {
                        bestMatch.error = error;
                        bestMatch.start = i - sum;
                        bestMatch.end = i;
                        return bestMatch;
                      }

                      if (tryHarder) {
                        for (var j = 0; j < counter.length - 2; j++) {
                          counter[j] = counter[j + 2];
                        }

                        counter[counter.length - 2] = 0;
                        counter[counter.length - 1] = 0;
                        counterPos--;
                      } else {
                        return null;
                      }
                    } else {
                      counterPos++;
                    }

                    counter[counterPos] = 1;
                    isWhite = !isWhite;
                  }
                }

                return null;
              },
            },
            {
              key: "_findStart",
              value: function _findStart() {
                var leadingWhitespaceStart = 0;

                var offset = this._nextSet(this._row);

                var startInfo = null;
                var narrowBarWidth = 1;

                while (!startInfo) {
                  startInfo = this._findPattern(
                    this.START_PATTERN,
                    offset,
                    false,
                    true
                  );

                  if (!startInfo) {
                    return null;
                  }

                  narrowBarWidth = Math.floor(
                    (startInfo.end - startInfo.start) / 4
                  );
                  leadingWhitespaceStart =
                    startInfo.start - narrowBarWidth * 10;

                  if (leadingWhitespaceStart >= 0) {
                    if (
                      this._matchRange(
                        leadingWhitespaceStart,
                        startInfo.start,
                        0
                      )
                    ) {
                      return startInfo;
                    }
                  }

                  offset = startInfo.end;
                  startInfo = null;
                }

                return null;
              },
            },
            {
              key: "_verifyTrailingWhitespace",
              value: function _verifyTrailingWhitespace(endInfo) {
                var trailingWhitespaceEnd =
                  endInfo.end + (endInfo.end - endInfo.start) / 2;

                if (trailingWhitespaceEnd < this._row.length) {
                  if (this._matchRange(endInfo.end, trailingWhitespaceEnd, 0)) {
                    return endInfo;
                  }
                }

                return null;
              },
            },
            {
              key: "_findEnd",
              value: function _findEnd() {
                this._row.reverse();

                var endInfo = this._findPattern(this.STOP_PATTERN);

                this._row.reverse();

                if (endInfo === null) {
                  return null;
                } // reverse numbers

                var tmp = endInfo.start;
                endInfo.start = this._row.length - endInfo.end;
                endInfo.end = this._row.length - tmp;
                return endInfo !== null
                  ? this._verifyTrailingWhitespace(endInfo)
                  : null;
              },
            },
            {
              key: "_decodePair",
              value: function _decodePair(counterPair) {
                var codes = [];

                for (var i = 0; i < counterPair.length; i++) {
                  var code = this._decodeCode(counterPair[i]);

                  if (!code) {
                    return null;
                  }

                  codes.push(code);
                }

                return codes;
              },
            },
            {
              key: "_decodeCode",
              value: function _decodeCode(counter) {
                var epsilon = this.AVG_CODE_ERROR;
                var bestMatch = {
                  error: Number.MAX_VALUE,
                  code: -1,
                  start: 0,
                  end: 0,
                };

                for (var code = 0; code < this.CODE_PATTERN.length; code++) {
                  var error = this._matchPattern(
                    counter,
                    this.CODE_PATTERN[code]
                  );

                  if (error < bestMatch.error) {
                    bestMatch.code = code;
                    bestMatch.error = error;
                  }
                }

                if (bestMatch.error < epsilon) {
                  return bestMatch;
                }

                return null;
              },
            },
            {
              key: "_decodePayload",
              value: function _decodePayload(counters, result, decodedCodes) {
                var pos = 0;
                var counterLength = counters.length;
                var counterPair = [
                  [0, 0, 0, 0, 0],
                  [0, 0, 0, 0, 0],
                ];
                var codes = null;

                while (pos < counterLength) {
                  for (var i = 0; i < 5; i++) {
                    counterPair[0][i] = counters[pos] * this.barSpaceRatio[0];
                    counterPair[1][i] =
                      counters[pos + 1] * this.barSpaceRatio[1];
                    pos += 2;
                  }

                  codes = this._decodePair(counterPair);

                  if (!codes) {
                    return null;
                  }

                  for (var _i2 = 0; _i2 < codes.length; _i2++) {
                    result.push(codes[_i2].code + "");
                    decodedCodes.push(codes[_i2]);
                  }
                }

                return codes;
              },
            },
            {
              key: "_verifyCounterLength",
              value: function _verifyCounterLength(counters) {
                return counters.length % 10 === 0;
              },
            },
            {
              key: "decode",
              value: function decode(row, start) {
                var result = new Array();
                var decodedCodes = new Array();

                var startInfo = this._findStart();

                if (!startInfo) {
                  return null;
                }

                decodedCodes.push(startInfo);

                var endInfo = this._findEnd();

                if (!endInfo) {
                  return null;
                }

                var counters = this._fillCounters(
                  startInfo.end,
                  endInfo.start,
                  false
                );

                if (!this._verifyCounterLength(counters)) {
                  return null;
                }

                var code = this._decodePayload(counters, result, decodedCodes);

                if (!code) {
                  return null;
                }

                if (result.length % 2 !== 0 || result.length < 6) {
                  return null;
                }

                decodedCodes.push(endInfo);
                return {
                  code: result.join(""),
                  start: startInfo.start,
                  end: endInfo.end,
                  startInfo: startInfo,
                  decodedCodes: decodedCodes,
                  format: this.FORMAT,
                };
              },
            },
          ]);

          return I2of5Reader;
        })(barcode_reader);

        /* harmony default export */ var i2of5_reader =
          i2of5_reader_I2of5Reader;
        // CONCATENATED MODULE: ./src/reader/upc_e_reader.ts

        function upc_e_reader_ownKeys(object, enumerableOnly) {
          var keys = Object.keys(object);
          if (Object.getOwnPropertySymbols) {
            var symbols = Object.getOwnPropertySymbols(object);
            enumerableOnly &&
              (symbols = symbols.filter(function (sym) {
                return Object.getOwnPropertyDescriptor(object, sym).enumerable;
              })),
              keys.push.apply(keys, symbols);
          }
          return keys;
        }

        function upc_e_reader_objectSpread(target) {
          for (var i = 1; i < arguments.length; i++) {
            var source = null != arguments[i] ? arguments[i] : {};
            i % 2
              ? upc_e_reader_ownKeys(Object(source), !0).forEach(function (
                  key
                ) {
                  defineProperty_default()(target, key, source[key]);
                })
              : Object.getOwnPropertyDescriptors
              ? Object.defineProperties(
                  target,
                  Object.getOwnPropertyDescriptors(source)
                )
              : upc_e_reader_ownKeys(Object(source)).forEach(function (key) {
                  Object.defineProperty(
                    target,
                    key,
                    Object.getOwnPropertyDescriptor(source, key)
                  );
                });
          }
          return target;
        }

        function upc_e_reader_createSuper(Derived) {
          var hasNativeReflectConstruct =
            upc_e_reader_isNativeReflectConstruct();
          return function _createSuperInternal() {
            var Super = getPrototypeOf_default()(Derived),
              result;
            if (hasNativeReflectConstruct) {
              var NewTarget = getPrototypeOf_default()(this).constructor;
              result = Reflect.construct(Super, arguments, NewTarget);
            } else {
              result = Super.apply(this, arguments);
            }
            return possibleConstructorReturn_default()(this, result);
          };
        }

        function upc_e_reader_isNativeReflectConstruct() {
          if (typeof Reflect === "undefined" || !Reflect.construct)
            return false;
          if (Reflect.construct.sham) return false;
          if (typeof Proxy === "function") return true;
          try {
            Boolean.prototype.valueOf.call(
              Reflect.construct(Boolean, [], function () {})
            );
            return true;
          } catch (e) {
            return false;
          }
        }

        var upc_e_reader_UPCEReader = /*#__PURE__*/ (function (_EANReader) {
          inherits_default()(UPCEReader, _EANReader);

          var _super = upc_e_reader_createSuper(UPCEReader);

          function UPCEReader() {
            var _this;

            classCallCheck_default()(this, UPCEReader);

            for (
              var _len = arguments.length, args = new Array(_len), _key = 0;
              _key < _len;
              _key++
            ) {
              args[_key] = arguments[_key];
            }

            _this = _super.call.apply(_super, [this].concat(args));

            defineProperty_default()(
              assertThisInitialized_default()(_this),
              "CODE_FREQUENCY",
              [
                [56, 52, 50, 49, 44, 38, 35, 42, 41, 37],
                [7, 11, 13, 14, 19, 25, 28, 21, 22, 26],
              ]
            );

            defineProperty_default()(
              assertThisInitialized_default()(_this),
              "STOP_PATTERN",
              [
                (1 / 6) * 7,
                (1 / 6) * 7,
                (1 / 6) * 7,
                (1 / 6) * 7,
                (1 / 6) * 7,
                (1 / 6) * 7,
              ]
            );

            defineProperty_default()(
              assertThisInitialized_default()(_this),
              "FORMAT",
              "upc_e"
            );

            return _this;
          }

          createClass_default()(UPCEReader, [
            {
              key: "_decodePayload",
              value: function _decodePayload(inCode, result, decodedCodes) {
                var outCode = upc_e_reader_objectSpread({}, inCode);

                var codeFrequency = 0x0;

                for (var i = 0; i < 6; i++) {
                  outCode = this._decodeCode(outCode.end);

                  if (!outCode) {
                    return null;
                  }

                  if (outCode.code >= CODE_G_START) {
                    outCode.code = outCode.code - CODE_G_START;
                    codeFrequency |= 1 << (5 - i);
                  }

                  result.push(outCode.code);
                  decodedCodes.push(outCode);
                }

                if (!this._determineParity(codeFrequency, result)) {
                  return null;
                }

                return outCode;
              },
            },
            {
              key: "_determineParity",
              value: function _determineParity(codeFrequency, result) {
                for (
                  var nrSystem = 0;
                  nrSystem < this.CODE_FREQUENCY.length;
                  nrSystem++
                ) {
                  for (
                    var i = 0;
                    i < this.CODE_FREQUENCY[nrSystem].length;
                    i++
                  ) {
                    if (codeFrequency === this.CODE_FREQUENCY[nrSystem][i]) {
                      result.unshift(nrSystem);
                      result.push(i);
                      return true;
                    }
                  }
                }

                return false;
              },
            },
            {
              key: "_convertToUPCA",
              value: function _convertToUPCA(result) {
                var upca = [result[0]];
                var lastDigit = result[result.length - 2];

                if (lastDigit <= 2) {
                  upca = upca
                    .concat(result.slice(1, 3))
                    .concat([lastDigit, 0, 0, 0, 0])
                    .concat(result.slice(3, 6));
                } else if (lastDigit === 3) {
                  upca = upca
                    .concat(result.slice(1, 4))
                    .concat([0, 0, 0, 0, 0])
                    .concat(result.slice(4, 6));
                } else if (lastDigit === 4) {
                  upca = upca
                    .concat(result.slice(1, 5))
                    .concat([0, 0, 0, 0, 0, result[5]]);
                } else {
                  upca = upca
                    .concat(result.slice(1, 6))
                    .concat([0, 0, 0, 0, lastDigit]);
                }

                upca.push(result[result.length - 1]);
                return upca;
              },
            },
            {
              key: "_checksum",
              value: function _checksum(result) {
                return get_default()(
                  getPrototypeOf_default()(UPCEReader.prototype),
                  "_checksum",
                  this
                ).call(this, this._convertToUPCA(result));
              },
            },
            {
              key: "_findEnd",
              value: function _findEnd(offset, isWhite) {
                return get_default()(
                  getPrototypeOf_default()(UPCEReader.prototype),
                  "_findEnd",
                  this
                ).call(this, offset, true);
              },
            },
            {
              key: "_verifyTrailingWhitespace",
              value: function _verifyTrailingWhitespace(endInfo) {
                var trailingWhitespaceEnd =
                  endInfo.end + (endInfo.end - endInfo.start) / 2;

                if (trailingWhitespaceEnd < this._row.length) {
                  if (this._matchRange(endInfo.end, trailingWhitespaceEnd, 0)) {
                    return endInfo;
                  }
                }

                return null;
              },
            },
          ]);

          return UPCEReader;
        })(ean_reader);

        /* harmony default export */ var upc_e_reader = upc_e_reader_UPCEReader;
        // CONCATENATED MODULE: ./src/reader/upc_reader.ts

        function upc_reader_createSuper(Derived) {
          var hasNativeReflectConstruct = upc_reader_isNativeReflectConstruct();
          return function _createSuperInternal() {
            var Super = getPrototypeOf_default()(Derived),
              result;
            if (hasNativeReflectConstruct) {
              var NewTarget = getPrototypeOf_default()(this).constructor;
              result = Reflect.construct(Super, arguments, NewTarget);
            } else {
              result = Super.apply(this, arguments);
            }
            return possibleConstructorReturn_default()(this, result);
          };
        }

        function upc_reader_isNativeReflectConstruct() {
          if (typeof Reflect === "undefined" || !Reflect.construct)
            return false;
          if (Reflect.construct.sham) return false;
          if (typeof Proxy === "function") return true;
          try {
            Boolean.prototype.valueOf.call(
              Reflect.construct(Boolean, [], function () {})
            );
            return true;
          } catch (e) {
            return false;
          }
        }

        var upc_reader_UPCReader = /*#__PURE__*/ (function (_EANReader) {
          inherits_default()(UPCReader, _EANReader);

          var _super = upc_reader_createSuper(UPCReader);

          function UPCReader() {
            var _this;

            classCallCheck_default()(this, UPCReader);

            for (
              var _len = arguments.length, args = new Array(_len), _key = 0;
              _key < _len;
              _key++
            ) {
              args[_key] = arguments[_key];
            }

            _this = _super.call.apply(_super, [this].concat(args));

            defineProperty_default()(
              assertThisInitialized_default()(_this),
              "FORMAT",
              "upc_a"
            );

            return _this;
          }

          createClass_default()(UPCReader, [
            {
              key: "decode",
              value: function decode(row, start) {
                var result = ean_reader.prototype.decode.call(this);

                if (
                  result &&
                  result.code &&
                  result.code.length === 13 &&
                  result.code.charAt(0) === "0"
                ) {
                  result.code = result.code.substring(1);
                  return result;
                }

                return null;
              },
            },
          ]);

          return UPCReader;
        })(ean_reader);

        /* harmony default export */ var upc_reader = upc_reader_UPCReader;
        // CONCATENATED MODULE: ./src/decoder/bresenham.js
        var Bresenham = {};
        var Slope = {
          DIR: {
            UP: 1,
            DOWN: -1,
          },
        };
        /**
         * Scans a line of the given image from point p1 to p2 and returns a result object containing
         * gray-scale values (0-255) of the underlying pixels in addition to the min
         * and max values.
         * @param {Object} imageWrapper
         * @param {Object} p1 The start point {x,y}
         * @param {Object} p2 The end point {x,y}
         * @returns {line, min, max}
         */

        Bresenham.getBarcodeLine = function (imageWrapper, p1, p2) {
          /* eslint-disable no-bitwise */
          var x0 = p1.x | 0;
          var y0 = p1.y | 0;
          var x1 = p2.x | 0;
          var y1 = p2.y | 0;
          /* eslint-disable no-bitwise */

          var steep = Math.abs(y1 - y0) > Math.abs(x1 - x0);
          var error;
          var y;
          var tmp;
          var x;
          var line = [];
          var imageData = imageWrapper.data;
          var width = imageWrapper.size.x;
          var val;
          var min = 255;
          var max = 0;

          function read(a, b) {
            val = imageData[b * width + a];
            min = val < min ? val : min;
            max = val > max ? val : max;
            line.push(val);
          }

          if (steep) {
            tmp = x0;
            x0 = y0;
            y0 = tmp;
            tmp = x1;
            x1 = y1;
            y1 = tmp;
          }

          if (x0 > x1) {
            tmp = x0;
            x0 = x1;
            x1 = tmp;
            tmp = y0;
            y0 = y1;
            y1 = tmp;
          }

          var deltaX = x1 - x0;
          var deltaY = Math.abs(y1 - y0);
          error = (deltaX / 2) | 0;
          y = y0;
          var yStep = y0 < y1 ? 1 : -1;

          for (x = x0; x < x1; x++) {
            if (steep) {
              read(y, x);
            } else {
              read(x, y);
            }

            error -= deltaY;

            if (error < 0) {
              y += yStep;
              error += deltaX;
            }
          }

          return {
            line: line,
            min: min,
            max: max,
          };
        };
        /**
         * Converts the result from getBarcodeLine into a binary representation
         * also considering the frequency and slope of the signal for more robust results
         * @param {Object} result {line, min, max}
         */

        Bresenham.toBinaryLine = function (result) {
          var min = result.min;
          var max = result.max;
          var line = result.line;
          var slope;
          var slope2;
          var center = min + (max - min) / 2;
          var extrema = [];
          var currentDir;
          var dir;
          var threshold = (max - min) / 12;
          var rThreshold = -threshold;
          var i;
          var j; // 1. find extrema

          currentDir = line[0] > center ? Slope.DIR.UP : Slope.DIR.DOWN;
          extrema.push({
            pos: 0,
            val: line[0],
          });

          for (i = 0; i < line.length - 2; i++) {
            slope = line[i + 1] - line[i];
            slope2 = line[i + 2] - line[i + 1];

            if (slope + slope2 < rThreshold && line[i + 1] < center * 1.5) {
              dir = Slope.DIR.DOWN;
            } else if (
              slope + slope2 > threshold &&
              line[i + 1] > center * 0.5
            ) {
              dir = Slope.DIR.UP;
            } else {
              dir = currentDir;
            }

            if (currentDir !== dir) {
              extrema.push({
                pos: i,
                val: line[i],
              });
              currentDir = dir;
            }
          }

          extrema.push({
            pos: line.length,
            val: line[line.length - 1],
          });

          for (j = extrema[0].pos; j < extrema[1].pos; j++) {
            line[j] = line[j] > center ? 0 : 1;
          } // iterate over extrema and convert to binary based on avg between minmax

          for (i = 1; i < extrema.length - 1; i++) {
            if (extrema[i + 1].val > extrema[i].val) {
              threshold =
                (extrema[i].val +
                  ((extrema[i + 1].val - extrema[i].val) / 3) * 2) |
                0;
            } else {
              threshold =
                (extrema[i + 1].val +
                  (extrema[i].val - extrema[i + 1].val) / 3) |
                0;
            }

            for (j = extrema[i].pos; j < extrema[i + 1].pos; j++) {
              line[j] = line[j] > threshold ? 0 : 1;
            }
          }

          return {
            line: line,
            threshold: threshold,
          };
        };
        /**
         * Used for development only
         */

        Bresenham.debug = {
          printFrequency: function printFrequency(line, canvas) {
            var i;
            var ctx = canvas.getContext("2d"); // eslint-disable-next-line no-param-reassign

            canvas.width = line.length; // eslint-disable-next-line no-param-reassign

            canvas.height = 256;
            ctx.beginPath();
            ctx.strokeStyle = "blue";

            for (i = 0; i < line.length; i++) {
              ctx.moveTo(i, 255);
              ctx.lineTo(i, 255 - line[i]);
            }

            ctx.stroke();
            ctx.closePath();
          },
          printPattern: function printPattern(line, canvas) {
            var ctx = canvas.getContext("2d");
            var i; // eslint-disable-next-line no-param-reassign

            canvas.width = line.length;
            ctx.fillColor = "black";

            for (i = 0; i < line.length; i++) {
              if (line[i] === 1) {
                ctx.fillRect(i, 0, 1, 100);
              }
            }
          },
        };
        /* harmony default export */ var bresenham = Bresenham;
        // CONCATENATED MODULE: ./src/decoder/barcode_decoder.js

        function _createForOfIteratorHelper(o, allowArrayLike) {
          var it =
            (typeof Symbol !== "undefined" && o[Symbol.iterator]) ||
            o["@@iterator"];
          if (!it) {
            if (
              Array.isArray(o) ||
              (it = _unsupportedIterableToArray(o)) ||
              (allowArrayLike && o && typeof o.length === "number")
            ) {
              if (it) o = it;
              var i = 0;
              var F = function F() {};
              return {
                s: F,
                n: function n() {
                  if (i >= o.length) return { done: true };
                  return { done: false, value: o[i++] };
                },
                e: function e(_e) {
                  throw _e;
                },
                f: F,
              };
            }
            throw new TypeError(
              "Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."
            );
          }
          var normalCompletion = true,
            didErr = false,
            err;
          return {
            s: function s() {
              it = it.call(o);
            },
            n: function n() {
              var step = it.next();
              normalCompletion = step.done;
              return step;
            },
            e: function e(_e2) {
              didErr = true;
              err = _e2;
            },
            f: function f() {
              try {
                if (!normalCompletion && it["return"] != null) it["return"]();
              } finally {
                if (didErr) throw err;
              }
            },
          };
        }

        function _unsupportedIterableToArray(o, minLen) {
          if (!o) return;
          if (typeof o === "string") return _arrayLikeToArray(o, minLen);
          var n = Object.prototype.toString.call(o).slice(8, -1);
          if (n === "Object" && o.constructor) n = o.constructor.name;
          if (n === "Map" || n === "Set") return Array.from(o);
          if (
            n === "Arguments" ||
            /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)
          )
            return _arrayLikeToArray(o, minLen);
        }

        function _arrayLikeToArray(arr, len) {
          if (len == null || len > arr.length) len = arr.length;
          for (var i = 0, arr2 = new Array(len); i < len; i++) {
            arr2[i] = arr[i];
          }
          return arr2;
        }

        /* eslint-disable import/no-cycle */

        var READERS = {
          code_128_reader: code_128_reader,
          ean_reader: ean_reader,
          ean_5_reader: ean_5_reader,
          ean_2_reader: ean_2_reader,
          ean_8_reader: ean_8_reader,
          code_39_reader: code_39_reader,
          code_39_vin_reader: code_39_vin_reader,
          codabar_reader: codabar_reader,
          upc_reader: upc_reader,
          upc_e_reader: upc_e_reader,
          i2of5_reader: i2of5_reader,
          "2of5_reader": _2of5_reader,
          code_93_reader: code_93_reader,
          code_32_reader: code_32_reader,
        };
        /* harmony default export */ var barcode_decoder = {
          registerReader: function registerReader(name, reader) {
            READERS[name] = reader;
          },
          create: function create(config, inputImageWrapper) {
            var _canvas = {
              ctx: {
                frequency: null,
                pattern: null,
                overlay: null,
              },
              dom: {
                frequency: null,
                pattern: null,
                overlay: null,
              },
            };
            var _barcodeReaders = [];
            initCanvas();
            initReaders();
            initConfig();

            function initCanvas() {
              if (true && typeof document !== "undefined") {
                var $debug = document.querySelector("#debug.detection");
                _canvas.dom.frequency =
                  document.querySelector("canvas.frequency");

                if (!_canvas.dom.frequency) {
                  _canvas.dom.frequency = document.createElement("canvas");
                  _canvas.dom.frequency.className = "frequency";

                  if ($debug) {
                    $debug.appendChild(_canvas.dom.frequency);
                  }
                }

                _canvas.ctx.frequency = _canvas.dom.frequency.getContext("2d");
                _canvas.dom.pattern = document.querySelector(
                  "canvas.patternBuffer"
                );

                if (!_canvas.dom.pattern) {
                  _canvas.dom.pattern = document.createElement("canvas");
                  _canvas.dom.pattern.className = "patternBuffer";

                  if ($debug) {
                    $debug.appendChild(_canvas.dom.pattern);
                  }
                }

                _canvas.ctx.pattern = _canvas.dom.pattern.getContext("2d");
                _canvas.dom.overlay = document.querySelector(
                  "canvas.drawingBuffer"
                );

                if (_canvas.dom.overlay) {
                  _canvas.ctx.overlay = _canvas.dom.overlay.getContext("2d");
                }
              }
            }

            function initReaders() {
              config.readers.forEach(function (readerConfig) {
                var reader;
                var configuration = {};
                var supplements = [];

                if (typeof_default()(readerConfig) === "object") {
                  reader = readerConfig.format;
                  configuration = readerConfig.config;
                } else if (typeof readerConfig === "string") {
                  reader = readerConfig;
                }

                if (true) {
                  console.log("Before registering reader: ", reader);
                }

                if (configuration.supplements) {
                  supplements = configuration.supplements.map(function (
                    supplement
                  ) {
                    return new READERS[supplement]();
                  });
                }

                try {
                  var readerObj = new READERS[reader](
                    configuration,
                    supplements
                  );

                  _barcodeReaders.push(readerObj);
                } catch (err) {
                  console.error("* Error constructing reader ", reader, err);
                  throw err;
                }
              });

              if (true) {
                console.log(
                  "Registered Readers: ".concat(
                    _barcodeReaders
                      .map(function (reader) {
                        return JSON.stringify({
                          format: reader.FORMAT,
                          config: reader.config,
                        });
                      })
                      .join(", ")
                  )
                );
              }
            }

            function initConfig() {
              if (true && typeof document !== "undefined") {
                var i;
                var vis = [
                  {
                    node: _canvas.dom.frequency,
                    prop: config.debug.showFrequency,
                  },
                  {
                    node: _canvas.dom.pattern,
                    prop: config.debug.showPattern,
                  },
                ];

                for (i = 0; i < vis.length; i++) {
                  if (vis[i].prop === true) {
                    vis[i].node.style.display = "block";
                  } else {
                    vis[i].node.style.display = "none";
                  }
                }
              }
            }
            /**
             * extend the line on both ends
             * @param {Array} line
             * @param {Number} angle
             */

            function getExtendedLine(line, angle, ext) {
              function extendLine(amount) {
                var extension = {
                  y: amount * Math.sin(angle),
                  x: amount * Math.cos(angle),
                };
                /* eslint-disable no-param-reassign */

                line[0].y -= extension.y;
                line[0].x -= extension.x;
                line[1].y += extension.y;
                line[1].x += extension.x;
                /* eslint-enable no-param-reassign */
              } // check if inside image

              extendLine(ext);

              while (
                ext > 1 &&
                (!inputImageWrapper.inImageWithBorder(line[0]) ||
                  !inputImageWrapper.inImageWithBorder(line[1]))
              ) {
                // eslint-disable-next-line no-param-reassign
                ext -= Math.ceil(ext / 2);
                extendLine(-ext);
              }

              return line;
            }

            function getLine(box) {
              return [
                {
                  x: (box[1][0] - box[0][0]) / 2 + box[0][0],
                  y: (box[1][1] - box[0][1]) / 2 + box[0][1],
                },
                {
                  x: (box[3][0] - box[2][0]) / 2 + box[2][0],
                  y: (box[3][1] - box[2][1]) / 2 + box[2][1],
                },
              ];
            }

            function tryDecode(line) {
              var result = null;
              var i;
              var barcodeLine = bresenham.getBarcodeLine(
                inputImageWrapper,
                line[0],
                line[1]
              );

              if (true && config.debug.showFrequency) {
                image_debug["a" /* default */].drawPath(
                  line,
                  {
                    x: "x",
                    y: "y",
                  },
                  _canvas.ctx.overlay,
                  {
                    color: "red",
                    lineWidth: 3,
                  }
                );
                bresenham.debug.printFrequency(
                  barcodeLine.line,
                  _canvas.dom.frequency
                );
              }

              bresenham.toBinaryLine(barcodeLine);

              if (true && config.debug.showPattern) {
                bresenham.debug.printPattern(
                  barcodeLine.line,
                  _canvas.dom.pattern
                );
              }

              for (i = 0; i < _barcodeReaders.length && result === null; i++) {
                result = _barcodeReaders[i].decodePattern(barcodeLine.line);
              }

              if (result === null) {
                return null;
              }

              return {
                codeResult: result,
                barcodeLine: barcodeLine,
              };
            }
            /**
             * This method slices the given area apart and tries to detect a barcode-pattern
             * for each slice. It returns the decoded barcode, or null if nothing was found
             * @param {Array} box
             * @param {Array} line
             * @param {Number} lineAngle
             */

            function tryDecodeBruteForce(box, line, lineAngle) {
              var sideLength = Math.sqrt(
                Math.pow(box[1][0] - box[0][0], 2) +
                  Math.pow(box[1][1] - box[0][1], 2)
              );
              var i;
              var slices = 16;
              var result = null;
              var dir;
              var extension;
              var xdir = Math.sin(lineAngle);
              var ydir = Math.cos(lineAngle);

              for (i = 1; i < slices && result === null; i++) {
                // move line perpendicular to angle
                // eslint-disable-next-line no-mixed-operators
                dir = (sideLength / slices) * i * (i % 2 === 0 ? -1 : 1);
                extension = {
                  y: dir * xdir,
                  x: dir * ydir,
                };
                /* eslint-disable no-param-reassign */

                line[0].y += extension.x;
                line[0].x -= extension.y;
                line[1].y += extension.x;
                line[1].x -= extension.y;
                /* eslint-enable no-param-reassign */

                result = tryDecode(line);
              }

              return result;
            }

            function getLineLength(line) {
              return Math.sqrt(
                Math.pow(Math.abs(line[1].y - line[0].y), 2) +
                  Math.pow(Math.abs(line[1].x - line[0].x), 2)
              );
            }

            function _decodeFromImage2(_x) {
              return _decodeFromImage.apply(this, arguments);
            }
            /**
             * With the help of the configured readers (Code128 or EAN) this function tries to detect a
             * valid barcode pattern within the given area.
             * @param {Object} box The area to search in
             * @returns {Object} the result {codeResult, line, angle, pattern, threshold}
             */

            function _decodeFromImage() {
              _decodeFromImage = asyncToGenerator_default()(
                /*#__PURE__*/ regenerator_default.a.mark(function _callee2(
                  imageWrapper
                ) {
                  var result, _iterator, _step, reader;

                  return regenerator_default.a.wrap(
                    function _callee2$(_context2) {
                      while (1) {
                        switch ((_context2.prev = _context2.next)) {
                          case 0:
                            result = null;
                            _iterator =
                              _createForOfIteratorHelper(_barcodeReaders);
                            _context2.prev = 2;

                            _iterator.s();

                          case 4:
                            if ((_step = _iterator.n()).done) {
                              _context2.next = 14;
                              break;
                            }

                            reader = _step.value;

                            if (!reader.decodeImage) {
                              _context2.next = 12;
                              break;
                            }

                            _context2.next = 9;
                            return reader.decodeImage(imageWrapper);

                          case 9:
                            result = _context2.sent;

                            if (!result) {
                              _context2.next = 12;
                              break;
                            }

                            return _context2.abrupt("break", 14);

                          case 12:
                            _context2.next = 4;
                            break;

                          case 14:
                            _context2.next = 19;
                            break;

                          case 16:
                            _context2.prev = 16;
                            _context2.t0 = _context2["catch"](2);

                            _iterator.e(_context2.t0);

                          case 19:
                            _context2.prev = 19;

                            _iterator.f();

                            return _context2.finish(19);

                          case 22:
                            return _context2.abrupt("return", result);

                          case 23:
                          case "end":
                            return _context2.stop();
                        }
                      }
                    },
                    _callee2,
                    null,
                    [[2, 16, 19, 22]]
                  );
                })
              );
              return _decodeFromImage.apply(this, arguments);
            }

            function _decodeFromBoundingBox(box) {
              var line;
              var ctx = _canvas.ctx.overlay;
              var result;

              if (true) {
                if (config.debug.drawBoundingBox && ctx) {
                  image_debug["a" /* default */].drawPath(
                    box,
                    {
                      x: 0,
                      y: 1,
                    },
                    ctx,
                    {
                      color: "blue",
                      lineWidth: 2,
                    }
                  );
                }
              }

              line = getLine(box);
              var lineLength = getLineLength(line);
              var lineAngle = Math.atan2(
                line[1].y - line[0].y,
                line[1].x - line[0].x
              );
              line = getExtendedLine(
                line,
                lineAngle,
                Math.floor(lineLength * 0.1)
              );

              if (line === null) {
                return null;
              }

              result = tryDecode(line);

              if (result === null) {
                result = tryDecodeBruteForce(box, line, lineAngle);
              }

              if (result === null) {
                return null;
              }

              if (true && result && config.debug.drawScanline && ctx) {
                image_debug["a" /* default */].drawPath(
                  line,
                  {
                    x: "x",
                    y: "y",
                  },
                  ctx,
                  {
                    color: "red",
                    lineWidth: 3,
                  }
                );
              }

              return {
                codeResult: result.codeResult,
                line: line,
                angle: lineAngle,
                pattern: result.barcodeLine.line,
                threshold: result.barcodeLine.threshold,
              };
            }

            return {
              decodeFromBoundingBox: function decodeFromBoundingBox(box) {
                return _decodeFromBoundingBox(box);
              },
              decodeFromBoundingBoxes: function decodeFromBoundingBoxes(boxes) {
                var i;
                var result;
                var barcodes = [];
                var multiple = config.multiple;

                for (i = 0; i < boxes.length; i++) {
                  var box = boxes[i];
                  result = _decodeFromBoundingBox(box) || {};
                  result.box = box;

                  if (multiple) {
                    barcodes.push(result);
                  } else if (result.codeResult) {
                    return result;
                  }
                }

                return {
                  barcodes: barcodes,
                };
              },
              decodeFromImage: function decodeFromImage(imageWrapperIn) {
                return asyncToGenerator_default()(
                  /*#__PURE__*/ regenerator_default.a.mark(function _callee() {
                    var result;
                    return regenerator_default.a.wrap(function _callee$(
                      _context
                    ) {
                      while (1) {
                        switch ((_context.prev = _context.next)) {
                          case 0:
                            _context.next = 2;
                            return _decodeFromImage2(imageWrapperIn);

                          case 2:
                            result = _context.sent;
                            return _context.abrupt("return", result);

                          case 4:
                          case "end":
                            return _context.stop();
                        }
                      }
                    },
                    _callee);
                  })
                )();
              },
              registerReader: function registerReader(name, reader) {
                if (READERS[name]) {
                  throw new Error("cannot register existing reader", name);
                }

                READERS[name] = reader;
              },
              setReaders: function setReaders(readers) {
                // eslint-disable-next-line no-param-reassign
                config.readers = readers;
                _barcodeReaders.length = 0;
                initReaders();
              },
            };
          },
        };
        // CONCATENATED MODULE: ./src/reader/index.ts

        // CONCATENATED MODULE: ./src/common/events.ts
        /* harmony default export */ var events = (function EventInterface() {
          var events = {};

          function getEvent(eventName) {
            if (!events[eventName]) {
              events[eventName] = {
                subscribers: [],
              };
            }

            return events[eventName];
          }

          function clearEvents() {
            events = {};
          }

          function publishSubscription(subscription, data) {
            if (subscription.async) {
              setTimeout(function () {
                subscription.callback(data);
              }, 4);
            } else {
              subscription.callback(data);
            }
          }

          function _subscribe(event, callback, async) {
            var subscription;

            if (typeof callback === "function") {
              subscription = {
                callback: callback,
                async: async,
              };
            } else {
              subscription = callback;

              if (!subscription.callback) {
                throw new Error("Callback was not specified on options");
              }
            }

            getEvent(event).subscribers.push(subscription);
          }

          return {
            subscribe: function subscribe(event, callback, async) {
              return _subscribe(event, callback, async);
            },
            publish: function publish(eventName, data) {
              var event = getEvent(eventName);
              var subscribers = event.subscribers; // Publish one-time subscriptions

              subscribers
                .filter(function (subscriber) {
                  return !!subscriber.once;
                })
                .forEach(function (subscriber) {
                  publishSubscription(subscriber, data);
                }); // remove them from the subscriber

              event.subscribers = subscribers.filter(function (subscriber) {
                return !subscriber.once;
              }); // publish the rest

              event.subscribers.forEach(function (subscriber) {
                publishSubscription(subscriber, data);
              });
            },
            once: function once(event, callback) {
              var async =
                arguments.length > 2 && arguments[2] !== undefined
                  ? arguments[2]
                  : false;

              _subscribe(event, {
                callback: callback,
                async: async,
                once: true,
              });
            },
            unsubscribe: function unsubscribe(eventName, callback) {
              if (eventName) {
                var _event = getEvent(eventName);

                if (_event && callback) {
                  _event.subscribers = _event.subscribers.filter(function (
                    subscriber
                  ) {
                    return subscriber.callback !== callback;
                  });
                } else {
                  _event.subscribers = [];
                }
              } else {
                clearEvents();
              }
            },
          };
        })();
        // EXTERNAL MODULE: ./node_modules/lodash/pick.js
        var pick = __webpack_require__(62);
        var pick_default = /*#__PURE__*/ __webpack_require__.n(pick);

        // EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/wrapNativeSuper.js
        var wrapNativeSuper = __webpack_require__(63);
        var wrapNativeSuper_default =
          /*#__PURE__*/ __webpack_require__.n(wrapNativeSuper);

        // CONCATENATED MODULE: ./src/quagga/Exception.ts

        function Exception_createSuper(Derived) {
          var hasNativeReflectConstruct = Exception_isNativeReflectConstruct();
          return function _createSuperInternal() {
            var Super = getPrototypeOf_default()(Derived),
              result;
            if (hasNativeReflectConstruct) {
              var NewTarget = getPrototypeOf_default()(this).constructor;
              result = Reflect.construct(Super, arguments, NewTarget);
            } else {
              result = Super.apply(this, arguments);
            }
            return possibleConstructorReturn_default()(this, result);
          };
        }

        function Exception_isNativeReflectConstruct() {
          if (typeof Reflect === "undefined" || !Reflect.construct)
            return false;
          if (Reflect.construct.sham) return false;
          if (typeof Proxy === "function") return true;
          try {
            Boolean.prototype.valueOf.call(
              Reflect.construct(Boolean, [], function () {})
            );
            return true;
          } catch (e) {
            return false;
          }
        }

        var Exception_Exception = /*#__PURE__*/ (function (_Error) {
          inherits_default()(Exception, _Error);

          var _super = Exception_createSuper(Exception);

          function Exception(m, code) {
            var _this;

            classCallCheck_default()(this, Exception);

            _this = _super.call(this, m);

            defineProperty_default()(
              assertThisInitialized_default()(_this),
              "code",
              void 0
            );

            _this.code = code;
            Object.setPrototypeOf(
              assertThisInitialized_default()(_this),
              Exception.prototype
            );
            return _this;
          }

          return createClass_default()(Exception);
        })(/*#__PURE__*/ wrapNativeSuper_default()(Error));

        // CONCATENATED MODULE: ./src/common/mediaDevices.ts

        var ERROR_DESC =
          "This may mean that the user has declined camera access, or the browser does not support media APIs. If you are running in iOS, you must use Safari.";
        function enumerateDevices() {
          try {
            return navigator.mediaDevices.enumerateDevices();
          } catch (err) {
            var error = new Exception_Exception(
              "enumerateDevices is not defined. ".concat(ERROR_DESC),
              -1
            );
            return Promise.reject(error);
          }
        }
        function getUserMedia(constraints) {
          try {
            return navigator.mediaDevices.getUserMedia(constraints);
          } catch (err) {
            var error = new Exception_Exception(
              "getUserMedia is not defined. ".concat(ERROR_DESC),
              -1
            );
            return Promise.reject(error);
          }
        }
        // CONCATENATED MODULE: ./src/input/camera_access.ts

        // TODO: when this file was written years ago, HTMLMediaElement.play() did not return a useful value
        // to let us know when the video started playing.  Now, it does.  So, we shouldn't need to run this
        // odd waitForVideo() function that polls to see if the video has started.

        var streamRef;

        function waitForVideo(video) {
          return new Promise(function (resolve, reject) {
            var attempts = 10;

            function checkVideo() {
              if (attempts > 0) {
                if (video.videoWidth > 10 && video.videoHeight > 10) {
                  if (true) {
                    console.log(
                      "* dev: checkVideo found "
                        .concat(video.videoWidth, "px x ")
                        .concat(video.videoHeight, "px")
                    );
                  }

                  resolve();
                } else {
                  window.setTimeout(checkVideo, 500);
                }
              } else {
                reject(
                  new Exception_Exception(
                    "Unable to play video stream. Is webcam working?",
                    -1
                  )
                ); // TODO: add error code
              }

              attempts--;
            }

            checkVideo();
          });
        }
        /**
         * Tries to attach the camera-stream to a given video-element
         * and calls the callback function when the content is ready
         * @param {Object} constraints
         * @param {Object} video
         */

        function initCamera(_x, _x2) {
          return _initCamera.apply(this, arguments);
        }

        function _initCamera() {
          _initCamera = asyncToGenerator_default()(
            /*#__PURE__*/ regenerator_default.a.mark(function _callee4(
              video,
              constraints
            ) {
              var stream;
              return regenerator_default.a.wrap(function _callee4$(_context4) {
                while (1) {
                  switch ((_context4.prev = _context4.next)) {
                    case 0:
                      _context4.next = 2;
                      return getUserMedia(constraints);

                    case 2:
                      stream = _context4.sent;
                      streamRef = stream;

                      if (!video) {
                        _context4.next = 11;
                        break;
                      }

                      video.setAttribute("autoplay", "true");
                      video.setAttribute("muted", "true");
                      video.setAttribute("playsinline", "true"); // not listed on MDN...
                      // eslint-disable-next-line no-param-reassign

                      video.srcObject = stream;
                      video.addEventListener("loadedmetadata", function () {
                        video.play()["catch"](function (err) {
                          console.warn(
                            "* Error while trying to play video stream:",
                            err
                          );
                        });
                      });
                      return _context4.abrupt("return", waitForVideo(video));

                    case 11:
                      return _context4.abrupt("return", Promise.resolve());

                    case 12:
                    case "end":
                      return _context4.stop();
                  }
                }
              }, _callee4);
            })
          );
          return _initCamera.apply(this, arguments);
        }

        function deprecatedConstraints(videoConstraints) {
          var normalized = pick_default()(videoConstraints, [
            "width",
            "height",
            "facingMode",
            "aspectRatio",
            "deviceId",
          ]);

          if (
            typeof videoConstraints.minAspectRatio !== "undefined" &&
            videoConstraints.minAspectRatio > 0
          ) {
            normalized.aspectRatio = videoConstraints.minAspectRatio;
            console.log(
              "WARNING: Constraint 'minAspectRatio' is deprecated; Use 'aspectRatio' instead"
            );
          }

          if (typeof videoConstraints.facing !== "undefined") {
            normalized.facingMode = videoConstraints.facing;
            console.log(
              "WARNING: Constraint 'facing' is deprecated. Use 'facingMode' instead'"
            );
          }

          return normalized;
        } // TODO: #192 I don't think there's any good reason pickConstraints should return a Promise,
        // I think it was just that way so it could be chained to other functions that did return a Promise.
        // That's not necessary with async functions being a thing, so that should be fixed.

        function pickConstraints() {
          var videoConstraints =
            arguments.length > 0 && arguments[0] !== undefined
              ? arguments[0]
              : {};
          var video = deprecatedConstraints(videoConstraints);

          if (video && video.deviceId && video.facingMode) {
            delete video.facingMode;
          }

          return Promise.resolve({
            audio: false,
            video: video,
          });
        }

        function enumerateVideoDevices() {
          return _enumerateVideoDevices.apply(this, arguments);
        }

        function _enumerateVideoDevices() {
          _enumerateVideoDevices = asyncToGenerator_default()(
            /*#__PURE__*/ regenerator_default.a.mark(function _callee5() {
              var devices;
              return regenerator_default.a.wrap(function _callee5$(_context5) {
                while (1) {
                  switch ((_context5.prev = _context5.next)) {
                    case 0:
                      _context5.next = 2;
                      return enumerateDevices();

                    case 2:
                      devices = _context5.sent;
                      return _context5.abrupt(
                        "return",
                        devices.filter(function (device) {
                          return device.kind === "videoinput";
                        })
                      );

                    case 4:
                    case "end":
                      return _context5.stop();
                  }
                }
              }, _callee5);
            })
          );
          return _enumerateVideoDevices.apply(this, arguments);
        }

        function getActiveTrack() {
          if (!streamRef) {
            return null;
          }

          var tracks = streamRef.getVideoTracks();
          return tracks && tracks !== null && tracks !== void 0 && tracks.length
            ? tracks[0]
            : null;
        }
        /**
         * Used for accessing information about the active stream track and available video devices.
         */

        var QuaggaJSCameraAccess = {
          requestedVideoElement: null,
          request: function request(video, videoConstraints) {
            return asyncToGenerator_default()(
              /*#__PURE__*/ regenerator_default.a.mark(function _callee() {
                var newConstraints;
                return regenerator_default.a.wrap(function _callee$(_context) {
                  while (1) {
                    switch ((_context.prev = _context.next)) {
                      case 0:
                        QuaggaJSCameraAccess.requestedVideoElement = video;
                        _context.next = 3;
                        return pickConstraints(videoConstraints);

                      case 3:
                        newConstraints = _context.sent;
                        return _context.abrupt(
                          "return",
                          initCamera(video, newConstraints)
                        );

                      case 5:
                      case "end":
                        return _context.stop();
                    }
                  }
                }, _callee);
              })
            )();
          },
          release: function release() {
            var tracks = streamRef && streamRef.getVideoTracks();

            if (QuaggaJSCameraAccess.requestedVideoElement !== null) {
              QuaggaJSCameraAccess.requestedVideoElement.pause();
            }

            return new Promise(function (resolve) {
              setTimeout(function () {
                if (tracks && tracks.length) {
                  tracks.forEach(function (track) {
                    return track.stop();
                  });
                }

                streamRef = null;
                QuaggaJSCameraAccess.requestedVideoElement = null;
                resolve();
              }, 0);
            });
          },
          enumerateVideoDevices: enumerateVideoDevices,
          getActiveStreamLabel: function getActiveStreamLabel() {
            var track = getActiveTrack();
            return track ? track.label : "";
          },
          getActiveTrack: getActiveTrack,
          disableTorch: function disableTorch() {
            return asyncToGenerator_default()(
              /*#__PURE__*/ regenerator_default.a.mark(function _callee2() {
                var track;
                return regenerator_default.a.wrap(function _callee2$(
                  _context2
                ) {
                  while (1) {
                    switch ((_context2.prev = _context2.next)) {
                      case 0:
                        track = getActiveTrack(); // TODO: should we acquire camera access even if there's no current camera open?
                        // TODO: what happens on iOS or another device where torch isn't supported at all? Should we throw an error?

                        if (!track) {
                          _context2.next = 4;
                          break;
                        }

                        _context2.next = 4;
                        return track.applyConstraints({
                          torch: false,
                        });

                      case 4:
                      case "end":
                        return _context2.stop();
                    }
                  }
                },
                _callee2);
              })
            )();
          },
          enableTorch: function enableTorch() {
            return asyncToGenerator_default()(
              /*#__PURE__*/ regenerator_default.a.mark(function _callee3() {
                var track;
                return regenerator_default.a.wrap(function _callee3$(
                  _context3
                ) {
                  while (1) {
                    switch ((_context3.prev = _context3.next)) {
                      case 0:
                        track = getActiveTrack(); // TODO: should we acquire camera access even if there's no current camera open?
                        // TODO: what happens on iOS or another device where torch isn't supported at all? Should we throw an error?

                        if (!track) {
                          _context3.next = 4;
                          break;
                        }

                        _context3.next = 4;
                        return track.applyConstraints({
                          torch: true,
                        });

                      case 4:
                      case "end":
                        return _context3.stop();
                    }
                  }
                },
                _callee3);
              })
            )();
          },
        };
        /* harmony default export */ var camera_access = QuaggaJSCameraAccess;
        // CONCATENATED MODULE: ./src/analytics/result_collector.ts

        function contains(codeResult, list) {
          return (
            list &&
            list.some(function (item) {
              var keys = Object.keys(item);
              return keys.every(function (key) {
                return item[key] === codeResult[key];
              });
            })
          );
        }

        function passesFilter(codeResult, filter) {
          return typeof filter === "function" ? filter(codeResult) : true;
        }

        /* harmony default export */ var result_collector = {
          create: function create(config) {
            var _config$capacity;

            var canvas = document.createElement("canvas");
            var ctx = canvas.getContext("2d");
            var results = [];
            var capacity =
              (_config$capacity = config.capacity) !== null &&
              _config$capacity !== void 0
                ? _config$capacity
                : 20;
            var capture = config.capture === true;

            function matchesConstraints(codeResult) {
              return (
                !!capacity &&
                codeResult &&
                !contains(codeResult, config.blacklist) &&
                passesFilter(codeResult, config.filter)
              );
            }

            return {
              addResult: function addResult(data, imageSize, codeResult) {
                var result = {}; // this is 'any' to avoid having to construct a whole QuaggaJSCodeResult :|

                if (matchesConstraints(codeResult)) {
                  capacity--;
                  result.codeResult = codeResult;

                  if (capture) {
                    canvas.width = imageSize.x;
                    canvas.height = imageSize.y;
                    image_debug["a" /* default */].drawImage(
                      data,
                      imageSize,
                      ctx
                    );
                    result.frame = canvas.toDataURL();
                  }

                  results.push(result);
                }
              },
              getResults: function getResults() {
                return results;
              },
            };
          },
        };
        // CONCATENATED MODULE: ./src/config/config.dev.ts
        var DevConfig = {
          inputStream: {
            name: "Live",
            type: "LiveStream",
            constraints: {
              width: 640,
              height: 480,
              // aspectRatio: 640/480, // optional
              facingMode: "environment", // or user
              // deviceId: "38745983457387598375983759834"
            },
            area: {
              top: "0%",
              right: "0%",
              left: "0%",
              bottom: "0%",
            },
            singleChannel: false, // true: only the red color-channel is read
          },
          locate: true,
          numOfWorkers: 0,
          decoder: {
            readers: ["code_128_reader"],
            debug: {
              drawBoundingBox: false,
              showFrequency: false,
              drawScanline: false,
              showPattern: false,
            },
          },
          locator: {
            halfSample: true,
            patchSize: "medium",
            // x-small, small, medium, large, x-large
            debug: {
              showCanvas: false,
              showPatches: false,
              showFoundPatches: false,
              showSkeleton: false,
              showLabels: false,
              showPatchLabels: false,
              showRemainingPatchLabels: false,
              boxFromPatches: {
                showTransformed: false,
                showTransformedBox: false,
                showBB: false,
              },
            },
          },
        };
        /* harmony default export */ var config_dev = DevConfig;
        // CONCATENATED MODULE: ./src/config/config.node.ts
        var NodeConfig = {
          inputStream: {
            type: "ImageStream",
            sequence: false,
            size: 800,
            area: {
              top: "0%",
              right: "0%",
              left: "0%",
              bottom: "0%",
            },
            singleChannel: false, // true: only the red color-channel is read
          },
          locate: true,
          numOfWorkers: 0,
          decoder: {
            readers: ["code_128_reader"],
          },
          locator: {
            halfSample: true,
            patchSize: "medium", // x-small, small, medium, large, x-large
          },
        };
        /* harmony default export */ var config_node = NodeConfig;
        // CONCATENATED MODULE: ./src/config/config.prod.ts
        var ProdConfig = {
          inputStream: {
            name: "Live",
            type: "LiveStream",
            constraints: {
              width: 640,
              height: 480,
              // aspectRatio: 640/480, // optional
              facingMode: "environment", // or user
              // deviceId: "38745983457387598375983759834"
            },
            area: {
              top: "0%",
              right: "0%",
              left: "0%",
              bottom: "0%",
            },
            singleChannel: false, // true: only the red color-channel is read
          },
          locate: true,
          numOfWorkers: 4,
          decoder: {
            readers: ["code_128_reader"],
          },
          locator: {
            halfSample: true,
            patchSize: "medium", // x-small, small, medium, large, x-large
          },
        };
        /* harmony default export */ var config_prod = ProdConfig;
        // CONCATENATED MODULE: ./src/config/config.ts

        var ExportConfig = (function () {
          var QuaggaConfig;

          if (true) {
            QuaggaConfig = config_dev;
          } else {
          }

          return QuaggaConfig;
        })();

        /* harmony default export */ var config_config = ExportConfig;
        // EXTERNAL MODULE: ./node_modules/gl-matrix/esm/index.js + 4 modules
        var esm = __webpack_require__(5);

        // EXTERNAL MODULE: ./src/common/cv_utils.js + 1 modules
        var cv_utils = __webpack_require__(9);

        // CONCATENATED MODULE: ./src/input/frame_grabber_browser.js
        // NOTE FOR ANYONE IN HERE IN THE FUTURE:
        // webpack.config.js replaces the frame_grabber module with THIS module when it is building for a Browser environment.

        var TO_RADIANS = Math.PI / 180;

        function adjustCanvasSize(canvas, targetSize) {
          if (canvas.width !== targetSize.x) {
            if (true) {
              console.log("WARNING: canvas-size needs to be adjusted");
            }

            canvas.width = targetSize.x;
          }

          if (canvas.height !== targetSize.y) {
            if (true) {
              console.log("WARNING: canvas-size needs to be adjusted");
            }

            canvas.height = targetSize.y;
          }
        }

        var FrameGrabber = {};

        FrameGrabber.create = function (inputStream, canvas) {
          // console.warn('*** FrameGrabberBrowser create');
          var _that = {};

          var _streamConfig = inputStream.getConfig();

          var _videoSize = Object(cv_utils["h" /* imageRef */])(
            inputStream.getRealWidth(),
            inputStream.getRealHeight()
          );

          var _canvasSize = inputStream.getCanvasSize();

          var _size = Object(cv_utils["h" /* imageRef */])(
            inputStream.getWidth(),
            inputStream.getHeight()
          );

          var topRight = inputStream.getTopRight();
          var _sx = topRight.x;
          var _sy = topRight.y;

          var _canvas;

          var _ctx = null;
          var _data = null;
          _canvas = canvas || document.createElement("canvas");
          _canvas.width = _canvasSize.x;
          _canvas.height = _canvasSize.y;
          _ctx = _canvas.getContext("2d");
          _data = new Uint8Array(_size.x * _size.y);

          if (true) {
            console.log(
              "FrameGrabber",
              JSON.stringify({
                size: _size,
                topRight: topRight,
                videoSize: _videoSize,
                canvasSize: _canvasSize,
              })
            );
          }
          /**
           * Uses the given array as frame-buffer
           */

          _that.attachData = function (data) {
            _data = data;
          };
          /**
           * Returns the used frame-buffer
           */

          _that.getData = function () {
            return _data;
          };
          /**
           * Fetches a frame from the input-stream and puts into the frame-buffer.
           * The image-data is converted to gray-scale and then half-sampled if configured.
           */

          _that.grab = function () {
            var doHalfSample = _streamConfig.halfSample;
            var frame = inputStream.getFrame();
            var drawable = frame;
            var drawAngle = 0;
            var ctxData;

            if (drawable) {
              adjustCanvasSize(_canvas, _canvasSize);

              if (_streamConfig.type === "ImageStream") {
                drawable = frame.img;

                if (frame.tags && frame.tags.orientation) {
                  switch (frame.tags.orientation) {
                    case 6:
                      drawAngle = 90 * TO_RADIANS;
                      break;

                    case 8:
                      drawAngle = -90 * TO_RADIANS;
                      break;
                  }
                }
              }

              if (drawAngle !== 0) {
                _ctx.translate(_canvasSize.x / 2, _canvasSize.y / 2);

                _ctx.rotate(drawAngle);

                _ctx.drawImage(
                  drawable,
                  -_canvasSize.y / 2,
                  -_canvasSize.x / 2,
                  _canvasSize.y,
                  _canvasSize.x
                );

                _ctx.rotate(-drawAngle);

                _ctx.translate(-_canvasSize.x / 2, -_canvasSize.y / 2);
              } else {
                _ctx.drawImage(drawable, 0, 0, _canvasSize.x, _canvasSize.y);
              }

              ctxData = _ctx.getImageData(_sx, _sy, _size.x, _size.y).data;

              if (doHalfSample) {
                Object(cv_utils["e" /* grayAndHalfSampleFromCanvasData */])(
                  ctxData,
                  _size,
                  _data
                );
              } else {
                Object(cv_utils["c" /* computeGray */])(
                  ctxData,
                  _data,
                  _streamConfig
                );
              }

              return true;
            }

            return false;
          };

          _that.getSize = function () {
            return _size;
          };

          return _that;
        };

        /* harmony default export */ var frame_grabber_browser = FrameGrabber;
        // CONCATENATED MODULE: ./src/input/exif_helper.js
        // NOTE: (SOME OF) THIS IS BROWSER ONLY CODE.  Node does not have 'atob' built in, nor XMLHttpRequest.
        // How exactly is this set of functions used in Quagga? Do we need the browser specific code? Do we
        // need to port any part of this that doesn't work in Node to node?
        // Tags scraped from https://github.com/exif-js/exif-js
        var ExifTags = {
          0x0112: "orientation",
        };
        var AvailableTags = Object.keys(ExifTags).map(function (key) {
          return ExifTags[key];
        });
        function findTagsInObjectURL(src) {
          var tags =
            arguments.length > 1 && arguments[1] !== undefined
              ? arguments[1]
              : AvailableTags;

          if (/^blob:/i.test(src)) {
            return objectURLToBlob(src)
              .then(readToBuffer)
              .then(function (buffer) {
                return findTagsInBuffer(buffer, tags);
              });
          }

          return Promise.resolve(null);
        }
        function base64ToArrayBuffer(dataUrl) {
          var base64 = dataUrl.replace(/^data:([^;]+);base64,/gim, "");
          var binary = atob(base64);
          var len = binary.length;
          var buffer = new ArrayBuffer(len);
          var view = new Uint8Array(buffer);

          for (var i = 0; i < len; i++) {
            view[i] = binary.charCodeAt(i);
          }

          return buffer;
        }

        function readToBuffer(blob) {
          return new Promise(function (resolve) {
            var fileReader = new FileReader();

            fileReader.onload = function (e) {
              return resolve(e.target.result);
            };

            fileReader.readAsArrayBuffer(blob);
          });
        }

        function objectURLToBlob(url) {
          return new Promise(function (resolve, reject) {
            var http = new XMLHttpRequest();
            http.open("GET", url, true);
            http.responseType = "blob";

            http.onreadystatechange = function () {
              if (
                http.readyState === XMLHttpRequest.DONE &&
                (http.status === 200 || http.status === 0)
              ) {
                resolve(this.response);
              }
            };

            http.onerror = reject;
            http.send();
          });
        }

        function findTagsInBuffer(file) {
          var selectedTags =
            arguments.length > 1 && arguments[1] !== undefined
              ? arguments[1]
              : AvailableTags;
          var dataView = new DataView(file);
          var length = file.byteLength;
          var exifTags = selectedTags.reduce(function (result, selectedTag) {
            var exifTag = Object.keys(ExifTags).filter(function (tag) {
              return ExifTags[tag] === selectedTag;
            })[0];

            if (exifTag) {
              result[exifTag] = selectedTag;
            }

            return result;
          }, {});
          var offset = 2;
          var marker;

          if (dataView.getUint8(0) !== 0xff || dataView.getUint8(1) !== 0xd8) {
            return false;
          }

          while (offset < length) {
            if (dataView.getUint8(offset) !== 0xff) {
              return false;
            }

            marker = dataView.getUint8(offset + 1);

            if (marker === 0xe1) {
              return readEXIFData(dataView, offset + 4, exifTags);
            }

            offset += 2 + dataView.getUint16(offset + 2);
          }

          return false;
        }

        function readEXIFData(file, start, exifTags) {
          if (getStringFromBuffer(file, start, 4) !== "Exif") {
            return false;
          }

          var tiffOffset = start + 6;
          var bigEnd;

          if (file.getUint16(tiffOffset) === 0x4949) {
            bigEnd = false;
          } else if (file.getUint16(tiffOffset) === 0x4d4d) {
            bigEnd = true;
          } else {
            return false;
          }

          if (file.getUint16(tiffOffset + 2, !bigEnd) !== 0x002a) {
            return false;
          }

          var firstIFDOffset = file.getUint32(tiffOffset + 4, !bigEnd);

          if (firstIFDOffset < 0x00000008) {
            return false;
          }

          var tags = readTags(
            file,
            tiffOffset,
            tiffOffset + firstIFDOffset,
            exifTags,
            bigEnd
          );
          return tags;
        }

        function readTags(file, tiffStart, dirStart, strings, bigEnd) {
          var entries = file.getUint16(dirStart, !bigEnd);
          var tags = {};

          for (var i = 0; i < entries; i++) {
            var entryOffset = dirStart + i * 12 + 2;
            var tag = strings[file.getUint16(entryOffset, !bigEnd)];

            if (tag) {
              tags[tag] = readTagValue(
                file,
                entryOffset,
                tiffStart,
                dirStart,
                bigEnd
              );
            }
          }

          return tags;
        }

        function readTagValue(file, entryOffset, tiffStart, dirStart, bigEnd) {
          var type = file.getUint16(entryOffset + 2, !bigEnd);
          var numValues = file.getUint32(entryOffset + 4, !bigEnd);

          switch (type) {
            case 3:
              if (numValues === 1) {
                return file.getUint16(entryOffset + 8, !bigEnd);
              }
          }

          return null;
        }

        function getStringFromBuffer(buffer, start, length) {
          var outstr = "";

          for (var n = start; n < start + length; n++) {
            outstr += String.fromCharCode(buffer.getUint8(n));
          }

          return outstr;
        }
        // CONCATENATED MODULE: ./src/input/image_loader.js

        var ImageLoader = {};

        ImageLoader.load = function (
          directory,
          callback,
          offset,
          size,
          sequence
        ) {
          var htmlImagesSrcArray = new Array(size);
          var htmlImagesArray = new Array(htmlImagesSrcArray.length);
          var i;
          var img;
          var num;

          if (sequence === false) {
            htmlImagesSrcArray[0] = directory;
          } else {
            for (i = 0; i < htmlImagesSrcArray.length; i++) {
              num = offset + i;
              htmlImagesSrcArray[i] = ""
                .concat(directory, "image-")
                .concat("00".concat(num).slice(-3), ".jpg");
            }
          }

          htmlImagesArray.notLoaded = [];

          htmlImagesArray.addImage = function (image) {
            htmlImagesArray.notLoaded.push(image);
          };

          htmlImagesArray.loaded = function (loadedImg) {
            var notloadedImgs = htmlImagesArray.notLoaded;

            for (var x = 0; x < notloadedImgs.length; x++) {
              if (notloadedImgs[x] === loadedImg) {
                notloadedImgs.splice(x, 1);

                for (var y = 0; y < htmlImagesSrcArray.length; y++) {
                  var imgName = htmlImagesSrcArray[y].substr(
                    htmlImagesSrcArray[y].lastIndexOf("/")
                  );

                  if (loadedImg.src.lastIndexOf(imgName) !== -1) {
                    htmlImagesArray[y] = {
                      img: loadedImg,
                    };
                    break;
                  }
                }

                break;
              }
            }

            if (notloadedImgs.length === 0) {
              if (true) {
                console.log("Images loaded");
              }

              if (sequence === false) {
                findTagsInObjectURL(directory, ["orientation"])
                  .then(function (tags) {
                    htmlImagesArray[0].tags = tags;
                    callback(htmlImagesArray);
                  })
                  ["catch"](function (e) {
                    console.log(e);
                    callback(htmlImagesArray);
                  });
              } else {
                callback(htmlImagesArray);
              }
            }
          };

          for (i = 0; i < htmlImagesSrcArray.length; i++) {
            img = new Image();
            htmlImagesArray.addImage(img);
            addOnloadHandler(img, htmlImagesArray);
            img.src = htmlImagesSrcArray[i];
          }
        };

        function addOnloadHandler(img, htmlImagesArray) {
          img.onload = function () {
            htmlImagesArray.loaded(this);
          };
        }

        /* harmony default export */ var image_loader = ImageLoader;
        // CONCATENATED MODULE: ./src/input/input_stream/input_stream_browser.ts
        /* eslint-disable @typescript-eslint/no-explicit-any */

        var inputStreamFactory = {
          createVideoStream: function createVideoStream(video) {
            console.warn("**** InputStreamBrowser createVideoStream");
            var _config = null;
            var _eventNames = ["canrecord", "ended"];
            var _eventHandlers = {};

            var _calculatedWidth;

            var _calculatedHeight;

            var _topRight = {
              x: 0,
              y: 0,
              type: "Point",
            };
            var _canvasSize = {
              x: 0,
              y: 0,
              type: "XYSize",
            };

            function initSize() {
              var _config2, _config3;

              var width = video.videoWidth;
              var height = video.videoHeight; // eslint-disable-next-line no-nested-ternary

              _calculatedWidth =
                (_config2 = _config) !== null &&
                _config2 !== void 0 &&
                _config2.size
                  ? width / height > 1
                    ? _config.size
                    : Math.floor((width / height) * _config.size)
                  : width; // eslint-disable-next-line no-nested-ternary

              _calculatedHeight =
                (_config3 = _config) !== null &&
                _config3 !== void 0 &&
                _config3.size
                  ? width / height > 1
                    ? Math.floor((height / width) * _config.size)
                    : _config.size
                  : height;
              _canvasSize.x = _calculatedWidth;
              _canvasSize.y = _calculatedHeight;
            }

            var inputStream = {
              getRealWidth: function getRealWidth() {
                return video.videoWidth;
              },
              getRealHeight: function getRealHeight() {
                return video.videoHeight;
              },
              getWidth: function getWidth() {
                return _calculatedWidth;
              },
              getHeight: function getHeight() {
                return _calculatedHeight;
              },
              setWidth: function setWidth(width) {
                _calculatedWidth = width;
              },
              setHeight: function setHeight(height) {
                _calculatedHeight = height;
              },
              setInputStream: function setInputStream(config) {
                // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
                _config = config; // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access

                this.setAttribute(
                  "src",
                  typeof config.src !== "undefined" ? config.src : ""
                );
              },
              ended: function ended() {
                return video.ended;
              },
              getConfig: function getConfig() {
                return _config;
              },
              setAttribute: function setAttribute(name, value) {
                if (video) {
                  video.setAttribute(name, value);
                }
              },
              pause: function pause() {
                video.pause();
              },
              play: function play() {
                // eslint-disable-next-line @typescript-eslint/no-floating-promises
                video.play();
              },
              setCurrentTime: function setCurrentTime(time) {
                var _config4;

                if (
                  ((_config4 = _config) === null || _config4 === void 0
                    ? void 0
                    : _config4.type) !== "LiveStream"
                ) {
                  this.setAttribute("currentTime", time.toString());
                }
              },
              addEventListener: function addEventListener(event, f, bool) {
                if (_eventNames.indexOf(event) !== -1) {
                  if (!_eventHandlers[event]) {
                    _eventHandlers[event] = [];
                  }

                  _eventHandlers[event].push(f);
                } else {
                  video.addEventListener(event, f, bool);
                }
              },
              clearEventHandlers: function clearEventHandlers() {
                _eventNames.forEach(function (eventName) {
                  var handlers = _eventHandlers[eventName];

                  if (handlers && handlers.length > 0) {
                    handlers.forEach(function (handler) {
                      video.removeEventListener(eventName, handler);
                    });
                  }
                });
              },
              trigger: function trigger(eventName, args) {
                var j; // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access

                var handlers = _eventHandlers[eventName];

                if (eventName === "canrecord") {
                  initSize();
                }

                if (handlers && handlers.length > 0) {
                  for (j = 0; j < handlers.length; j++) {
                    handlers[j].apply(inputStream, args);
                  }
                }
              },
              setTopRight: function setTopRight(topRight) {
                _topRight.x = topRight.x;
                _topRight.y = topRight.y;
              },
              getTopRight: function getTopRight() {
                return _topRight;
              },
              setCanvasSize: function setCanvasSize(size) {
                _canvasSize.x = size.x;
                _canvasSize.y = size.y;
              },
              getCanvasSize: function getCanvasSize() {
                return _canvasSize;
              },
              getFrame: function getFrame() {
                return video;
              },
            };
            return inputStream;
          },
          createLiveStream: function createLiveStream(video) {
            console.warn("**** InputStreamBrowser createLiveStream");

            if (video) {
              video.setAttribute("autoplay", "true");
            }

            var that = inputStreamFactory.createVideoStream(video);

            that.ended = function ended() {
              return false;
            };

            return that;
          },
          createImageStream: function createImageStream() {
            // console.warn('**** InputStreamBrowser createImageStream');
            var _config = null;
            var width = 0;
            var height = 0;
            var frameIdx = 0;
            var paused = true;
            var loaded = false;
            var imgArray = null;
            var size = 0;
            var offset = 1;
            var baseUrl = null;
            var _ended = false;
            var calculatedWidth;
            var calculatedHeight;
            var _eventNames = ["canrecord", "ended"];
            var _eventHandlers = {};
            var _topRight = {
              x: 0,
              y: 0,
              type: "Point",
            };
            var _canvasSize = {
              x: 0,
              y: 0,
              type: "XYSize",
            };

            function loadImages() {
              var _config7;

              loaded = false;
              image_loader.load(
                baseUrl,
                function (imgs) {
                  var _config5, _config6;

                  imgArray = imgs; // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access

                  if (imgs[0].tags && imgs[0].tags.orientation) {
                    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
                    switch (imgs[0].tags.orientation) {
                      case 6:
                      case 8:
                        width = imgs[0].img.height;
                        height = imgs[0].img.width;
                        break;

                      default:
                        width = imgs[0].img.width;
                        height = imgs[0].img.height;
                    }
                  } else {
                    width = imgs[0].img.width;
                    height = imgs[0].img.height;
                  } // eslint-disable-next-line no-nested-ternary

                  calculatedWidth =
                    (_config5 = _config) !== null &&
                    _config5 !== void 0 &&
                    _config5.size
                      ? width / height > 1
                        ? _config.size
                        : Math.floor((width / height) * _config.size)
                      : width; // eslint-disable-next-line no-nested-ternary

                  calculatedHeight =
                    (_config6 = _config) !== null &&
                    _config6 !== void 0 &&
                    _config6.size
                      ? width / height > 1
                        ? Math.floor((height / width) * _config.size)
                        : _config.size
                      : height;
                  _canvasSize.x = calculatedWidth;
                  _canvasSize.y = calculatedHeight;
                  loaded = true;
                  frameIdx = 0;
                  setTimeout(function () {
                    // eslint-disable-next-line @typescript-eslint/no-use-before-define
                    publishEvent("canrecord", []);
                  }, 0);
                },
                offset,
                size,
                (_config7 = _config) === null || _config7 === void 0
                  ? void 0
                  : _config7.sequence
              );
            }

            function publishEvent(eventName, args) {
              var j;
              var handlers = _eventHandlers[eventName];

              if (handlers && handlers.length > 0) {
                for (j = 0; j < handlers.length; j++) {
                  // eslint-disable-next-line @typescript-eslint/no-use-before-define
                  handlers[j].apply(inputStream, args); // TODO: typescript complains that any[] is not valid for a second arg for apply?!
                }
              }
            } // TODO: any code shared with the first InputStream above should be shared not copied
            // TODO: publishEvent needs access to inputStream, but inputStream needs access to publishEvent
            // TODO: This is why it's a 'var', so it hoists back.  This is ugly, and should be changed.
            // eslint-disable-next-line no-var,vars-on-top

            var inputStream = {
              trigger: publishEvent,
              getWidth: function getWidth() {
                return calculatedWidth;
              },
              getHeight: function getHeight() {
                return calculatedHeight;
              },
              setWidth: function setWidth(newWidth) {
                calculatedWidth = newWidth;
              },
              setHeight: function setHeight(newHeight) {
                calculatedHeight = newHeight;
              },
              getRealWidth: function getRealWidth() {
                return width;
              },
              getRealHeight: function getRealHeight() {
                return height;
              },
              setInputStream: function setInputStream(stream) {
                // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
                _config = stream; // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access

                if (stream.sequence === false) {
                  // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment,@typescript-eslint/no-unsafe-member-access
                  baseUrl = stream.src;
                  size = 1;
                } else {
                  // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment,@typescript-eslint/no-unsafe-member-access
                  baseUrl = stream.src; // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment,@typescript-eslint/no-unsafe-member-access

                  size = stream.length;
                }

                loadImages();
              },
              ended: function ended() {
                return _ended;
              },
              setAttribute: function setAttribute() {},
              getConfig: function getConfig() {
                return _config;
              },
              pause: function pause() {
                paused = true;
              },
              play: function play() {
                paused = false;
              },
              setCurrentTime: function setCurrentTime(time) {
                frameIdx = time;
              },
              addEventListener: function addEventListener(event, f) {
                if (_eventNames.indexOf(event) !== -1) {
                  if (!_eventHandlers[event]) {
                    _eventHandlers[event] = [];
                  }

                  _eventHandlers[event].push(f);
                }
              },
              clearEventHandlers: function clearEventHandlers() {
                Object.keys(_eventHandlers).forEach(function (ind) {
                  return delete _eventHandlers[ind];
                });
              },
              setTopRight: function setTopRight(topRight) {
                _topRight.x = topRight.x;
                _topRight.y = topRight.y;
              },
              getTopRight: function getTopRight() {
                return _topRight;
              },
              setCanvasSize: function setCanvasSize(canvasSize) {
                _canvasSize.x = canvasSize.x;
                _canvasSize.y = canvasSize.y;
              },
              getCanvasSize: function getCanvasSize() {
                return _canvasSize;
              },
              getFrame: function getFrame() {
                var frame;

                if (!loaded) {
                  return null;
                }

                if (!paused) {
                  var _imgArray;

                  // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
                  frame =
                    (_imgArray = imgArray) === null || _imgArray === void 0
                      ? void 0
                      : _imgArray[frameIdx];

                  if (frameIdx < size - 1) {
                    frameIdx++;
                  } else {
                    setTimeout(function () {
                      _ended = true;
                      publishEvent("ended", []);
                    }, 0);
                  }
                } // eslint-disable-next-line @typescript-eslint/no-unsafe-return

                return frame;
              },
            };
            return inputStream;
          },
        };
        /* harmony default export */ var input_stream_browser =
          inputStreamFactory;
        // EXTERNAL MODULE: ./src/locator/barcode_locator.js
        var barcode_locator = __webpack_require__(23);

        // CONCATENATED MODULE: ./src/QuaggaContext.ts

        var QuaggaContext_QuaggaContext = /*#__PURE__*/ createClass_default()(
          function QuaggaContext() {
            classCallCheck_default()(this, QuaggaContext);

            defineProperty_default()(this, "config", void 0);

            defineProperty_default()(this, "inputStream", void 0);

            defineProperty_default()(this, "framegrabber", void 0);

            defineProperty_default()(this, "inputImageWrapper", void 0);

            defineProperty_default()(this, "stopped", false);

            defineProperty_default()(this, "boxSize", void 0);

            defineProperty_default()(this, "resultCollector", void 0);

            defineProperty_default()(this, "decoder", void 0);

            defineProperty_default()(this, "workerPool", []);

            defineProperty_default()(this, "onUIThread", true);

            defineProperty_default()(
              this,
              "canvasContainer",
              new QuaggaContext_CanvasContainer()
            );
          }
        );
        var QuaggaContext_CanvasInfo = /*#__PURE__*/ createClass_default()(
          function CanvasInfo() {
            classCallCheck_default()(this, CanvasInfo);

            defineProperty_default()(this, "image", void 0);

            defineProperty_default()(this, "overlay", void 0);
          }
        );
        var QuaggaContext_CanvasContainer = /*#__PURE__*/ createClass_default()(
          function CanvasContainer() {
            classCallCheck_default()(this, CanvasContainer);

            defineProperty_default()(this, "ctx", void 0);

            defineProperty_default()(this, "dom", void 0);

            this.ctx = new QuaggaContext_CanvasInfo();
            this.dom = new QuaggaContext_CanvasInfo();
          }
        );
        // CONCATENATED MODULE: ./src/quagga/getViewPort.ts
        function getViewPort_getViewPort(target) {
          if (typeof document === "undefined") {
            return null;
          } // Check if target is already a DOM element

          if (
            target instanceof HTMLElement &&
            target.nodeName &&
            target.nodeType === 1
          ) {
            return target;
          } // Use '#interactive.viewport' as a fallback selector (backwards compatibility)

          var selector =
            typeof target === "string" ? target : "#interactive.viewport";
          return document.querySelector(selector);
        }
        // CONCATENATED MODULE: ./src/quagga/initBuffers.ts

        esm["a" /* glMatrix */].setMatrixArrayType(Array); // TODO: need typescript def for BarcodeLocator

        function initBuffers_initBuffers(inputStream, imageWrapper, locator) {
          var inputImageWrapper =
            imageWrapper ||
            new image_wrapper["a" /* default */]({
              x: inputStream.getWidth(),
              y: inputStream.getHeight(),
              type: "XYSize",
            });

          if (true) {
            console.log("image wrapper size ".concat(inputImageWrapper.size));
          }

          var boxSize = [
            esm["c" /* vec2 */].clone([0, 0]),
            esm["c" /* vec2 */].clone([0, inputImageWrapper.size.y]),
            esm["c" /* vec2 */].clone([
              inputImageWrapper.size.x,
              inputImageWrapper.size.y,
            ]),
            esm["c" /* vec2 */].clone([inputImageWrapper.size.x, 0]),
          ];
          barcode_locator["a" /* default */].init(inputImageWrapper, locator);
          return {
            inputImageWrapper: inputImageWrapper,
            boxSize: boxSize,
          };
        }
        // CONCATENATED MODULE: ./src/quagga/initCanvas.ts

        function findOrCreateCanvas(selector, className) {
          var canvas = document.querySelector(selector);

          if (!canvas) {
            canvas = document.createElement("canvas");
            canvas.className = className;
          }

          return canvas;
        }

        function getCanvasAndContext(selector, className) {
          var canvas = findOrCreateCanvas(selector, className);
          var context = canvas.getContext("2d");
          return {
            canvas: canvas,
            context: context,
          };
        }

        function initCanvases(canvasSize) {
          if (typeof document !== "undefined") {
            var image = getCanvasAndContext("canvas.imgBuffer", "imgBuffer");
            var overlay = getCanvasAndContext(
              "canvas.drawingBuffer",
              "drawingBuffer"
            ); // eslint-disable-next-line no-multi-assign

            image.canvas.width = overlay.canvas.width = canvasSize.x; // eslint-disable-next-line no-multi-assign

            image.canvas.height = overlay.canvas.height = canvasSize.y;
            return {
              dom: {
                image: image.canvas,
                overlay: overlay.canvas,
              },
              ctx: {
                image: image.context,
                overlay: overlay.context,
              },
            };
          }

          return null;
        }

        function initCanvas_initCanvas(context) {
          var _context$config,
            _context$config$input,
            _context$config2,
            _context$config2$inpu;

          var viewport = getViewPort_getViewPort(
            context === null || context === void 0
              ? void 0
              : (_context$config = context.config) === null ||
                _context$config === void 0
              ? void 0
              : (_context$config$input = _context$config.inputStream) ===
                  null || _context$config$input === void 0
              ? void 0
              : _context$config$input.target
          );
          var type =
            context === null || context === void 0
              ? void 0
              : (_context$config2 = context.config) === null ||
                _context$config2 === void 0
              ? void 0
              : (_context$config2$inpu = _context$config2.inputStream) ===
                  null || _context$config2$inpu === void 0
              ? void 0
              : _context$config2$inpu.type;
          if (!type) return null;
          var container = initCanvases(context.inputStream.getCanvasSize());
          if (!container)
            return {
              dom: {
                image: null,
                overlay: null,
              },
              ctx: {
                image: null,
                overlay: null,
              },
            };
          var dom = container.dom;

          if (typeof document !== "undefined") {
            if (viewport) {
              if (type === "ImageStream" && !viewport.contains(dom.image)) {
                viewport.appendChild(dom.image);
              }

              if (!viewport.contains(dom.overlay)) {
                viewport.appendChild(dom.overlay);
              }
            }
          }

          return container;
        }
        // CONCATENATED MODULE: ./src/quagga/qworker.ts

        function qworker_ownKeys(object, enumerableOnly) {
          var keys = Object.keys(object);
          if (Object.getOwnPropertySymbols) {
            var symbols = Object.getOwnPropertySymbols(object);
            enumerableOnly &&
              (symbols = symbols.filter(function (sym) {
                return Object.getOwnPropertyDescriptor(object, sym).enumerable;
              })),
              keys.push.apply(keys, symbols);
          }
          return keys;
        }

        function qworker_objectSpread(target) {
          for (var i = 1; i < arguments.length; i++) {
            var source = null != arguments[i] ? arguments[i] : {};
            i % 2
              ? qworker_ownKeys(Object(source), !0).forEach(function (key) {
                  defineProperty_default()(target, key, source[key]);
                })
              : Object.getOwnPropertyDescriptors
              ? Object.defineProperties(
                  target,
                  Object.getOwnPropertyDescriptors(source)
                )
              : qworker_ownKeys(Object(source)).forEach(function (key) {
                  Object.defineProperty(
                    target,
                    key,
                    Object.getOwnPropertyDescriptor(source, key)
                  );
                });
          }
          return target;
        }

        /* Worker functions. These are straight from the original quagga.js file.
         * Not presently used, as worker support is non-functional.  Keeping them around temporarily
         * to refer to until it is re-implemented. We may be able to fix/use some of this.
         */
        // TODO: need a typescript interface for FrameGrabber
        var workerPool = [];
        function updateWorkers(frameGrabber) {
          var availableWorker;

          if (workerPool.length) {
            availableWorker = workerPool.filter(function (workerThread) {
              return !workerThread.busy;
            })[0];

            if (availableWorker) {
              frameGrabber.attachData(availableWorker.imageData);

              if (frameGrabber.grab()) {
                availableWorker.busy = true;
                availableWorker.worker.postMessage(
                  {
                    cmd: "process",
                    imageData: availableWorker.imageData,
                  },
                  [availableWorker.imageData.buffer]
                );
              }

              return true;
            } else {
              return false;
            }
          }

          return null;
        }

        function configForWorker(config) {
          return qworker_objectSpread(
            qworker_objectSpread({}, config),
            {},
            {
              inputStream: qworker_objectSpread(
                qworker_objectSpread({}, config.inputStream),
                {},
                {
                  target: null,
                }
              ),
            }
          );
        } // @ts-ignore

        function workerInterface(factory) {
          if (factory) {
            var Quagga = factory()["default"];

            if (!Quagga) {
              // @ts-ignore
              self.postMessage({
                event: "error",
                message: "Quagga could not be created",
              });
              return;
            }
          } // @ts-ignore

          var imageWrapper; // @ts-ignore

          function onProcessed(result) {
            self.postMessage(
              {
                event: "processed",
                // @ts-ignore
                imageData: imageWrapper.data,
                result: result, // @ts-ignore
              },
              [imageWrapper.data.buffer]
            );
          }

          function workerInterfaceReady() {
            self.postMessage(
              {
                event: "initialized",
                // @ts-ignore
                imageData: imageWrapper.data, // @ts-ignore
              },
              [imageWrapper.data.buffer]
            );
          } // @ts-ignore

          self.onmessage = function (e) {
            if (e.data.cmd === "init") {
              var config = e.data.config;
              config.numOfWorkers = 0;
              imageWrapper = new Quagga.ImageWrapper(
                {
                  x: e.data.size.x,
                  y: e.data.size.y,
                },
                new Uint8Array(e.data.imageData)
              );
              Quagga.init(config, workerInterfaceReady, imageWrapper);
              Quagga.onProcessed(onProcessed);
            } else if (e.data.cmd === "process") {
              // @ts-ignore
              imageWrapper.data = new Uint8Array(e.data.imageData);
              Quagga.start();
            } else if (e.data.cmd === "setReaders") {
              Quagga.setReaders(e.data.readers);
            } else if (e.data.cmd === "registerReader") {
              Quagga.registerReader(e.data.name, e.data.reader);
            }
          };
        }

        function generateWorkerBlob() {
          var blob, factorySource;
          /* jshint ignore:start */
          // @ts-ignore

          if (typeof __factorySource__ !== "undefined") {
            // @ts-ignore
            factorySource = __factorySource__; // eslint-disable-line no-undef
          }
          /* jshint ignore:end */

          blob = new Blob(
            ["(" + workerInterface.toString() + ")(" + factorySource + ");"],
            {
              type: "text/javascript",
            }
          );
          return window.URL.createObjectURL(blob);
        }

        function initWorker(config, inputStream, cb) {
          var blobURL = generateWorkerBlob();
          var worker = new Worker(blobURL);
          var workerThread = {
            worker: worker,
            imageData: new Uint8Array(
              inputStream.getWidth() * inputStream.getHeight()
            ),
            busy: true,
          };

          workerThread.worker.onmessage = function (e) {
            if (e.data.event === "initialized") {
              URL.revokeObjectURL(blobURL);
              workerThread.busy = false;
              workerThread.imageData = new Uint8Array(e.data.imageData);

              if (true) {
                console.log("Worker initialized");
              }

              cb(workerThread);
            } else if (e.data.event === "processed") {
              workerThread.imageData = new Uint8Array(e.data.imageData);
              workerThread.busy = false; // TODO: how to thread publishResult into here?
              // publishResult(e.data.result, workerThread.imageData);
            } else if (e.data.event === "error") {
              if (true) {
                console.log("Worker error: " + e.data.message);
              }
            }
          };

          workerThread.worker.postMessage(
            {
              cmd: "init",
              size: {
                x: inputStream.getWidth(),
                y: inputStream.getHeight(),
              },
              imageData: workerThread.imageData,
              config: configForWorker(config),
            },
            [workerThread.imageData.buffer]
          );
        }
        function adjustWorkerPool(capacity, config, inputStream, cb) {
          var increaseBy = capacity - workerPool.length;

          if (increaseBy === 0 && cb) {
            cb();
          } else if (increaseBy < 0) {
            var workersToTerminate = workerPool.slice(increaseBy);
            workersToTerminate.forEach(function (workerThread) {
              workerThread.worker.terminate();

              if (true) {
                console.log("Worker terminated!");
              }
            });
            workerPool = workerPool.slice(0, increaseBy);

            if (cb) {
              cb();
            }
          } else {
            var workerInitialized = function workerInitialized(workerThread) {
              workerPool.push(workerThread);

              if (workerPool.length >= capacity && cb) {
                cb();
              }
            };

            if (config) {
              for (var i = 0; i < increaseBy; i++) {
                initWorker(config, inputStream, workerInitialized);
              }
            }
          }
        }
        function qworker_setReaders(readers) {
          workerPool.forEach(function (workerThread) {
            return workerThread.worker.postMessage({
              cmd: "setReaders",
              readers: readers,
            });
          });
        }
        function qworker_registerReader(name, reader) {
          workerPool.forEach(function (workerThread) {
            return workerThread.worker.postMessage({
              cmd: "registerReader",
              name: name,
              reader: reader,
            });
          });
        }
        // CONCATENATED MODULE: ./src/quagga/setupInputStream.ts
        // TODO: need to create an InputStream typescript interface, so we don't have an "any" in the next line
        function setupInputStream() {
          var type =
            arguments.length > 0 && arguments[0] !== undefined
              ? arguments[0]
              : "LiveStream";
          var viewport = arguments.length > 1 ? arguments[1] : undefined;
          var inputStreamFactory =
            arguments.length > 2 ? arguments[2] : undefined;

          switch (type) {
            case "VideoStream": {
              var video = document.createElement("video");
              return {
                video: video,
                inputStream: inputStreamFactory.createVideoStream(video),
              };
            }

            case "ImageStream":
              return {
                inputStream: inputStreamFactory.createImageStream(),
              };

            case "LiveStream": {
              var _video = null;

              if (viewport) {
                _video = viewport.querySelector("video");

                if (!_video) {
                  _video = document.createElement("video");
                  viewport.appendChild(_video);
                }
              }

              return {
                video: _video,
                inputStream: inputStreamFactory.createLiveStream(_video),
              };
            }

            default:
              console.error("* setupInputStream invalid type ".concat(type));
              return {
                video: null,
                inputStream: null,
              };
          }
        }
        // CONCATENATED MODULE: ./src/quagga/transform.ts
        /* eslint-disable no-param-reassign */
        function moveBox(box, xOffset, yOffset) {
          var corner = box.length;

          while (corner--) {
            box[corner][0] += xOffset;
            box[corner][1] += yOffset;
          }
        }
        function moveLine(line, xOffset, yOffset) {
          line[0].x += xOffset;
          line[0].y += yOffset;
          line[1].x += xOffset;
          line[1].y += yOffset;
        }
        // CONCATENATED MODULE: ./src/quagga/quagga.ts

        esm["a" /* glMatrix */].setMatrixArrayType(Array);

        var quagga_Quagga = /*#__PURE__*/ (function () {
          function Quagga() {
            var _this = this;

            classCallCheck_default()(this, Quagga);

            defineProperty_default()(
              this,
              "context",
              new QuaggaContext_QuaggaContext()
            );

            defineProperty_default()(this, "canRecord", function (callback) {
              var _this$context$config;

              if (!_this.context.config) {
                return;
              }

              barcode_locator["a" /* default */].checkImageConstraints(
                _this.context.inputStream,
                (_this$context$config = _this.context.config) === null ||
                  _this$context$config === void 0
                  ? void 0
                  : _this$context$config.locator
              );

              _this.initCanvas();

              _this.context.framegrabber = frame_grabber_browser.create(
                _this.context.inputStream,
                _this.context.canvasContainer.dom.image
              );

              if (_this.context.config.numOfWorkers === undefined) {
                _this.context.config.numOfWorkers = 0;
              }

              adjustWorkerPool(
                _this.context.config.numOfWorkers,
                _this.context.config,
                _this.context.inputStream,
                function () {
                  var _this$context$config2;

                  if (
                    ((_this$context$config2 = _this.context.config) === null ||
                    _this$context$config2 === void 0
                      ? void 0
                      : _this$context$config2.numOfWorkers) === 0
                  ) {
                    _this.initializeData();
                  }

                  _this.ready(callback);
                }
              );
            });

            defineProperty_default()(this, "update", function () {
              if (_this.context.onUIThread) {
                var workersUpdated = updateWorkers(_this.context.framegrabber);

                if (!workersUpdated) {
                  var _this$context$inputIm;

                  _this.context.framegrabber.attachData(
                    (_this$context$inputIm =
                      _this.context.inputImageWrapper) === null ||
                      _this$context$inputIm === void 0
                      ? void 0
                      : _this$context$inputIm.data
                  );

                  if (_this.context.framegrabber.grab()) {
                    if (!workersUpdated) {
                      _this.locateAndDecode();
                    }
                  }
                }
              } else {
                var _this$context$inputIm2;

                _this.context.framegrabber.attachData(
                  (_this$context$inputIm2 = _this.context.inputImageWrapper) ===
                    null || _this$context$inputIm2 === void 0
                    ? void 0
                    : _this$context$inputIm2.data
                );

                _this.context.framegrabber.grab();

                _this.locateAndDecode();
              }
            });
          }

          createClass_default()(Quagga, [
            {
              key: "initBuffers",
              value: function initBuffers(imageWrapper) {
                if (!this.context.config) {
                  return;
                }

                var _initBuffers2 = initBuffers_initBuffers(
                    this.context.inputStream,
                    imageWrapper,
                    this.context.config.locator
                  ),
                  inputImageWrapper = _initBuffers2.inputImageWrapper,
                  boxSize = _initBuffers2.boxSize;

                this.context.inputImageWrapper = inputImageWrapper;
                this.context.boxSize = boxSize;
              },
            },
            {
              key: "initializeData",
              value: function initializeData(imageWrapper) {
                if (!this.context.config) {
                  return;
                }

                this.initBuffers(imageWrapper);
                this.context.decoder = barcode_decoder.create(
                  this.context.config.decoder,
                  this.context.inputImageWrapper
                );
              },
            },
            {
              key: "getViewPort",
              value: function getViewPort() {
                if (!this.context.config || !this.context.config.inputStream) {
                  return null;
                }

                var target = this.context.config.inputStream.target;
                return getViewPort_getViewPort(target);
              },
            },
            {
              key: "ready",
              value: function ready(callback) {
                this.context.inputStream.play();
                callback();
              },
            },
            {
              key: "initCanvas",
              value: function initCanvas() {
                var container = initCanvas_initCanvas(this.context);

                if (!container) {
                  return;
                }

                var ctx = container.ctx,
                  dom = container.dom;
                this.context.canvasContainer.dom.image = dom.image;
                this.context.canvasContainer.dom.overlay = dom.overlay;
                this.context.canvasContainer.ctx.image = ctx.image;
                this.context.canvasContainer.ctx.overlay = ctx.overlay;
              },
            },
            {
              key: "initInputStream",
              value: function initInputStream(callback) {
                if (!this.context.config || !this.context.config.inputStream) {
                  return;
                }

                var _this$context$config$ = this.context.config.inputStream,
                  inputType = _this$context$config$.type,
                  constraints = _this$context$config$.constraints;

                var _setupInputStream = setupInputStream(
                    inputType,
                    this.getViewPort(),
                    input_stream_browser
                  ),
                  video = _setupInputStream.video,
                  inputStream = _setupInputStream.inputStream;

                if (inputType === "LiveStream" && video) {
                  camera_access
                    .request(video, constraints)
                    .then(function () {
                      return inputStream.trigger("canrecord");
                    })
                    ["catch"](function (err) {
                      return callback(err);
                    });
                }

                if (inputStream) {
                  inputStream.setAttribute("preload", "auto");
                  inputStream.setInputStream(this.context.config.inputStream);
                  inputStream.addEventListener(
                    "canrecord",
                    this.canRecord.bind(undefined, callback)
                  );
                }

                this.context.inputStream = inputStream;
              },
            },
            {
              key: "getBoundingBoxes",
              value: function getBoundingBoxes() {
                var _this$context$config3;

                return (_this$context$config3 = this.context.config) !== null &&
                  _this$context$config3 !== void 0 &&
                  _this$context$config3.locate
                  ? barcode_locator["a" /* default */].locate()
                  : [
                      [
                        esm["c" /* vec2 */].clone(this.context.boxSize[0]),
                        esm["c" /* vec2 */].clone(this.context.boxSize[1]),
                        esm["c" /* vec2 */].clone(this.context.boxSize[2]),
                        esm["c" /* vec2 */].clone(this.context.boxSize[3]),
                      ],
                    ];
              }, // TODO: need a typescript type for result here.
              // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
            },
            {
              key: "transformResult",
              value: function transformResult(result) {
                var _this2 = this;

                var topRight = this.context.inputStream.getTopRight();
                var xOffset = topRight.x;
                var yOffset = topRight.y;

                if (xOffset === 0 && yOffset === 0) {
                  return;
                }

                if (result.barcodes) {
                  // TODO: BarcodeInfo may not be the right type here.
                  result.barcodes.forEach(function (barcode) {
                    return _this2.transformResult(barcode);
                  });
                }

                if (result.line && result.line.length === 2) {
                  moveLine(result.line, xOffset, yOffset);
                }

                if (result.box) {
                  moveBox(result.box, xOffset, yOffset);
                }

                if (result.boxes && result.boxes.length > 0) {
                  for (var i = 0; i < result.boxes.length; i++) {
                    moveBox(result.boxes[i], xOffset, yOffset);
                  }
                }
              },
            },
            {
              key: "addResult",
              value: function addResult(result, imageData) {
                var _this3 = this;

                if (!imageData || !this.context.resultCollector) {
                  return;
                } // TODO: Figure out what data structure holds a "barcodes" result, if any...

                if (result.barcodes) {
                  result.barcodes
                    .filter(function (barcode) {
                      return barcode.codeResult;
                    })
                    .forEach(function (barcode) {
                      return _this3.addResult(barcode, imageData);
                    });
                } else if (result.codeResult) {
                  this.context.resultCollector.addResult(
                    imageData,
                    this.context.inputStream.getCanvasSize(),
                    result.codeResult
                  );
                }
              }, // eslint-disable-next-line class-methods-use-this
            },
            {
              key: "hasCodeResult",
              value: function hasCodeResult(result) {
                return !!(
                  result &&
                  (result.barcodes
                    ? result.barcodes.some(function (barcode) {
                        return barcode.codeResult;
                      })
                    : result.codeResult)
                );
              }, // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
            },
            {
              key: "publishResult",
              value: function publishResult() {
                var result =
                  arguments.length > 0 && arguments[0] !== undefined
                    ? arguments[0]
                    : null;
                var imageData = arguments.length > 1 ? arguments[1] : undefined;
                var resultToPublish = result;

                if (result && this.context.onUIThread) {
                  this.transformResult(result);
                  this.addResult(result, imageData);
                  resultToPublish = result.barcodes || result;
                }

                events.publish("processed", resultToPublish);

                if (this.hasCodeResult(result)) {
                  events.publish("detected", resultToPublish);
                }
              },
            },
            {
              key: "locateAndDecode",
              value: (function () {
                var _locateAndDecode = asyncToGenerator_default()(
                  /*#__PURE__*/ regenerator_default.a.mark(function _callee() {
                    var boxes,
                      _this$context$inputIm3,
                      decodeResult,
                      imageResult,
                      _this$context$inputIm4;

                    return regenerator_default.a.wrap(
                      function _callee$(_context) {
                        while (1) {
                          switch ((_context.prev = _context.next)) {
                            case 0:
                              boxes = this.getBoundingBoxes();

                              if (!boxes) {
                                _context.next = 12;
                                break;
                              }

                              _context.next = 4;
                              return this.context.decoder.decodeFromBoundingBoxes(
                                boxes
                              );

                            case 4:
                              _context.t0 = _context.sent;

                              if (_context.t0) {
                                _context.next = 7;
                                break;
                              }

                              _context.t0 = {};

                            case 7:
                              decodeResult = _context.t0;
                              decodeResult.boxes = boxes;
                              this.publishResult(
                                decodeResult,
                                (_this$context$inputIm3 =
                                  this.context.inputImageWrapper) === null ||
                                  _this$context$inputIm3 === void 0
                                  ? void 0
                                  : _this$context$inputIm3.data
                              );
                              _context.next = 16;
                              break;

                            case 12:
                              _context.next = 14;
                              return this.context.decoder.decodeFromImage(
                                this.context.inputImageWrapper
                              );

                            case 14:
                              imageResult = _context.sent;

                              if (imageResult) {
                                this.publishResult(
                                  imageResult,
                                  (_this$context$inputIm4 =
                                    this.context.inputImageWrapper) === null ||
                                    _this$context$inputIm4 === void 0
                                    ? void 0
                                    : _this$context$inputIm4.data
                                );
                              } else {
                                this.publishResult();
                              }

                            case 16:
                            case "end":
                              return _context.stop();
                          }
                        }
                      },
                      _callee,
                      this
                    );
                  })
                );

                function locateAndDecode() {
                  return _locateAndDecode.apply(this, arguments);
                }

                return locateAndDecode;
              })(),
            },
            {
              key: "startContinuousUpdate",
              value: function startContinuousUpdate() {
                var _this$context$config4,
                  _this4 = this;

                var next = null;
                var delay =
                  1000 /
                  (((_this$context$config4 = this.context.config) === null ||
                  _this$context$config4 === void 0
                    ? void 0
                    : _this$context$config4.frequency) || 60);
                this.context.stopped = false;
                var context = this.context;

                var newFrame = function newFrame(timestamp) {
                  next = next || timestamp;

                  if (!context.stopped) {
                    if (timestamp >= next) {
                      next += delay;

                      _this4.update();
                    }

                    window.requestAnimationFrame(newFrame);
                  }
                };

                newFrame(performance.now());
              },
            },
            {
              key: "start",
              value: function start() {
                var _this$context$config5, _this$context$config6;

                if (
                  this.context.onUIThread &&
                  ((_this$context$config5 = this.context.config) === null ||
                  _this$context$config5 === void 0
                    ? void 0
                    : (_this$context$config6 =
                        _this$context$config5.inputStream) === null ||
                      _this$context$config6 === void 0
                    ? void 0
                    : _this$context$config6.type) === "LiveStream"
                ) {
                  this.startContinuousUpdate();
                } else {
                  this.update();
                }
              },
            },
            {
              key: "stop",
              value: (function () {
                var _stop = asyncToGenerator_default()(
                  /*#__PURE__*/ regenerator_default.a.mark(function _callee2() {
                    var _this$context$config7;

                    return regenerator_default.a.wrap(
                      function _callee2$(_context2) {
                        while (1) {
                          switch ((_context2.prev = _context2.next)) {
                            case 0:
                              this.context.stopped = true;
                              adjustWorkerPool(0);

                              if (
                                !(
                                  (_this$context$config7 =
                                    this.context.config) !== null &&
                                  _this$context$config7 !== void 0 &&
                                  _this$context$config7.inputStream &&
                                  this.context.config.inputStream.type ===
                                    "LiveStream"
                                )
                              ) {
                                _context2.next = 6;
                                break;
                              }

                              _context2.next = 5;
                              return camera_access.release();

                            case 5:
                              this.context.inputStream.clearEventHandlers();

                            case 6:
                            case "end":
                              return _context2.stop();
                          }
                        }
                      },
                      _callee2,
                      this
                    );
                  })
                );

                function stop() {
                  return _stop.apply(this, arguments);
                }

                return stop;
              })(),
            },
            {
              key: "setReaders",
              value: function setReaders(readers) {
                if (this.context.decoder) {
                  this.context.decoder.setReaders(readers);
                }

                qworker_setReaders(readers);
              },
            },
            {
              key: "registerReader",
              value: function registerReader(name, reader) {
                barcode_decoder.registerReader(name, reader);

                if (this.context.decoder) {
                  this.context.decoder.registerReader(name, reader);
                }

                qworker_registerReader(name, reader);
              },
            },
          ]);

          return Quagga;
        })();

        // CONCATENATED MODULE: ./src/quagga.js

        // eslint-disable-line no-unused-vars

        var instance = new quagga_Quagga();
        var _context = instance.context;
        var QuaggaJSStaticInterface = {
          init: function init(config, cb, imageWrapper) {
            var quaggaInstance =
              arguments.length > 3 && arguments[3] !== undefined
                ? arguments[3]
                : instance;
            var promise;

            if (!cb) {
              promise = new Promise(function (resolve, reject) {
                cb = function cb(err) {
                  err ? reject(err) : resolve();
                };
              });
            }

            quaggaInstance.context.config = merge_default()(
              {},
              config_config,
              config
            ); // TODO #179: pending restructure in Issue #179, we are temp disabling workers

            if (quaggaInstance.context.config.numOfWorkers > 0) {
              quaggaInstance.context.config.numOfWorkers = 0;
            }

            if (imageWrapper) {
              quaggaInstance.context.onUIThread = false;
              quaggaInstance.initializeData(imageWrapper);

              if (cb) {
                cb();
              }
            } else {
              quaggaInstance.initInputStream(cb);
            }

            return promise;
          },
          start: function start() {
            return instance.start();
          },
          stop: function stop() {
            return instance.stop();
          },
          pause: function pause() {
            _context.stopped = true;
          },
          onDetected: function onDetected(callback) {
            if (
              !callback ||
              (typeof callback !== "function" &&
                (typeof_default()(callback) !== "object" || !callback.callback))
            ) {
              console.trace(
                "* warning: Quagga.onDetected called with invalid callback, ignoring"
              );
              return;
            }

            events.subscribe("detected", callback);
          },
          offDetected: function offDetected(callback) {
            events.unsubscribe("detected", callback);
          },
          onProcessed: function onProcessed(callback) {
            if (
              !callback ||
              (typeof callback !== "function" &&
                (typeof_default()(callback) !== "object" || !callback.callback))
            ) {
              console.trace(
                "* warning: Quagga.onProcessed called with invalid callback, ignoring"
              );
              return;
            }

            events.subscribe("processed", callback);
          },
          offProcessed: function offProcessed(callback) {
            events.unsubscribe("processed", callback);
          },
          setReaders: function setReaders(readers) {
            if (!readers) {
              console.trace(
                "* warning: Quagga.setReaders called with no readers, ignoring"
              );
              return;
            }

            instance.setReaders(readers);
          },
          registerReader: function registerReader(name, reader) {
            if (!name) {
              console.trace(
                "* warning: Quagga.registerReader called with no name, ignoring"
              );
              return;
            }

            if (!reader) {
              console.trace(
                "* warning: Quagga.registerReader called with no reader, ignoring"
              );
              return;
            }

            instance.registerReader(name, reader);
          },
          registerResultCollector: function registerResultCollector(
            resultCollector
          ) {
            if (
              resultCollector &&
              typeof resultCollector.addResult === "function"
            ) {
              _context.resultCollector = resultCollector;
            }
          },

          get canvas() {
            return _context.canvasContainer;
          },

          decodeSingle: function decodeSingle(config, resultCallback) {
            var _this = this;

            var quaggaInstance = new quagga_Quagga();
            config = merge_default()(
              {
                inputStream: {
                  type: "ImageStream",
                  sequence: false,
                  size: 800,
                  src: config.src,
                },
                numOfWorkers: true && config.debug ? 0 : 1,
                locator: {
                  halfSample: false,
                },
              },
              config
            ); // TODO #175: restructure worker support so that it will work with typescript using worker-loader
            // https://webpack.js.org/loaders/worker-loader/

            if (config.numOfWorkers > 0) {
              config.numOfWorkers = 0;
            } // workers require Worker and Blob support presently, so if no Blob or Worker then set
            // workers to 0.

            if (
              config.numOfWorkers > 0 &&
              (typeof Blob === "undefined" || typeof Worker === "undefined")
            ) {
              console.warn(
                "* no Worker and/or Blob support - forcing numOfWorkers to 0"
              );
              config.numOfWorkers = 0;
            }

            return new Promise(function (resolve, reject) {
              try {
                _this.init(
                  config,
                  function () {
                    events.once(
                      "processed",
                      function (result) {
                        quaggaInstance.stop();

                        if (resultCallback) {
                          resultCallback.call(null, result);
                        }

                        resolve(result);
                      },
                      true
                    );
                    quaggaInstance.start();
                  },
                  null,
                  quaggaInstance
                );
              } catch (err) {
                reject(err);
              }
            });
          },

          // add the usually expected "default" for use with require, build step won't allow us to
          // write to module.exports so do it here.
          get default() {
            return QuaggaJSStaticInterface;
          },

          Readers: reader_namespaceObject,
          CameraAccess: camera_access,
          ImageDebug: image_debug["a" /* default */],
          ImageWrapper: image_wrapper["a" /* default */],
          ResultCollector: result_collector,
        };
        /* harmony default export */ var quagga = (__webpack_exports__[
          "default"
        ] = QuaggaJSStaticInterface); // export BarcodeReader and other utilities for external plugins

        /***/
      },
      /******/
    ]
  )["default"];
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9RdWFnZ2Evd2VicGFjay91bml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uIiwid2VicGFjazovL1F1YWdnYS93ZWJwYWNrL2Jvb3RzdHJhcCIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9kZWZpbmVQcm9wZXJ0eS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZ2V0UHJvdG90eXBlT2YuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvY2xhc3NDYWxsQ2hlY2suanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvY3JlYXRlQ2xhc3MuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2dsLW1hdHJpeC9lc20vY29tbW9uLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC1tYXRyaXgvZXNtL21hdDIuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2dsLW1hdHJpeC9lc20vdmVjMi5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZ2wtbWF0cml4L2VzbS92ZWMzLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC1tYXRyaXgvZXNtL2luZGV4LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4uanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW5oZXJpdHMuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL3JlZ2VuZXJhdG9yL2luZGV4LmpzIiwid2VicGFjazovL1F1YWdnYS8uL3NyYy9jb21tb24vY2x1c3Rlci5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9zcmMvY29tbW9uL2N2X3V0aWxzLmpzIiwid2VicGFjazovL1F1YWdnYS8uL3NyYy9jb21tb24vaW1hZ2VfZGVidWcudHMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vc3JjL2NvbW1vbi9hcnJheV9oZWxwZXIudHMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vc3JjL2NvbW1vbi9pbWFnZV93cmFwcGVyLnRzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2FzeW5jVG9HZW5lcmF0b3IuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZ2V0LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNPYmplY3QuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9pc0FycmF5LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL3R5cGVvZi5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL21lcmdlLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3Jvb3QuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9pc09iamVjdExpa2UuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vc3JjL2xvY2F0b3IvdHJhY2VyLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VHZXRUYWcuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vc3JjL2xvY2F0b3IvYmFyY29kZV9sb2NhdG9yLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX0xpc3RDYWNoZS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19hc3NvY0luZGV4T2YuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9lcS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19TeW1ib2wuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbmF0aXZlQ3JlYXRlLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2dldE1hcERhdGEuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9pc0FyZ3VtZW50cy5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19pc0luZGV4LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Nhc3RQYXRoLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL3RvQ29uc3VtYWJsZUFycmF5LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2dldE5hdGl2ZS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lzRnVuY3Rpb24uanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUFzc2lnblZhbHVlLmpzIiwid2VicGFjazovL1F1YWdnYS8od2VicGFjaykvYnVpbGRpbi9tb2R1bGUuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9pc0FycmF5TGlrZS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lzTGVuZ3RoLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL3NldFByb3RvdHlwZU9mLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNTeW1ib2wuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fdG9LZXkuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fTWFwLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2ZyZWVHbG9iYWwuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLyh3ZWJwYWNrKS9idWlsZGluL2dsb2JhbC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19NYXBDYWNoZS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19hc3NpZ25NZXJnZVZhbHVlLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2RlZmluZVByb3BlcnR5LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2dldFByb3RvdHlwZS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19pc1Byb3RvdHlwZS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lzQnVmZmVyLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNUeXBlZEFycmF5LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3NhZmVHZXQuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYXNzaWduVmFsdWUuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9rZXlzSW4uanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9pZGVudGl0eS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19vdmVyUmVzdC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19zZXRUb1N0cmluZy5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9hcnJheUxpa2VUb0FycmF5LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL3NsaWNlZFRvQXJyYXkuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9waWNrLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL3dyYXBOYXRpdmVTdXBlci5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9zcmMvbG9jYXRvci9yYXN0ZXJpemVyLmpzIiwid2VicGFjazovL1F1YWdnYS8uL3NyYy9sb2NhdG9yL3NrZWxldG9uaXplci5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlTWVyZ2UuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fU3RhY2suanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbGlzdENhY2hlQ2xlYXIuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbGlzdENhY2hlRGVsZXRlLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2xpc3RDYWNoZUdldC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19saXN0Q2FjaGVIYXMuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbGlzdENhY2hlU2V0LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3N0YWNrQ2xlYXIuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fc3RhY2tEZWxldGUuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fc3RhY2tHZXQuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fc3RhY2tIYXMuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fc3RhY2tTZXQuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUlzTmF0aXZlLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2dldFJhd1RhZy5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19vYmplY3RUb1N0cmluZy5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19pc01hc2tlZC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19jb3JlSnNEYXRhLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3RvU291cmNlLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2dldFZhbHVlLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX21hcENhY2hlQ2xlYXIuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fSGFzaC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19oYXNoQ2xlYXIuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9faGFzaERlbGV0ZS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19oYXNoR2V0LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2hhc2hIYXMuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9faGFzaFNldC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19tYXBDYWNoZURlbGV0ZS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19pc0tleWFibGUuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbWFwQ2FjaGVHZXQuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbWFwQ2FjaGVIYXMuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbWFwQ2FjaGVTZXQuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUZvci5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19jcmVhdGVCYXNlRm9yLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VNZXJnZURlZXAuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fY2xvbmVCdWZmZXIuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fY2xvbmVUeXBlZEFycmF5LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Nsb25lQXJyYXlCdWZmZXIuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fVWludDhBcnJheS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19jb3B5QXJyYXkuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9faW5pdENsb25lT2JqZWN0LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VDcmVhdGUuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fb3ZlckFyZy5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlSXNBcmd1bWVudHMuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9pc0FycmF5TGlrZU9iamVjdC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL3N0dWJGYWxzZS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lzUGxhaW5PYmplY3QuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUlzVHlwZWRBcnJheS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlVW5hcnkuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbm9kZVV0aWwuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC90b1BsYWluT2JqZWN0LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2NvcHlPYmplY3QuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYXJyYXlMaWtlS2V5cy5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlVGltZXMuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUtleXNJbi5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19uYXRpdmVLZXlzSW4uanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fY3JlYXRlQXNzaWduZXIuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZVJlc3QuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYXBwbHkuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZVNldFRvU3RyaW5nLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvY29uc3RhbnQuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fc2hvcnRPdXQuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9faXNJdGVyYXRlZUNhbGwuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vc3JjL2NvbW1vbi90eXBlZGVmcy5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9hcnJheVdpdGhIb2xlcy5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pdGVyYWJsZVRvQXJyYXlMaW1pdC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9ub25JdGVyYWJsZVJlc3QuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvcmVnZW5lcmF0b3JSdW50aW1lLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL3N1cGVyUHJvcEJhc2UuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvYXJyYXlXaXRob3V0SG9sZXMuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvaXRlcmFibGVUb0FycmF5LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL25vbkl0ZXJhYmxlU3ByZWFkLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VQaWNrLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VQaWNrQnkuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUdldC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19pc0tleS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19zdHJpbmdUb1BhdGguanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbWVtb2l6ZUNhcHBlZC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL21lbW9pemUuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC90b1N0cmluZy5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlVG9TdHJpbmcuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYXJyYXlNYXAuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZVNldC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL2hhc0luLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VIYXNJbi5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19oYXNQYXRoLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2ZsYXRSZXN0LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvZmxhdHRlbi5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlRmxhdHRlbi5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19hcnJheVB1c2guanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9faXNGbGF0dGVuYWJsZS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pc05hdGl2ZUZ1bmN0aW9uLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2NvbnN0cnVjdC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vc3JjL3JlYWRlci9iYXJjb2RlX3JlYWRlci50cyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9zcmMvcmVhZGVyLzJvZjVfcmVhZGVyLnRzIiwid2VicGFjazovL1F1YWdnYS8uL3NyYy9yZWFkZXIvY29kYWJhcl9yZWFkZXIudHMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vc3JjL3JlYWRlci9jb2RlXzEyOF9yZWFkZXIudHMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vc3JjL3JlYWRlci9jb2RlXzM5X3JlYWRlci50cyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9zcmMvcmVhZGVyL2NvZGVfMzJfcmVhZGVyLnRzIiwid2VicGFjazovL1F1YWdnYS8uL3NyYy9yZWFkZXIvY29kZV8zOV92aW5fcmVhZGVyLnRzIiwid2VicGFjazovL1F1YWdnYS8uL3NyYy9yZWFkZXIvY29kZV85M19yZWFkZXIudHMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vc3JjL3JlYWRlci9lYW5fcmVhZGVyLnRzIiwid2VicGFjazovL1F1YWdnYS8uL3NyYy9yZWFkZXIvZWFuXzJfcmVhZGVyLnRzIiwid2VicGFjazovL1F1YWdnYS8uL3NyYy9yZWFkZXIvZWFuXzVfcmVhZGVyLnRzIiwid2VicGFjazovL1F1YWdnYS8uL3NyYy9yZWFkZXIvZWFuXzhfcmVhZGVyLnRzIiwid2VicGFjazovL1F1YWdnYS8uL3NyYy9yZWFkZXIvaTJvZjVfcmVhZGVyLnRzIiwid2VicGFjazovL1F1YWdnYS8uL3NyYy9yZWFkZXIvdXBjX2VfcmVhZGVyLnRzIiwid2VicGFjazovL1F1YWdnYS8uL3NyYy9yZWFkZXIvdXBjX3JlYWRlci50cyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9zcmMvZGVjb2Rlci9icmVzZW5oYW0uanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vc3JjL2RlY29kZXIvYmFyY29kZV9kZWNvZGVyLmpzIiwid2VicGFjazovL1F1YWdnYS8uL3NyYy9yZWFkZXIvaW5kZXgudHMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vc3JjL2NvbW1vbi9ldmVudHMudHMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vc3JjL3F1YWdnYS9FeGNlcHRpb24udHMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vc3JjL2NvbW1vbi9tZWRpYURldmljZXMudHMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vc3JjL2lucHV0L2NhbWVyYV9hY2Nlc3MudHMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vc3JjL2FuYWx5dGljcy9yZXN1bHRfY29sbGVjdG9yLnRzIiwid2VicGFjazovL1F1YWdnYS8uL3NyYy9jb25maWcvY29uZmlnLmRldi50cyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9zcmMvY29uZmlnL2NvbmZpZy5ub2RlLnRzIiwid2VicGFjazovL1F1YWdnYS8uL3NyYy9jb25maWcvY29uZmlnLnByb2QudHMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vc3JjL2NvbmZpZy9jb25maWcudHMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vc3JjL2lucHV0L2ZyYW1lX2dyYWJiZXJfYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9zcmMvaW5wdXQvZXhpZl9oZWxwZXIuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vc3JjL2lucHV0L2ltYWdlX2xvYWRlci5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9zcmMvaW5wdXQvaW5wdXRfc3RyZWFtL2lucHV0X3N0cmVhbV9icm93c2VyLnRzIiwid2VicGFjazovL1F1YWdnYS8uL3NyYy9RdWFnZ2FDb250ZXh0LnRzIiwid2VicGFjazovL1F1YWdnYS8uL3NyYy9xdWFnZ2EvZ2V0Vmlld1BvcnQudHMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vc3JjL3F1YWdnYS9pbml0QnVmZmVycy50cyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9zcmMvcXVhZ2dhL2luaXRDYW52YXMudHMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vc3JjL3F1YWdnYS9xd29ya2VyLnRzIiwid2VicGFjazovL1F1YWdnYS8uL3NyYy9xdWFnZ2Evc2V0dXBJbnB1dFN0cmVhbS50cyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9zcmMvcXVhZ2dhL3RyYW5zZm9ybS50cyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9zcmMvcXVhZ2dhL3F1YWdnYS50cyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9zcmMvcXVhZ2dhLmpzIl0sIm5hbWVzIjpbIl9kZWZpbmVQcm9wZXJ0eSIsIm9iaiIsImtleSIsInZhbHVlIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJlbnVtZXJhYmxlIiwiY29uZmlndXJhYmxlIiwid3JpdGFibGUiLCJtb2R1bGUiLCJleHBvcnRzIiwiX19lc01vZHVsZSIsIl9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQiLCJzZWxmIiwiUmVmZXJlbmNlRXJyb3IiLCJfZ2V0UHJvdG90eXBlT2YiLCJvIiwic2V0UHJvdG90eXBlT2YiLCJnZXRQcm90b3R5cGVPZiIsImJpbmQiLCJfX3Byb3RvX18iLCJfY2xhc3NDYWxsQ2hlY2siLCJpbnN0YW5jZSIsIkNvbnN0cnVjdG9yIiwiVHlwZUVycm9yIiwiX2RlZmluZVByb3BlcnRpZXMiLCJ0YXJnZXQiLCJwcm9wcyIsImkiLCJsZW5ndGgiLCJkZXNjcmlwdG9yIiwiX2NyZWF0ZUNsYXNzIiwicHJvdG9Qcm9wcyIsInN0YXRpY1Byb3BzIiwicHJvdG90eXBlIiwiRVBTSUxPTiIsIkFSUkFZX1RZUEUiLCJGbG9hdDMyQXJyYXkiLCJBcnJheSIsIlJBTkRPTSIsIk1hdGgiLCJyYW5kb20iLCJzZXRNYXRyaXhBcnJheVR5cGUiLCJ0eXBlIiwiZGVncmVlIiwiUEkiLCJ0b1JhZGlhbiIsImEiLCJlcXVhbHMiLCJiIiwiYWJzIiwibWF4IiwiaHlwb3QiLCJ5IiwiYXJndW1lbnRzIiwic3FydCIsImNyZWF0ZSIsIm91dCIsImdsTWF0cml4IiwiY2xvbmUiLCJjb3B5IiwiaWRlbnRpdHkiLCJmcm9tVmFsdWVzIiwibTAwIiwibTAxIiwibTEwIiwibTExIiwic2V0IiwidHJhbnNwb3NlIiwiYTEiLCJpbnZlcnQiLCJhMCIsImEyIiwiYTMiLCJkZXQiLCJhZGpvaW50IiwiZGV0ZXJtaW5hbnQiLCJtdWx0aXBseSIsImIwIiwiYjEiLCJiMiIsImIzIiwicm90YXRlIiwicmFkIiwicyIsInNpbiIsImMiLCJjb3MiLCJzY2FsZSIsInYiLCJ2MCIsInYxIiwiZnJvbVJvdGF0aW9uIiwiZnJvbVNjYWxpbmciLCJzdHIiLCJmcm9iIiwiTERVIiwiTCIsIkQiLCJVIiwiYWRkIiwic3VidHJhY3QiLCJleGFjdEVxdWFscyIsIm11bHRpcGx5U2NhbGFyIiwibXVsdGlwbHlTY2FsYXJBbmRBZGQiLCJtdWwiLCJzdWIiLCJ4IiwiZGl2aWRlIiwiY2VpbCIsImZsb29yIiwibWluIiwicm91bmQiLCJzY2FsZUFuZEFkZCIsImRpc3RhbmNlIiwic3F1YXJlZERpc3RhbmNlIiwic3F1YXJlZExlbmd0aCIsIm5lZ2F0ZSIsImludmVyc2UiLCJub3JtYWxpemUiLCJsZW4iLCJkb3QiLCJjcm9zcyIsInoiLCJsZXJwIiwidCIsImF4IiwiYXkiLCJyIiwidHJhbnNmb3JtTWF0MiIsIm0iLCJ0cmFuc2Zvcm1NYXQyZCIsInRyYW5zZm9ybU1hdDMiLCJ0cmFuc2Zvcm1NYXQ0IiwicDAiLCJwMSIsInNpbkMiLCJjb3NDIiwiYW5nbGUiLCJ4MSIsInkxIiwieDIiLCJ5MiIsIm1hZyIsImNvc2luZSIsImFjb3MiLCJ6ZXJvIiwiZGl2IiwiZGlzdCIsInNxckRpc3QiLCJzcXJMZW4iLCJmb3JFYWNoIiwidmVjIiwic3RyaWRlIiwib2Zmc2V0IiwiY291bnQiLCJmbiIsImFyZyIsImwiLCJheiIsImJ4IiwiYnkiLCJieiIsImhlcm1pdGUiLCJkIiwiZmFjdG9yVGltZXMyIiwiZmFjdG9yMSIsImZhY3RvcjIiLCJmYWN0b3IzIiwiZmFjdG9yNCIsImJlemllciIsImludmVyc2VGYWN0b3IiLCJpbnZlcnNlRmFjdG9yVGltZXNUd28iLCJ6U2NhbGUiLCJ3IiwidHJhbnNmb3JtUXVhdCIsInEiLCJxeCIsInF5IiwicXoiLCJxdyIsInV2eCIsInV2eSIsInV2eiIsInV1dngiLCJ1dXZ5IiwidXV2eiIsIncyIiwicm90YXRlWCIsInAiLCJyb3RhdGVZIiwicm90YXRlWiIsIm1hZzEiLCJtYWcyIiwiX3R5cGVvZiIsInJlcXVpcmUiLCJhc3NlcnRUaGlzSW5pdGlhbGl6ZWQiLCJfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybiIsImNhbGwiLCJfaW5oZXJpdHMiLCJzdWJDbGFzcyIsInN1cGVyQ2xhc3MiLCJjb25zdHJ1Y3RvciIsInJ1bnRpbWUiLCJyZWdlbmVyYXRvclJ1bnRpbWUiLCJhY2NpZGVudGFsU3RyaWN0TW9kZSIsImdsb2JhbFRoaXMiLCJGdW5jdGlvbiIsInBvaW50IiwidGhyZXNob2xkIiwicG9pbnRzIiwiY2VudGVyIiwidmVjMiIsInBvaW50TWFwIiwicG9pbnRUb0FkZCIsImlkIiwicHVzaCIsInVwZGF0ZUNlbnRlciIsInN1bSIsImluaXQiLCJmaXRzIiwib3RoZXJQb2ludCIsInNpbWlsYXJpdHkiLCJnZXRQb2ludHMiLCJnZXRDZW50ZXIiLCJjcmVhdGVQb2ludCIsIm5ld1BvaW50IiwicHJvcGVydHkiLCJpbWFnZVJlZiIsInRoYXQiLCJ0b1ZlYzIiLCJ0b1ZlYzMiLCJ2ZWMzIiwiY29tcHV0ZUludGVncmFsSW1hZ2UyIiwiaW1hZ2VXcmFwcGVyIiwiaW50ZWdyYWxXcmFwcGVyIiwiaW1hZ2VEYXRhIiwiZGF0YSIsIndpZHRoIiwic2l6ZSIsImhlaWdodCIsImludGVncmFsSW1hZ2VEYXRhIiwicG9zQSIsInBvc0IiLCJwb3NDIiwicG9zRCIsImNvbXB1dGVJbnRlZ3JhbEltYWdlIiwidSIsInRocmVzaG9sZEltYWdlIiwidGFyZ2V0V3JhcHBlciIsInRhcmdldERhdGEiLCJjb21wdXRlSGlzdG9ncmFtIiwiYml0c1BlclBpeGVsIiwiYml0U2hpZnQiLCJidWNrZXRDbnQiLCJoaXN0IiwiSW50MzJBcnJheSIsInNoYXJwZW5MaW5lIiwibGluZSIsImxlZnQiLCJyaWdodCIsImRldGVybWluZU90c3VUaHJlc2hvbGQiLCJweCIsImVuZCIsIm14IiwiZGV0ZXJtaW5lVGhyZXNob2xkIiwidmV0IiwicDIiLCJwMTIiLCJtMSIsIm0yIiwibTEyIiwiayIsIkFycmF5SGVscGVyIiwibWF4SW5kZXgiLCJvdHN1VGhyZXNob2xkIiwiY29tcHV0ZUJpbmFyeUltYWdlIiwia2VybmVsIiwiQSIsIkIiLCJDIiwiYXZnIiwiY2x1c3RlciIsInRoaXNDbHVzdGVyIiwiY2x1c3RlcnMiLCJhZGRUb0NsdXN0ZXIiLCJmb3VuZCIsIkNsdXN0ZXIyIiwiVHJhY2VyIiwidHJhY2UiLCJpdGVyYXRpb24iLCJtYXhJdGVyYXRpb25zIiwidG9wIiwicmVzdWx0IiwiY2VudGVyUG9zIiwiY3VycmVudFBvcyIsImlkeCIsImZvcndhcmQiLCJ0byIsInRvSWR4IiwicHJlZGljdGVkUG9zIiwidGhyZXNob2xkWCIsInRocmVzaG9sZFkiLCJtYXRjaCIsInBvcyIsInByZWRpY3RlZCIsImZyb20iLCJESUxBVEUiLCJFUk9ERSIsImRpbGF0ZSIsImluSW1hZ2VXcmFwcGVyIiwib3V0SW1hZ2VXcmFwcGVyIiwiaW5JbWFnZURhdGEiLCJvdXRJbWFnZURhdGEiLCJ5U3RhcnQxIiwieVN0YXJ0MiIsInhTdGFydDEiLCJ4U3RhcnQyIiwiZXJvZGUiLCJhSW1hZ2VXcmFwcGVyIiwiYkltYWdlV3JhcHBlciIsInJlc3VsdEltYWdlV3JhcHBlciIsImFJbWFnZURhdGEiLCJiSW1hZ2VEYXRhIiwiY0ltYWdlRGF0YSIsImJpdHdpc2VPciIsImNvdW50Tm9uWmVybyIsInRvcEdlbmVyaWMiLCJsaXN0Iiwic2NvcmVGdW5jIiwibWluSWR4IiwicXVldWUiLCJzY29yZSIsImhpdCIsIml0ZW0iLCJhcHBseSIsIk51bWJlciIsIk1BWF9WQUxVRSIsImdyYXlBcnJheUZyb21JbWFnZSIsImh0bWxJbWFnZSIsIm9mZnNldFgiLCJjdHgiLCJhcnJheSIsImRyYXdJbWFnZSIsImN0eERhdGEiLCJnZXRJbWFnZURhdGEiLCJjb21wdXRlR3JheSIsImdyYXlBcnJheUZyb21Db250ZXh0IiwiZ3JheUFuZEhhbGZTYW1wbGVGcm9tQ2FudmFzRGF0YSIsImNhbnZhc0RhdGEiLCJvdXRBcnJheSIsInRvcFJvd0lkeCIsImJvdHRvbVJvd0lkeCIsImVuZElkeCIsIm91dFdpZHRoIiwib3V0SW1nSWR4IiwiaW5XaWR0aCIsImNvbmZpZyIsInNpbmdsZUNoYW5uZWwiLCJsb2FkSW1hZ2VBcnJheSIsInNyYyIsImNhbGxiYWNrIiwiY2FudmFzIiwiZG9jdW1lbnQiLCJjcmVhdGVFbGVtZW50IiwiaW1nIiwiSW1hZ2UiLCJvbmxvYWQiLCJnZXRDb250ZXh0IiwiVWludDhBcnJheSIsImhhbGZTYW1wbGUiLCJpbkltZ1dyYXBwZXIiLCJvdXRJbWdXcmFwcGVyIiwiaW5JbWciLCJvdXRJbWciLCJoc3YycmdiIiwiaHN2IiwicmdiIiwiaCIsImciLCJfY29tcHV0ZURpdmlzb3JzIiwibiIsImxhcmdlRGl2aXNvcnMiLCJkaXZpc29ycyIsInVuc2hpZnQiLCJjb25jYXQiLCJfY29tcHV0ZUludGVyc2VjdGlvbiIsImFycjEiLCJhcnIyIiwiaiIsImNhbGN1bGF0ZVBhdGNoU2l6ZSIsInBhdGNoU2l6ZSIsImltZ1NpemUiLCJkaXZpc29yc1giLCJkaXZpc29yc1kiLCJ3aWRlU2lkZSIsImNvbW1vbiIsIm5yT2ZQYXRjaGVzTGlzdCIsIm5yT2ZQYXRjaGVzTWFwIiwic21hbGwiLCJtZWRpdW0iLCJsYXJnZSIsIm5yT2ZQYXRjaGVzSWR4IiwibnJPZlBhdGNoZXMiLCJkZXNpcmVkUGF0Y2hTaXplIiwib3B0aW1hbFBhdGNoU2l6ZSIsImZpbmRQYXRjaFNpemVGb3JEaXZpc29ycyIsIl9wYXJzZUNTU0RpbWVuc2lvblZhbHVlcyIsImRpbWVuc2lvbiIsInBhcnNlRmxvYXQiLCJ1bml0IiwiaW5kZXhPZiIsIl9kaW1lbnNpb25zQ29udmVydGVycyIsImNvbnRleHQiLCJib3R0b20iLCJjb21wdXRlSW1hZ2VBcmVhIiwiaW5wdXRXaWR0aCIsImlucHV0SGVpZ2h0IiwiYXJlYSIsInBhcnNlZEFyZWEiLCJrZXlzIiwicmVkdWNlIiwicGFyc2VkIiwiY2FsY3VsYXRlZCIsInN4Iiwic3kiLCJzdyIsInNoIiwiZHJhd1JlY3QiLCJzdHlsZSIsInN0cm9rZVN0eWxlIiwiY29sb3IiLCJmaWxsU3R5bGUiLCJsaW5lV2lkdGgiLCJiZWdpblBhdGgiLCJzdHJva2VSZWN0IiwiZHJhd1BhdGgiLCJwYXRoIiwiZGVmIiwibW92ZVRvIiwibGluZVRvIiwiY2xvc2VQYXRoIiwic3Ryb2tlIiwiY2FudmFzRGF0YVBvcyIsImltYWdlRGF0YVBvcyIsInB1dEltYWdlRGF0YSIsImFyciIsInZhbCIsImZpbGwiLCJzaHVmZmxlIiwidG9Qb2ludExpc3QiLCJyb3dzIiwicm93Iiwiam9pbiIsInByZXYiLCJuZXh0IiwiYXNzZXJ0TnVtYmVyUG9zaXRpdmUiLCJFcnJvciIsIkltYWdlV3JhcHBlciIsIkFycmF5VHlwZSIsImluaXRpYWxpemUiLCJpbWdSZWYiLCJib3JkZXIiLCJzaXplWCIsInNpemVZIiwiaW5kZXhNYXBwaW5nIiwibGFiZWxDb3VudCIsInlzcSIsImxhYmVsU3VtIiwibGFiZWwiLCJtdTExIiwibXUwMiIsIm11MjAiLCJ4XyIsInlfIiwidG1wIiwiUElfNCIsIm0wMiIsIm0yMCIsInRoZXRhIiwiaXNOYU4iLCJhdGFuIiwicmV0IiwiVWludDhDbGFtcGVkQXJyYXkiLCJwaXhlbCIsImN1cnJlbnQiLCJnZXQiLCJmcmFtZSIsImdldEFzUkdCQSIsIm5ld0ZyYW1lIiwiSW1hZ2VEYXRhIiwiaW5TY2FsZSIsImFkanVzdGVkU2NhbGUiLCJ3aGl0ZVJnYiIsImJsYWNrUmdiIiwiYXN5bmNHZW5lcmF0b3JTdGVwIiwiZ2VuIiwicmVzb2x2ZSIsInJlamVjdCIsIl9uZXh0IiwiX3Rocm93IiwiaW5mbyIsImVycm9yIiwiZG9uZSIsIlByb21pc2UiLCJ0aGVuIiwiX2FzeW5jVG9HZW5lcmF0b3IiLCJhcmdzIiwiZXJyIiwidW5kZWZpbmVkIiwic3VwZXJQcm9wQmFzZSIsIl9nZXQiLCJSZWZsZWN0IiwicmVjZWl2ZXIiLCJiYXNlIiwiZGVzYyIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsImlzT2JqZWN0IiwiaXNBcnJheSIsIlN5bWJvbCIsIml0ZXJhdG9yIiwiYmFzZU1lcmdlIiwiY3JlYXRlQXNzaWduZXIiLCJtZXJnZSIsIm9iamVjdCIsInNvdXJjZSIsInNyY0luZGV4IiwiZnJlZUdsb2JhbCIsImZyZWVTZWxmIiwicm9vdCIsImlzT2JqZWN0TGlrZSIsInNlYXJjaERpcmVjdGlvbnMiLCJsYWJlbFdyYXBwZXIiLCJsYWJlbERhdGEiLCJlZGdlbGFiZWwiLCJjeSIsImRpciIsImN4IiwidmVydGV4MkQiLCJjb250b3VyVHJhY2luZyIsIkZ2IiwiQ3YiLCJQIiwibGRpciIsInRvdGFsUGl4ZWxDb3VudCIsInBpeGVsQ291bnRlciIsImdldFJhd1RhZyIsIm9iamVjdFRvU3RyaW5nIiwibnVsbFRhZyIsInVuZGVmaW5lZFRhZyIsInN5bVRvU3RyaW5nVGFnIiwidG9TdHJpbmdUYWciLCJiYXNlR2V0VGFnIiwiX2NvbmZpZyIsIl9jdXJyZW50SW1hZ2VXcmFwcGVyIiwiX3NrZWxJbWFnZVdyYXBwZXIiLCJfc3ViSW1hZ2VXcmFwcGVyIiwiX2xhYmVsSW1hZ2VXcmFwcGVyIiwiX3BhdGNoR3JpZCIsIl9wYXRjaExhYmVsR3JpZCIsIl9pbWFnZVRvUGF0Y2hHcmlkIiwiX2JpbmFyeUltYWdlV3JhcHBlciIsIl9wYXRjaFNpemUiLCJfY2FudmFzQ29udGFpbmVyIiwiYmluYXJ5IiwiZG9tIiwiX251bVBhdGNoZXMiLCJfaW5wdXRJbWFnZVdyYXBwZXIiLCJfc2tlbGV0b25pemVyIiwiaW5pdEJ1ZmZlcnMiLCJza2VsZXRvbkltYWdlRGF0YSIsIkFycmF5QnVmZmVyIiwic2tlbGV0b25pemVyIiwid2luZG93IiwiZ2xvYmFsIiwiaW5pdENhbnZhcyIsInVzZVdvcmtlciIsImNsYXNzTmFtZSIsIkVOViIsImRlYnVnIiwic2hvd0NhbnZhcyIsInF1ZXJ5U2VsZWN0b3IiLCJhcHBlbmRDaGlsZCIsImJveEZyb21QYXRjaGVzIiwicGF0Y2hlcyIsIm92ZXJBdmciLCJwYXRjaCIsInRyYW5zTWF0IiwibWlueCIsIm1pbnkiLCJtYXh4IiwibWF4eSIsImJveCIsInNob3dQYXRjaGVzIiwiSW1hZ2VEZWJ1ZyIsIm1hdDIiLCJzaG93VHJhbnNmb3JtZWQiLCJzaG93VHJhbnNmb3JtZWRCb3giLCJzaG93QkIiLCJiaW5hcml6ZUltYWdlIiwiemVyb0JvcmRlciIsInNob3ciLCJmaW5kUGF0Y2hlcyIsIm1vbWVudHMiLCJwYXRjaGVzRm91bmQiLCJyYXN0ZXJpemVyIiwicmFzdGVyUmVzdWx0Iiwic2tlbGV0b25pemUiLCJSYXN0ZXJpemVyIiwicmFzdGVyaXplIiwic2hvd0xhYmVscyIsIm92ZXJsYXkiLCJkZXNjcmliZVBhdGNoIiwic2hvd0ZvdW5kUGF0Y2hlcyIsImZpbmRCaWdnZXN0Q29ubmVjdGVkQXJlYXMiLCJtYXhMYWJlbCIsImxhYmVsSGlzdCIsInRvcExhYmVscyIsIm1hcCIsInNvcnQiLCJmaWx0ZXIiLCJlbCIsImZpbmRCb3hlcyIsImJveGVzIiwic2hvd1JlbWFpbmluZ1BhdGNoTGFiZWxzIiwic2ltaWxhck1vbWVudHMiLCJ0b3BDbHVzdGVyIiwiZSIsInN1YkltYWdlQXNDb3B5Iiwic2hvd1NrZWxldG9uIiwicGF0Y2hQb3MiLCJlbGlnaWJsZU1vbWVudHMiLCJtYXRjaGluZ01vbWVudHMiLCJtaW5Db21wb25lbnRXZWlnaHQiLCJpbmRleCIsInJhc3Rlcml6ZUFuZ3VsYXJTaW1pbGFyaXR5IiwiY3VycklkeCIsIm5vdFlldFByb2Nlc3NlZCIsImN1cnJlbnRJZHgiLCJjdXJyZW50UGF0Y2giLCJzaG93UGF0Y2hMYWJlbHMiLCJpbnB1dEltYWdlV3JhcHBlciIsImxvY2F0ZSIsImNoZWNrSW1hZ2VDb25zdHJhaW50cyIsImlucHV0U3RyZWFtIiwiZ2V0V2lkdGgiLCJnZXRIZWlnaHQiLCJ0aGlzSGFsZlNhbXBsZSIsImdldENvbmZpZyIsInNldFRvcFJpZ2h0Iiwic2V0Q2FudmFzU2l6ZSIsImNvbnNvbGUiLCJsb2ciLCJKU09OIiwic3RyaW5naWZ5Iiwic2V0V2lkdGgiLCJzZXRIZWlnaHQiLCJsaXN0Q2FjaGVDbGVhciIsImxpc3RDYWNoZURlbGV0ZSIsImxpc3RDYWNoZUdldCIsImxpc3RDYWNoZUhhcyIsImxpc3RDYWNoZVNldCIsIkxpc3RDYWNoZSIsImVudHJpZXMiLCJjbGVhciIsImVudHJ5IiwiaGFzIiwiZXEiLCJhc3NvY0luZGV4T2YiLCJvdGhlciIsImdldE5hdGl2ZSIsIm5hdGl2ZUNyZWF0ZSIsImlzS2V5YWJsZSIsImdldE1hcERhdGEiLCJfX2RhdGFfXyIsImJhc2VJc0FyZ3VtZW50cyIsIm9iamVjdFByb3RvIiwiaGFzT3duUHJvcGVydHkiLCJwcm9wZXJ0eUlzRW51bWVyYWJsZSIsImlzQXJndW1lbnRzIiwiTUFYX1NBRkVfSU5URUdFUiIsInJlSXNVaW50IiwiaXNJbmRleCIsInRlc3QiLCJpc0tleSIsInN0cmluZ1RvUGF0aCIsInRvU3RyaW5nIiwiY2FzdFBhdGgiLCJhcnJheVdpdGhvdXRIb2xlcyIsIml0ZXJhYmxlVG9BcnJheSIsInVuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5Iiwibm9uSXRlcmFibGVTcHJlYWQiLCJfdG9Db25zdW1hYmxlQXJyYXkiLCJiYXNlSXNOYXRpdmUiLCJnZXRWYWx1ZSIsImFzeW5jVGFnIiwiZnVuY1RhZyIsImdlblRhZyIsInByb3h5VGFnIiwiaXNGdW5jdGlvbiIsInRhZyIsImJhc2VBc3NpZ25WYWx1ZSIsIndlYnBhY2tQb2x5ZmlsbCIsImRlcHJlY2F0ZSIsInBhdGhzIiwiY2hpbGRyZW4iLCJpc0xlbmd0aCIsImlzQXJyYXlMaWtlIiwiX3NldFByb3RvdHlwZU9mIiwic3ltYm9sVGFnIiwiaXNTeW1ib2wiLCJJTkZJTklUWSIsInRvS2V5IiwiTWFwIiwibWFwQ2FjaGVDbGVhciIsIm1hcENhY2hlRGVsZXRlIiwibWFwQ2FjaGVHZXQiLCJtYXBDYWNoZUhhcyIsIm1hcENhY2hlU2V0IiwiTWFwQ2FjaGUiLCJhc3NpZ25NZXJnZVZhbHVlIiwiZnVuYyIsIm92ZXJBcmciLCJnZXRQcm90b3R5cGUiLCJpc1Byb3RvdHlwZSIsIkN0b3IiLCJwcm90byIsInN0dWJGYWxzZSIsImZyZWVFeHBvcnRzIiwibm9kZVR5cGUiLCJmcmVlTW9kdWxlIiwibW9kdWxlRXhwb3J0cyIsIkJ1ZmZlciIsIm5hdGl2ZUlzQnVmZmVyIiwiaXNCdWZmZXIiLCJiYXNlSXNUeXBlZEFycmF5IiwiYmFzZVVuYXJ5Iiwibm9kZVV0aWwiLCJub2RlSXNUeXBlZEFycmF5IiwiaXNUeXBlZEFycmF5Iiwic2FmZUdldCIsImFzc2lnblZhbHVlIiwib2JqVmFsdWUiLCJhcnJheUxpa2VLZXlzIiwiYmFzZUtleXNJbiIsImtleXNJbiIsIm5hdGl2ZU1heCIsIm92ZXJSZXN0Iiwic3RhcnQiLCJ0cmFuc2Zvcm0iLCJvdGhlckFyZ3MiLCJiYXNlU2V0VG9TdHJpbmciLCJzaG9ydE91dCIsInNldFRvU3RyaW5nIiwiYXJyYXlMaWtlVG9BcnJheSIsIl91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSIsIm1pbkxlbiIsInNsaWNlIiwibmFtZSIsIl9hcnJheUxpa2VUb0FycmF5IiwiYXJyYXlXaXRoSG9sZXMiLCJpdGVyYWJsZVRvQXJyYXlMaW1pdCIsIm5vbkl0ZXJhYmxlUmVzdCIsIl9zbGljZWRUb0FycmF5IiwiYmFzZVBpY2siLCJmbGF0UmVzdCIsInBpY2siLCJpc05hdGl2ZUZ1bmN0aW9uIiwiY29uc3RydWN0IiwiX3dyYXBOYXRpdmVTdXBlciIsIkNsYXNzIiwiX2NhY2hlIiwiV3JhcHBlciIsImNyZWF0ZUNvbnRvdXIyRCIsImZpcnN0VmVydGV4IiwiaW5zaWRlQ29udG91cnMiLCJuZXh0cGVlciIsInByZXZwZWVyIiwiQ09OVE9VUl9ESVIiLCJDV19ESVIiLCJDQ1dfRElSIiwiVU5LTk9XTl9ESVIiLCJESVIiLCJPVVRTSURFX0VER0UiLCJJTlNJREVfRURHRSIsInRyYWNlciIsImRlcHRobGFiZWwiLCJiYyIsImxjIiwibGFiZWxpbmRleCIsImNvbG9yTWFwIiwidmVydGV4IiwiY2MiLCJzYyIsImNvbm5lY3RlZENvdW50IiwiZHJhd0NvbnRvdXIiLCJmaXJzdENvbnRvdXIiLCJwcSIsImlxIiwiU2tlbGV0b25pemVyIiwic3RkbGliIiwiZm9yZWlnbiIsImJ1ZmZlciIsImltYWdlcyIsImltdWwiLCJpbkltYWdlUHRyIiwib3V0SW1hZ2VQdHIiLCJhSW1hZ2VQdHIiLCJiSW1hZ2VQdHIiLCJpbWFnZVB0ciIsIm1lbWNweSIsInNyY0ltYWdlUHRyIiwiZHN0SW1hZ2VQdHIiLCJzdWJJbWFnZVB0ciIsImVyb2RlZEltYWdlUHRyIiwidGVtcEltYWdlUHRyIiwic2tlbEltYWdlUHRyIiwiU3RhY2siLCJiYXNlRm9yIiwiYmFzZU1lcmdlRGVlcCIsImN1c3RvbWl6ZXIiLCJzdGFjayIsInNyY1ZhbHVlIiwibmV3VmFsdWUiLCJzdGFja0NsZWFyIiwic3RhY2tEZWxldGUiLCJzdGFja0dldCIsInN0YWNrSGFzIiwic3RhY2tTZXQiLCJhcnJheVByb3RvIiwic3BsaWNlIiwibGFzdEluZGV4IiwicG9wIiwiTEFSR0VfQVJSQVlfU0laRSIsInBhaXJzIiwiaXNNYXNrZWQiLCJ0b1NvdXJjZSIsInJlUmVnRXhwQ2hhciIsInJlSXNIb3N0Q3RvciIsImZ1bmNQcm90byIsImZ1bmNUb1N0cmluZyIsInJlSXNOYXRpdmUiLCJSZWdFeHAiLCJyZXBsYWNlIiwicGF0dGVybiIsIm5hdGl2ZU9iamVjdFRvU3RyaW5nIiwiaXNPd24iLCJ1bm1hc2tlZCIsImNvcmVKc0RhdGEiLCJtYXNrU3JjS2V5IiwidWlkIiwiZXhlYyIsIklFX1BST1RPIiwiSGFzaCIsImhhc2hDbGVhciIsImhhc2hEZWxldGUiLCJoYXNoR2V0IiwiaGFzaEhhcyIsImhhc2hTZXQiLCJIQVNIX1VOREVGSU5FRCIsImNyZWF0ZUJhc2VGb3IiLCJmcm9tUmlnaHQiLCJpdGVyYXRlZSIsImtleXNGdW5jIiwiaXRlcmFibGUiLCJjbG9uZUJ1ZmZlciIsImNsb25lVHlwZWRBcnJheSIsImNvcHlBcnJheSIsImluaXRDbG9uZU9iamVjdCIsImlzQXJyYXlMaWtlT2JqZWN0IiwiaXNQbGFpbk9iamVjdCIsInRvUGxhaW5PYmplY3QiLCJtZXJnZUZ1bmMiLCJzdGFja2VkIiwiaXNDb21tb24iLCJpc0FyciIsImlzQnVmZiIsImlzVHlwZWQiLCJhbGxvY1Vuc2FmZSIsImlzRGVlcCIsImNsb25lQXJyYXlCdWZmZXIiLCJ0eXBlZEFycmF5IiwiYnl0ZU9mZnNldCIsImFycmF5QnVmZmVyIiwiYnl0ZUxlbmd0aCIsImJhc2VDcmVhdGUiLCJvYmplY3RDcmVhdGUiLCJhcmdzVGFnIiwib2JqZWN0VGFnIiwib2JqZWN0Q3RvclN0cmluZyIsImFycmF5VGFnIiwiYm9vbFRhZyIsImRhdGVUYWciLCJlcnJvclRhZyIsIm1hcFRhZyIsIm51bWJlclRhZyIsInJlZ2V4cFRhZyIsInNldFRhZyIsInN0cmluZ1RhZyIsIndlYWtNYXBUYWciLCJhcnJheUJ1ZmZlclRhZyIsImRhdGFWaWV3VGFnIiwiZmxvYXQzMlRhZyIsImZsb2F0NjRUYWciLCJpbnQ4VGFnIiwiaW50MTZUYWciLCJpbnQzMlRhZyIsInVpbnQ4VGFnIiwidWludDhDbGFtcGVkVGFnIiwidWludDE2VGFnIiwidWludDMyVGFnIiwidHlwZWRBcnJheVRhZ3MiLCJmcmVlUHJvY2VzcyIsInByb2Nlc3MiLCJ0eXBlcyIsImJpbmRpbmciLCJjb3B5T2JqZWN0IiwiaXNOZXciLCJiYXNlVGltZXMiLCJpbmhlcml0ZWQiLCJpc0FyZyIsImlzVHlwZSIsInNraXBJbmRleGVzIiwiU3RyaW5nIiwibmF0aXZlS2V5c0luIiwiaXNQcm90byIsImJhc2VSZXN0IiwiaXNJdGVyYXRlZUNhbGwiLCJhc3NpZ25lciIsInNvdXJjZXMiLCJndWFyZCIsInRoaXNBcmciLCJjb25zdGFudCIsInN0cmluZyIsIkhPVF9DT1VOVCIsIkhPVF9TUEFOIiwibmF0aXZlTm93IiwiRGF0ZSIsIm5vdyIsImxhc3RDYWxsZWQiLCJzdGFtcCIsInJlbWFpbmluZyIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsIndlYmtpdFJlcXVlc3RBbmltYXRpb25GcmFtZSIsIm1velJlcXVlc3RBbmltYXRpb25GcmFtZSIsIm9SZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJtc1JlcXVlc3RBbmltYXRpb25GcmFtZSIsInNldFRpbWVvdXQiLCJhaCIsImFsIiwiYmgiLCJibCIsImFzc2lnbiIsIm5leHRTb3VyY2UiLCJuZXh0S2V5IiwiX2FycmF5V2l0aEhvbGVzIiwiX2l0ZXJhYmxlVG9BcnJheUxpbWl0IiwiX2kiLCJfYXJyIiwiX24iLCJfZCIsIl9zIiwiX2UiLCJfbm9uSXRlcmFibGVSZXN0IiwiX3JlZ2VuZXJhdG9yUnVudGltZSIsIk9wIiwiaGFzT3duIiwiJFN5bWJvbCIsIml0ZXJhdG9yU3ltYm9sIiwiYXN5bmNJdGVyYXRvclN5bWJvbCIsImFzeW5jSXRlcmF0b3IiLCJ0b1N0cmluZ1RhZ1N5bWJvbCIsImRlZmluZSIsIndyYXAiLCJpbm5lckZuIiwib3V0ZXJGbiIsInRyeUxvY3NMaXN0IiwicHJvdG9HZW5lcmF0b3IiLCJHZW5lcmF0b3IiLCJnZW5lcmF0b3IiLCJDb250ZXh0IiwiX2ludm9rZSIsInN0YXRlIiwibWV0aG9kIiwiZG9uZVJlc3VsdCIsImRlbGVnYXRlIiwiZGVsZWdhdGVSZXN1bHQiLCJtYXliZUludm9rZURlbGVnYXRlIiwiQ29udGludWVTZW50aW5lbCIsInNlbnQiLCJfc2VudCIsImRpc3BhdGNoRXhjZXB0aW9uIiwiYWJydXB0IiwicmVjb3JkIiwidHJ5Q2F0Y2giLCJHZW5lcmF0b3JGdW5jdGlvbiIsIkdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlIiwiSXRlcmF0b3JQcm90b3R5cGUiLCJnZXRQcm90byIsIk5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlIiwidmFsdWVzIiwiR3AiLCJkZWZpbmVJdGVyYXRvck1ldGhvZHMiLCJBc3luY0l0ZXJhdG9yIiwiUHJvbWlzZUltcGwiLCJpbnZva2UiLCJfX2F3YWl0IiwidW53cmFwcGVkIiwicHJldmlvdXNQcm9taXNlIiwiY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmciLCJyZXN1bHROYW1lIiwibmV4dExvYyIsInB1c2hUcnlFbnRyeSIsImxvY3MiLCJ0cnlMb2MiLCJjYXRjaExvYyIsImZpbmFsbHlMb2MiLCJhZnRlckxvYyIsInRyeUVudHJpZXMiLCJyZXNldFRyeUVudHJ5IiwiY29tcGxldGlvbiIsInJlc2V0IiwiaXRlcmF0b3JNZXRob2QiLCJkaXNwbGF5TmFtZSIsImlzR2VuZXJhdG9yRnVuY3Rpb24iLCJnZW5GdW4iLCJjdG9yIiwibWFyayIsImF3cmFwIiwiYXN5bmMiLCJpdGVyIiwicmV2ZXJzZSIsInNraXBUZW1wUmVzZXQiLCJjaGFyQXQiLCJzdG9wIiwicm9vdFJlY29yZCIsInJ2YWwiLCJleGNlcHRpb24iLCJoYW5kbGUiLCJsb2MiLCJjYXVnaHQiLCJoYXNDYXRjaCIsImhhc0ZpbmFsbHkiLCJmaW5hbGx5RW50cnkiLCJjb21wbGV0ZSIsImZpbmlzaCIsIl9jYXRjaCIsInRocm93biIsImRlbGVnYXRlWWllbGQiLCJfc3VwZXJQcm9wQmFzZSIsIl9hcnJheVdpdGhvdXRIb2xlcyIsIl9pdGVyYWJsZVRvQXJyYXkiLCJfbm9uSXRlcmFibGVTcHJlYWQiLCJiYXNlUGlja0J5IiwiaGFzSW4iLCJiYXNlR2V0IiwiYmFzZVNldCIsInByZWRpY2F0ZSIsInJlSXNEZWVwUHJvcCIsInJlSXNQbGFpblByb3AiLCJtZW1vaXplQ2FwcGVkIiwicmVQcm9wTmFtZSIsInJlRXNjYXBlQ2hhciIsImNoYXJDb2RlQXQiLCJudW1iZXIiLCJxdW90ZSIsInN1YlN0cmluZyIsIm1lbW9pemUiLCJNQVhfTUVNT0laRV9TSVpFIiwiY2FjaGUiLCJGVU5DX0VSUk9SX1RFWFQiLCJyZXNvbHZlciIsIm1lbW9pemVkIiwiQ2FjaGUiLCJiYXNlVG9TdHJpbmciLCJhcnJheU1hcCIsInN5bWJvbFByb3RvIiwic3ltYm9sVG9TdHJpbmciLCJuZXN0ZWQiLCJiYXNlSGFzSW4iLCJoYXNQYXRoIiwiaGFzRnVuYyIsImZsYXR0ZW4iLCJiYXNlRmxhdHRlbiIsImFycmF5UHVzaCIsImlzRmxhdHRlbmFibGUiLCJkZXB0aCIsImlzU3RyaWN0Iiwic3ByZWFkYWJsZVN5bWJvbCIsImlzQ29uY2F0U3ByZWFkYWJsZSIsIl9pc05hdGl2ZUZ1bmN0aW9uIiwiaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0IiwiX2NvbnN0cnVjdCIsIlBhcmVudCIsIl9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QiLCJzaGFtIiwiUHJveHkiLCJCb29sZWFuIiwidmFsdWVPZiIsIkJhcmNvZGVEaXJlY3Rpb24iLCJCYXJjb2RlUmVhZGVyIiwic3VwcGxlbWVudHMiLCJfcm93IiwiY291bnRlciIsImNvZGUiLCJtYXhTaW5nbGVFcnJvciIsIlNJTkdMRV9DT0RFX0VSUk9SIiwic2luZ2xlRXJyb3IiLCJtb2R1bG8iLCJiYXJXaWR0aCIsInNjYWxlZCIsImNvcnJlY3Rpb24iLCJpbmRpY2VzIiwiZGVjb2RlIiwiZGlyZWN0aW9uIiwiUmV2ZXJzZSIsIkZvcndhcmQiLCJmb3JtYXQiLCJGT1JNQVQiLCJfbmV4dFVuc2V0IiwiaXNXaGl0ZSIsImNvdW50ZXJzIiwiY291bnRlclBvcyIsIm51bUNvdW50ZXJzIiwiU3RhcnROb3RGb3VuZEV4Y2VwdGlvbiIsIkNvZGVOb3RGb3VuZEV4Y2VwdGlvbiIsIlBhdHRlcm5Ob3RGb3VuZEV4Y2VwdGlvbiIsIk4iLCJXIiwiU1RBUlRfUEFUVEVSTiIsIlNUT1BfUEFUVEVSTiIsIkNPREVfUEFUVEVSTiIsIlNUQVJUX1BBVFRFUk5fTEVOR1RIIiwiVHdvT2ZGaXZlUmVhZGVyIiwidHJ5SGFyZGVyIiwiYmVzdE1hdGNoIiwiZXBzaWxvbiIsIkFWR19DT0RFX0VSUk9SIiwiX25leHRTZXQiLCJfbWF0Y2hQYXR0ZXJuIiwic3RhcnRJbmZvIiwibmFycm93QmFyV2lkdGgiLCJsZWFkaW5nV2hpdGVzcGFjZVN0YXJ0IiwiX2ZpbmRQYXR0ZXJuIiwiX21hdGNoUmFuZ2UiLCJlbmRJbmZvIiwidHJhaWxpbmdXaGl0ZXNwYWNlRW5kIiwiX3ZlcmlmeVRyYWlsaW5nV2hpdGVzcGFjZSIsImRlY29kZWRDb2RlcyIsImNvdW50ZXJMZW5ndGgiLCJiYXJTcGFjZVJhdGlvIiwiX2RlY29kZUNvZGUiLCJfZmluZFN0YXJ0IiwiX2ZpbmRFbmQiLCJfZmlsbENvdW50ZXJzIiwiX3ZlcmlmeUNvdW50ZXJMZW5ndGgiLCJfZGVjb2RlUGF5bG9hZCIsIkFMUEhBQkVUIiwiQ0hBUkFDVEVSX0VOQ09ESU5HUyIsIlNUQVJUX0VORCIsIk1JTl9FTkNPREVEX0NIQVJTIiwiTUFYX0FDQ0VQVEFCTEUiLCJQQURESU5HIiwiTmV3Q29kYWJhclJlYWRlciIsIl9jb3VudGVycyIsImJhclRocmVzaG9sZCIsIl9jb21wdXRlQWx0ZXJuYXRpbmdUaHJlc2hvbGQiLCJzcGFjZVRocmVzaG9sZCIsImJpdG1hc2siLCJfdG9QYXR0ZXJuIiwiX2lzU3RhcnRFbmQiLCJfc3VtQ291bnRlcnMiLCJzdGFydENvdW50ZXIiLCJlbmRDb3VudGVyIiwiZnJvbUNoYXJDb2RlIiwiX2NhbGN1bGF0ZVBhdHRlcm5MZW5ndGgiLCJjaGFyIiwiY2hhckNvZGUiLCJjYXRlZ29yaXphdGlvbiIsInNwYWNlIiwibmFycm93IiwiY291bnRzIiwid2lkZSIsImJhciIsIl9jaGFyVG9QYXR0ZXJuIiwia2luZCIsImNhdCIsIm5ld2tpbmQiLCJ0aHJlc2hvbGRzIiwiX3RocmVzaG9sZFJlc3VsdFBhdHRlcm4iLCJuZXh0U3RhcnQiLCJkZWNvZGVkQ2hhciIsIl9wYXR0ZXJuVG9DaGFyIiwiX3ZlcmlmeVdoaXRlc3BhY2UiLCJfdmFsaWRhdGVSZXN1bHQiLCJDb2RlMTI4UmVhZGVyIiwiX2NvcnJlY3QiLCJjYWxjdWxhdGVDb3JyZWN0aW9uIiwiTU9EVUxFX0lORElDRVMiLCJfY29ycmVjdEJhcnMiLCJTVEFSVF9DT0RFX0EiLCJTVEFSVF9DT0RFX0MiLCJjaGVja3N1bSIsImNvZGVzZXQiLCJDT0RFX0EiLCJTVEFSVF9DT0RFX0IiLCJDT0RFX0IiLCJDT0RFX0MiLCJzaGlmdE5leHQiLCJyZW1vdmVMYXN0Q2hhcmFjdGVyIiwibXVsdGlwbGllciIsInJhd1Jlc3VsdCIsIlNUT1BfQ09ERSIsIkNPREVfU0hJRlQiLCJleHBlY3RlZCIsIm5vcm1hbGl6ZWQiLCJzdW1Ob3JtYWxpemVkIiwic3VtRXhwZWN0ZWQiLCJBTFBIQUJFVEhfU1RSSU5HIiwiVWludDE2QXJyYXkiLCJBU1RFUklTSyIsIkNvZGUzOVJlYWRlciIsInBhdHRlcm5TdGFydCIsIndoaXRlU3BhY2VNdXN0U3RhcnQiLCJtYXhOYXJyb3dXaWR0aCIsIm51bVdpZGVCYXJzIiwid2lkZUJhcldpZHRoIiwiX2ZpbmROZXh0V2lkdGgiLCJtaW5XaWR0aCIsImxhc3RTdGFydCIsInBhdHRlcm5TaXplIiwiX3RvQ291bnRlcnMiLCJwYXR0ZXJucyIsIkFFSU8iLCJBWjA5IiwiY29kZTMyc2V0IiwiQ29kZTMyUmVhZGVyIiwicmVzIiwiY29kZTMyIiwiX2NoZWNrQ2hlY2tzdW0iLCJfZGVjb2RlQ29kZTMyIiwiSU9RIiwiQ29kZTM5VklOUmVhZGVyIiwiQ29kZTkzUmVhZGVyIiwiY2hhckFycmF5IiwibmV4dENoYXIiLCJuZXh0Q2hhckNvZGUiLCJ3YXJuIiwibWF4V2VpZ2h0IiwiYXJyYXlUb0NoZWNrIiwid2VpZ2h0ZWRTdW1zIiwid2VpZ2h0IiwiY2hlY2tDaGFyIiwiX21hdGNoQ2hlY2tDaGFyIiwiX3ZlcmlmeUVuZCIsIl92ZXJpZnlDaGVja3N1bXMiLCJfZGVjb2RlRXh0ZW5kZWQiLCJDT0RFX0dfU1RBUlQiLCJNSURETEVfUEFUVEVSTiIsIkVYVEVOU0lPTl9TVEFSVF9QQVRURVJOIiwiQ09ERV9GUkVRVUVOQ1kiLCJFQU5SZWFkZXIiLCJjb2RlcmFuZ2UiLCJjb2RlRnJlcXVlbmN5IiwiaW5Db2RlIiwib3V0Q29kZSIsImZpcnN0RGlnaXQiLCJfY2FsY3VsYXRlRmlyc3REaWdpdCIsIm1pZGRsZVBhdHRlcm4iLCJyZXN1bHRJbmZvIiwiX2NoZWNrc3VtIiwic3VwcGxlbWVudCIsIl9kZWNvZGVFeHRlbnNpb25zIiwibGFzdENvZGUiLCJFQU4yUmVhZGVyIiwicGFyc2VJbnQiLCJDSEVDS19ESUdJVF9FTkNPRElOR1MiLCJkZXRlcm1pbmVDaGVja0RpZ2l0IiwiZXh0ZW5zaW9uQ2hlY2tzdW0iLCJFQU41UmVhZGVyIiwiRUFOOFJlYWRlciIsIkkyb2Y1UmVhZGVyIiwib3B0cyIsIm5vcm1hbGl6ZUJhclNwYWNlV2lkdGgiLCJjb3VudGVyU3VtIiwiY29kZVN1bSIsImNvcnJlY3Rpb25SYXRpbyIsIk1BWF9DT1JSRUNUSU9OX0ZBQ1RPUiIsImNvcnJlY3Rpb25SYXRpb0ludmVyc2UiLCJjb3VudGVyUGFpciIsImNvZGVzIiwiX2RlY29kZVBhaXIiLCJVUENFUmVhZGVyIiwiX2RldGVybWluZVBhcml0eSIsIm5yU3lzdGVtIiwidXBjYSIsImxhc3REaWdpdCIsIl9jb252ZXJ0VG9VUENBIiwiVVBDUmVhZGVyIiwic3Vic3RyaW5nIiwiQnJlc2VuaGFtIiwiU2xvcGUiLCJVUCIsIkRPV04iLCJnZXRCYXJjb2RlTGluZSIsIngwIiwieTAiLCJzdGVlcCIsInJlYWQiLCJkZWx0YVgiLCJkZWx0YVkiLCJ5U3RlcCIsInRvQmluYXJ5TGluZSIsInNsb3BlIiwic2xvcGUyIiwiZXh0cmVtYSIsImN1cnJlbnREaXIiLCJyVGhyZXNob2xkIiwicHJpbnRGcmVxdWVuY3kiLCJwcmludFBhdHRlcm4iLCJmaWxsQ29sb3IiLCJmaWxsUmVjdCIsIlJFQURFUlMiLCJjb2RlXzEyOF9yZWFkZXIiLCJlYW5fcmVhZGVyIiwiZWFuXzVfcmVhZGVyIiwiZWFuXzJfcmVhZGVyIiwiZWFuXzhfcmVhZGVyIiwiY29kZV8zOV9yZWFkZXIiLCJjb2RlXzM5X3Zpbl9yZWFkZXIiLCJjb2RhYmFyX3JlYWRlciIsIkNvZGFiYXJSZWFkZXIiLCJ1cGNfcmVhZGVyIiwidXBjX2VfcmVhZGVyIiwiaTJvZjVfcmVhZGVyIiwiY29kZV85M19yZWFkZXIiLCJjb2RlXzMyX3JlYWRlciIsInJlZ2lzdGVyUmVhZGVyIiwicmVhZGVyIiwiX2NhbnZhcyIsImZyZXF1ZW5jeSIsIl9iYXJjb2RlUmVhZGVycyIsImluaXRSZWFkZXJzIiwiaW5pdENvbmZpZyIsIiRkZWJ1ZyIsInJlYWRlcnMiLCJyZWFkZXJDb25maWciLCJjb25maWd1cmF0aW9uIiwicmVhZGVyT2JqIiwidmlzIiwibm9kZSIsInByb3AiLCJzaG93RnJlcXVlbmN5Iiwic2hvd1BhdHRlcm4iLCJkaXNwbGF5IiwiZ2V0RXh0ZW5kZWRMaW5lIiwiZXh0IiwiZXh0ZW5kTGluZSIsImFtb3VudCIsImV4dGVuc2lvbiIsImluSW1hZ2VXaXRoQm9yZGVyIiwiZ2V0TGluZSIsInRyeURlY29kZSIsImJhcmNvZGVMaW5lIiwiZGVjb2RlUGF0dGVybiIsImNvZGVSZXN1bHQiLCJ0cnlEZWNvZGVCcnV0ZUZvcmNlIiwibGluZUFuZ2xlIiwic2lkZUxlbmd0aCIsInBvdyIsInNsaWNlcyIsInhkaXIiLCJ5ZGlyIiwiZ2V0TGluZUxlbmd0aCIsImRlY29kZUZyb21JbWFnZSIsImRlY29kZUltYWdlIiwiZGVjb2RlRnJvbUJvdW5kaW5nQm94IiwiZHJhd0JvdW5kaW5nQm94IiwibGluZUxlbmd0aCIsImF0YW4yIiwiZHJhd1NjYW5saW5lIiwiZGVjb2RlRnJvbUJvdW5kaW5nQm94ZXMiLCJiYXJjb2RlcyIsIm11bHRpcGxlIiwiaW1hZ2VXcmFwcGVySW4iLCJzZXRSZWFkZXJzIiwiRXZlbnRJbnRlcmZhY2UiLCJldmVudHMiLCJnZXRFdmVudCIsImV2ZW50TmFtZSIsInN1YnNjcmliZXJzIiwiY2xlYXJFdmVudHMiLCJwdWJsaXNoU3Vic2NyaXB0aW9uIiwic3Vic2NyaXB0aW9uIiwiX3N1YnNjcmliZSIsImV2ZW50Iiwic3Vic2NyaWJlIiwicHVibGlzaCIsInN1YnNjcmliZXIiLCJvbmNlIiwidW5zdWJzY3JpYmUiLCJFeGNlcHRpb24iLCJFUlJPUl9ERVNDIiwiZW51bWVyYXRlRGV2aWNlcyIsIm5hdmlnYXRvciIsIm1lZGlhRGV2aWNlcyIsImdldFVzZXJNZWRpYSIsImNvbnN0cmFpbnRzIiwic3RyZWFtUmVmIiwid2FpdEZvclZpZGVvIiwidmlkZW8iLCJhdHRlbXB0cyIsImNoZWNrVmlkZW8iLCJ2aWRlb1dpZHRoIiwidmlkZW9IZWlnaHQiLCJpbml0Q2FtZXJhIiwic3RyZWFtIiwic2V0QXR0cmlidXRlIiwic3JjT2JqZWN0IiwiYWRkRXZlbnRMaXN0ZW5lciIsInBsYXkiLCJkZXByZWNhdGVkQ29uc3RyYWludHMiLCJ2aWRlb0NvbnN0cmFpbnRzIiwibWluQXNwZWN0UmF0aW8iLCJhc3BlY3RSYXRpbyIsImZhY2luZyIsImZhY2luZ01vZGUiLCJwaWNrQ29uc3RyYWludHMiLCJkZXZpY2VJZCIsImF1ZGlvIiwiZW51bWVyYXRlVmlkZW9EZXZpY2VzIiwiZGV2aWNlcyIsImRldmljZSIsImdldEFjdGl2ZVRyYWNrIiwidHJhY2tzIiwiZ2V0VmlkZW9UcmFja3MiLCJRdWFnZ2FKU0NhbWVyYUFjY2VzcyIsInJlcXVlc3RlZFZpZGVvRWxlbWVudCIsInJlcXVlc3QiLCJuZXdDb25zdHJhaW50cyIsInJlbGVhc2UiLCJwYXVzZSIsInRyYWNrIiwiZ2V0QWN0aXZlU3RyZWFtTGFiZWwiLCJkaXNhYmxlVG9yY2giLCJhcHBseUNvbnN0cmFpbnRzIiwidG9yY2giLCJlbmFibGVUb3JjaCIsImNvbnRhaW5zIiwic29tZSIsImV2ZXJ5IiwicGFzc2VzRmlsdGVyIiwicmVzdWx0cyIsImNhcGFjaXR5IiwiY2FwdHVyZSIsIm1hdGNoZXNDb25zdHJhaW50cyIsImJsYWNrbGlzdCIsImFkZFJlc3VsdCIsImltYWdlU2l6ZSIsInRvRGF0YVVSTCIsImdldFJlc3VsdHMiLCJEZXZDb25maWciLCJudW1PZldvcmtlcnMiLCJkZWNvZGVyIiwibG9jYXRvciIsIk5vZGVDb25maWciLCJzZXF1ZW5jZSIsIlByb2RDb25maWciLCJFeHBvcnRDb25maWciLCJRdWFnZ2FDb25maWciLCJUT19SQURJQU5TIiwiYWRqdXN0Q2FudmFzU2l6ZSIsInRhcmdldFNpemUiLCJGcmFtZUdyYWJiZXIiLCJfdGhhdCIsIl9zdHJlYW1Db25maWciLCJfdmlkZW9TaXplIiwiZ2V0UmVhbFdpZHRoIiwiZ2V0UmVhbEhlaWdodCIsIl9jYW52YXNTaXplIiwiZ2V0Q2FudmFzU2l6ZSIsIl9zaXplIiwidG9wUmlnaHQiLCJnZXRUb3BSaWdodCIsIl9zeCIsIl9zeSIsIl9jdHgiLCJfZGF0YSIsInZpZGVvU2l6ZSIsImNhbnZhc1NpemUiLCJhdHRhY2hEYXRhIiwiZ2V0RGF0YSIsImdyYWIiLCJkb0hhbGZTYW1wbGUiLCJnZXRGcmFtZSIsImRyYXdhYmxlIiwiZHJhd0FuZ2xlIiwidGFncyIsIm9yaWVudGF0aW9uIiwidHJhbnNsYXRlIiwiZ2V0U2l6ZSIsIkV4aWZUYWdzIiwiQXZhaWxhYmxlVGFncyIsImZpbmRUYWdzSW5PYmplY3RVUkwiLCJvYmplY3RVUkxUb0Jsb2IiLCJyZWFkVG9CdWZmZXIiLCJmaW5kVGFnc0luQnVmZmVyIiwiYmFzZTY0VG9BcnJheUJ1ZmZlciIsImRhdGFVcmwiLCJiYXNlNjQiLCJhdG9iIiwidmlldyIsImJsb2IiLCJmaWxlUmVhZGVyIiwiRmlsZVJlYWRlciIsInJlYWRBc0FycmF5QnVmZmVyIiwidXJsIiwiaHR0cCIsIlhNTEh0dHBSZXF1ZXN0Iiwib3BlbiIsInJlc3BvbnNlVHlwZSIsIm9ucmVhZHlzdGF0ZWNoYW5nZSIsInJlYWR5U3RhdGUiLCJET05FIiwic3RhdHVzIiwicmVzcG9uc2UiLCJvbmVycm9yIiwic2VuZCIsImZpbGUiLCJzZWxlY3RlZFRhZ3MiLCJkYXRhVmlldyIsIkRhdGFWaWV3IiwiZXhpZlRhZ3MiLCJzZWxlY3RlZFRhZyIsImV4aWZUYWciLCJtYXJrZXIiLCJnZXRVaW50OCIsInJlYWRFWElGRGF0YSIsImdldFVpbnQxNiIsImdldFN0cmluZ0Zyb21CdWZmZXIiLCJ0aWZmT2Zmc2V0IiwiYmlnRW5kIiwiZmlyc3RJRkRPZmZzZXQiLCJnZXRVaW50MzIiLCJyZWFkVGFncyIsInRpZmZTdGFydCIsImRpclN0YXJ0Iiwic3RyaW5ncyIsImVudHJ5T2Zmc2V0IiwicmVhZFRhZ1ZhbHVlIiwibnVtVmFsdWVzIiwib3V0c3RyIiwiSW1hZ2VMb2FkZXIiLCJsb2FkIiwiZGlyZWN0b3J5IiwiaHRtbEltYWdlc1NyY0FycmF5IiwiaHRtbEltYWdlc0FycmF5IiwibnVtIiwibm90TG9hZGVkIiwiYWRkSW1hZ2UiLCJpbWFnZSIsImxvYWRlZCIsImxvYWRlZEltZyIsIm5vdGxvYWRlZEltZ3MiLCJpbWdOYW1lIiwic3Vic3RyIiwibGFzdEluZGV4T2YiLCJhZGRPbmxvYWRIYW5kbGVyIiwiaW5wdXRTdHJlYW1GYWN0b3J5IiwiY3JlYXRlVmlkZW9TdHJlYW0iLCJfZXZlbnROYW1lcyIsIl9ldmVudEhhbmRsZXJzIiwiX2NhbGN1bGF0ZWRXaWR0aCIsIl9jYWxjdWxhdGVkSGVpZ2h0IiwiX3RvcFJpZ2h0IiwiaW5pdFNpemUiLCJzZXRJbnB1dFN0cmVhbSIsImVuZGVkIiwic2V0Q3VycmVudFRpbWUiLCJ0aW1lIiwiZiIsImJvb2wiLCJjbGVhckV2ZW50SGFuZGxlcnMiLCJoYW5kbGVycyIsImhhbmRsZXIiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwidHJpZ2dlciIsImNyZWF0ZUxpdmVTdHJlYW0iLCJjcmVhdGVJbWFnZVN0cmVhbSIsImZyYW1lSWR4IiwicGF1c2VkIiwiaW1nQXJyYXkiLCJiYXNlVXJsIiwiY2FsY3VsYXRlZFdpZHRoIiwiY2FsY3VsYXRlZEhlaWdodCIsImxvYWRJbWFnZXMiLCJpbWdzIiwicHVibGlzaEV2ZW50IiwibmV3V2lkdGgiLCJuZXdIZWlnaHQiLCJpbmQiLCJRdWFnZ2FDb250ZXh0IiwiQ2FudmFzQ29udGFpbmVyIiwiQ2FudmFzSW5mbyIsImdldFZpZXdQb3J0IiwiSFRNTEVsZW1lbnQiLCJub2RlTmFtZSIsInNlbGVjdG9yIiwiYm94U2l6ZSIsIkJhcmNvZGVMb2NhdG9yIiwiZmluZE9yQ3JlYXRlQ2FudmFzIiwiZ2V0Q2FudmFzQW5kQ29udGV4dCIsImluaXRDYW52YXNlcyIsInZpZXdwb3J0IiwiY29udGFpbmVyIiwid29ya2VyUG9vbCIsInVwZGF0ZVdvcmtlcnMiLCJmcmFtZUdyYWJiZXIiLCJhdmFpbGFibGVXb3JrZXIiLCJ3b3JrZXJUaHJlYWQiLCJidXN5Iiwid29ya2VyIiwicG9zdE1lc3NhZ2UiLCJjbWQiLCJjb25maWdGb3JXb3JrZXIiLCJ3b3JrZXJJbnRlcmZhY2UiLCJmYWN0b3J5IiwiUXVhZ2dhIiwibWVzc2FnZSIsIm9uUHJvY2Vzc2VkIiwid29ya2VySW50ZXJmYWNlUmVhZHkiLCJvbm1lc3NhZ2UiLCJnZW5lcmF0ZVdvcmtlckJsb2IiLCJmYWN0b3J5U291cmNlIiwiX19mYWN0b3J5U291cmNlX18iLCJCbG9iIiwiVVJMIiwiY3JlYXRlT2JqZWN0VVJMIiwiaW5pdFdvcmtlciIsImNiIiwiYmxvYlVSTCIsIldvcmtlciIsInJldm9rZU9iamVjdFVSTCIsImFkanVzdFdvcmtlclBvb2wiLCJpbmNyZWFzZUJ5Iiwid29ya2Vyc1RvVGVybWluYXRlIiwidGVybWluYXRlIiwid29ya2VySW5pdGlhbGl6ZWQiLCJzZXR1cElucHV0U3RyZWFtIiwibW92ZUJveCIsInhPZmZzZXQiLCJ5T2Zmc2V0IiwiY29ybmVyIiwibW92ZUxpbmUiLCJmcmFtZWdyYWJiZXIiLCJjYW52YXNDb250YWluZXIiLCJRV29ya2VycyIsImluaXRpYWxpemVEYXRhIiwicmVhZHkiLCJvblVJVGhyZWFkIiwid29ya2Vyc1VwZGF0ZWQiLCJsb2NhdGVBbmREZWNvZGUiLCJfaW5pdEJ1ZmZlcnMiLCJCYXJjb2RlRGVjb2RlciIsIl9nZXRWaWV3UG9ydCIsIl9pbml0Q2FudmFzIiwiaW5wdXRUeXBlIiwiSW5wdXRTdHJlYW0iLCJDYW1lcmFBY2Nlc3MiLCJjYW5SZWNvcmQiLCJiYXJjb2RlIiwidHJhbnNmb3JtUmVzdWx0IiwicmVzdWx0Q29sbGVjdG9yIiwicmVzdWx0VG9QdWJsaXNoIiwiRXZlbnRzIiwiaGFzQ29kZVJlc3VsdCIsImdldEJvdW5kaW5nQm94ZXMiLCJkZWNvZGVSZXN1bHQiLCJwdWJsaXNoUmVzdWx0IiwiaW1hZ2VSZXN1bHQiLCJkZWxheSIsInN0b3BwZWQiLCJ0aW1lc3RhbXAiLCJ1cGRhdGUiLCJwZXJmb3JtYW5jZSIsInN0YXJ0Q29udGludW91c1VwZGF0ZSIsIl9jb250ZXh0IiwiUXVhZ2dhSlNTdGF0aWNJbnRlcmZhY2UiLCJxdWFnZ2FJbnN0YW5jZSIsInByb21pc2UiLCJDb25maWciLCJpbml0SW5wdXRTdHJlYW0iLCJvbkRldGVjdGVkIiwib2ZmRGV0ZWN0ZWQiLCJvZmZQcm9jZXNzZWQiLCJyZWdpc3RlclJlc3VsdENvbGxlY3RvciIsImRlY29kZVNpbmdsZSIsInJlc3VsdENhbGxiYWNrIiwiZGVmYXVsdCIsIlJlYWRlcnMiLCJSZXN1bHRDb2xsZWN0b3IiXSwibWFwcGluZ3MiOiJB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UCxFQUFVLENBQVYsRUFBYSxDQUFiLEVBQWdCLENBQWhCLENBRE8sRUFFUCxDQUFDLENBQUQsRUFBSSxDQUFKLEVBQU8sQ0FBUCxFQUFVLENBQVYsRUFBYSxDQUFiLEVBQWdCLENBQWhCLENBRk8sRUFHUCxDQUFDLENBQUQsRUFBSSxDQUFKLEVBQU8sQ0FBUCxFQUFVLENBQVYsRUFBYSxDQUFiLEVBQWdCLENBQWhCLENBSE8sRUFJUCxDQUFDLENBQUQsRUFBSSxDQUFKLEVBQU8sQ0FBUCxFQUFVLENBQVYsRUFBYSxDQUFiLEVBQWdCLENBQWhCLENBSk8sRUFLUCxDQUFDLENBQUQsRUFBSSxDQUFKLEVBQU8sQ0FBUCxFQUFVLENBQVYsRUFBYSxDQUFiLEVBQWdCLENBQWhCLENBTE8sRUFNUCxDQUFDLENBQUQsRUFBSSxDQUFKLEVBQU8sQ0FBUCxFQUFVLENBQVYsRUFBYSxDQUFiLEVBQWdCLENBQWhCLENBTk8sRUFPUCxDQUFDLENBQUQsRUFBSSxDQUFKLEVBQU8sQ0FBUCxFQUFVLENBQVYsRUFBYSxDQUFiLEVBQWdCLENBQWhCLENBUE8sRUFRUCxDQUFDLENBQUQsRUFBSSxDQUFKLEVBQU8sQ0FBUCxFQUFVLENBQVYsRUFBYSxDQUFiLEVBQWdCLENBQWhCLENBUk8sRUFTUCxDQUFDLENBQUQsRUFBSSxDQUFKLEVBQU8sQ0FBUCxFQUFVLENBQVYsRUFBYSxDQUFiLEVBQWdCLENBQWhCLENBVE8sRUFVUCxDQUFDLENBQUQsRUFBSSxDQUFKLEVBQU8sQ0FBUCxFQUFVLENBQVYsRUFBYSxDQUFiLEVBQWdCLENBQWhCLENBVk8sRUFXUCxDQUFDLENBQUQsRUFBSSxDQUFKLEVBQU8sQ0FBUCxFQUFVLENBQVYsRUFBYSxDQUFiLEVBQWdCLENBQWhCLENBWE8sRUFZUCxDQUFDLENBQUQsRUFBSSxDQUFKLEVBQU8sQ0FBUCxFQUFVLENBQVYsRUFBYSxDQUFiLEVBQWdCLENBQWhCLENBWk8sRUFhUCxDQUFDLENBQUQsRUFBSSxDQUFKLEVBQU8sQ0FBUCxFQUFVLENBQVYsRUFBYSxDQUFiLEVBQWdCLENBQWhCLENB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UCxFQUFZO1FBQ1ZWLE1BQU0sQ0FBQ1UsR0FBRCxDQUFOO01BQ0g7SUFDSixDQWZNLENBQVA7RUFnQkgsQ0F4SDJCOztFQXlINUI7RUFDQTtFQUNBLElBQUlzcUMsT0FBSixHQUFjO0lBQ1YsT0FBT1gsdUJBQVA7RUFDSCxDQTdIMkI7O0VBOEg1QlksT0FBTyxFQUFQQSxzQkE5SDRCO0VBK0g1Qi9CLFlBQVksRUFBWkEsYUEvSDRCO0VBZ0k1QmxqQyxVQUFVLEVBQVZBLDhCQWhJNEI7RUFpSTVCeEksWUFBWSxFQUFaQSxnQ0FqSTRCO0VBa0k1QjB0QyxlQUFlLEVBQWZBLGdCQUFlQTtBQWxJYSxDQUFoQztBQXFJZWIsbUdBQWYsRSxDQUNBIiwiZmlsZSI6InF1YWdnYS5qcyIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiB3ZWJwYWNrVW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbihyb290LCBmYWN0b3J5KSB7XG5cdGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0Jylcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTtcblx0ZWxzZSBpZih0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpXG5cdFx0ZGVmaW5lKFtdLCBmYWN0b3J5KTtcblx0ZWxzZSBpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpXG5cdFx0ZXhwb3J0c1tcIlF1YWdnYVwiXSA9IGZhY3RvcnkoKTtcblx0ZWxzZVxuXHRcdHJvb3RbXCJRdWFnZ2FcIl0gPSBmYWN0b3J5KCk7XG59KSh3aW5kb3csIGZ1bmN0aW9uKCkge1xucmV0dXJuICIsIiBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbiBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbiBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cbiBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKSB7XG4gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG4gXHRcdH1cbiBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbiBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuIFx0XHRcdGk6IG1vZHVsZUlkLFxuIFx0XHRcdGw6IGZhbHNlLFxuIFx0XHRcdGV4cG9ydHM6IHt9XG4gXHRcdH07XG5cbiBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG4gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbiBcdFx0bW9kdWxlLmwgPSB0cnVlO1xuXG4gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbiBcdH1cblxuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbiBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cbiBcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb24gZm9yIGhhcm1vbnkgZXhwb3J0c1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgZ2V0dGVyKSB7XG4gXHRcdGlmKCFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywgbmFtZSkpIHtcbiBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbmFtZSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGdldHRlciB9KTtcbiBcdFx0fVxuIFx0fTtcblxuIFx0Ly8gZGVmaW5lIF9fZXNNb2R1bGUgb24gZXhwb3J0c1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yID0gZnVuY3Rpb24oZXhwb3J0cykge1xuIFx0XHRpZih0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcpIHtcbiBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcbiBcdFx0fVxuIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuIFx0fTtcblxuIFx0Ly8gY3JlYXRlIGEgZmFrZSBuYW1lc3BhY2Ugb2JqZWN0XG4gXHQvLyBtb2RlICYgMTogdmFsdWUgaXMgYSBtb2R1bGUgaWQsIHJlcXVpcmUgaXRcbiBcdC8vIG1vZGUgJiAyOiBtZXJnZSBhbGwgcHJvcGVydGllcyBvZiB2YWx1ZSBpbnRvIHRoZSBuc1xuIFx0Ly8gbW9kZSAmIDQ6IHJldHVybiB2YWx1ZSB3aGVuIGFscmVhZHkgbnMgb2JqZWN0XG4gXHQvLyBtb2RlICYgOHwxOiBiZWhhdmUgbGlrZSByZXF1aXJlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnQgPSBmdW5jdGlvbih2YWx1ZSwgbW9kZSkge1xuIFx0XHRpZihtb2RlICYgMSkgdmFsdWUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKHZhbHVlKTtcbiBcdFx0aWYobW9kZSAmIDgpIHJldHVybiB2YWx1ZTtcbiBcdFx0aWYoKG1vZGUgJiA0KSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlICYmIHZhbHVlLl9fZXNNb2R1bGUpIHJldHVybiB2YWx1ZTtcbiBcdFx0dmFyIG5zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yKG5zKTtcbiBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG5zLCAnZGVmYXVsdCcsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHZhbHVlIH0pO1xuIFx0XHRpZihtb2RlICYgMiAmJiB0eXBlb2YgdmFsdWUgIT0gJ3N0cmluZycpIGZvcih2YXIga2V5IGluIHZhbHVlKSBfX3dlYnBhY2tfcmVxdWlyZV9fLmQobnMsIGtleSwgZnVuY3Rpb24oa2V5KSB7IHJldHVybiB2YWx1ZVtrZXldOyB9LmJpbmQobnVsbCwga2V5KSk7XG4gXHRcdHJldHVybiBucztcbiBcdH07XG5cbiBcdC8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSBmdW5jdGlvbihtb2R1bGUpIHtcbiBcdFx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0RGVmYXVsdCgpIHsgcmV0dXJuIG1vZHVsZVsnZGVmYXVsdCddOyB9IDpcbiBcdFx0XHRmdW5jdGlvbiBnZXRNb2R1bGVFeHBvcnRzKCkgeyByZXR1cm4gbW9kdWxlOyB9O1xuIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCAnYScsIGdldHRlcik7XG4gXHRcdHJldHVybiBnZXR0ZXI7XG4gXHR9O1xuXG4gXHQvLyBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGxcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KTsgfTtcblxuIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbiBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiL1wiO1xuXG5cbiBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oX193ZWJwYWNrX3JlcXVpcmVfXy5zID0gNzIpO1xuIiwiZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkge1xuICBpZiAoa2V5IGluIG9iaikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgb2JqW2tleV0gPSB2YWx1ZTtcbiAgfVxuXG4gIHJldHVybiBvYmo7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2RlZmluZVByb3BlcnR5LCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZSwgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHM7IiwiZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7XG4gIGlmIChzZWxmID09PSB2b2lkIDApIHtcbiAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7XG4gIH1cblxuICByZXR1cm4gc2VsZjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfYXNzZXJ0VGhpc0luaXRpYWxpemVkLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZSwgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHM7IiwiZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YuYmluZCgpIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHtcbiAgICByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pO1xuICB9LCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZSwgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHM7XG4gIHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2dldFByb3RvdHlwZU9mLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZSwgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHM7IiwiZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfY2xhc3NDYWxsQ2hlY2ssIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlLCBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0czsiLCJmdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldO1xuICAgIGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTtcbiAgICBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7XG4gICAgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7XG4gIH1cbn1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xuICBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTtcbiAgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29uc3RydWN0b3IsIFwicHJvdG90eXBlXCIsIHtcbiAgICB3cml0YWJsZTogZmFsc2VcbiAgfSk7XG4gIHJldHVybiBDb25zdHJ1Y3Rvcjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfY3JlYXRlQ2xhc3MsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlLCBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0czsiLCIvKipcbiAqIENvbW1vbiB1dGlsaXRpZXNcbiAqIEBtb2R1bGUgZ2xNYXRyaXhcbiAqL1xuLy8gQ29uZmlndXJhdGlvbiBDb25zdGFudHNcbmV4cG9ydCB2YXIgRVBTSUxPTiA9IDAuMDAwMDAxO1xuZXhwb3J0IHZhciBBUlJBWV9UWVBFID0gdHlwZW9mIEZsb2F0MzJBcnJheSAhPT0gJ3VuZGVmaW5lZCcgPyBGbG9hdDMyQXJyYXkgOiBBcnJheTtcbmV4cG9ydCB2YXIgUkFORE9NID0gTWF0aC5yYW5kb207XG4vKipcbiAqIFNldHMgdGhlIHR5cGUgb2YgYXJyYXkgdXNlZCB3aGVuIGNyZWF0aW5nIG5ldyB2ZWN0b3JzIGFuZCBtYXRyaWNlc1xuICpcbiAqIEBwYXJhbSB7RmxvYXQzMkFycmF5Q29uc3RydWN0b3IgfCBBcnJheUNvbnN0cnVjdG9yfSB0eXBlIEFycmF5IHR5cGUsIHN1Y2ggYXMgRmxvYXQzMkFycmF5IG9yIEFycmF5XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHNldE1hdHJpeEFycmF5VHlwZSh0eXBlKSB7XG4gIEFSUkFZX1RZUEUgPSB0eXBlO1xufVxudmFyIGRlZ3JlZSA9IE1hdGguUEkgLyAxODA7XG4vKipcbiAqIENvbnZlcnQgRGVncmVlIFRvIFJhZGlhblxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBhIEFuZ2xlIGluIERlZ3JlZXNcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gdG9SYWRpYW4oYSkge1xuICByZXR1cm4gYSAqIGRlZ3JlZTtcbn1cbi8qKlxuICogVGVzdHMgd2hldGhlciBvciBub3QgdGhlIGFyZ3VtZW50cyBoYXZlIGFwcHJveGltYXRlbHkgdGhlIHNhbWUgdmFsdWUsIHdpdGhpbiBhbiBhYnNvbHV0ZVxuICogb3IgcmVsYXRpdmUgdG9sZXJhbmNlIG9mIGdsTWF0cml4LkVQU0lMT04gKGFuIGFic29sdXRlIHRvbGVyYW5jZSBpcyB1c2VkIGZvciB2YWx1ZXMgbGVzc1xuICogdGhhbiBvciBlcXVhbCB0byAxLjAsIGFuZCBhIHJlbGF0aXZlIHRvbGVyYW5jZSBpcyB1c2VkIGZvciBsYXJnZXIgdmFsdWVzKVxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBhIFRoZSBmaXJzdCBudW1iZXIgdG8gdGVzdC5cbiAqIEBwYXJhbSB7TnVtYmVyfSBiIFRoZSBzZWNvbmQgbnVtYmVyIHRvIHRlc3QuXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gVHJ1ZSBpZiB0aGUgbnVtYmVycyBhcmUgYXBwcm94aW1hdGVseSBlcXVhbCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBlcXVhbHMoYSwgYikge1xuICByZXR1cm4gTWF0aC5hYnMoYSAtIGIpIDw9IEVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGEpLCBNYXRoLmFicyhiKSk7XG59XG5pZiAoIU1hdGguaHlwb3QpIE1hdGguaHlwb3QgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciB5ID0gMCxcbiAgICAgIGkgPSBhcmd1bWVudHMubGVuZ3RoO1xuXG4gIHdoaWxlIChpLS0pIHtcbiAgICB5ICs9IGFyZ3VtZW50c1tpXSAqIGFyZ3VtZW50c1tpXTtcbiAgfVxuXG4gIHJldHVybiBNYXRoLnNxcnQoeSk7XG59OyIsImltcG9ydCAqIGFzIGdsTWF0cml4IGZyb20gXCIuL2NvbW1vbi5qc1wiO1xuLyoqXG4gKiAyeDIgTWF0cml4XG4gKiBAbW9kdWxlIG1hdDJcbiAqL1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgaWRlbnRpdHkgbWF0MlxuICpcbiAqIEByZXR1cm5zIHttYXQyfSBhIG5ldyAyeDIgbWF0cml4XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZSgpIHtcbiAgdmFyIG91dCA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDQpO1xuXG4gIGlmIChnbE1hdHJpeC5BUlJBWV9UWVBFICE9IEZsb2F0MzJBcnJheSkge1xuICAgIG91dFsxXSA9IDA7XG4gICAgb3V0WzJdID0gMDtcbiAgfVxuXG4gIG91dFswXSA9IDE7XG4gIG91dFszXSA9IDE7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgbWF0MiBpbml0aWFsaXplZCB3aXRoIHZhbHVlcyBmcm9tIGFuIGV4aXN0aW5nIG1hdHJpeFxuICpcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQyfSBhIG1hdHJpeCB0byBjbG9uZVxuICogQHJldHVybnMge21hdDJ9IGEgbmV3IDJ4MiBtYXRyaXhcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gY2xvbmUoYSkge1xuICB2YXIgb3V0ID0gbmV3IGdsTWF0cml4LkFSUkFZX1RZUEUoNCk7XG4gIG91dFswXSA9IGFbMF07XG4gIG91dFsxXSA9IGFbMV07XG4gIG91dFsyXSA9IGFbMl07XG4gIG91dFszXSA9IGFbM107XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIENvcHkgdGhlIHZhbHVlcyBmcm9tIG9uZSBtYXQyIHRvIGFub3RoZXJcbiAqXG4gKiBAcGFyYW0ge21hdDJ9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHtSZWFkb25seU1hdDJ9IGEgdGhlIHNvdXJjZSBtYXRyaXhcbiAqIEByZXR1cm5zIHttYXQyfSBvdXRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gY29weShvdXQsIGEpIHtcbiAgb3V0WzBdID0gYVswXTtcbiAgb3V0WzFdID0gYVsxXTtcbiAgb3V0WzJdID0gYVsyXTtcbiAgb3V0WzNdID0gYVszXTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogU2V0IGEgbWF0MiB0byB0aGUgaWRlbnRpdHkgbWF0cml4XG4gKlxuICogQHBhcmFtIHttYXQyfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEByZXR1cm5zIHttYXQyfSBvdXRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gaWRlbnRpdHkob3V0KSB7XG4gIG91dFswXSA9IDE7XG4gIG91dFsxXSA9IDA7XG4gIG91dFsyXSA9IDA7XG4gIG91dFszXSA9IDE7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIENyZWF0ZSBhIG5ldyBtYXQyIHdpdGggdGhlIGdpdmVuIHZhbHVlc1xuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMDAgQ29tcG9uZW50IGluIGNvbHVtbiAwLCByb3cgMCBwb3NpdGlvbiAoaW5kZXggMClcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMDEgQ29tcG9uZW50IGluIGNvbHVtbiAwLCByb3cgMSBwb3NpdGlvbiAoaW5kZXggMSlcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMTAgQ29tcG9uZW50IGluIGNvbHVtbiAxLCByb3cgMCBwb3NpdGlvbiAoaW5kZXggMilcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMTEgQ29tcG9uZW50IGluIGNvbHVtbiAxLCByb3cgMSBwb3NpdGlvbiAoaW5kZXggMylcbiAqIEByZXR1cm5zIHttYXQyfSBvdXQgQSBuZXcgMngyIG1hdHJpeFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBmcm9tVmFsdWVzKG0wMCwgbTAxLCBtMTAsIG0xMSkge1xuICB2YXIgb3V0ID0gbmV3IGdsTWF0cml4LkFSUkFZX1RZUEUoNCk7XG4gIG91dFswXSA9IG0wMDtcbiAgb3V0WzFdID0gbTAxO1xuICBvdXRbMl0gPSBtMTA7XG4gIG91dFszXSA9IG0xMTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogU2V0IHRoZSBjb21wb25lbnRzIG9mIGEgbWF0MiB0byB0aGUgZ2l2ZW4gdmFsdWVzXG4gKlxuICogQHBhcmFtIHttYXQyfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMDAgQ29tcG9uZW50IGluIGNvbHVtbiAwLCByb3cgMCBwb3NpdGlvbiAoaW5kZXggMClcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMDEgQ29tcG9uZW50IGluIGNvbHVtbiAwLCByb3cgMSBwb3NpdGlvbiAoaW5kZXggMSlcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMTAgQ29tcG9uZW50IGluIGNvbHVtbiAxLCByb3cgMCBwb3NpdGlvbiAoaW5kZXggMilcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMTEgQ29tcG9uZW50IGluIGNvbHVtbiAxLCByb3cgMSBwb3NpdGlvbiAoaW5kZXggMylcbiAqIEByZXR1cm5zIHttYXQyfSBvdXRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gc2V0KG91dCwgbTAwLCBtMDEsIG0xMCwgbTExKSB7XG4gIG91dFswXSA9IG0wMDtcbiAgb3V0WzFdID0gbTAxO1xuICBvdXRbMl0gPSBtMTA7XG4gIG91dFszXSA9IG0xMTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogVHJhbnNwb3NlIHRoZSB2YWx1ZXMgb2YgYSBtYXQyXG4gKlxuICogQHBhcmFtIHttYXQyfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQyfSBhIHRoZSBzb3VyY2UgbWF0cml4XG4gKiBAcmV0dXJucyB7bWF0Mn0gb3V0XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHRyYW5zcG9zZShvdXQsIGEpIHtcbiAgLy8gSWYgd2UgYXJlIHRyYW5zcG9zaW5nIG91cnNlbHZlcyB3ZSBjYW4gc2tpcCBhIGZldyBzdGVwcyBidXQgaGF2ZSB0byBjYWNoZVxuICAvLyBzb21lIHZhbHVlc1xuICBpZiAob3V0ID09PSBhKSB7XG4gICAgdmFyIGExID0gYVsxXTtcbiAgICBvdXRbMV0gPSBhWzJdO1xuICAgIG91dFsyXSA9IGExO1xuICB9IGVsc2Uge1xuICAgIG91dFswXSA9IGFbMF07XG4gICAgb3V0WzFdID0gYVsyXTtcbiAgICBvdXRbMl0gPSBhWzFdO1xuICAgIG91dFszXSA9IGFbM107XG4gIH1cblxuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBJbnZlcnRzIGEgbWF0MlxuICpcbiAqIEBwYXJhbSB7bWF0Mn0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0Mn0gYSB0aGUgc291cmNlIG1hdHJpeFxuICogQHJldHVybnMge21hdDJ9IG91dFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBpbnZlcnQob3V0LCBhKSB7XG4gIHZhciBhMCA9IGFbMF0sXG4gICAgICBhMSA9IGFbMV0sXG4gICAgICBhMiA9IGFbMl0sXG4gICAgICBhMyA9IGFbM107IC8vIENhbGN1bGF0ZSB0aGUgZGV0ZXJtaW5hbnRcblxuICB2YXIgZGV0ID0gYTAgKiBhMyAtIGEyICogYTE7XG5cbiAgaWYgKCFkZXQpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGRldCA9IDEuMCAvIGRldDtcbiAgb3V0WzBdID0gYTMgKiBkZXQ7XG4gIG91dFsxXSA9IC1hMSAqIGRldDtcbiAgb3V0WzJdID0gLWEyICogZGV0O1xuICBvdXRbM10gPSBhMCAqIGRldDtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgYWRqdWdhdGUgb2YgYSBtYXQyXG4gKlxuICogQHBhcmFtIHttYXQyfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQyfSBhIHRoZSBzb3VyY2UgbWF0cml4XG4gKiBAcmV0dXJucyB7bWF0Mn0gb3V0XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGFkam9pbnQob3V0LCBhKSB7XG4gIC8vIENhY2hpbmcgdGhpcyB2YWx1ZSBpcyBuZXNzZWNhcnkgaWYgb3V0ID09IGFcbiAgdmFyIGEwID0gYVswXTtcbiAgb3V0WzBdID0gYVszXTtcbiAgb3V0WzFdID0gLWFbMV07XG4gIG91dFsyXSA9IC1hWzJdO1xuICBvdXRbM10gPSBhMDtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgZGV0ZXJtaW5hbnQgb2YgYSBtYXQyXG4gKlxuICogQHBhcmFtIHtSZWFkb25seU1hdDJ9IGEgdGhlIHNvdXJjZSBtYXRyaXhcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGRldGVybWluYW50IG9mIGFcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZGV0ZXJtaW5hbnQoYSkge1xuICByZXR1cm4gYVswXSAqIGFbM10gLSBhWzJdICogYVsxXTtcbn1cbi8qKlxuICogTXVsdGlwbGllcyB0d28gbWF0MidzXG4gKlxuICogQHBhcmFtIHttYXQyfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0Mn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHttYXQyfSBvdXRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gbXVsdGlwbHkob3V0LCBhLCBiKSB7XG4gIHZhciBhMCA9IGFbMF0sXG4gICAgICBhMSA9IGFbMV0sXG4gICAgICBhMiA9IGFbMl0sXG4gICAgICBhMyA9IGFbM107XG4gIHZhciBiMCA9IGJbMF0sXG4gICAgICBiMSA9IGJbMV0sXG4gICAgICBiMiA9IGJbMl0sXG4gICAgICBiMyA9IGJbM107XG4gIG91dFswXSA9IGEwICogYjAgKyBhMiAqIGIxO1xuICBvdXRbMV0gPSBhMSAqIGIwICsgYTMgKiBiMTtcbiAgb3V0WzJdID0gYTAgKiBiMiArIGEyICogYjM7XG4gIG91dFszXSA9IGExICogYjIgKyBhMyAqIGIzO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBSb3RhdGVzIGEgbWF0MiBieSB0aGUgZ2l2ZW4gYW5nbGVcbiAqXG4gKiBAcGFyYW0ge21hdDJ9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHtSZWFkb25seU1hdDJ9IGEgdGhlIG1hdHJpeCB0byByb3RhdGVcbiAqIEBwYXJhbSB7TnVtYmVyfSByYWQgdGhlIGFuZ2xlIHRvIHJvdGF0ZSB0aGUgbWF0cml4IGJ5XG4gKiBAcmV0dXJucyB7bWF0Mn0gb3V0XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHJvdGF0ZShvdXQsIGEsIHJhZCkge1xuICB2YXIgYTAgPSBhWzBdLFxuICAgICAgYTEgPSBhWzFdLFxuICAgICAgYTIgPSBhWzJdLFxuICAgICAgYTMgPSBhWzNdO1xuICB2YXIgcyA9IE1hdGguc2luKHJhZCk7XG4gIHZhciBjID0gTWF0aC5jb3MocmFkKTtcbiAgb3V0WzBdID0gYTAgKiBjICsgYTIgKiBzO1xuICBvdXRbMV0gPSBhMSAqIGMgKyBhMyAqIHM7XG4gIG91dFsyXSA9IGEwICogLXMgKyBhMiAqIGM7XG4gIG91dFszXSA9IGExICogLXMgKyBhMyAqIGM7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIFNjYWxlcyB0aGUgbWF0MiBieSB0aGUgZGltZW5zaW9ucyBpbiB0aGUgZ2l2ZW4gdmVjMlxuICpcbiAqIEBwYXJhbSB7bWF0Mn0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0Mn0gYSB0aGUgbWF0cml4IHRvIHJvdGF0ZVxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IHYgdGhlIHZlYzIgdG8gc2NhbGUgdGhlIG1hdHJpeCBieVxuICogQHJldHVybnMge21hdDJ9IG91dFxuICoqL1xuXG5leHBvcnQgZnVuY3Rpb24gc2NhbGUob3V0LCBhLCB2KSB7XG4gIHZhciBhMCA9IGFbMF0sXG4gICAgICBhMSA9IGFbMV0sXG4gICAgICBhMiA9IGFbMl0sXG4gICAgICBhMyA9IGFbM107XG4gIHZhciB2MCA9IHZbMF0sXG4gICAgICB2MSA9IHZbMV07XG4gIG91dFswXSA9IGEwICogdjA7XG4gIG91dFsxXSA9IGExICogdjA7XG4gIG91dFsyXSA9IGEyICogdjE7XG4gIG91dFszXSA9IGEzICogdjE7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIENyZWF0ZXMgYSBtYXRyaXggZnJvbSBhIGdpdmVuIGFuZ2xlXG4gKiBUaGlzIGlzIGVxdWl2YWxlbnQgdG8gKGJ1dCBtdWNoIGZhc3RlciB0aGFuKTpcbiAqXG4gKiAgICAgbWF0Mi5pZGVudGl0eShkZXN0KTtcbiAqICAgICBtYXQyLnJvdGF0ZShkZXN0LCBkZXN0LCByYWQpO1xuICpcbiAqIEBwYXJhbSB7bWF0Mn0gb3V0IG1hdDIgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcbiAqIEBwYXJhbSB7TnVtYmVyfSByYWQgdGhlIGFuZ2xlIHRvIHJvdGF0ZSB0aGUgbWF0cml4IGJ5XG4gKiBAcmV0dXJucyB7bWF0Mn0gb3V0XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGZyb21Sb3RhdGlvbihvdXQsIHJhZCkge1xuICB2YXIgcyA9IE1hdGguc2luKHJhZCk7XG4gIHZhciBjID0gTWF0aC5jb3MocmFkKTtcbiAgb3V0WzBdID0gYztcbiAgb3V0WzFdID0gcztcbiAgb3V0WzJdID0gLXM7XG4gIG91dFszXSA9IGM7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIENyZWF0ZXMgYSBtYXRyaXggZnJvbSBhIHZlY3RvciBzY2FsaW5nXG4gKiBUaGlzIGlzIGVxdWl2YWxlbnQgdG8gKGJ1dCBtdWNoIGZhc3RlciB0aGFuKTpcbiAqXG4gKiAgICAgbWF0Mi5pZGVudGl0eShkZXN0KTtcbiAqICAgICBtYXQyLnNjYWxlKGRlc3QsIGRlc3QsIHZlYyk7XG4gKlxuICogQHBhcmFtIHttYXQyfSBvdXQgbWF0MiByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IHYgU2NhbGluZyB2ZWN0b3JcbiAqIEByZXR1cm5zIHttYXQyfSBvdXRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZnJvbVNjYWxpbmcob3V0LCB2KSB7XG4gIG91dFswXSA9IHZbMF07XG4gIG91dFsxXSA9IDA7XG4gIG91dFsyXSA9IDA7XG4gIG91dFszXSA9IHZbMV07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYSBtYXQyXG4gKlxuICogQHBhcmFtIHtSZWFkb25seU1hdDJ9IGEgbWF0cml4IHRvIHJlcHJlc2VudCBhcyBhIHN0cmluZ1xuICogQHJldHVybnMge1N0cmluZ30gc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBtYXRyaXhcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gc3RyKGEpIHtcbiAgcmV0dXJuIFwibWF0MihcIiArIGFbMF0gKyBcIiwgXCIgKyBhWzFdICsgXCIsIFwiICsgYVsyXSArIFwiLCBcIiArIGFbM10gKyBcIilcIjtcbn1cbi8qKlxuICogUmV0dXJucyBGcm9iZW5pdXMgbm9ybSBvZiBhIG1hdDJcbiAqXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0Mn0gYSB0aGUgbWF0cml4IHRvIGNhbGN1bGF0ZSBGcm9iZW5pdXMgbm9ybSBvZlxuICogQHJldHVybnMge051bWJlcn0gRnJvYmVuaXVzIG5vcm1cbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZnJvYihhKSB7XG4gIHJldHVybiBNYXRoLmh5cG90KGFbMF0sIGFbMV0sIGFbMl0sIGFbM10pO1xufVxuLyoqXG4gKiBSZXR1cm5zIEwsIEQgYW5kIFUgbWF0cmljZXMgKExvd2VyIHRyaWFuZ3VsYXIsIERpYWdvbmFsIGFuZCBVcHBlciB0cmlhbmd1bGFyKSBieSBmYWN0b3JpemluZyB0aGUgaW5wdXQgbWF0cml4XG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0Mn0gTCB0aGUgbG93ZXIgdHJpYW5ndWxhciBtYXRyaXhcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQyfSBEIHRoZSBkaWFnb25hbCBtYXRyaXhcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQyfSBVIHRoZSB1cHBlciB0cmlhbmd1bGFyIG1hdHJpeFxuICogQHBhcmFtIHtSZWFkb25seU1hdDJ9IGEgdGhlIGlucHV0IG1hdHJpeCB0byBmYWN0b3JpemVcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gTERVKEwsIEQsIFUsIGEpIHtcbiAgTFsyXSA9IGFbMl0gLyBhWzBdO1xuICBVWzBdID0gYVswXTtcbiAgVVsxXSA9IGFbMV07XG4gIFVbM10gPSBhWzNdIC0gTFsyXSAqIFVbMV07XG4gIHJldHVybiBbTCwgRCwgVV07XG59XG4vKipcbiAqIEFkZHMgdHdvIG1hdDInc1xuICpcbiAqIEBwYXJhbSB7bWF0Mn0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0Mn0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHtSZWFkb25seU1hdDJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7bWF0Mn0gb3V0XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGFkZChvdXQsIGEsIGIpIHtcbiAgb3V0WzBdID0gYVswXSArIGJbMF07XG4gIG91dFsxXSA9IGFbMV0gKyBiWzFdO1xuICBvdXRbMl0gPSBhWzJdICsgYlsyXTtcbiAgb3V0WzNdID0gYVszXSArIGJbM107XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIFN1YnRyYWN0cyBtYXRyaXggYiBmcm9tIG1hdHJpeCBhXG4gKlxuICogQHBhcmFtIHttYXQyfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0Mn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHttYXQyfSBvdXRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gc3VidHJhY3Qob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IGFbMF0gLSBiWzBdO1xuICBvdXRbMV0gPSBhWzFdIC0gYlsxXTtcbiAgb3V0WzJdID0gYVsyXSAtIGJbMl07XG4gIG91dFszXSA9IGFbM10gLSBiWzNdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSBtYXRyaWNlcyBoYXZlIGV4YWN0bHkgdGhlIHNhbWUgZWxlbWVudHMgaW4gdGhlIHNhbWUgcG9zaXRpb24gKHdoZW4gY29tcGFyZWQgd2l0aCA9PT0pXG4gKlxuICogQHBhcmFtIHtSZWFkb25seU1hdDJ9IGEgVGhlIGZpcnN0IG1hdHJpeC5cbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQyfSBiIFRoZSBzZWNvbmQgbWF0cml4LlxuICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWYgdGhlIG1hdHJpY2VzIGFyZSBlcXVhbCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBleGFjdEVxdWFscyhhLCBiKSB7XG4gIHJldHVybiBhWzBdID09PSBiWzBdICYmIGFbMV0gPT09IGJbMV0gJiYgYVsyXSA9PT0gYlsyXSAmJiBhWzNdID09PSBiWzNdO1xufVxuLyoqXG4gKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSBtYXRyaWNlcyBoYXZlIGFwcHJveGltYXRlbHkgdGhlIHNhbWUgZWxlbWVudHMgaW4gdGhlIHNhbWUgcG9zaXRpb24uXG4gKlxuICogQHBhcmFtIHtSZWFkb25seU1hdDJ9IGEgVGhlIGZpcnN0IG1hdHJpeC5cbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQyfSBiIFRoZSBzZWNvbmQgbWF0cml4LlxuICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWYgdGhlIG1hdHJpY2VzIGFyZSBlcXVhbCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBlcXVhbHMoYSwgYikge1xuICB2YXIgYTAgPSBhWzBdLFxuICAgICAgYTEgPSBhWzFdLFxuICAgICAgYTIgPSBhWzJdLFxuICAgICAgYTMgPSBhWzNdO1xuICB2YXIgYjAgPSBiWzBdLFxuICAgICAgYjEgPSBiWzFdLFxuICAgICAgYjIgPSBiWzJdLFxuICAgICAgYjMgPSBiWzNdO1xuICByZXR1cm4gTWF0aC5hYnMoYTAgLSBiMCkgPD0gZ2xNYXRyaXguRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTApLCBNYXRoLmFicyhiMCkpICYmIE1hdGguYWJzKGExIC0gYjEpIDw9IGdsTWF0cml4LkVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGExKSwgTWF0aC5hYnMoYjEpKSAmJiBNYXRoLmFicyhhMiAtIGIyKSA8PSBnbE1hdHJpeC5FUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMiksIE1hdGguYWJzKGIyKSkgJiYgTWF0aC5hYnMoYTMgLSBiMykgPD0gZ2xNYXRyaXguRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTMpLCBNYXRoLmFicyhiMykpO1xufVxuLyoqXG4gKiBNdWx0aXBseSBlYWNoIGVsZW1lbnQgb2YgdGhlIG1hdHJpeCBieSBhIHNjYWxhci5cbiAqXG4gKiBAcGFyYW0ge21hdDJ9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHtSZWFkb25seU1hdDJ9IGEgdGhlIG1hdHJpeCB0byBzY2FsZVxuICogQHBhcmFtIHtOdW1iZXJ9IGIgYW1vdW50IHRvIHNjYWxlIHRoZSBtYXRyaXgncyBlbGVtZW50cyBieVxuICogQHJldHVybnMge21hdDJ9IG91dFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBtdWx0aXBseVNjYWxhcihvdXQsIGEsIGIpIHtcbiAgb3V0WzBdID0gYVswXSAqIGI7XG4gIG91dFsxXSA9IGFbMV0gKiBiO1xuICBvdXRbMl0gPSBhWzJdICogYjtcbiAgb3V0WzNdID0gYVszXSAqIGI7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIEFkZHMgdHdvIG1hdDIncyBhZnRlciBtdWx0aXBseWluZyBlYWNoIGVsZW1lbnQgb2YgdGhlIHNlY29uZCBvcGVyYW5kIGJ5IGEgc2NhbGFyIHZhbHVlLlxuICpcbiAqIEBwYXJhbSB7bWF0Mn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0Mn0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHtSZWFkb25seU1hdDJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcGFyYW0ge051bWJlcn0gc2NhbGUgdGhlIGFtb3VudCB0byBzY2FsZSBiJ3MgZWxlbWVudHMgYnkgYmVmb3JlIGFkZGluZ1xuICogQHJldHVybnMge21hdDJ9IG91dFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBtdWx0aXBseVNjYWxhckFuZEFkZChvdXQsIGEsIGIsIHNjYWxlKSB7XG4gIG91dFswXSA9IGFbMF0gKyBiWzBdICogc2NhbGU7XG4gIG91dFsxXSA9IGFbMV0gKyBiWzFdICogc2NhbGU7XG4gIG91dFsyXSA9IGFbMl0gKyBiWzJdICogc2NhbGU7XG4gIG91dFszXSA9IGFbM10gKyBiWzNdICogc2NhbGU7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgbWF0Mi5tdWx0aXBseX1cbiAqIEBmdW5jdGlvblxuICovXG5cbmV4cG9ydCB2YXIgbXVsID0gbXVsdGlwbHk7XG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgbWF0Mi5zdWJ0cmFjdH1cbiAqIEBmdW5jdGlvblxuICovXG5cbmV4cG9ydCB2YXIgc3ViID0gc3VidHJhY3Q7IiwiaW1wb3J0ICogYXMgZ2xNYXRyaXggZnJvbSBcIi4vY29tbW9uLmpzXCI7XG4vKipcbiAqIDIgRGltZW5zaW9uYWwgVmVjdG9yXG4gKiBAbW9kdWxlIHZlYzJcbiAqL1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcsIGVtcHR5IHZlYzJcbiAqXG4gKiBAcmV0dXJucyB7dmVjMn0gYSBuZXcgMkQgdmVjdG9yXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZSgpIHtcbiAgdmFyIG91dCA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDIpO1xuXG4gIGlmIChnbE1hdHJpeC5BUlJBWV9UWVBFICE9IEZsb2F0MzJBcnJheSkge1xuICAgIG91dFswXSA9IDA7XG4gICAgb3V0WzFdID0gMDtcbiAgfVxuXG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgdmVjMiBpbml0aWFsaXplZCB3aXRoIHZhbHVlcyBmcm9tIGFuIGV4aXN0aW5nIHZlY3RvclxuICpcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBhIHZlY3RvciB0byBjbG9uZVxuICogQHJldHVybnMge3ZlYzJ9IGEgbmV3IDJEIHZlY3RvclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBjbG9uZShhKSB7XG4gIHZhciBvdXQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSgyKTtcbiAgb3V0WzBdID0gYVswXTtcbiAgb3V0WzFdID0gYVsxXTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyB2ZWMyIGluaXRpYWxpemVkIHdpdGggdGhlIGdpdmVuIHZhbHVlc1xuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSB4IFggY29tcG9uZW50XG4gKiBAcGFyYW0ge051bWJlcn0geSBZIGNvbXBvbmVudFxuICogQHJldHVybnMge3ZlYzJ9IGEgbmV3IDJEIHZlY3RvclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBmcm9tVmFsdWVzKHgsIHkpIHtcbiAgdmFyIG91dCA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDIpO1xuICBvdXRbMF0gPSB4O1xuICBvdXRbMV0gPSB5O1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBDb3B5IHRoZSB2YWx1ZXMgZnJvbSBvbmUgdmVjMiB0byBhbm90aGVyXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBhIHRoZSBzb3VyY2UgdmVjdG9yXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGNvcHkob3V0LCBhKSB7XG4gIG91dFswXSA9IGFbMF07XG4gIG91dFsxXSA9IGFbMV07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIFNldCB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzIgdG8gdGhlIGdpdmVuIHZhbHVlc1xuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge051bWJlcn0geCBYIGNvbXBvbmVudFxuICogQHBhcmFtIHtOdW1iZXJ9IHkgWSBjb21wb25lbnRcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gc2V0KG91dCwgeCwgeSkge1xuICBvdXRbMF0gPSB4O1xuICBvdXRbMV0gPSB5O1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBBZGRzIHR3byB2ZWMyJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBhZGQob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IGFbMF0gKyBiWzBdO1xuICBvdXRbMV0gPSBhWzFdICsgYlsxXTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogU3VidHJhY3RzIHZlY3RvciBiIGZyb20gdmVjdG9yIGFcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBzdWJ0cmFjdChvdXQsIGEsIGIpIHtcbiAgb3V0WzBdID0gYVswXSAtIGJbMF07XG4gIG91dFsxXSA9IGFbMV0gLSBiWzFdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBNdWx0aXBsaWVzIHR3byB2ZWMyJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBtdWx0aXBseShvdXQsIGEsIGIpIHtcbiAgb3V0WzBdID0gYVswXSAqIGJbMF07XG4gIG91dFsxXSA9IGFbMV0gKiBiWzFdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBEaXZpZGVzIHR3byB2ZWMyJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBkaXZpZGUob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IGFbMF0gLyBiWzBdO1xuICBvdXRbMV0gPSBhWzFdIC8gYlsxXTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogTWF0aC5jZWlsIHRoZSBjb21wb25lbnRzIG9mIGEgdmVjMlxuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gYSB2ZWN0b3IgdG8gY2VpbFxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBjZWlsKG91dCwgYSkge1xuICBvdXRbMF0gPSBNYXRoLmNlaWwoYVswXSk7XG4gIG91dFsxXSA9IE1hdGguY2VpbChhWzFdKTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogTWF0aC5mbG9vciB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzJcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGEgdmVjdG9yIHRvIGZsb29yXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGZsb29yKG91dCwgYSkge1xuICBvdXRbMF0gPSBNYXRoLmZsb29yKGFbMF0pO1xuICBvdXRbMV0gPSBNYXRoLmZsb29yKGFbMV0pO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBSZXR1cm5zIHRoZSBtaW5pbXVtIG9mIHR3byB2ZWMyJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBtaW4ob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IE1hdGgubWluKGFbMF0sIGJbMF0pO1xuICBvdXRbMV0gPSBNYXRoLm1pbihhWzFdLCBiWzFdKTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogUmV0dXJucyB0aGUgbWF4aW11bSBvZiB0d28gdmVjMidzXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gbWF4KG91dCwgYSwgYikge1xuICBvdXRbMF0gPSBNYXRoLm1heChhWzBdLCBiWzBdKTtcbiAgb3V0WzFdID0gTWF0aC5tYXgoYVsxXSwgYlsxXSk7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIE1hdGgucm91bmQgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWMyXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBhIHZlY3RvciB0byByb3VuZFxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiByb3VuZChvdXQsIGEpIHtcbiAgb3V0WzBdID0gTWF0aC5yb3VuZChhWzBdKTtcbiAgb3V0WzFdID0gTWF0aC5yb3VuZChhWzFdKTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogU2NhbGVzIGEgdmVjMiBieSBhIHNjYWxhciBudW1iZXJcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGEgdGhlIHZlY3RvciB0byBzY2FsZVxuICogQHBhcmFtIHtOdW1iZXJ9IGIgYW1vdW50IHRvIHNjYWxlIHRoZSB2ZWN0b3IgYnlcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gc2NhbGUob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IGFbMF0gKiBiO1xuICBvdXRbMV0gPSBhWzFdICogYjtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogQWRkcyB0d28gdmVjMidzIGFmdGVyIHNjYWxpbmcgdGhlIHNlY29uZCBvcGVyYW5kIGJ5IGEgc2NhbGFyIHZhbHVlXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEBwYXJhbSB7TnVtYmVyfSBzY2FsZSB0aGUgYW1vdW50IHRvIHNjYWxlIGIgYnkgYmVmb3JlIGFkZGluZ1xuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBzY2FsZUFuZEFkZChvdXQsIGEsIGIsIHNjYWxlKSB7XG4gIG91dFswXSA9IGFbMF0gKyBiWzBdICogc2NhbGU7XG4gIG91dFsxXSA9IGFbMV0gKyBiWzFdICogc2NhbGU7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGV1Y2xpZGlhbiBkaXN0YW5jZSBiZXR3ZWVuIHR3byB2ZWMyJ3NcbiAqXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBkaXN0YW5jZSBiZXR3ZWVuIGEgYW5kIGJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZGlzdGFuY2UoYSwgYikge1xuICB2YXIgeCA9IGJbMF0gLSBhWzBdLFxuICAgICAgeSA9IGJbMV0gLSBhWzFdO1xuICByZXR1cm4gTWF0aC5oeXBvdCh4LCB5KTtcbn1cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgc3F1YXJlZCBldWNsaWRpYW4gZGlzdGFuY2UgYmV0d2VlbiB0d28gdmVjMidzXG4gKlxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge051bWJlcn0gc3F1YXJlZCBkaXN0YW5jZSBiZXR3ZWVuIGEgYW5kIGJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gc3F1YXJlZERpc3RhbmNlKGEsIGIpIHtcbiAgdmFyIHggPSBiWzBdIC0gYVswXSxcbiAgICAgIHkgPSBiWzFdIC0gYVsxXTtcbiAgcmV0dXJuIHggKiB4ICsgeSAqIHk7XG59XG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGxlbmd0aCBvZiBhIHZlYzJcbiAqXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gYSB2ZWN0b3IgdG8gY2FsY3VsYXRlIGxlbmd0aCBvZlxuICogQHJldHVybnMge051bWJlcn0gbGVuZ3RoIG9mIGFcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gbGVuZ3RoKGEpIHtcbiAgdmFyIHggPSBhWzBdLFxuICAgICAgeSA9IGFbMV07XG4gIHJldHVybiBNYXRoLmh5cG90KHgsIHkpO1xufVxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBzcXVhcmVkIGxlbmd0aCBvZiBhIHZlYzJcbiAqXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gYSB2ZWN0b3IgdG8gY2FsY3VsYXRlIHNxdWFyZWQgbGVuZ3RoIG9mXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBzcXVhcmVkIGxlbmd0aCBvZiBhXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHNxdWFyZWRMZW5ndGgoYSkge1xuICB2YXIgeCA9IGFbMF0sXG4gICAgICB5ID0gYVsxXTtcbiAgcmV0dXJuIHggKiB4ICsgeSAqIHk7XG59XG4vKipcbiAqIE5lZ2F0ZXMgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWMyXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBhIHZlY3RvciB0byBuZWdhdGVcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gbmVnYXRlKG91dCwgYSkge1xuICBvdXRbMF0gPSAtYVswXTtcbiAgb3V0WzFdID0gLWFbMV07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIFJldHVybnMgdGhlIGludmVyc2Ugb2YgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWMyXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBhIHZlY3RvciB0byBpbnZlcnRcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gaW52ZXJzZShvdXQsIGEpIHtcbiAgb3V0WzBdID0gMS4wIC8gYVswXTtcbiAgb3V0WzFdID0gMS4wIC8gYVsxXTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogTm9ybWFsaXplIGEgdmVjMlxuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gYSB2ZWN0b3IgdG8gbm9ybWFsaXplXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIG5vcm1hbGl6ZShvdXQsIGEpIHtcbiAgdmFyIHggPSBhWzBdLFxuICAgICAgeSA9IGFbMV07XG4gIHZhciBsZW4gPSB4ICogeCArIHkgKiB5O1xuXG4gIGlmIChsZW4gPiAwKSB7XG4gICAgLy9UT0RPOiBldmFsdWF0ZSB1c2Ugb2YgZ2xtX2ludnNxcnQgaGVyZT9cbiAgICBsZW4gPSAxIC8gTWF0aC5zcXJ0KGxlbik7XG4gIH1cblxuICBvdXRbMF0gPSBhWzBdICogbGVuO1xuICBvdXRbMV0gPSBhWzFdICogbGVuO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBkb3QgcHJvZHVjdCBvZiB0d28gdmVjMidzXG4gKlxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge051bWJlcn0gZG90IHByb2R1Y3Qgb2YgYSBhbmQgYlxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBkb3QoYSwgYikge1xuICByZXR1cm4gYVswXSAqIGJbMF0gKyBhWzFdICogYlsxXTtcbn1cbi8qKlxuICogQ29tcHV0ZXMgdGhlIGNyb3NzIHByb2R1Y3Qgb2YgdHdvIHZlYzInc1xuICogTm90ZSB0aGF0IHRoZSBjcm9zcyBwcm9kdWN0IG11c3QgYnkgZGVmaW5pdGlvbiBwcm9kdWNlIGEgM0QgdmVjdG9yXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gY3Jvc3Mob3V0LCBhLCBiKSB7XG4gIHZhciB6ID0gYVswXSAqIGJbMV0gLSBhWzFdICogYlswXTtcbiAgb3V0WzBdID0gb3V0WzFdID0gMDtcbiAgb3V0WzJdID0gejtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogUGVyZm9ybXMgYSBsaW5lYXIgaW50ZXJwb2xhdGlvbiBiZXR3ZWVuIHR3byB2ZWMyJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHBhcmFtIHtOdW1iZXJ9IHQgaW50ZXJwb2xhdGlvbiBhbW91bnQsIGluIHRoZSByYW5nZSBbMC0xXSwgYmV0d2VlbiB0aGUgdHdvIGlucHV0c1xuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBsZXJwKG91dCwgYSwgYiwgdCkge1xuICB2YXIgYXggPSBhWzBdLFxuICAgICAgYXkgPSBhWzFdO1xuICBvdXRbMF0gPSBheCArIHQgKiAoYlswXSAtIGF4KTtcbiAgb3V0WzFdID0gYXkgKyB0ICogKGJbMV0gLSBheSk7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIEdlbmVyYXRlcyBhIHJhbmRvbSB2ZWN0b3Igd2l0aCB0aGUgZ2l2ZW4gc2NhbGVcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtOdW1iZXJ9IFtzY2FsZV0gTGVuZ3RoIG9mIHRoZSByZXN1bHRpbmcgdmVjdG9yLiBJZiBvbW1pdHRlZCwgYSB1bml0IHZlY3RvciB3aWxsIGJlIHJldHVybmVkXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHJhbmRvbShvdXQsIHNjYWxlKSB7XG4gIHNjYWxlID0gc2NhbGUgfHwgMS4wO1xuICB2YXIgciA9IGdsTWF0cml4LlJBTkRPTSgpICogMi4wICogTWF0aC5QSTtcbiAgb3V0WzBdID0gTWF0aC5jb3MocikgKiBzY2FsZTtcbiAgb3V0WzFdID0gTWF0aC5zaW4ocikgKiBzY2FsZTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogVHJhbnNmb3JtcyB0aGUgdmVjMiB3aXRoIGEgbWF0MlxuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gYSB0aGUgdmVjdG9yIHRvIHRyYW5zZm9ybVxuICogQHBhcmFtIHtSZWFkb25seU1hdDJ9IG0gbWF0cml4IHRvIHRyYW5zZm9ybSB3aXRoXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHRyYW5zZm9ybU1hdDIob3V0LCBhLCBtKSB7XG4gIHZhciB4ID0gYVswXSxcbiAgICAgIHkgPSBhWzFdO1xuICBvdXRbMF0gPSBtWzBdICogeCArIG1bMl0gKiB5O1xuICBvdXRbMV0gPSBtWzFdICogeCArIG1bM10gKiB5O1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBUcmFuc2Zvcm1zIHRoZSB2ZWMyIHdpdGggYSBtYXQyZFxuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gYSB0aGUgdmVjdG9yIHRvIHRyYW5zZm9ybVxuICogQHBhcmFtIHtSZWFkb25seU1hdDJkfSBtIG1hdHJpeCB0byB0cmFuc2Zvcm0gd2l0aFxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiB0cmFuc2Zvcm1NYXQyZChvdXQsIGEsIG0pIHtcbiAgdmFyIHggPSBhWzBdLFxuICAgICAgeSA9IGFbMV07XG4gIG91dFswXSA9IG1bMF0gKiB4ICsgbVsyXSAqIHkgKyBtWzRdO1xuICBvdXRbMV0gPSBtWzFdICogeCArIG1bM10gKiB5ICsgbVs1XTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogVHJhbnNmb3JtcyB0aGUgdmVjMiB3aXRoIGEgbWF0M1xuICogM3JkIHZlY3RvciBjb21wb25lbnQgaXMgaW1wbGljaXRseSAnMSdcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGEgdGhlIHZlY3RvciB0byB0cmFuc2Zvcm1cbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQzfSBtIG1hdHJpeCB0byB0cmFuc2Zvcm0gd2l0aFxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiB0cmFuc2Zvcm1NYXQzKG91dCwgYSwgbSkge1xuICB2YXIgeCA9IGFbMF0sXG4gICAgICB5ID0gYVsxXTtcbiAgb3V0WzBdID0gbVswXSAqIHggKyBtWzNdICogeSArIG1bNl07XG4gIG91dFsxXSA9IG1bMV0gKiB4ICsgbVs0XSAqIHkgKyBtWzddO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBUcmFuc2Zvcm1zIHRoZSB2ZWMyIHdpdGggYSBtYXQ0XG4gKiAzcmQgdmVjdG9yIGNvbXBvbmVudCBpcyBpbXBsaWNpdGx5ICcwJ1xuICogNHRoIHZlY3RvciBjb21wb25lbnQgaXMgaW1wbGljaXRseSAnMSdcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGEgdGhlIHZlY3RvciB0byB0cmFuc2Zvcm1cbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQ0fSBtIG1hdHJpeCB0byB0cmFuc2Zvcm0gd2l0aFxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiB0cmFuc2Zvcm1NYXQ0KG91dCwgYSwgbSkge1xuICB2YXIgeCA9IGFbMF07XG4gIHZhciB5ID0gYVsxXTtcbiAgb3V0WzBdID0gbVswXSAqIHggKyBtWzRdICogeSArIG1bMTJdO1xuICBvdXRbMV0gPSBtWzFdICogeCArIG1bNV0gKiB5ICsgbVsxM107XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIFJvdGF0ZSBhIDJEIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBvdXQgVGhlIHJlY2VpdmluZyB2ZWMyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gYSBUaGUgdmVjMiBwb2ludCB0byByb3RhdGVcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBiIFRoZSBvcmlnaW4gb2YgdGhlIHJvdGF0aW9uXG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIFRoZSBhbmdsZSBvZiByb3RhdGlvbiBpbiByYWRpYW5zXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHJvdGF0ZShvdXQsIGEsIGIsIHJhZCkge1xuICAvL1RyYW5zbGF0ZSBwb2ludCB0byB0aGUgb3JpZ2luXG4gIHZhciBwMCA9IGFbMF0gLSBiWzBdLFxuICAgICAgcDEgPSBhWzFdIC0gYlsxXSxcbiAgICAgIHNpbkMgPSBNYXRoLnNpbihyYWQpLFxuICAgICAgY29zQyA9IE1hdGguY29zKHJhZCk7IC8vcGVyZm9ybSByb3RhdGlvbiBhbmQgdHJhbnNsYXRlIHRvIGNvcnJlY3QgcG9zaXRpb25cblxuICBvdXRbMF0gPSBwMCAqIGNvc0MgLSBwMSAqIHNpbkMgKyBiWzBdO1xuICBvdXRbMV0gPSBwMCAqIHNpbkMgKyBwMSAqIGNvc0MgKyBiWzFdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBHZXQgdGhlIGFuZ2xlIGJldHdlZW4gdHdvIDJEIHZlY3RvcnNcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBhIFRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gYiBUaGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSBhbmdsZSBpbiByYWRpYW5zXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGFuZ2xlKGEsIGIpIHtcbiAgdmFyIHgxID0gYVswXSxcbiAgICAgIHkxID0gYVsxXSxcbiAgICAgIHgyID0gYlswXSxcbiAgICAgIHkyID0gYlsxXSxcbiAgICAgIC8vIG1hZyBpcyB0aGUgcHJvZHVjdCBvZiB0aGUgbWFnbml0dWRlcyBvZiBhIGFuZCBiXG4gIG1hZyA9IE1hdGguc3FydCh4MSAqIHgxICsgeTEgKiB5MSkgKiBNYXRoLnNxcnQoeDIgKiB4MiArIHkyICogeTIpLFxuICAgICAgLy8gbWFnICYmLi4gc2hvcnQgY2lyY3VpdHMgaWYgbWFnID09IDBcbiAgY29zaW5lID0gbWFnICYmICh4MSAqIHgyICsgeTEgKiB5MikgLyBtYWc7IC8vIE1hdGgubWluKE1hdGgubWF4KGNvc2luZSwgLTEpLCAxKSBjbGFtcHMgdGhlIGNvc2luZSBiZXR3ZWVuIC0xIGFuZCAxXG5cbiAgcmV0dXJuIE1hdGguYWNvcyhNYXRoLm1pbihNYXRoLm1heChjb3NpbmUsIC0xKSwgMSkpO1xufVxuLyoqXG4gKiBTZXQgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWMyIHRvIHplcm9cbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiB6ZXJvKG91dCkge1xuICBvdXRbMF0gPSAwLjA7XG4gIG91dFsxXSA9IDAuMDtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhIHZlY3RvclxuICpcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBhIHZlY3RvciB0byByZXByZXNlbnQgYXMgYSBzdHJpbmdcbiAqIEByZXR1cm5zIHtTdHJpbmd9IHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgdmVjdG9yXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHN0cihhKSB7XG4gIHJldHVybiBcInZlYzIoXCIgKyBhWzBdICsgXCIsIFwiICsgYVsxXSArIFwiKVwiO1xufVxuLyoqXG4gKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSB2ZWN0b3JzIGV4YWN0bHkgaGF2ZSB0aGUgc2FtZSBlbGVtZW50cyBpbiB0aGUgc2FtZSBwb3NpdGlvbiAod2hlbiBjb21wYXJlZCB3aXRoID09PSlcbiAqXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gYSBUaGUgZmlyc3QgdmVjdG9yLlxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGIgVGhlIHNlY29uZCB2ZWN0b3IuXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gVHJ1ZSBpZiB0aGUgdmVjdG9ycyBhcmUgZXF1YWwsIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZXhhY3RFcXVhbHMoYSwgYikge1xuICByZXR1cm4gYVswXSA9PT0gYlswXSAmJiBhWzFdID09PSBiWzFdO1xufVxuLyoqXG4gKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSB2ZWN0b3JzIGhhdmUgYXBwcm94aW1hdGVseSB0aGUgc2FtZSBlbGVtZW50cyBpbiB0aGUgc2FtZSBwb3NpdGlvbi5cbiAqXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gYSBUaGUgZmlyc3QgdmVjdG9yLlxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGIgVGhlIHNlY29uZCB2ZWN0b3IuXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gVHJ1ZSBpZiB0aGUgdmVjdG9ycyBhcmUgZXF1YWwsIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZXF1YWxzKGEsIGIpIHtcbiAgdmFyIGEwID0gYVswXSxcbiAgICAgIGExID0gYVsxXTtcbiAgdmFyIGIwID0gYlswXSxcbiAgICAgIGIxID0gYlsxXTtcbiAgcmV0dXJuIE1hdGguYWJzKGEwIC0gYjApIDw9IGdsTWF0cml4LkVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGEwKSwgTWF0aC5hYnMoYjApKSAmJiBNYXRoLmFicyhhMSAtIGIxKSA8PSBnbE1hdHJpeC5FUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMSksIE1hdGguYWJzKGIxKSk7XG59XG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjMi5sZW5ndGh9XG4gKiBAZnVuY3Rpb25cbiAqL1xuXG5leHBvcnQgdmFyIGxlbiA9IGxlbmd0aDtcbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayB2ZWMyLnN1YnRyYWN0fVxuICogQGZ1bmN0aW9uXG4gKi9cblxuZXhwb3J0IHZhciBzdWIgPSBzdWJ0cmFjdDtcbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayB2ZWMyLm11bHRpcGx5fVxuICogQGZ1bmN0aW9uXG4gKi9cblxuZXhwb3J0IHZhciBtdWwgPSBtdWx0aXBseTtcbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayB2ZWMyLmRpdmlkZX1cbiAqIEBmdW5jdGlvblxuICovXG5cbmV4cG9ydCB2YXIgZGl2ID0gZGl2aWRlO1xuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzIuZGlzdGFuY2V9XG4gKiBAZnVuY3Rpb25cbiAqL1xuXG5leHBvcnQgdmFyIGRpc3QgPSBkaXN0YW5jZTtcbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayB2ZWMyLnNxdWFyZWREaXN0YW5jZX1cbiAqIEBmdW5jdGlvblxuICovXG5cbmV4cG9ydCB2YXIgc3FyRGlzdCA9IHNxdWFyZWREaXN0YW5jZTtcbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayB2ZWMyLnNxdWFyZWRMZW5ndGh9XG4gKiBAZnVuY3Rpb25cbiAqL1xuXG5leHBvcnQgdmFyIHNxckxlbiA9IHNxdWFyZWRMZW5ndGg7XG4vKipcbiAqIFBlcmZvcm0gc29tZSBvcGVyYXRpb24gb3ZlciBhbiBhcnJheSBvZiB2ZWMycy5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBhIHRoZSBhcnJheSBvZiB2ZWN0b3JzIHRvIGl0ZXJhdGUgb3ZlclxuICogQHBhcmFtIHtOdW1iZXJ9IHN0cmlkZSBOdW1iZXIgb2YgZWxlbWVudHMgYmV0d2VlbiB0aGUgc3RhcnQgb2YgZWFjaCB2ZWMyLiBJZiAwIGFzc3VtZXMgdGlnaHRseSBwYWNrZWRcbiAqIEBwYXJhbSB7TnVtYmVyfSBvZmZzZXQgTnVtYmVyIG9mIGVsZW1lbnRzIHRvIHNraXAgYXQgdGhlIGJlZ2lubmluZyBvZiB0aGUgYXJyYXlcbiAqIEBwYXJhbSB7TnVtYmVyfSBjb3VudCBOdW1iZXIgb2YgdmVjMnMgdG8gaXRlcmF0ZSBvdmVyLiBJZiAwIGl0ZXJhdGVzIG92ZXIgZW50aXJlIGFycmF5XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBGdW5jdGlvbiB0byBjYWxsIGZvciBlYWNoIHZlY3RvciBpbiB0aGUgYXJyYXlcbiAqIEBwYXJhbSB7T2JqZWN0fSBbYXJnXSBhZGRpdGlvbmFsIGFyZ3VtZW50IHRvIHBhc3MgdG8gZm5cbiAqIEByZXR1cm5zIHtBcnJheX0gYVxuICogQGZ1bmN0aW9uXG4gKi9cblxuZXhwb3J0IHZhciBmb3JFYWNoID0gZnVuY3Rpb24gKCkge1xuICB2YXIgdmVjID0gY3JlYXRlKCk7XG4gIHJldHVybiBmdW5jdGlvbiAoYSwgc3RyaWRlLCBvZmZzZXQsIGNvdW50LCBmbiwgYXJnKSB7XG4gICAgdmFyIGksIGw7XG5cbiAgICBpZiAoIXN0cmlkZSkge1xuICAgICAgc3RyaWRlID0gMjtcbiAgICB9XG5cbiAgICBpZiAoIW9mZnNldCkge1xuICAgICAgb2Zmc2V0ID0gMDtcbiAgICB9XG5cbiAgICBpZiAoY291bnQpIHtcbiAgICAgIGwgPSBNYXRoLm1pbihjb3VudCAqIHN0cmlkZSArIG9mZnNldCwgYS5sZW5ndGgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBsID0gYS5sZW5ndGg7XG4gICAgfVxuXG4gICAgZm9yIChpID0gb2Zmc2V0OyBpIDwgbDsgaSArPSBzdHJpZGUpIHtcbiAgICAgIHZlY1swXSA9IGFbaV07XG4gICAgICB2ZWNbMV0gPSBhW2kgKyAxXTtcbiAgICAgIGZuKHZlYywgdmVjLCBhcmcpO1xuICAgICAgYVtpXSA9IHZlY1swXTtcbiAgICAgIGFbaSArIDFdID0gdmVjWzFdO1xuICAgIH1cblxuICAgIHJldHVybiBhO1xuICB9O1xufSgpOyIsImltcG9ydCAqIGFzIGdsTWF0cml4IGZyb20gXCIuL2NvbW1vbi5qc1wiO1xuLyoqXG4gKiAzIERpbWVuc2lvbmFsIFZlY3RvclxuICogQG1vZHVsZSB2ZWMzXG4gKi9cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3LCBlbXB0eSB2ZWMzXG4gKlxuICogQHJldHVybnMge3ZlYzN9IGEgbmV3IDNEIHZlY3RvclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGUoKSB7XG4gIHZhciBvdXQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSgzKTtcblxuICBpZiAoZ2xNYXRyaXguQVJSQVlfVFlQRSAhPSBGbG9hdDMyQXJyYXkpIHtcbiAgICBvdXRbMF0gPSAwO1xuICAgIG91dFsxXSA9IDA7XG4gICAgb3V0WzJdID0gMDtcbiAgfVxuXG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgdmVjMyBpbml0aWFsaXplZCB3aXRoIHZhbHVlcyBmcm9tIGFuIGV4aXN0aW5nIHZlY3RvclxuICpcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBhIHZlY3RvciB0byBjbG9uZVxuICogQHJldHVybnMge3ZlYzN9IGEgbmV3IDNEIHZlY3RvclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBjbG9uZShhKSB7XG4gIHZhciBvdXQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSgzKTtcbiAgb3V0WzBdID0gYVswXTtcbiAgb3V0WzFdID0gYVsxXTtcbiAgb3V0WzJdID0gYVsyXTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgbGVuZ3RoIG9mIGEgdmVjM1xuICpcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBhIHZlY3RvciB0byBjYWxjdWxhdGUgbGVuZ3RoIG9mXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBsZW5ndGggb2YgYVxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBsZW5ndGgoYSkge1xuICB2YXIgeCA9IGFbMF07XG4gIHZhciB5ID0gYVsxXTtcbiAgdmFyIHogPSBhWzJdO1xuICByZXR1cm4gTWF0aC5oeXBvdCh4LCB5LCB6KTtcbn1cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyB2ZWMzIGluaXRpYWxpemVkIHdpdGggdGhlIGdpdmVuIHZhbHVlc1xuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSB4IFggY29tcG9uZW50XG4gKiBAcGFyYW0ge051bWJlcn0geSBZIGNvbXBvbmVudFxuICogQHBhcmFtIHtOdW1iZXJ9IHogWiBjb21wb25lbnRcbiAqIEByZXR1cm5zIHt2ZWMzfSBhIG5ldyAzRCB2ZWN0b3JcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZnJvbVZhbHVlcyh4LCB5LCB6KSB7XG4gIHZhciBvdXQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSgzKTtcbiAgb3V0WzBdID0geDtcbiAgb3V0WzFdID0geTtcbiAgb3V0WzJdID0gejtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogQ29weSB0aGUgdmFsdWVzIGZyb20gb25lIHZlYzMgdG8gYW5vdGhlclxuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYSB0aGUgc291cmNlIHZlY3RvclxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBjb3B5KG91dCwgYSkge1xuICBvdXRbMF0gPSBhWzBdO1xuICBvdXRbMV0gPSBhWzFdO1xuICBvdXRbMl0gPSBhWzJdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBTZXQgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWMzIHRvIHRoZSBnaXZlbiB2YWx1ZXNcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtOdW1iZXJ9IHggWCBjb21wb25lbnRcbiAqIEBwYXJhbSB7TnVtYmVyfSB5IFkgY29tcG9uZW50XG4gKiBAcGFyYW0ge051bWJlcn0geiBaIGNvbXBvbmVudFxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBzZXQob3V0LCB4LCB5LCB6KSB7XG4gIG91dFswXSA9IHg7XG4gIG91dFsxXSA9IHk7XG4gIG91dFsyXSA9IHo7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIEFkZHMgdHdvIHZlYzMnc1xuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGFkZChvdXQsIGEsIGIpIHtcbiAgb3V0WzBdID0gYVswXSArIGJbMF07XG4gIG91dFsxXSA9IGFbMV0gKyBiWzFdO1xuICBvdXRbMl0gPSBhWzJdICsgYlsyXTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogU3VidHJhY3RzIHZlY3RvciBiIGZyb20gdmVjdG9yIGFcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBzdWJ0cmFjdChvdXQsIGEsIGIpIHtcbiAgb3V0WzBdID0gYVswXSAtIGJbMF07XG4gIG91dFsxXSA9IGFbMV0gLSBiWzFdO1xuICBvdXRbMl0gPSBhWzJdIC0gYlsyXTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogTXVsdGlwbGllcyB0d28gdmVjMydzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gbXVsdGlwbHkob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IGFbMF0gKiBiWzBdO1xuICBvdXRbMV0gPSBhWzFdICogYlsxXTtcbiAgb3V0WzJdID0gYVsyXSAqIGJbMl07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIERpdmlkZXMgdHdvIHZlYzMnc1xuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGRpdmlkZShvdXQsIGEsIGIpIHtcbiAgb3V0WzBdID0gYVswXSAvIGJbMF07XG4gIG91dFsxXSA9IGFbMV0gLyBiWzFdO1xuICBvdXRbMl0gPSBhWzJdIC8gYlsyXTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogTWF0aC5jZWlsIHRoZSBjb21wb25lbnRzIG9mIGEgdmVjM1xuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYSB2ZWN0b3IgdG8gY2VpbFxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBjZWlsKG91dCwgYSkge1xuICBvdXRbMF0gPSBNYXRoLmNlaWwoYVswXSk7XG4gIG91dFsxXSA9IE1hdGguY2VpbChhWzFdKTtcbiAgb3V0WzJdID0gTWF0aC5jZWlsKGFbMl0pO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBNYXRoLmZsb29yIHRoZSBjb21wb25lbnRzIG9mIGEgdmVjM1xuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYSB2ZWN0b3IgdG8gZmxvb3JcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZmxvb3Iob3V0LCBhKSB7XG4gIG91dFswXSA9IE1hdGguZmxvb3IoYVswXSk7XG4gIG91dFsxXSA9IE1hdGguZmxvb3IoYVsxXSk7XG4gIG91dFsyXSA9IE1hdGguZmxvb3IoYVsyXSk7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIFJldHVybnMgdGhlIG1pbmltdW0gb2YgdHdvIHZlYzMnc1xuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIG1pbihvdXQsIGEsIGIpIHtcbiAgb3V0WzBdID0gTWF0aC5taW4oYVswXSwgYlswXSk7XG4gIG91dFsxXSA9IE1hdGgubWluKGFbMV0sIGJbMV0pO1xuICBvdXRbMl0gPSBNYXRoLm1pbihhWzJdLCBiWzJdKTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogUmV0dXJucyB0aGUgbWF4aW11bSBvZiB0d28gdmVjMydzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gbWF4KG91dCwgYSwgYikge1xuICBvdXRbMF0gPSBNYXRoLm1heChhWzBdLCBiWzBdKTtcbiAgb3V0WzFdID0gTWF0aC5tYXgoYVsxXSwgYlsxXSk7XG4gIG91dFsyXSA9IE1hdGgubWF4KGFbMl0sIGJbMl0pO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBNYXRoLnJvdW5kIHRoZSBjb21wb25lbnRzIG9mIGEgdmVjM1xuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYSB2ZWN0b3IgdG8gcm91bmRcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gcm91bmQob3V0LCBhKSB7XG4gIG91dFswXSA9IE1hdGgucm91bmQoYVswXSk7XG4gIG91dFsxXSA9IE1hdGgucm91bmQoYVsxXSk7XG4gIG91dFsyXSA9IE1hdGgucm91bmQoYVsyXSk7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIFNjYWxlcyBhIHZlYzMgYnkgYSBzY2FsYXIgbnVtYmVyXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBhIHRoZSB2ZWN0b3IgdG8gc2NhbGVcbiAqIEBwYXJhbSB7TnVtYmVyfSBiIGFtb3VudCB0byBzY2FsZSB0aGUgdmVjdG9yIGJ5XG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHNjYWxlKG91dCwgYSwgYikge1xuICBvdXRbMF0gPSBhWzBdICogYjtcbiAgb3V0WzFdID0gYVsxXSAqIGI7XG4gIG91dFsyXSA9IGFbMl0gKiBiO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBBZGRzIHR3byB2ZWMzJ3MgYWZ0ZXIgc2NhbGluZyB0aGUgc2Vjb25kIG9wZXJhbmQgYnkgYSBzY2FsYXIgdmFsdWVcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHBhcmFtIHtOdW1iZXJ9IHNjYWxlIHRoZSBhbW91bnQgdG8gc2NhbGUgYiBieSBiZWZvcmUgYWRkaW5nXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHNjYWxlQW5kQWRkKG91dCwgYSwgYiwgc2NhbGUpIHtcbiAgb3V0WzBdID0gYVswXSArIGJbMF0gKiBzY2FsZTtcbiAgb3V0WzFdID0gYVsxXSArIGJbMV0gKiBzY2FsZTtcbiAgb3V0WzJdID0gYVsyXSArIGJbMl0gKiBzY2FsZTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgZXVjbGlkaWFuIGRpc3RhbmNlIGJldHdlZW4gdHdvIHZlYzMnc1xuICpcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGRpc3RhbmNlIGJldHdlZW4gYSBhbmQgYlxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBkaXN0YW5jZShhLCBiKSB7XG4gIHZhciB4ID0gYlswXSAtIGFbMF07XG4gIHZhciB5ID0gYlsxXSAtIGFbMV07XG4gIHZhciB6ID0gYlsyXSAtIGFbMl07XG4gIHJldHVybiBNYXRoLmh5cG90KHgsIHksIHopO1xufVxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBzcXVhcmVkIGV1Y2xpZGlhbiBkaXN0YW5jZSBiZXR3ZWVuIHR3byB2ZWMzJ3NcbiAqXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBzcXVhcmVkIGRpc3RhbmNlIGJldHdlZW4gYSBhbmQgYlxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBzcXVhcmVkRGlzdGFuY2UoYSwgYikge1xuICB2YXIgeCA9IGJbMF0gLSBhWzBdO1xuICB2YXIgeSA9IGJbMV0gLSBhWzFdO1xuICB2YXIgeiA9IGJbMl0gLSBhWzJdO1xuICByZXR1cm4geCAqIHggKyB5ICogeSArIHogKiB6O1xufVxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBzcXVhcmVkIGxlbmd0aCBvZiBhIHZlYzNcbiAqXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYSB2ZWN0b3IgdG8gY2FsY3VsYXRlIHNxdWFyZWQgbGVuZ3RoIG9mXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBzcXVhcmVkIGxlbmd0aCBvZiBhXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHNxdWFyZWRMZW5ndGgoYSkge1xuICB2YXIgeCA9IGFbMF07XG4gIHZhciB5ID0gYVsxXTtcbiAgdmFyIHogPSBhWzJdO1xuICByZXR1cm4geCAqIHggKyB5ICogeSArIHogKiB6O1xufVxuLyoqXG4gKiBOZWdhdGVzIHRoZSBjb21wb25lbnRzIG9mIGEgdmVjM1xuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYSB2ZWN0b3IgdG8gbmVnYXRlXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIG5lZ2F0ZShvdXQsIGEpIHtcbiAgb3V0WzBdID0gLWFbMF07XG4gIG91dFsxXSA9IC1hWzFdO1xuICBvdXRbMl0gPSAtYVsyXTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogUmV0dXJucyB0aGUgaW52ZXJzZSBvZiB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzNcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGEgdmVjdG9yIHRvIGludmVydFxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBpbnZlcnNlKG91dCwgYSkge1xuICBvdXRbMF0gPSAxLjAgLyBhWzBdO1xuICBvdXRbMV0gPSAxLjAgLyBhWzFdO1xuICBvdXRbMl0gPSAxLjAgLyBhWzJdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBOb3JtYWxpemUgYSB2ZWMzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBhIHZlY3RvciB0byBub3JtYWxpemVcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gbm9ybWFsaXplKG91dCwgYSkge1xuICB2YXIgeCA9IGFbMF07XG4gIHZhciB5ID0gYVsxXTtcbiAgdmFyIHogPSBhWzJdO1xuICB2YXIgbGVuID0geCAqIHggKyB5ICogeSArIHogKiB6O1xuXG4gIGlmIChsZW4gPiAwKSB7XG4gICAgLy9UT0RPOiBldmFsdWF0ZSB1c2Ugb2YgZ2xtX2ludnNxcnQgaGVyZT9cbiAgICBsZW4gPSAxIC8gTWF0aC5zcXJ0KGxlbik7XG4gIH1cblxuICBvdXRbMF0gPSBhWzBdICogbGVuO1xuICBvdXRbMV0gPSBhWzFdICogbGVuO1xuICBvdXRbMl0gPSBhWzJdICogbGVuO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBkb3QgcHJvZHVjdCBvZiB0d28gdmVjMydzXG4gKlxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge051bWJlcn0gZG90IHByb2R1Y3Qgb2YgYSBhbmQgYlxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBkb3QoYSwgYikge1xuICByZXR1cm4gYVswXSAqIGJbMF0gKyBhWzFdICogYlsxXSArIGFbMl0gKiBiWzJdO1xufVxuLyoqXG4gKiBDb21wdXRlcyB0aGUgY3Jvc3MgcHJvZHVjdCBvZiB0d28gdmVjMydzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gY3Jvc3Mob3V0LCBhLCBiKSB7XG4gIHZhciBheCA9IGFbMF0sXG4gICAgICBheSA9IGFbMV0sXG4gICAgICBheiA9IGFbMl07XG4gIHZhciBieCA9IGJbMF0sXG4gICAgICBieSA9IGJbMV0sXG4gICAgICBieiA9IGJbMl07XG4gIG91dFswXSA9IGF5ICogYnogLSBheiAqIGJ5O1xuICBvdXRbMV0gPSBheiAqIGJ4IC0gYXggKiBiejtcbiAgb3V0WzJdID0gYXggKiBieSAtIGF5ICogYng7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIFBlcmZvcm1zIGEgbGluZWFyIGludGVycG9sYXRpb24gYmV0d2VlbiB0d28gdmVjMydzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEBwYXJhbSB7TnVtYmVyfSB0IGludGVycG9sYXRpb24gYW1vdW50LCBpbiB0aGUgcmFuZ2UgWzAtMV0sIGJldHdlZW4gdGhlIHR3byBpbnB1dHNcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gbGVycChvdXQsIGEsIGIsIHQpIHtcbiAgdmFyIGF4ID0gYVswXTtcbiAgdmFyIGF5ID0gYVsxXTtcbiAgdmFyIGF6ID0gYVsyXTtcbiAgb3V0WzBdID0gYXggKyB0ICogKGJbMF0gLSBheCk7XG4gIG91dFsxXSA9IGF5ICsgdCAqIChiWzFdIC0gYXkpO1xuICBvdXRbMl0gPSBheiArIHQgKiAoYlsyXSAtIGF6KTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogUGVyZm9ybXMgYSBoZXJtaXRlIGludGVycG9sYXRpb24gd2l0aCB0d28gY29udHJvbCBwb2ludHNcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGMgdGhlIHRoaXJkIG9wZXJhbmRcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBkIHRoZSBmb3VydGggb3BlcmFuZFxuICogQHBhcmFtIHtOdW1iZXJ9IHQgaW50ZXJwb2xhdGlvbiBhbW91bnQsIGluIHRoZSByYW5nZSBbMC0xXSwgYmV0d2VlbiB0aGUgdHdvIGlucHV0c1xuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBoZXJtaXRlKG91dCwgYSwgYiwgYywgZCwgdCkge1xuICB2YXIgZmFjdG9yVGltZXMyID0gdCAqIHQ7XG4gIHZhciBmYWN0b3IxID0gZmFjdG9yVGltZXMyICogKDIgKiB0IC0gMykgKyAxO1xuICB2YXIgZmFjdG9yMiA9IGZhY3RvclRpbWVzMiAqICh0IC0gMikgKyB0O1xuICB2YXIgZmFjdG9yMyA9IGZhY3RvclRpbWVzMiAqICh0IC0gMSk7XG4gIHZhciBmYWN0b3I0ID0gZmFjdG9yVGltZXMyICogKDMgLSAyICogdCk7XG4gIG91dFswXSA9IGFbMF0gKiBmYWN0b3IxICsgYlswXSAqIGZhY3RvcjIgKyBjWzBdICogZmFjdG9yMyArIGRbMF0gKiBmYWN0b3I0O1xuICBvdXRbMV0gPSBhWzFdICogZmFjdG9yMSArIGJbMV0gKiBmYWN0b3IyICsgY1sxXSAqIGZhY3RvcjMgKyBkWzFdICogZmFjdG9yNDtcbiAgb3V0WzJdID0gYVsyXSAqIGZhY3RvcjEgKyBiWzJdICogZmFjdG9yMiArIGNbMl0gKiBmYWN0b3IzICsgZFsyXSAqIGZhY3RvcjQ7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIFBlcmZvcm1zIGEgYmV6aWVyIGludGVycG9sYXRpb24gd2l0aCB0d28gY29udHJvbCBwb2ludHNcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGMgdGhlIHRoaXJkIG9wZXJhbmRcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBkIHRoZSBmb3VydGggb3BlcmFuZFxuICogQHBhcmFtIHtOdW1iZXJ9IHQgaW50ZXJwb2xhdGlvbiBhbW91bnQsIGluIHRoZSByYW5nZSBbMC0xXSwgYmV0d2VlbiB0aGUgdHdvIGlucHV0c1xuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBiZXppZXIob3V0LCBhLCBiLCBjLCBkLCB0KSB7XG4gIHZhciBpbnZlcnNlRmFjdG9yID0gMSAtIHQ7XG4gIHZhciBpbnZlcnNlRmFjdG9yVGltZXNUd28gPSBpbnZlcnNlRmFjdG9yICogaW52ZXJzZUZhY3RvcjtcbiAgdmFyIGZhY3RvclRpbWVzMiA9IHQgKiB0O1xuICB2YXIgZmFjdG9yMSA9IGludmVyc2VGYWN0b3JUaW1lc1R3byAqIGludmVyc2VGYWN0b3I7XG4gIHZhciBmYWN0b3IyID0gMyAqIHQgKiBpbnZlcnNlRmFjdG9yVGltZXNUd287XG4gIHZhciBmYWN0b3IzID0gMyAqIGZhY3RvclRpbWVzMiAqIGludmVyc2VGYWN0b3I7XG4gIHZhciBmYWN0b3I0ID0gZmFjdG9yVGltZXMyICogdDtcbiAgb3V0WzBdID0gYVswXSAqIGZhY3RvcjEgKyBiWzBdICogZmFjdG9yMiArIGNbMF0gKiBmYWN0b3IzICsgZFswXSAqIGZhY3RvcjQ7XG4gIG91dFsxXSA9IGFbMV0gKiBmYWN0b3IxICsgYlsxXSAqIGZhY3RvcjIgKyBjWzFdICogZmFjdG9yMyArIGRbMV0gKiBmYWN0b3I0O1xuICBvdXRbMl0gPSBhWzJdICogZmFjdG9yMSArIGJbMl0gKiBmYWN0b3IyICsgY1syXSAqIGZhY3RvcjMgKyBkWzJdICogZmFjdG9yNDtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogR2VuZXJhdGVzIGEgcmFuZG9tIHZlY3RvciB3aXRoIHRoZSBnaXZlbiBzY2FsZVxuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge051bWJlcn0gW3NjYWxlXSBMZW5ndGggb2YgdGhlIHJlc3VsdGluZyB2ZWN0b3IuIElmIG9tbWl0dGVkLCBhIHVuaXQgdmVjdG9yIHdpbGwgYmUgcmV0dXJuZWRcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gcmFuZG9tKG91dCwgc2NhbGUpIHtcbiAgc2NhbGUgPSBzY2FsZSB8fCAxLjA7XG4gIHZhciByID0gZ2xNYXRyaXguUkFORE9NKCkgKiAyLjAgKiBNYXRoLlBJO1xuICB2YXIgeiA9IGdsTWF0cml4LlJBTkRPTSgpICogMi4wIC0gMS4wO1xuICB2YXIgelNjYWxlID0gTWF0aC5zcXJ0KDEuMCAtIHogKiB6KSAqIHNjYWxlO1xuICBvdXRbMF0gPSBNYXRoLmNvcyhyKSAqIHpTY2FsZTtcbiAgb3V0WzFdID0gTWF0aC5zaW4ocikgKiB6U2NhbGU7XG4gIG91dFsyXSA9IHogKiBzY2FsZTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogVHJhbnNmb3JtcyB0aGUgdmVjMyB3aXRoIGEgbWF0NC5cbiAqIDR0aCB2ZWN0b3IgY29tcG9uZW50IGlzIGltcGxpY2l0bHkgJzEnXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBhIHRoZSB2ZWN0b3IgdG8gdHJhbnNmb3JtXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0NH0gbSBtYXRyaXggdG8gdHJhbnNmb3JtIHdpdGhcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gdHJhbnNmb3JtTWF0NChvdXQsIGEsIG0pIHtcbiAgdmFyIHggPSBhWzBdLFxuICAgICAgeSA9IGFbMV0sXG4gICAgICB6ID0gYVsyXTtcbiAgdmFyIHcgPSBtWzNdICogeCArIG1bN10gKiB5ICsgbVsxMV0gKiB6ICsgbVsxNV07XG4gIHcgPSB3IHx8IDEuMDtcbiAgb3V0WzBdID0gKG1bMF0gKiB4ICsgbVs0XSAqIHkgKyBtWzhdICogeiArIG1bMTJdKSAvIHc7XG4gIG91dFsxXSA9IChtWzFdICogeCArIG1bNV0gKiB5ICsgbVs5XSAqIHogKyBtWzEzXSkgLyB3O1xuICBvdXRbMl0gPSAobVsyXSAqIHggKyBtWzZdICogeSArIG1bMTBdICogeiArIG1bMTRdKSAvIHc7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIFRyYW5zZm9ybXMgdGhlIHZlYzMgd2l0aCBhIG1hdDMuXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBhIHRoZSB2ZWN0b3IgdG8gdHJhbnNmb3JtXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0M30gbSB0aGUgM3gzIG1hdHJpeCB0byB0cmFuc2Zvcm0gd2l0aFxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiB0cmFuc2Zvcm1NYXQzKG91dCwgYSwgbSkge1xuICB2YXIgeCA9IGFbMF0sXG4gICAgICB5ID0gYVsxXSxcbiAgICAgIHogPSBhWzJdO1xuICBvdXRbMF0gPSB4ICogbVswXSArIHkgKiBtWzNdICsgeiAqIG1bNl07XG4gIG91dFsxXSA9IHggKiBtWzFdICsgeSAqIG1bNF0gKyB6ICogbVs3XTtcbiAgb3V0WzJdID0geCAqIG1bMl0gKyB5ICogbVs1XSArIHogKiBtWzhdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBUcmFuc2Zvcm1zIHRoZSB2ZWMzIHdpdGggYSBxdWF0XG4gKiBDYW4gYWxzbyBiZSB1c2VkIGZvciBkdWFsIHF1YXRlcm5pb25zLiAoTXVsdGlwbHkgaXQgd2l0aCB0aGUgcmVhbCBwYXJ0KVxuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYSB0aGUgdmVjdG9yIHRvIHRyYW5zZm9ybVxuICogQHBhcmFtIHtSZWFkb25seVF1YXR9IHEgcXVhdGVybmlvbiB0byB0cmFuc2Zvcm0gd2l0aFxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiB0cmFuc2Zvcm1RdWF0KG91dCwgYSwgcSkge1xuICAvLyBiZW5jaG1hcmtzOiBodHRwczovL2pzcGVyZi5jb20vcXVhdGVybmlvbi10cmFuc2Zvcm0tdmVjMy1pbXBsZW1lbnRhdGlvbnMtZml4ZWRcbiAgdmFyIHF4ID0gcVswXSxcbiAgICAgIHF5ID0gcVsxXSxcbiAgICAgIHF6ID0gcVsyXSxcbiAgICAgIHF3ID0gcVszXTtcbiAgdmFyIHggPSBhWzBdLFxuICAgICAgeSA9IGFbMV0sXG4gICAgICB6ID0gYVsyXTsgLy8gdmFyIHF2ZWMgPSBbcXgsIHF5LCBxel07XG4gIC8vIHZhciB1diA9IHZlYzMuY3Jvc3MoW10sIHF2ZWMsIGEpO1xuXG4gIHZhciB1dnggPSBxeSAqIHogLSBxeiAqIHksXG4gICAgICB1dnkgPSBxeiAqIHggLSBxeCAqIHosXG4gICAgICB1dnogPSBxeCAqIHkgLSBxeSAqIHg7IC8vIHZhciB1dXYgPSB2ZWMzLmNyb3NzKFtdLCBxdmVjLCB1dik7XG5cbiAgdmFyIHV1dnggPSBxeSAqIHV2eiAtIHF6ICogdXZ5LFxuICAgICAgdXV2eSA9IHF6ICogdXZ4IC0gcXggKiB1dnosXG4gICAgICB1dXZ6ID0gcXggKiB1dnkgLSBxeSAqIHV2eDsgLy8gdmVjMy5zY2FsZSh1diwgdXYsIDIgKiB3KTtcblxuICB2YXIgdzIgPSBxdyAqIDI7XG4gIHV2eCAqPSB3MjtcbiAgdXZ5ICo9IHcyO1xuICB1dnogKj0gdzI7IC8vIHZlYzMuc2NhbGUodXV2LCB1dXYsIDIpO1xuXG4gIHV1dnggKj0gMjtcbiAgdXV2eSAqPSAyO1xuICB1dXZ6ICo9IDI7IC8vIHJldHVybiB2ZWMzLmFkZChvdXQsIGEsIHZlYzMuYWRkKG91dCwgdXYsIHV1dikpO1xuXG4gIG91dFswXSA9IHggKyB1dnggKyB1dXZ4O1xuICBvdXRbMV0gPSB5ICsgdXZ5ICsgdXV2eTtcbiAgb3V0WzJdID0geiArIHV2eiArIHV1dno7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIFJvdGF0ZSBhIDNEIHZlY3RvciBhcm91bmQgdGhlIHgtYXhpc1xuICogQHBhcmFtIHt2ZWMzfSBvdXQgVGhlIHJlY2VpdmluZyB2ZWMzXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYSBUaGUgdmVjMyBwb2ludCB0byByb3RhdGVcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBiIFRoZSBvcmlnaW4gb2YgdGhlIHJvdGF0aW9uXG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIFRoZSBhbmdsZSBvZiByb3RhdGlvbiBpbiByYWRpYW5zXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHJvdGF0ZVgob3V0LCBhLCBiLCByYWQpIHtcbiAgdmFyIHAgPSBbXSxcbiAgICAgIHIgPSBbXTsgLy9UcmFuc2xhdGUgcG9pbnQgdG8gdGhlIG9yaWdpblxuXG4gIHBbMF0gPSBhWzBdIC0gYlswXTtcbiAgcFsxXSA9IGFbMV0gLSBiWzFdO1xuICBwWzJdID0gYVsyXSAtIGJbMl07IC8vcGVyZm9ybSByb3RhdGlvblxuXG4gIHJbMF0gPSBwWzBdO1xuICByWzFdID0gcFsxXSAqIE1hdGguY29zKHJhZCkgLSBwWzJdICogTWF0aC5zaW4ocmFkKTtcbiAgclsyXSA9IHBbMV0gKiBNYXRoLnNpbihyYWQpICsgcFsyXSAqIE1hdGguY29zKHJhZCk7IC8vdHJhbnNsYXRlIHRvIGNvcnJlY3QgcG9zaXRpb25cblxuICBvdXRbMF0gPSByWzBdICsgYlswXTtcbiAgb3V0WzFdID0gclsxXSArIGJbMV07XG4gIG91dFsyXSA9IHJbMl0gKyBiWzJdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBSb3RhdGUgYSAzRCB2ZWN0b3IgYXJvdW5kIHRoZSB5LWF4aXNcbiAqIEBwYXJhbSB7dmVjM30gb3V0IFRoZSByZWNlaXZpbmcgdmVjM1xuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGEgVGhlIHZlYzMgcG9pbnQgdG8gcm90YXRlXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYiBUaGUgb3JpZ2luIG9mIHRoZSByb3RhdGlvblxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZCBUaGUgYW5nbGUgb2Ygcm90YXRpb24gaW4gcmFkaWFuc1xuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiByb3RhdGVZKG91dCwgYSwgYiwgcmFkKSB7XG4gIHZhciBwID0gW10sXG4gICAgICByID0gW107IC8vVHJhbnNsYXRlIHBvaW50IHRvIHRoZSBvcmlnaW5cblxuICBwWzBdID0gYVswXSAtIGJbMF07XG4gIHBbMV0gPSBhWzFdIC0gYlsxXTtcbiAgcFsyXSA9IGFbMl0gLSBiWzJdOyAvL3BlcmZvcm0gcm90YXRpb25cblxuICByWzBdID0gcFsyXSAqIE1hdGguc2luKHJhZCkgKyBwWzBdICogTWF0aC5jb3MocmFkKTtcbiAgclsxXSA9IHBbMV07XG4gIHJbMl0gPSBwWzJdICogTWF0aC5jb3MocmFkKSAtIHBbMF0gKiBNYXRoLnNpbihyYWQpOyAvL3RyYW5zbGF0ZSB0byBjb3JyZWN0IHBvc2l0aW9uXG5cbiAgb3V0WzBdID0gclswXSArIGJbMF07XG4gIG91dFsxXSA9IHJbMV0gKyBiWzFdO1xuICBvdXRbMl0gPSByWzJdICsgYlsyXTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogUm90YXRlIGEgM0QgdmVjdG9yIGFyb3VuZCB0aGUgei1heGlzXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCBUaGUgcmVjZWl2aW5nIHZlYzNcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBhIFRoZSB2ZWMzIHBvaW50IHRvIHJvdGF0ZVxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGIgVGhlIG9yaWdpbiBvZiB0aGUgcm90YXRpb25cbiAqIEBwYXJhbSB7TnVtYmVyfSByYWQgVGhlIGFuZ2xlIG9mIHJvdGF0aW9uIGluIHJhZGlhbnNcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gcm90YXRlWihvdXQsIGEsIGIsIHJhZCkge1xuICB2YXIgcCA9IFtdLFxuICAgICAgciA9IFtdOyAvL1RyYW5zbGF0ZSBwb2ludCB0byB0aGUgb3JpZ2luXG5cbiAgcFswXSA9IGFbMF0gLSBiWzBdO1xuICBwWzFdID0gYVsxXSAtIGJbMV07XG4gIHBbMl0gPSBhWzJdIC0gYlsyXTsgLy9wZXJmb3JtIHJvdGF0aW9uXG5cbiAgclswXSA9IHBbMF0gKiBNYXRoLmNvcyhyYWQpIC0gcFsxXSAqIE1hdGguc2luKHJhZCk7XG4gIHJbMV0gPSBwWzBdICogTWF0aC5zaW4ocmFkKSArIHBbMV0gKiBNYXRoLmNvcyhyYWQpO1xuICByWzJdID0gcFsyXTsgLy90cmFuc2xhdGUgdG8gY29ycmVjdCBwb3NpdGlvblxuXG4gIG91dFswXSA9IHJbMF0gKyBiWzBdO1xuICBvdXRbMV0gPSByWzFdICsgYlsxXTtcbiAgb3V0WzJdID0gclsyXSArIGJbMl07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIEdldCB0aGUgYW5nbGUgYmV0d2VlbiB0d28gM0QgdmVjdG9yc1xuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGEgVGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBiIFRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge051bWJlcn0gVGhlIGFuZ2xlIGluIHJhZGlhbnNcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gYW5nbGUoYSwgYikge1xuICB2YXIgYXggPSBhWzBdLFxuICAgICAgYXkgPSBhWzFdLFxuICAgICAgYXogPSBhWzJdLFxuICAgICAgYnggPSBiWzBdLFxuICAgICAgYnkgPSBiWzFdLFxuICAgICAgYnogPSBiWzJdLFxuICAgICAgbWFnMSA9IE1hdGguc3FydChheCAqIGF4ICsgYXkgKiBheSArIGF6ICogYXopLFxuICAgICAgbWFnMiA9IE1hdGguc3FydChieCAqIGJ4ICsgYnkgKiBieSArIGJ6ICogYnopLFxuICAgICAgbWFnID0gbWFnMSAqIG1hZzIsXG4gICAgICBjb3NpbmUgPSBtYWcgJiYgZG90KGEsIGIpIC8gbWFnO1xuICByZXR1cm4gTWF0aC5hY29zKE1hdGgubWluKE1hdGgubWF4KGNvc2luZSwgLTEpLCAxKSk7XG59XG4vKipcbiAqIFNldCB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzMgdG8gemVyb1xuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHplcm8ob3V0KSB7XG4gIG91dFswXSA9IDAuMDtcbiAgb3V0WzFdID0gMC4wO1xuICBvdXRbMl0gPSAwLjA7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYSB2ZWN0b3JcbiAqXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYSB2ZWN0b3IgdG8gcmVwcmVzZW50IGFzIGEgc3RyaW5nXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIHZlY3RvclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBzdHIoYSkge1xuICByZXR1cm4gXCJ2ZWMzKFwiICsgYVswXSArIFwiLCBcIiArIGFbMV0gKyBcIiwgXCIgKyBhWzJdICsgXCIpXCI7XG59XG4vKipcbiAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIHZlY3RvcnMgaGF2ZSBleGFjdGx5IHRoZSBzYW1lIGVsZW1lbnRzIGluIHRoZSBzYW1lIHBvc2l0aW9uICh3aGVuIGNvbXBhcmVkIHdpdGggPT09KVxuICpcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBhIFRoZSBmaXJzdCB2ZWN0b3IuXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYiBUaGUgc2Vjb25kIHZlY3Rvci5cbiAqIEByZXR1cm5zIHtCb29sZWFufSBUcnVlIGlmIHRoZSB2ZWN0b3JzIGFyZSBlcXVhbCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBleGFjdEVxdWFscyhhLCBiKSB7XG4gIHJldHVybiBhWzBdID09PSBiWzBdICYmIGFbMV0gPT09IGJbMV0gJiYgYVsyXSA9PT0gYlsyXTtcbn1cbi8qKlxuICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgdmVjdG9ycyBoYXZlIGFwcHJveGltYXRlbHkgdGhlIHNhbWUgZWxlbWVudHMgaW4gdGhlIHNhbWUgcG9zaXRpb24uXG4gKlxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGEgVGhlIGZpcnN0IHZlY3Rvci5cbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBiIFRoZSBzZWNvbmQgdmVjdG9yLlxuICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWYgdGhlIHZlY3RvcnMgYXJlIGVxdWFsLCBmYWxzZSBvdGhlcndpc2UuXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGVxdWFscyhhLCBiKSB7XG4gIHZhciBhMCA9IGFbMF0sXG4gICAgICBhMSA9IGFbMV0sXG4gICAgICBhMiA9IGFbMl07XG4gIHZhciBiMCA9IGJbMF0sXG4gICAgICBiMSA9IGJbMV0sXG4gICAgICBiMiA9IGJbMl07XG4gIHJldHVybiBNYXRoLmFicyhhMCAtIGIwKSA8PSBnbE1hdHJpeC5FUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMCksIE1hdGguYWJzKGIwKSkgJiYgTWF0aC5hYnMoYTEgLSBiMSkgPD0gZ2xNYXRyaXguRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTEpLCBNYXRoLmFicyhiMSkpICYmIE1hdGguYWJzKGEyIC0gYjIpIDw9IGdsTWF0cml4LkVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGEyKSwgTWF0aC5hYnMoYjIpKTtcbn1cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayB2ZWMzLnN1YnRyYWN0fVxuICogQGZ1bmN0aW9uXG4gKi9cblxuZXhwb3J0IHZhciBzdWIgPSBzdWJ0cmFjdDtcbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayB2ZWMzLm11bHRpcGx5fVxuICogQGZ1bmN0aW9uXG4gKi9cblxuZXhwb3J0IHZhciBtdWwgPSBtdWx0aXBseTtcbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayB2ZWMzLmRpdmlkZX1cbiAqIEBmdW5jdGlvblxuICovXG5cbmV4cG9ydCB2YXIgZGl2ID0gZGl2aWRlO1xuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzMuZGlzdGFuY2V9XG4gKiBAZnVuY3Rpb25cbiAqL1xuXG5leHBvcnQgdmFyIGRpc3QgPSBkaXN0YW5jZTtcbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayB2ZWMzLnNxdWFyZWREaXN0YW5jZX1cbiAqIEBmdW5jdGlvblxuICovXG5cbmV4cG9ydCB2YXIgc3FyRGlzdCA9IHNxdWFyZWREaXN0YW5jZTtcbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayB2ZWMzLmxlbmd0aH1cbiAqIEBmdW5jdGlvblxuICovXG5cbmV4cG9ydCB2YXIgbGVuID0gbGVuZ3RoO1xuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzMuc3F1YXJlZExlbmd0aH1cbiAqIEBmdW5jdGlvblxuICovXG5cbmV4cG9ydCB2YXIgc3FyTGVuID0gc3F1YXJlZExlbmd0aDtcbi8qKlxuICogUGVyZm9ybSBzb21lIG9wZXJhdGlvbiBvdmVyIGFuIGFycmF5IG9mIHZlYzNzLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGEgdGhlIGFycmF5IG9mIHZlY3RvcnMgdG8gaXRlcmF0ZSBvdmVyXG4gKiBAcGFyYW0ge051bWJlcn0gc3RyaWRlIE51bWJlciBvZiBlbGVtZW50cyBiZXR3ZWVuIHRoZSBzdGFydCBvZiBlYWNoIHZlYzMuIElmIDAgYXNzdW1lcyB0aWdodGx5IHBhY2tlZFxuICogQHBhcmFtIHtOdW1iZXJ9IG9mZnNldCBOdW1iZXIgb2YgZWxlbWVudHMgdG8gc2tpcCBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZSBhcnJheVxuICogQHBhcmFtIHtOdW1iZXJ9IGNvdW50IE51bWJlciBvZiB2ZWMzcyB0byBpdGVyYXRlIG92ZXIuIElmIDAgaXRlcmF0ZXMgb3ZlciBlbnRpcmUgYXJyYXlcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIEZ1bmN0aW9uIHRvIGNhbGwgZm9yIGVhY2ggdmVjdG9yIGluIHRoZSBhcnJheVxuICogQHBhcmFtIHtPYmplY3R9IFthcmddIGFkZGl0aW9uYWwgYXJndW1lbnQgdG8gcGFzcyB0byBmblxuICogQHJldHVybnMge0FycmF5fSBhXG4gKiBAZnVuY3Rpb25cbiAqL1xuXG5leHBvcnQgdmFyIGZvckVhY2ggPSBmdW5jdGlvbiAoKSB7XG4gIHZhciB2ZWMgPSBjcmVhdGUoKTtcbiAgcmV0dXJuIGZ1bmN0aW9uIChhLCBzdHJpZGUsIG9mZnNldCwgY291bnQsIGZuLCBhcmcpIHtcbiAgICB2YXIgaSwgbDtcblxuICAgIGlmICghc3RyaWRlKSB7XG4gICAgICBzdHJpZGUgPSAzO1xuICAgIH1cblxuICAgIGlmICghb2Zmc2V0KSB7XG4gICAgICBvZmZzZXQgPSAwO1xuICAgIH1cblxuICAgIGlmIChjb3VudCkge1xuICAgICAgbCA9IE1hdGgubWluKGNvdW50ICogc3RyaWRlICsgb2Zmc2V0LCBhLmxlbmd0aCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGwgPSBhLmxlbmd0aDtcbiAgICB9XG5cbiAgICBmb3IgKGkgPSBvZmZzZXQ7IGkgPCBsOyBpICs9IHN0cmlkZSkge1xuICAgICAgdmVjWzBdID0gYVtpXTtcbiAgICAgIHZlY1sxXSA9IGFbaSArIDFdO1xuICAgICAgdmVjWzJdID0gYVtpICsgMl07XG4gICAgICBmbih2ZWMsIHZlYywgYXJnKTtcbiAgICAgIGFbaV0gPSB2ZWNbMF07XG4gICAgICBhW2kgKyAxXSA9IHZlY1sxXTtcbiAgICAgIGFbaSArIDJdID0gdmVjWzJdO1xuICAgIH1cblxuICAgIHJldHVybiBhO1xuICB9O1xufSgpOyIsImltcG9ydCAqIGFzIGdsTWF0cml4IGZyb20gXCIuL2NvbW1vbi5qc1wiO1xuaW1wb3J0ICogYXMgbWF0MiBmcm9tIFwiLi9tYXQyLmpzXCI7XG5pbXBvcnQgKiBhcyBtYXQyZCBmcm9tIFwiLi9tYXQyZC5qc1wiO1xuaW1wb3J0ICogYXMgbWF0MyBmcm9tIFwiLi9tYXQzLmpzXCI7XG5pbXBvcnQgKiBhcyBtYXQ0IGZyb20gXCIuL21hdDQuanNcIjtcbmltcG9ydCAqIGFzIHF1YXQgZnJvbSBcIi4vcXVhdC5qc1wiO1xuaW1wb3J0ICogYXMgcXVhdDIgZnJvbSBcIi4vcXVhdDIuanNcIjtcbmltcG9ydCAqIGFzIHZlYzIgZnJvbSBcIi4vdmVjMi5qc1wiO1xuaW1wb3J0ICogYXMgdmVjMyBmcm9tIFwiLi92ZWMzLmpzXCI7XG5pbXBvcnQgKiBhcyB2ZWM0IGZyb20gXCIuL3ZlYzQuanNcIjtcbmV4cG9ydCB7IGdsTWF0cml4LCBtYXQyLCBtYXQyZCwgbWF0MywgbWF0NCwgcXVhdCwgcXVhdDIsIHZlYzIsIHZlYzMsIHZlYzQgfTsiLCJ2YXIgX3R5cGVvZiA9IHJlcXVpcmUoXCIuL3R5cGVvZi5qc1wiKVtcImRlZmF1bHRcIl07XG5cbnZhciBhc3NlcnRUaGlzSW5pdGlhbGl6ZWQgPSByZXF1aXJlKFwiLi9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQuanNcIik7XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHtcbiAgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHtcbiAgICByZXR1cm4gY2FsbDtcbiAgfSBlbHNlIGlmIChjYWxsICE9PSB2b2lkIDApIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRGVyaXZlZCBjb25zdHJ1Y3RvcnMgbWF5IG9ubHkgcmV0dXJuIG9iamVjdCBvciB1bmRlZmluZWRcIik7XG4gIH1cblxuICByZXR1cm4gYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZSwgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHM7IiwidmFyIHNldFByb3RvdHlwZU9mID0gcmVxdWlyZShcIi4vc2V0UHJvdG90eXBlT2YuanNcIik7XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykge1xuICBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpO1xuICB9XG5cbiAgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7XG4gICAgY29uc3RydWN0b3I6IHtcbiAgICAgIHZhbHVlOiBzdWJDbGFzcyxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHN1YkNsYXNzLCBcInByb3RvdHlwZVwiLCB7XG4gICAgd3JpdGFibGU6IGZhbHNlXG4gIH0pO1xuICBpZiAoc3VwZXJDbGFzcykgc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9pbmhlcml0cywgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzOyIsIi8vIFRPRE8oQmFiZWwgOCk6IFJlbW92ZSB0aGlzIGZpbGUuXG5cbnZhciBydW50aW1lID0gcmVxdWlyZShcIi4uL2hlbHBlcnMvcmVnZW5lcmF0b3JSdW50aW1lXCIpKCk7XG5tb2R1bGUuZXhwb3J0cyA9IHJ1bnRpbWU7XG5cbi8vIENvcGllZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWdlbmVyYXRvci9ibG9iL21haW4vcGFja2FnZXMvcnVudGltZS9ydW50aW1lLmpzI0w3MzY9XG50cnkge1xuICByZWdlbmVyYXRvclJ1bnRpbWUgPSBydW50aW1lO1xufSBjYXRjaCAoYWNjaWRlbnRhbFN0cmljdE1vZGUpIHtcbiAgaWYgKHR5cGVvZiBnbG9iYWxUaGlzID09PSBcIm9iamVjdFwiKSB7XG4gICAgZ2xvYmFsVGhpcy5yZWdlbmVyYXRvclJ1bnRpbWUgPSBydW50aW1lO1xuICB9IGVsc2Uge1xuICAgIEZ1bmN0aW9uKFwiclwiLCBcInJlZ2VuZXJhdG9yUnVudGltZSA9IHJcIikocnVudGltZSk7XG4gIH1cbn1cbiIsIi8vIFRPRE86IGNsdXN0ZXIuanMgYW5kIGN2X3V0aWxzLmpzIGFyZSBwcmV0dHkgdGlnaHRseSBpbnRlcnR3aW5lZCwgbWFraW5nIGZvciBhIGNvbXBsZXggY29udmVyc2lvblxuLy8gaW50byB0eXBlc2NyaXB0LiBiZSB3YXJuZWQuIDotKVxuXG5pbXBvcnQgeyBnbE1hdHJpeCwgdmVjMiB9IGZyb20gJ2dsLW1hdHJpeCc7XG5cbmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7XG4vKipcbiAqIENyZWF0ZXMgYSBjbHVzdGVyIGZvciBncm91cGluZyBzaW1pbGFyIG9yaWVudGF0aW9ucyBvZiBkYXRhcG9pbnRzXG4gKi9cbmV4cG9ydCBkZWZhdWx0IHtcbiAgICBjcmVhdGUocG9pbnQsIHRocmVzaG9sZCkge1xuICAgICAgICBjb25zdCBwb2ludHMgPSBbXTtcbiAgICAgICAgY29uc3QgY2VudGVyID0ge1xuICAgICAgICAgICAgcmFkOiAwLFxuICAgICAgICAgICAgdmVjOiB2ZWMyLmNsb25lKFswLCAwXSksXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHBvaW50TWFwID0ge307XG5cbiAgICAgICAgZnVuY3Rpb24gYWRkKHBvaW50VG9BZGQpIHtcbiAgICAgICAgICAgIHBvaW50TWFwW3BvaW50VG9BZGQuaWRdID0gcG9pbnRUb0FkZDtcbiAgICAgICAgICAgIHBvaW50cy5wdXNoKHBvaW50VG9BZGQpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gdXBkYXRlQ2VudGVyKCkge1xuICAgICAgICAgICAgbGV0IGk7IGxldFxuICAgICAgICAgICAgICAgIHN1bSA9IDA7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcG9pbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgc3VtICs9IHBvaW50c1tpXS5yYWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjZW50ZXIucmFkID0gc3VtIC8gcG9pbnRzLmxlbmd0aDtcbiAgICAgICAgICAgIGNlbnRlci52ZWMgPSB2ZWMyLmNsb25lKFtNYXRoLmNvcyhjZW50ZXIucmFkKSwgTWF0aC5zaW4oY2VudGVyLnJhZCldKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGluaXQoKSB7XG4gICAgICAgICAgICBhZGQocG9pbnQpO1xuICAgICAgICAgICAgdXBkYXRlQ2VudGVyKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpbml0KCk7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGFkZChwb2ludFRvQWRkKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFwb2ludE1hcFtwb2ludFRvQWRkLmlkXSkge1xuICAgICAgICAgICAgICAgICAgICBhZGQocG9pbnRUb0FkZCk7XG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZUNlbnRlcigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmaXRzKG90aGVyUG9pbnQpIHtcbiAgICAgICAgICAgICAgICAvLyBjaGVjayBjb3NpbmUgc2ltaWxhcml0eSB0byBjZW50ZXItYW5nbGVcbiAgICAgICAgICAgICAgICBjb25zdCBzaW1pbGFyaXR5ID0gTWF0aC5hYnModmVjMi5kb3Qob3RoZXJQb2ludC5wb2ludC52ZWMsIGNlbnRlci52ZWMpKTtcbiAgICAgICAgICAgICAgICBpZiAoc2ltaWxhcml0eSA+IHRocmVzaG9sZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldFBvaW50cygpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcG9pbnRzO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldENlbnRlcigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2VudGVyO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIGNyZWF0ZVBvaW50KG5ld1BvaW50LCBpZCwgcHJvcGVydHkpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJhZDogbmV3UG9pbnRbcHJvcGVydHldLFxuICAgICAgICAgICAgcG9pbnQ6IG5ld1BvaW50LFxuICAgICAgICAgICAgaWQsXG4gICAgICAgIH07XG4gICAgfSxcbn07XG4iLCIvKiBlc2xpbnQtZGlzYWJsZSBuby1taXhlZC1vcGVyYXRvcnMgKi9cbi8qIGVzbGludC1kaXNhYmxlIG5vLWJpdHdpc2UgKi9cbmltcG9ydCB7IGdsTWF0cml4LCB2ZWMyLCB2ZWMzIH0gZnJvbSAnZ2wtbWF0cml4JztcbmltcG9ydCBBcnJheUhlbHBlciBmcm9tICcuL2FycmF5X2hlbHBlcic7XG5pbXBvcnQgQ2x1c3RlcjIgZnJvbSAnLi9jbHVzdGVyJztcblxuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtcblxuLyoqXG4gKiBAcGFyYW0geCB4LWNvb3JkaW5hdGVcbiAqIEBwYXJhbSB5IHktY29vcmRpbmF0ZVxuICogQHJldHVybiBJbWFnZVJlZmVyZW5jZSB7eCx5fSBDb29yZGluYXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbWFnZVJlZih4LCB5KSB7XG4gICAgY29uc3QgdGhhdCA9IHtcbiAgICAgICAgeCxcbiAgICAgICAgeSxcbiAgICAgICAgdG9WZWMyKCkge1xuICAgICAgICAgICAgcmV0dXJuIHZlYzIuY2xvbmUoW3RoaXMueCwgdGhpcy55XSk7XG4gICAgICAgIH0sXG4gICAgICAgIHRvVmVjMygpIHtcbiAgICAgICAgICAgIHJldHVybiB2ZWMzLmNsb25lKFt0aGlzLngsIHRoaXMueSwgMV0pO1xuICAgICAgICB9LFxuICAgICAgICByb3VuZCgpIHtcbiAgICAgICAgICAgIHRoaXMueCA9IHRoaXMueCA+IDAuMCA/IE1hdGguZmxvb3IodGhpcy54ICsgMC41KSA6IE1hdGguZmxvb3IodGhpcy54IC0gMC41KTtcbiAgICAgICAgICAgIHRoaXMueSA9IHRoaXMueSA+IDAuMCA/IE1hdGguZmxvb3IodGhpcy55ICsgMC41KSA6IE1hdGguZmxvb3IodGhpcy55IC0gMC41KTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuICAgIH07XG4gICAgcmV0dXJuIHRoYXQ7XG59XG5cbi8qKlxuICogQ29tcHV0ZXMgYW4gaW50ZWdyYWwgaW1hZ2Ugb2YgYSBnaXZlbiBncmF5c2NhbGUgaW1hZ2UuXG4gKiBAcGFyYW0gaW1hZ2VEYXRhQ29udGFpbmVyIHtJbWFnZURhdGFDb250YWluZXJ9IHRoZSBpbWFnZSB0byBiZSBpbnRlZ3JhdGVkXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb21wdXRlSW50ZWdyYWxJbWFnZTIoaW1hZ2VXcmFwcGVyLCBpbnRlZ3JhbFdyYXBwZXIpIHtcbiAgICBjb25zdCBpbWFnZURhdGEgPSBpbWFnZVdyYXBwZXIuZGF0YTtcbiAgICBjb25zdCB3aWR0aCA9IGltYWdlV3JhcHBlci5zaXplLng7XG4gICAgY29uc3QgaGVpZ2h0ID0gaW1hZ2VXcmFwcGVyLnNpemUueTtcbiAgICBjb25zdCBpbnRlZ3JhbEltYWdlRGF0YSA9IGludGVncmFsV3JhcHBlci5kYXRhO1xuICAgIGxldCBzdW0gPSAwOyBsZXQgcG9zQSA9IDA7IGxldCBwb3NCID0gMDsgbGV0IHBvc0MgPSAwOyBsZXQgcG9zRCA9IDA7IGxldCB4OyBsZXRcbiAgICAgICAgeTtcblxuICAgIC8vIHN1bSB1cCBmaXJzdCBjb2x1bW5cbiAgICBwb3NCID0gd2lkdGg7XG4gICAgc3VtID0gMDtcbiAgICBmb3IgKHkgPSAxOyB5IDwgaGVpZ2h0OyB5KyspIHtcbiAgICAgICAgc3VtICs9IGltYWdlRGF0YVtwb3NBXTtcbiAgICAgICAgaW50ZWdyYWxJbWFnZURhdGFbcG9zQl0gKz0gc3VtO1xuICAgICAgICBwb3NBICs9IHdpZHRoO1xuICAgICAgICBwb3NCICs9IHdpZHRoO1xuICAgIH1cblxuICAgIHBvc0EgPSAwO1xuICAgIHBvc0IgPSAxO1xuICAgIHN1bSA9IDA7XG4gICAgZm9yICh4ID0gMTsgeCA8IHdpZHRoOyB4KyspIHtcbiAgICAgICAgc3VtICs9IGltYWdlRGF0YVtwb3NBXTtcbiAgICAgICAgaW50ZWdyYWxJbWFnZURhdGFbcG9zQl0gKz0gc3VtO1xuICAgICAgICBwb3NBKys7XG4gICAgICAgIHBvc0IrKztcbiAgICB9XG5cbiAgICBmb3IgKHkgPSAxOyB5IDwgaGVpZ2h0OyB5KyspIHtcbiAgICAgICAgcG9zQSA9IHkgKiB3aWR0aCArIDE7XG4gICAgICAgIHBvc0IgPSAoeSAtIDEpICogd2lkdGggKyAxO1xuICAgICAgICBwb3NDID0geSAqIHdpZHRoO1xuICAgICAgICBwb3NEID0gKHkgLSAxKSAqIHdpZHRoO1xuICAgICAgICBmb3IgKHggPSAxOyB4IDwgd2lkdGg7IHgrKykge1xuICAgICAgICAgICAgaW50ZWdyYWxJbWFnZURhdGFbcG9zQV1cbiAgICAgICAgICAgICAgICArPSBpbWFnZURhdGFbcG9zQV0gKyBpbnRlZ3JhbEltYWdlRGF0YVtwb3NCXSArIGludGVncmFsSW1hZ2VEYXRhW3Bvc0NdIC0gaW50ZWdyYWxJbWFnZURhdGFbcG9zRF07XG4gICAgICAgICAgICBwb3NBKys7XG4gICAgICAgICAgICBwb3NCKys7XG4gICAgICAgICAgICBwb3NDKys7XG4gICAgICAgICAgICBwb3NEKys7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjb21wdXRlSW50ZWdyYWxJbWFnZShpbWFnZVdyYXBwZXIsIGludGVncmFsV3JhcHBlcikge1xuICAgIGNvbnN0IGltYWdlRGF0YSA9IGltYWdlV3JhcHBlci5kYXRhO1xuICAgIGNvbnN0IHdpZHRoID0gaW1hZ2VXcmFwcGVyLnNpemUueDtcbiAgICBjb25zdCBoZWlnaHQgPSBpbWFnZVdyYXBwZXIuc2l6ZS55O1xuICAgIGNvbnN0IGludGVncmFsSW1hZ2VEYXRhID0gaW50ZWdyYWxXcmFwcGVyLmRhdGE7XG4gICAgbGV0IHN1bSA9IDA7XG5cbiAgICAvLyBzdW0gdXAgZmlyc3Qgcm93XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB3aWR0aDsgaSsrKSB7XG4gICAgICAgIHN1bSArPSBpbWFnZURhdGFbaV07XG4gICAgICAgIGludGVncmFsSW1hZ2VEYXRhW2ldID0gc3VtO1xuICAgIH1cblxuICAgIGZvciAobGV0IHYgPSAxOyB2IDwgaGVpZ2h0OyB2KyspIHtcbiAgICAgICAgc3VtID0gMDtcbiAgICAgICAgZm9yIChsZXQgdSA9IDA7IHUgPCB3aWR0aDsgdSsrKSB7XG4gICAgICAgICAgICBzdW0gKz0gaW1hZ2VEYXRhW3YgKiB3aWR0aCArIHVdO1xuICAgICAgICAgICAgaW50ZWdyYWxJbWFnZURhdGFbKCh2KSAqIHdpZHRoKSArIHVdID0gc3VtICsgaW50ZWdyYWxJbWFnZURhdGFbKHYgLSAxKSAqIHdpZHRoICsgdV07XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0aHJlc2hvbGRJbWFnZShpbWFnZVdyYXBwZXIsIHRocmVzaG9sZCwgdGFyZ2V0V3JhcHBlcikge1xuICAgIGlmICghdGFyZ2V0V3JhcHBlcikge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgICAgdGFyZ2V0V3JhcHBlciA9IGltYWdlV3JhcHBlcjtcbiAgICB9XG4gICAgY29uc3QgaW1hZ2VEYXRhID0gaW1hZ2VXcmFwcGVyLmRhdGE7IGxldCB7IGxlbmd0aCB9ID0gaW1hZ2VEYXRhOyBjb25zdFxuICAgICAgICB0YXJnZXREYXRhID0gdGFyZ2V0V3JhcHBlci5kYXRhO1xuXG4gICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgIHRhcmdldERhdGFbbGVuZ3RoXSA9IGltYWdlRGF0YVtsZW5ndGhdIDwgdGhyZXNob2xkID8gMSA6IDA7XG4gICAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gY29tcHV0ZUhpc3RvZ3JhbShpbWFnZVdyYXBwZXIsIGJpdHNQZXJQaXhlbCkge1xuICAgIGlmICghYml0c1BlclBpeGVsKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgICBiaXRzUGVyUGl4ZWwgPSA4O1xuICAgIH1cbiAgICBjb25zdCBpbWFnZURhdGEgPSBpbWFnZVdyYXBwZXIuZGF0YTtcbiAgICBsZXQgeyBsZW5ndGggfSA9IGltYWdlRGF0YTtcbiAgICBjb25zdCBiaXRTaGlmdCA9IDggLSBiaXRzUGVyUGl4ZWw7XG4gICAgY29uc3QgYnVja2V0Q250ID0gMSA8PCBiaXRzUGVyUGl4ZWw7XG4gICAgY29uc3QgaGlzdCA9IG5ldyBJbnQzMkFycmF5KGJ1Y2tldENudCk7XG5cbiAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgaGlzdFtpbWFnZURhdGFbbGVuZ3RoXSA+PiBiaXRTaGlmdF0rKztcbiAgICB9XG4gICAgcmV0dXJuIGhpc3Q7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzaGFycGVuTGluZShsaW5lKSB7XG4gICAgbGV0IGk7XG4gICAgY29uc3QgeyBsZW5ndGggfSA9IGxpbmU7XG4gICAgbGV0IGxlZnQgPSBsaW5lWzBdO1xuICAgIGxldCBjZW50ZXIgPSBsaW5lWzFdO1xuICAgIGxldCByaWdodDtcblxuICAgIGZvciAoaSA9IDE7IGkgPCBsZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgcmlnaHQgPSBsaW5lW2kgKyAxXTtcbiAgICAgICAgLy8gIC0xIDQgLTEga2VybmVsXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgICBsaW5lW2kgLSAxXSA9ICgoKGNlbnRlciAqIDIpIC0gbGVmdCAtIHJpZ2h0KSkgJiAyNTU7XG4gICAgICAgIGxlZnQgPSBjZW50ZXI7XG4gICAgICAgIGNlbnRlciA9IHJpZ2h0O1xuICAgIH1cbiAgICByZXR1cm4gbGluZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRldGVybWluZU90c3VUaHJlc2hvbGQoaW1hZ2VXcmFwcGVyLCBiaXRzUGVyUGl4ZWwgPSA4KSB7XG4gICAgbGV0IGhpc3Q7XG4gICAgY29uc3QgYml0U2hpZnQgPSA4IC0gYml0c1BlclBpeGVsO1xuXG4gICAgZnVuY3Rpb24gcHgoaW5pdCwgZW5kKSB7XG4gICAgICAgIGxldCBzdW0gPSAwO1xuICAgICAgICBmb3IgKGxldCBpID0gaW5pdDsgaSA8PSBlbmQ7IGkrKykge1xuICAgICAgICAgICAgc3VtICs9IGhpc3RbaV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN1bTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBteChpbml0LCBlbmQpIHtcbiAgICAgICAgbGV0IHN1bSA9IDA7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IGluaXQ7IGkgPD0gZW5kOyBpKyspIHtcbiAgICAgICAgICAgIHN1bSArPSBpICogaGlzdFtpXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzdW07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGV0ZXJtaW5lVGhyZXNob2xkKCkge1xuICAgICAgICBjb25zdCB2ZXQgPSBbMF07XG4gICAgICAgIGxldCBwMTtcbiAgICAgICAgbGV0IHAyO1xuICAgICAgICBsZXQgcDEyO1xuICAgICAgICBsZXQgbTE7XG4gICAgICAgIGxldCBtMjtcbiAgICAgICAgbGV0IG0xMjtcbiAgICAgICAgY29uc3QgbWF4ID0gKDEgPDwgYml0c1BlclBpeGVsKSAtIDE7XG5cbiAgICAgICAgaGlzdCA9IGNvbXB1dGVIaXN0b2dyYW0oaW1hZ2VXcmFwcGVyLCBiaXRzUGVyUGl4ZWwpO1xuICAgICAgICBmb3IgKGxldCBrID0gMTsgayA8IG1heDsgaysrKSB7XG4gICAgICAgICAgICBwMSA9IHB4KDAsIGspO1xuICAgICAgICAgICAgcDIgPSBweChrICsgMSwgbWF4KTtcbiAgICAgICAgICAgIHAxMiA9IHAxICogcDI7XG4gICAgICAgICAgICBpZiAocDEyID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcDEyID0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG0xID0gbXgoMCwgaykgKiBwMjtcbiAgICAgICAgICAgIG0yID0gbXgoayArIDEsIG1heCkgKiBwMTtcbiAgICAgICAgICAgIG0xMiA9IG0xIC0gbTI7XG4gICAgICAgICAgICB2ZXRba10gPSBtMTIgKiBtMTIgLyBwMTI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEFycmF5SGVscGVyLm1heEluZGV4KHZldCk7XG4gICAgfVxuXG4gICAgY29uc3QgdGhyZXNob2xkID0gZGV0ZXJtaW5lVGhyZXNob2xkKCk7XG4gICAgcmV0dXJuIHRocmVzaG9sZCA8PCBiaXRTaGlmdDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG90c3VUaHJlc2hvbGQoaW1hZ2VXcmFwcGVyLCB0YXJnZXRXcmFwcGVyKSB7XG4gICAgY29uc3QgdGhyZXNob2xkID0gZGV0ZXJtaW5lT3RzdVRocmVzaG9sZChpbWFnZVdyYXBwZXIpO1xuXG4gICAgdGhyZXNob2xkSW1hZ2UoaW1hZ2VXcmFwcGVyLCB0aHJlc2hvbGQsIHRhcmdldFdyYXBwZXIpO1xuICAgIHJldHVybiB0aHJlc2hvbGQ7XG59XG5cbi8vIGxvY2FsIHRocmVzaG9sZGluZ1xuZXhwb3J0IGZ1bmN0aW9uIGNvbXB1dGVCaW5hcnlJbWFnZShpbWFnZVdyYXBwZXIsIGludGVncmFsV3JhcHBlciwgdGFyZ2V0V3JhcHBlcikge1xuICAgIGNvbXB1dGVJbnRlZ3JhbEltYWdlKGltYWdlV3JhcHBlciwgaW50ZWdyYWxXcmFwcGVyKTtcblxuICAgIGlmICghdGFyZ2V0V3JhcHBlcikge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgICAgdGFyZ2V0V3JhcHBlciA9IGltYWdlV3JhcHBlcjtcbiAgICB9XG4gICAgY29uc3QgaW1hZ2VEYXRhID0gaW1hZ2VXcmFwcGVyLmRhdGE7XG4gICAgY29uc3QgdGFyZ2V0RGF0YSA9IHRhcmdldFdyYXBwZXIuZGF0YTtcbiAgICBjb25zdCB3aWR0aCA9IGltYWdlV3JhcHBlci5zaXplLng7XG4gICAgY29uc3QgaGVpZ2h0ID0gaW1hZ2VXcmFwcGVyLnNpemUueTtcbiAgICBjb25zdCBpbnRlZ3JhbEltYWdlRGF0YSA9IGludGVncmFsV3JhcHBlci5kYXRhO1xuICAgIGxldCBzdW0gPSAwOyBsZXQgdjsgbGV0IHU7IGNvbnN0IGtlcm5lbCA9IDM7IGxldCBBOyBsZXQgQjsgbGV0IEM7IGxldCBEOyBsZXQgYXZnOyBjb25zdFxuICAgICAgICBzaXplID0gKGtlcm5lbCAqIDIgKyAxKSAqIChrZXJuZWwgKiAyICsgMSk7XG5cbiAgICAvLyBjbGVhciBvdXQgdG9wICYgYm90dG9tLWJvcmRlclxuICAgIGZvciAodiA9IDA7IHYgPD0ga2VybmVsOyB2KyspIHtcbiAgICAgICAgZm9yICh1ID0gMDsgdSA8IHdpZHRoOyB1KyspIHtcbiAgICAgICAgICAgIHRhcmdldERhdGFbKCh2KSAqIHdpZHRoKSArIHVdID0gMDtcbiAgICAgICAgICAgIHRhcmdldERhdGFbKCgoaGVpZ2h0IC0gMSkgLSB2KSAqIHdpZHRoKSArIHVdID0gMDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIGNsZWFyIG91dCBsZWZ0ICYgcmlnaHQgYm9yZGVyXG4gICAgZm9yICh2ID0ga2VybmVsOyB2IDwgaGVpZ2h0IC0ga2VybmVsOyB2KyspIHtcbiAgICAgICAgZm9yICh1ID0gMDsgdSA8PSBrZXJuZWw7IHUrKykge1xuICAgICAgICAgICAgdGFyZ2V0RGF0YVsoKHYpICogd2lkdGgpICsgdV0gPSAwO1xuICAgICAgICAgICAgdGFyZ2V0RGF0YVsoKHYpICogd2lkdGgpICsgKHdpZHRoIC0gMSAtIHUpXSA9IDA7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKHYgPSBrZXJuZWwgKyAxOyB2IDwgaGVpZ2h0IC0ga2VybmVsIC0gMTsgdisrKSB7XG4gICAgICAgIGZvciAodSA9IGtlcm5lbCArIDE7IHUgPCB3aWR0aCAtIGtlcm5lbDsgdSsrKSB7XG4gICAgICAgICAgICBBID0gaW50ZWdyYWxJbWFnZURhdGFbKHYgLSBrZXJuZWwgLSAxKSAqIHdpZHRoICsgKHUgLSBrZXJuZWwgLSAxKV07XG4gICAgICAgICAgICBCID0gaW50ZWdyYWxJbWFnZURhdGFbKHYgLSBrZXJuZWwgLSAxKSAqIHdpZHRoICsgKHUgKyBrZXJuZWwpXTtcbiAgICAgICAgICAgIEMgPSBpbnRlZ3JhbEltYWdlRGF0YVsodiArIGtlcm5lbCkgKiB3aWR0aCArICh1IC0ga2VybmVsIC0gMSldO1xuICAgICAgICAgICAgRCA9IGludGVncmFsSW1hZ2VEYXRhWyh2ICsga2VybmVsKSAqIHdpZHRoICsgKHUgKyBrZXJuZWwpXTtcbiAgICAgICAgICAgIHN1bSA9IEQgLSBDIC0gQiArIEE7XG4gICAgICAgICAgICBhdmcgPSBzdW0gLyAoc2l6ZSk7XG4gICAgICAgICAgICB0YXJnZXREYXRhW3YgKiB3aWR0aCArIHVdID0gaW1hZ2VEYXRhW3YgKiB3aWR0aCArIHVdID4gKGF2ZyArIDUpID8gMCA6IDE7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjbHVzdGVyKHBvaW50cywgdGhyZXNob2xkLCBwcm9wZXJ0eSkge1xuICAgIGxldCBpOyBsZXQgazsgbGV0IHRoaXNDbHVzdGVyOyBsZXQgcG9pbnQ7IGNvbnN0XG4gICAgICAgIGNsdXN0ZXJzID0gW107XG5cbiAgICBpZiAoIXByb3BlcnR5KSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgICBwcm9wZXJ0eSA9ICdyYWQnO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFkZFRvQ2x1c3RlcihuZXdQb2ludCkge1xuICAgICAgICBsZXQgZm91bmQgPSBmYWxzZTtcbiAgICAgICAgZm9yIChrID0gMDsgayA8IGNsdXN0ZXJzLmxlbmd0aDsgaysrKSB7XG4gICAgICAgICAgICB0aGlzQ2x1c3RlciA9IGNsdXN0ZXJzW2tdO1xuICAgICAgICAgICAgaWYgKHRoaXNDbHVzdGVyLmZpdHMobmV3UG9pbnQpKSB7XG4gICAgICAgICAgICAgICAgdGhpc0NsdXN0ZXIuYWRkKG5ld1BvaW50KTtcbiAgICAgICAgICAgICAgICBmb3VuZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZvdW5kO1xuICAgIH1cblxuICAgIC8vIGl0ZXJhdGUgb3ZlciBlYWNoIGNsb3VkXG4gICAgZm9yIChpID0gMDsgaSA8IHBvaW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBwb2ludCA9IENsdXN0ZXIyLmNyZWF0ZVBvaW50KHBvaW50c1tpXSwgaSwgcHJvcGVydHkpO1xuICAgICAgICBpZiAoIWFkZFRvQ2x1c3Rlcihwb2ludCkpIHtcbiAgICAgICAgICAgIGNsdXN0ZXJzLnB1c2goQ2x1c3RlcjIuY3JlYXRlKHBvaW50LCB0aHJlc2hvbGQpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY2x1c3RlcnM7XG59XG5cbmV4cG9ydCBjb25zdCBUcmFjZXIgPSB7XG4gICAgdHJhY2UocG9pbnRzLCB2ZWMpIHtcbiAgICAgICAgbGV0IGl0ZXJhdGlvbjtcbiAgICAgICAgY29uc3QgbWF4SXRlcmF0aW9ucyA9IDEwO1xuICAgICAgICBsZXQgdG9wID0gW107XG4gICAgICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICAgICAgbGV0IGNlbnRlclBvcyA9IDA7XG4gICAgICAgIGxldCBjdXJyZW50UG9zID0gMDtcblxuICAgICAgICBmdW5jdGlvbiB0cmFjZShpZHgsIGZvcndhcmQpIHtcbiAgICAgICAgICAgIGxldCB0bztcbiAgICAgICAgICAgIGxldCB0b0lkeDtcbiAgICAgICAgICAgIGxldCBwcmVkaWN0ZWRQb3M7XG4gICAgICAgICAgICBjb25zdCB0aHJlc2hvbGRYID0gMTtcbiAgICAgICAgICAgIGNvbnN0IHRocmVzaG9sZFkgPSBNYXRoLmFicyh2ZWNbMV0gLyAxMCk7XG4gICAgICAgICAgICBsZXQgZm91bmQgPSBmYWxzZTtcblxuICAgICAgICAgICAgZnVuY3Rpb24gbWF0Y2gocG9zLCBwcmVkaWN0ZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAocG9zLnggPiAocHJlZGljdGVkLnggLSB0aHJlc2hvbGRYKVxuICAgICAgICAgICAgICAgICAgICAgICAgJiYgcG9zLnggPCAocHJlZGljdGVkLnggKyB0aHJlc2hvbGRYKVxuICAgICAgICAgICAgICAgICAgICAgICAgJiYgcG9zLnkgPiAocHJlZGljdGVkLnkgLSB0aHJlc2hvbGRZKVxuICAgICAgICAgICAgICAgICAgICAgICAgJiYgcG9zLnkgPCAocHJlZGljdGVkLnkgKyB0aHJlc2hvbGRZKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBjaGVjayBpZiB0aGUgbmV4dCBpbmRleCBpcyB3aXRoaW4gdGhlIHZlYyBzcGVjaWZpY2F0aW9uc1xuICAgICAgICAgICAgLy8gaWYgbm90LCBjaGVjayBhcyBsb25nIGFzIHRoZSB0aHJlc2hvbGQgaXMgbWV0XG5cbiAgICAgICAgICAgIGNvbnN0IGZyb20gPSBwb2ludHNbaWR4XTtcbiAgICAgICAgICAgIGlmIChmb3J3YXJkKSB7XG4gICAgICAgICAgICAgICAgcHJlZGljdGVkUG9zID0ge1xuICAgICAgICAgICAgICAgICAgICB4OiBmcm9tLnggKyB2ZWNbMF0sXG4gICAgICAgICAgICAgICAgICAgIHk6IGZyb20ueSArIHZlY1sxXSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwcmVkaWN0ZWRQb3MgPSB7XG4gICAgICAgICAgICAgICAgICAgIHg6IGZyb20ueCAtIHZlY1swXSxcbiAgICAgICAgICAgICAgICAgICAgeTogZnJvbS55IC0gdmVjWzFdLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRvSWR4ID0gZm9yd2FyZCA/IGlkeCArIDEgOiBpZHggLSAxO1xuICAgICAgICAgICAgdG8gPSBwb2ludHNbdG9JZHhdO1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbmQtYXNzaWduXG4gICAgICAgICAgICB3aGlsZSAodG8gJiYgKGZvdW5kID0gbWF0Y2godG8sIHByZWRpY3RlZFBvcykpICE9PSB0cnVlICYmIChNYXRoLmFicyh0by55IC0gZnJvbS55KSA8IHZlY1sxXSkpIHtcbiAgICAgICAgICAgICAgICB0b0lkeCA9IGZvcndhcmQgPyB0b0lkeCArIDEgOiB0b0lkeCAtIDE7XG4gICAgICAgICAgICAgICAgdG8gPSBwb2ludHNbdG9JZHhdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gZm91bmQgPyB0b0lkeCA6IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGl0ZXJhdGlvbiA9IDA7IGl0ZXJhdGlvbiA8IG1heEl0ZXJhdGlvbnM7IGl0ZXJhdGlvbisrKSB7XG4gICAgICAgICAgICAvLyByYW5kb21seSBzZWxlY3QgcG9pbnQgdG8gc3RhcnQgd2l0aFxuICAgICAgICAgICAgY2VudGVyUG9zID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogcG9pbnRzLmxlbmd0aCk7XG5cbiAgICAgICAgICAgIC8vIHRyYWNlIGZvcndhcmRcbiAgICAgICAgICAgIHRvcCA9IFtdO1xuICAgICAgICAgICAgY3VycmVudFBvcyA9IGNlbnRlclBvcztcbiAgICAgICAgICAgIHRvcC5wdXNoKHBvaW50c1tjdXJyZW50UG9zXSk7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uZC1hc3NpZ25cbiAgICAgICAgICAgIHdoaWxlICgoY3VycmVudFBvcyA9IHRyYWNlKGN1cnJlbnRQb3MsIHRydWUpKSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRvcC5wdXNoKHBvaW50c1tjdXJyZW50UG9zXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY2VudGVyUG9zID4gMCkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRQb3MgPSBjZW50ZXJQb3M7XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbmQtYXNzaWduXG4gICAgICAgICAgICAgICAgd2hpbGUgKChjdXJyZW50UG9zID0gdHJhY2UoY3VycmVudFBvcywgZmFsc2UpKSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB0b3AucHVzaChwb2ludHNbY3VycmVudFBvc10pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRvcC5sZW5ndGggPiByZXN1bHQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gdG9wO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcbn07XG5cbmV4cG9ydCBjb25zdCBESUxBVEUgPSAxO1xuZXhwb3J0IGNvbnN0IEVST0RFID0gMjtcblxuZXhwb3J0IGZ1bmN0aW9uIGRpbGF0ZShpbkltYWdlV3JhcHBlciwgb3V0SW1hZ2VXcmFwcGVyKSB7XG4gICAgbGV0IHY7XG4gICAgbGV0IHU7XG4gICAgY29uc3QgaW5JbWFnZURhdGEgPSBpbkltYWdlV3JhcHBlci5kYXRhO1xuICAgIGNvbnN0IG91dEltYWdlRGF0YSA9IG91dEltYWdlV3JhcHBlci5kYXRhO1xuICAgIGNvbnN0IGhlaWdodCA9IGluSW1hZ2VXcmFwcGVyLnNpemUueTtcbiAgICBjb25zdCB3aWR0aCA9IGluSW1hZ2VXcmFwcGVyLnNpemUueDtcbiAgICBsZXQgc3VtO1xuICAgIGxldCB5U3RhcnQxO1xuICAgIGxldCB5U3RhcnQyO1xuICAgIGxldCB4U3RhcnQxO1xuICAgIGxldCB4U3RhcnQyO1xuXG4gICAgZm9yICh2ID0gMTsgdiA8IGhlaWdodCAtIDE7IHYrKykge1xuICAgICAgICBmb3IgKHUgPSAxOyB1IDwgd2lkdGggLSAxOyB1KyspIHtcbiAgICAgICAgICAgIHlTdGFydDEgPSB2IC0gMTtcbiAgICAgICAgICAgIHlTdGFydDIgPSB2ICsgMTtcbiAgICAgICAgICAgIHhTdGFydDEgPSB1IC0gMTtcbiAgICAgICAgICAgIHhTdGFydDIgPSB1ICsgMTtcbiAgICAgICAgICAgIHN1bSA9IGluSW1hZ2VEYXRhW3lTdGFydDEgKiB3aWR0aCArIHhTdGFydDFdICsgaW5JbWFnZURhdGFbeVN0YXJ0MSAqIHdpZHRoICsgeFN0YXJ0Ml1cbiAgICAgICAgICAgICsgaW5JbWFnZURhdGFbdiAqIHdpZHRoICsgdV1cbiAgICAgICAgICAgICsgaW5JbWFnZURhdGFbeVN0YXJ0MiAqIHdpZHRoICsgeFN0YXJ0MV0gKyBpbkltYWdlRGF0YVt5U3RhcnQyICogd2lkdGggKyB4U3RhcnQyXTtcbiAgICAgICAgICAgIG91dEltYWdlRGF0YVt2ICogd2lkdGggKyB1XSA9IHN1bSA+IDAgPyAxIDogMDtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGVyb2RlKGluSW1hZ2VXcmFwcGVyLCBvdXRJbWFnZVdyYXBwZXIpIHtcbiAgICBsZXQgdjtcbiAgICBsZXQgdTtcbiAgICBjb25zdCBpbkltYWdlRGF0YSA9IGluSW1hZ2VXcmFwcGVyLmRhdGE7XG4gICAgY29uc3Qgb3V0SW1hZ2VEYXRhID0gb3V0SW1hZ2VXcmFwcGVyLmRhdGE7XG4gICAgY29uc3QgaGVpZ2h0ID0gaW5JbWFnZVdyYXBwZXIuc2l6ZS55O1xuICAgIGNvbnN0IHdpZHRoID0gaW5JbWFnZVdyYXBwZXIuc2l6ZS54O1xuICAgIGxldCBzdW07XG4gICAgbGV0IHlTdGFydDE7XG4gICAgbGV0IHlTdGFydDI7XG4gICAgbGV0IHhTdGFydDE7XG4gICAgbGV0IHhTdGFydDI7XG5cbiAgICBmb3IgKHYgPSAxOyB2IDwgaGVpZ2h0IC0gMTsgdisrKSB7XG4gICAgICAgIGZvciAodSA9IDE7IHUgPCB3aWR0aCAtIDE7IHUrKykge1xuICAgICAgICAgICAgeVN0YXJ0MSA9IHYgLSAxO1xuICAgICAgICAgICAgeVN0YXJ0MiA9IHYgKyAxO1xuICAgICAgICAgICAgeFN0YXJ0MSA9IHUgLSAxO1xuICAgICAgICAgICAgeFN0YXJ0MiA9IHUgKyAxO1xuICAgICAgICAgICAgc3VtID0gaW5JbWFnZURhdGFbeVN0YXJ0MSAqIHdpZHRoICsgeFN0YXJ0MV0gKyBpbkltYWdlRGF0YVt5U3RhcnQxICogd2lkdGggKyB4U3RhcnQyXVxuICAgICAgICAgICAgKyBpbkltYWdlRGF0YVt2ICogd2lkdGggKyB1XVxuICAgICAgICAgICAgKyBpbkltYWdlRGF0YVt5U3RhcnQyICogd2lkdGggKyB4U3RhcnQxXSArIGluSW1hZ2VEYXRhW3lTdGFydDIgKiB3aWR0aCArIHhTdGFydDJdO1xuICAgICAgICAgICAgb3V0SW1hZ2VEYXRhW3YgKiB3aWR0aCArIHVdID0gc3VtID09PSA1ID8gMSA6IDA7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzdWJ0cmFjdChhSW1hZ2VXcmFwcGVyLCBiSW1hZ2VXcmFwcGVyLCByZXN1bHRJbWFnZVdyYXBwZXIpIHtcbiAgICBpZiAoIXJlc3VsdEltYWdlV3JhcHBlcikge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgICAgcmVzdWx0SW1hZ2VXcmFwcGVyID0gYUltYWdlV3JhcHBlcjtcbiAgICB9XG4gICAgbGV0IHsgbGVuZ3RoIH0gPSBhSW1hZ2VXcmFwcGVyLmRhdGE7XG4gICAgY29uc3QgYUltYWdlRGF0YSA9IGFJbWFnZVdyYXBwZXIuZGF0YTtcbiAgICBjb25zdCBiSW1hZ2VEYXRhID0gYkltYWdlV3JhcHBlci5kYXRhO1xuICAgIGNvbnN0IGNJbWFnZURhdGEgPSByZXN1bHRJbWFnZVdyYXBwZXIuZGF0YTtcblxuICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICBjSW1hZ2VEYXRhW2xlbmd0aF0gPSBhSW1hZ2VEYXRhW2xlbmd0aF0gLSBiSW1hZ2VEYXRhW2xlbmd0aF07XG4gICAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gYml0d2lzZU9yKGFJbWFnZVdyYXBwZXIsIGJJbWFnZVdyYXBwZXIsIHJlc3VsdEltYWdlV3JhcHBlcikge1xuICAgIGlmICghcmVzdWx0SW1hZ2VXcmFwcGVyKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgICByZXN1bHRJbWFnZVdyYXBwZXIgPSBhSW1hZ2VXcmFwcGVyO1xuICAgIH1cbiAgICBsZXQgeyBsZW5ndGggfSA9IGFJbWFnZVdyYXBwZXIuZGF0YTtcbiAgICBjb25zdCBhSW1hZ2VEYXRhID0gYUltYWdlV3JhcHBlci5kYXRhO1xuICAgIGNvbnN0IGJJbWFnZURhdGEgPSBiSW1hZ2VXcmFwcGVyLmRhdGE7XG4gICAgY29uc3QgY0ltYWdlRGF0YSA9IHJlc3VsdEltYWdlV3JhcHBlci5kYXRhO1xuXG4gICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgIGNJbWFnZURhdGFbbGVuZ3RoXSA9IGFJbWFnZURhdGFbbGVuZ3RoXSB8fCBiSW1hZ2VEYXRhW2xlbmd0aF07XG4gICAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gY291bnROb25aZXJvKGltYWdlV3JhcHBlcikge1xuICAgIGxldCB7IGxlbmd0aCB9ID0gaW1hZ2VXcmFwcGVyLmRhdGE7XG4gICAgY29uc3QgeyBkYXRhIH0gPSBpbWFnZVdyYXBwZXI7XG4gICAgbGV0IHN1bSA9IDA7XG5cbiAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgc3VtICs9IGRhdGFbbGVuZ3RoXTtcbiAgICB9XG4gICAgcmV0dXJuIHN1bTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHRvcEdlbmVyaWMobGlzdCwgdG9wLCBzY29yZUZ1bmMpIHtcbiAgICBsZXQgaTsgbGV0IG1pbklkeCA9IDA7IGxldCBtaW4gPSAwOyBjb25zdCBxdWV1ZSA9IFtdOyBsZXQgc2NvcmU7IGxldCBoaXQ7IGxldFxuICAgICAgICBwb3M7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgdG9wOyBpKyspIHtcbiAgICAgICAgcXVldWVbaV0gPSB7XG4gICAgICAgICAgICBzY29yZTogMCxcbiAgICAgICAgICAgIGl0ZW06IG51bGwsXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgc2NvcmUgPSBzY29yZUZ1bmMuYXBwbHkodGhpcywgW2xpc3RbaV1dKTtcbiAgICAgICAgaWYgKHNjb3JlID4gbWluKSB7XG4gICAgICAgICAgICBoaXQgPSBxdWV1ZVttaW5JZHhdO1xuICAgICAgICAgICAgaGl0LnNjb3JlID0gc2NvcmU7XG4gICAgICAgICAgICBoaXQuaXRlbSA9IGxpc3RbaV07XG4gICAgICAgICAgICBtaW4gPSBOdW1iZXIuTUFYX1ZBTFVFO1xuICAgICAgICAgICAgZm9yIChwb3MgPSAwOyBwb3MgPCB0b3A7IHBvcysrKSB7XG4gICAgICAgICAgICAgICAgaWYgKHF1ZXVlW3Bvc10uc2NvcmUgPCBtaW4pIHtcbiAgICAgICAgICAgICAgICAgICAgbWluID0gcXVldWVbcG9zXS5zY29yZTtcbiAgICAgICAgICAgICAgICAgICAgbWluSWR4ID0gcG9zO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBxdWV1ZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdyYXlBcnJheUZyb21JbWFnZShodG1sSW1hZ2UsIG9mZnNldFgsIGN0eCwgYXJyYXkpIHtcbiAgICBjdHguZHJhd0ltYWdlKGh0bWxJbWFnZSwgb2Zmc2V0WCwgMCwgaHRtbEltYWdlLndpZHRoLCBodG1sSW1hZ2UuaGVpZ2h0KTtcbiAgICBjb25zdCBjdHhEYXRhID0gY3R4LmdldEltYWdlRGF0YShvZmZzZXRYLCAwLCBodG1sSW1hZ2Uud2lkdGgsIGh0bWxJbWFnZS5oZWlnaHQpLmRhdGE7XG4gICAgY29tcHV0ZUdyYXkoY3R4RGF0YSwgYXJyYXkpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ3JheUFycmF5RnJvbUNvbnRleHQoY3R4LCBzaXplLCBvZmZzZXQsIGFycmF5KSB7XG4gICAgY29uc3QgY3R4RGF0YSA9IGN0eC5nZXRJbWFnZURhdGEob2Zmc2V0LngsIG9mZnNldC55LCBzaXplLngsIHNpemUueSkuZGF0YTtcbiAgICBjb21wdXRlR3JheShjdHhEYXRhLCBhcnJheSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBncmF5QW5kSGFsZlNhbXBsZUZyb21DYW52YXNEYXRhKGNhbnZhc0RhdGEsIHNpemUsIG91dEFycmF5KSB7XG4gICAgbGV0IHRvcFJvd0lkeCA9IDA7XG4gICAgbGV0IGJvdHRvbVJvd0lkeCA9IHNpemUueDtcbiAgICBjb25zdCBlbmRJZHggPSBNYXRoLmZsb29yKGNhbnZhc0RhdGEubGVuZ3RoIC8gNCk7XG4gICAgY29uc3Qgb3V0V2lkdGggPSBzaXplLnggLyAyO1xuICAgIGxldCBvdXRJbWdJZHggPSAwO1xuICAgIGNvbnN0IGluV2lkdGggPSBzaXplLng7XG4gICAgbGV0IGk7XG5cbiAgICB3aGlsZSAoYm90dG9tUm93SWR4IDwgZW5kSWR4KSB7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBvdXRXaWR0aDsgaSsrKSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgICAgICAgIG91dEFycmF5W291dEltZ0lkeF0gPSAoXG4gICAgICAgICAgICAgICAgKDAuMjk5ICogY2FudmFzRGF0YVt0b3BSb3dJZHggKiA0ICsgMF1cbiAgICAgICAgICAgICAgICAgKyAwLjU4NyAqIGNhbnZhc0RhdGFbdG9wUm93SWR4ICogNCArIDFdXG4gICAgICAgICAgICAgICAgICsgMC4xMTQgKiBjYW52YXNEYXRhW3RvcFJvd0lkeCAqIDQgKyAyXSlcbiAgICAgICAgICAgICAgICArICgwLjI5OSAqIGNhbnZhc0RhdGFbKHRvcFJvd0lkeCArIDEpICogNCArIDBdXG4gICAgICAgICAgICAgICAgICsgMC41ODcgKiBjYW52YXNEYXRhWyh0b3BSb3dJZHggKyAxKSAqIDQgKyAxXVxuICAgICAgICAgICAgICAgICArIDAuMTE0ICogY2FudmFzRGF0YVsodG9wUm93SWR4ICsgMSkgKiA0ICsgMl0pXG4gICAgICAgICAgICAgICAgKyAoMC4yOTkgKiBjYW52YXNEYXRhWyhib3R0b21Sb3dJZHgpICogNCArIDBdXG4gICAgICAgICAgICAgICAgICsgMC41ODcgKiBjYW52YXNEYXRhWyhib3R0b21Sb3dJZHgpICogNCArIDFdXG4gICAgICAgICAgICAgICAgICsgMC4xMTQgKiBjYW52YXNEYXRhWyhib3R0b21Sb3dJZHgpICogNCArIDJdKVxuICAgICAgICAgICAgICAgICsgKDAuMjk5ICogY2FudmFzRGF0YVsoYm90dG9tUm93SWR4ICsgMSkgKiA0ICsgMF1cbiAgICAgICAgICAgICAgICAgKyAwLjU4NyAqIGNhbnZhc0RhdGFbKGJvdHRvbVJvd0lkeCArIDEpICogNCArIDFdXG4gICAgICAgICAgICAgICAgICsgMC4xMTQgKiBjYW52YXNEYXRhWyhib3R0b21Sb3dJZHggKyAxKSAqIDQgKyAyXSkpIC8gNDtcbiAgICAgICAgICAgIG91dEltZ0lkeCsrO1xuICAgICAgICAgICAgdG9wUm93SWR4ICs9IDI7XG4gICAgICAgICAgICBib3R0b21Sb3dJZHggKz0gMjtcbiAgICAgICAgfVxuICAgICAgICB0b3BSb3dJZHggKz0gaW5XaWR0aDtcbiAgICAgICAgYm90dG9tUm93SWR4ICs9IGluV2lkdGg7XG4gICAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gY29tcHV0ZUdyYXkoaW1hZ2VEYXRhLCBvdXRBcnJheSwgY29uZmlnKSB7XG4gICAgY29uc3QgbCA9IChpbWFnZURhdGEubGVuZ3RoIC8gNCkgfCAwO1xuICAgIGNvbnN0IHNpbmdsZUNoYW5uZWwgPSBjb25maWcgJiYgY29uZmlnLnNpbmdsZUNoYW5uZWwgPT09IHRydWU7XG5cbiAgICBpZiAoc2luZ2xlQ2hhbm5lbCkge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICAgICAgICBvdXRBcnJheVtpXSA9IGltYWdlRGF0YVtpICogNCArIDBdO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgICAgICAgb3V0QXJyYXlbaV0gPSAwLjI5OSAqIGltYWdlRGF0YVtpICogNCArIDBdICsgMC41ODcgKiBpbWFnZURhdGFbaSAqIDQgKyAxXSArIDAuMTE0ICogaW1hZ2VEYXRhW2kgKiA0ICsgMl07XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBsb2FkSW1hZ2VBcnJheShzcmMsIGNhbGxiYWNrLCBjYW52YXMgPSBkb2N1bWVudCAmJiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKSkge1xuICAgIGNvbnN0IGltZyA9IG5ldyBJbWFnZSgpO1xuICAgIGltZy5jYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgIGltZy5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgICBjYW52YXMud2lkdGggPSB0aGlzLndpZHRoO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgICAgY2FudmFzLmhlaWdodCA9IHRoaXMuaGVpZ2h0O1xuICAgICAgICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgICAgY3R4LmRyYXdJbWFnZSh0aGlzLCAwLCAwKTtcbiAgICAgICAgY29uc3QgYXJyYXkgPSBuZXcgVWludDhBcnJheSh0aGlzLndpZHRoICogdGhpcy5oZWlnaHQpO1xuICAgICAgICBjdHguZHJhd0ltYWdlKHRoaXMsIDAsIDApO1xuICAgICAgICBjb25zdCB7IGRhdGEgfSA9IGN0eC5nZXRJbWFnZURhdGEoMCwgMCwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xuICAgICAgICBjb21wdXRlR3JheShkYXRhLCBhcnJheSk7XG4gICAgICAgIHRoaXMuY2FsbGJhY2soYXJyYXksIHtcbiAgICAgICAgICAgIHg6IHRoaXMud2lkdGgsXG4gICAgICAgICAgICB5OiB0aGlzLmhlaWdodCxcbiAgICAgICAgfSwgdGhpcyk7XG4gICAgfTtcbiAgICBpbWcuc3JjID0gc3JjO1xufVxuXG4vKipcbiAqIEBwYXJhbSBpbkltZyB7SW1hZ2VXcmFwcGVyfSBpbnB1dCBpbWFnZSB0byBiZSBzYW1wbGVkXG4gKiBAcGFyYW0gb3V0SW1nIHtJbWFnZVdyYXBwZXJ9IHRvIGJlIHN0b3JlZCBpblxuICovXG5leHBvcnQgZnVuY3Rpb24gaGFsZlNhbXBsZShpbkltZ1dyYXBwZXIsIG91dEltZ1dyYXBwZXIpIHtcbiAgICBjb25zdCBpbkltZyA9IGluSW1nV3JhcHBlci5kYXRhO1xuICAgIGNvbnN0IGluV2lkdGggPSBpbkltZ1dyYXBwZXIuc2l6ZS54O1xuICAgIGNvbnN0IG91dEltZyA9IG91dEltZ1dyYXBwZXIuZGF0YTtcbiAgICBsZXQgdG9wUm93SWR4ID0gMDtcbiAgICBsZXQgYm90dG9tUm93SWR4ID0gaW5XaWR0aDtcbiAgICBjb25zdCBlbmRJZHggPSBpbkltZy5sZW5ndGg7XG4gICAgY29uc3Qgb3V0V2lkdGggPSBpbldpZHRoIC8gMjtcbiAgICBsZXQgb3V0SW1nSWR4ID0gMDtcbiAgICB3aGlsZSAoYm90dG9tUm93SWR4IDwgZW5kSWR4KSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb3V0V2lkdGg7IGkrKykge1xuICAgICAgICAgICAgb3V0SW1nW291dEltZ0lkeF0gPSBNYXRoLmZsb29yKFxuICAgICAgICAgICAgICAgIChpbkltZ1t0b3BSb3dJZHhdICsgaW5JbWdbdG9wUm93SWR4ICsgMV0gKyBpbkltZ1tib3R0b21Sb3dJZHhdICsgaW5JbWdbYm90dG9tUm93SWR4ICsgMV0pIC8gNCxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBvdXRJbWdJZHgrKztcbiAgICAgICAgICAgIHRvcFJvd0lkeCArPSAyO1xuICAgICAgICAgICAgYm90dG9tUm93SWR4ICs9IDI7XG4gICAgICAgIH1cbiAgICAgICAgdG9wUm93SWR4ICs9IGluV2lkdGg7XG4gICAgICAgIGJvdHRvbVJvd0lkeCArPSBpbldpZHRoO1xuICAgIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGhzdjJyZ2IoaHN2LCByZ2IgPSBbMCwgMCwgMF0pIHtcbiAgICBjb25zdCBoID0gaHN2WzBdO1xuICAgIGNvbnN0IHMgPSBoc3ZbMV07XG4gICAgY29uc3QgdiA9IGhzdlsyXTtcbiAgICBjb25zdCBjID0gdiAqIHM7XG4gICAgY29uc3QgeCA9IGMgKiAoMSAtIE1hdGguYWJzKChoIC8gNjApICUgMiAtIDEpKTtcbiAgICBjb25zdCBtID0gdiAtIGM7XG4gICAgbGV0IHIgPSAwO1xuICAgIGxldCBnID0gMDtcbiAgICBsZXQgYiA9IDA7XG5cbiAgICBpZiAoaCA8IDYwKSB7XG4gICAgICAgIHIgPSBjO1xuICAgICAgICBnID0geDtcbiAgICB9IGVsc2UgaWYgKGggPCAxMjApIHtcbiAgICAgICAgciA9IHg7XG4gICAgICAgIGcgPSBjO1xuICAgIH0gZWxzZSBpZiAoaCA8IDE4MCkge1xuICAgICAgICBnID0gYztcbiAgICAgICAgYiA9IHg7XG4gICAgfSBlbHNlIGlmIChoIDwgMjQwKSB7XG4gICAgICAgIGcgPSB4O1xuICAgICAgICBiID0gYztcbiAgICB9IGVsc2UgaWYgKGggPCAzMDApIHtcbiAgICAgICAgciA9IHg7XG4gICAgICAgIGIgPSBjO1xuICAgIH0gZWxzZSBpZiAoaCA8IDM2MCkge1xuICAgICAgICByID0gYztcbiAgICAgICAgYiA9IHg7XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgIHJnYlswXSA9ICgociArIG0pICogMjU1KSB8IDA7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgcmdiWzFdID0gKChnICsgbSkgKiAyNTUpIHwgMDtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICByZ2JbMl0gPSAoKGIgKyBtKSAqIDI1NSkgfCAwO1xuICAgIHJldHVybiByZ2I7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfY29tcHV0ZURpdmlzb3JzKG4pIHtcbiAgICBjb25zdCBsYXJnZURpdmlzb3JzID0gW107XG4gICAgY29uc3QgZGl2aXNvcnMgPSBbXTtcblxuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgTWF0aC5zcXJ0KG4pICsgMTsgaSsrKSB7XG4gICAgICAgIGlmIChuICUgaSA9PT0gMCkge1xuICAgICAgICAgICAgZGl2aXNvcnMucHVzaChpKTtcbiAgICAgICAgICAgIGlmIChpICE9PSBuIC8gaSkge1xuICAgICAgICAgICAgICAgIGxhcmdlRGl2aXNvcnMudW5zaGlmdChNYXRoLmZsb29yKG4gLyBpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGRpdmlzb3JzLmNvbmNhdChsYXJnZURpdmlzb3JzKTtcbn1cblxuZnVuY3Rpb24gX2NvbXB1dGVJbnRlcnNlY3Rpb24oYXJyMSwgYXJyMikge1xuICAgIGxldCBpID0gMDtcbiAgICBsZXQgaiA9IDA7XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG5cbiAgICB3aGlsZSAoaSA8IGFycjEubGVuZ3RoICYmIGogPCBhcnIyLmxlbmd0aCkge1xuICAgICAgICBpZiAoYXJyMVtpXSA9PT0gYXJyMltqXSkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goYXJyMVtpXSk7XG4gICAgICAgICAgICBpKys7XG4gICAgICAgICAgICBqKys7XG4gICAgICAgIH0gZWxzZSBpZiAoYXJyMVtpXSA+IGFycjJbal0pIHtcbiAgICAgICAgICAgIGorKztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY2FsY3VsYXRlUGF0Y2hTaXplKHBhdGNoU2l6ZSwgaW1nU2l6ZSkge1xuICAgIGNvbnN0IGRpdmlzb3JzWCA9IF9jb21wdXRlRGl2aXNvcnMoaW1nU2l6ZS54KTtcbiAgICBjb25zdCBkaXZpc29yc1kgPSBfY29tcHV0ZURpdmlzb3JzKGltZ1NpemUueSk7XG4gICAgY29uc3Qgd2lkZVNpZGUgPSBNYXRoLm1heChpbWdTaXplLngsIGltZ1NpemUueSk7XG4gICAgY29uc3QgY29tbW9uID0gX2NvbXB1dGVJbnRlcnNlY3Rpb24oZGl2aXNvcnNYLCBkaXZpc29yc1kpO1xuICAgIGNvbnN0IG5yT2ZQYXRjaGVzTGlzdCA9IFs4LCAxMCwgMTUsIDIwLCAzMiwgNjAsIDgwXTtcbiAgICBjb25zdCBuck9mUGF0Y2hlc01hcCA9IHtcbiAgICAgICAgJ3gtc21hbGwnOiA1LFxuICAgICAgICBzbWFsbDogNCxcbiAgICAgICAgbWVkaXVtOiAzLFxuICAgICAgICBsYXJnZTogMixcbiAgICAgICAgJ3gtbGFyZ2UnOiAxLFxuICAgIH07XG4gICAgY29uc3QgbnJPZlBhdGNoZXNJZHggPSBuck9mUGF0Y2hlc01hcFtwYXRjaFNpemVdIHx8IG5yT2ZQYXRjaGVzTWFwLm1lZGl1bTtcbiAgICBjb25zdCBuck9mUGF0Y2hlcyA9IG5yT2ZQYXRjaGVzTGlzdFtuck9mUGF0Y2hlc0lkeF07XG4gICAgY29uc3QgZGVzaXJlZFBhdGNoU2l6ZSA9IE1hdGguZmxvb3Iod2lkZVNpZGUgLyBuck9mUGF0Y2hlcyk7XG4gICAgbGV0IG9wdGltYWxQYXRjaFNpemU7XG5cbiAgICBmdW5jdGlvbiBmaW5kUGF0Y2hTaXplRm9yRGl2aXNvcnMoZGl2aXNvcnMpIHtcbiAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICBsZXQgZm91bmQgPSBkaXZpc29yc1tNYXRoLmZsb29yKGRpdmlzb3JzLmxlbmd0aCAvIDIpXTtcblxuICAgICAgICB3aGlsZSAoaSA8IChkaXZpc29ycy5sZW5ndGggLSAxKSAmJiBkaXZpc29yc1tpXSA8IGRlc2lyZWRQYXRjaFNpemUpIHtcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuICAgICAgICBpZiAoaSA+IDApIHtcbiAgICAgICAgICAgIGlmIChNYXRoLmFicyhkaXZpc29yc1tpXSAtIGRlc2lyZWRQYXRjaFNpemUpID4gTWF0aC5hYnMoZGl2aXNvcnNbaSAtIDFdIC0gZGVzaXJlZFBhdGNoU2l6ZSkpIHtcbiAgICAgICAgICAgICAgICBmb3VuZCA9IGRpdmlzb3JzW2kgLSAxXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZm91bmQgPSBkaXZpc29yc1tpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZGVzaXJlZFBhdGNoU2l6ZSAvIGZvdW5kIDwgbnJPZlBhdGNoZXNMaXN0W25yT2ZQYXRjaGVzSWR4ICsgMV0gLyBuck9mUGF0Y2hlc0xpc3RbbnJPZlBhdGNoZXNJZHhdXG4gICAgICAgICAgICAmJiBkZXNpcmVkUGF0Y2hTaXplIC8gZm91bmQgPiBuck9mUGF0Y2hlc0xpc3RbbnJPZlBhdGNoZXNJZHggLSAxXSAvIG5yT2ZQYXRjaGVzTGlzdFtuck9mUGF0Y2hlc0lkeF0pIHtcbiAgICAgICAgICAgIHJldHVybiB7IHg6IGZvdW5kLCB5OiBmb3VuZCB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIG9wdGltYWxQYXRjaFNpemUgPSBmaW5kUGF0Y2hTaXplRm9yRGl2aXNvcnMoY29tbW9uKTtcbiAgICBpZiAoIW9wdGltYWxQYXRjaFNpemUpIHtcbiAgICAgICAgb3B0aW1hbFBhdGNoU2l6ZSA9IGZpbmRQYXRjaFNpemVGb3JEaXZpc29ycyhfY29tcHV0ZURpdmlzb3JzKHdpZGVTaWRlKSk7XG4gICAgICAgIGlmICghb3B0aW1hbFBhdGNoU2l6ZSkge1xuICAgICAgICAgICAgb3B0aW1hbFBhdGNoU2l6ZSA9IGZpbmRQYXRjaFNpemVGb3JEaXZpc29ycygoX2NvbXB1dGVEaXZpc29ycyhkZXNpcmVkUGF0Y2hTaXplICogbnJPZlBhdGNoZXMpKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG9wdGltYWxQYXRjaFNpemU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfcGFyc2VDU1NEaW1lbnNpb25WYWx1ZXModmFsdWUpIHtcbiAgICBjb25zdCBkaW1lbnNpb24gPSB7XG4gICAgICAgIHZhbHVlOiBwYXJzZUZsb2F0KHZhbHVlKSxcbiAgICAgICAgdW5pdDogdmFsdWUuaW5kZXhPZignJScpID09PSB2YWx1ZS5sZW5ndGggLSAxID8gJyUnIDogJyUnLFxuICAgIH07XG5cbiAgICByZXR1cm4gZGltZW5zaW9uO1xufVxuXG5leHBvcnQgY29uc3QgX2RpbWVuc2lvbnNDb252ZXJ0ZXJzID0ge1xuICAgIHRvcChkaW1lbnNpb24sIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIGRpbWVuc2lvbi51bml0ID09PSAnJScgPyBNYXRoLmZsb29yKGNvbnRleHQuaGVpZ2h0ICogKGRpbWVuc2lvbi52YWx1ZSAvIDEwMCkpIDogbnVsbDtcbiAgICB9LFxuICAgIHJpZ2h0KGRpbWVuc2lvbiwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gZGltZW5zaW9uLnVuaXQgPT09ICclJyA/IE1hdGguZmxvb3IoY29udGV4dC53aWR0aCAtIChjb250ZXh0LndpZHRoICogKGRpbWVuc2lvbi52YWx1ZSAvIDEwMCkpKSA6IG51bGw7XG4gICAgfSxcbiAgICBib3R0b20oZGltZW5zaW9uLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiBkaW1lbnNpb24udW5pdCA9PT0gJyUnID8gTWF0aC5mbG9vcihjb250ZXh0LmhlaWdodCAtIChjb250ZXh0LmhlaWdodCAqIChkaW1lbnNpb24udmFsdWUgLyAxMDApKSkgOiBudWxsO1xuICAgIH0sXG4gICAgbGVmdChkaW1lbnNpb24sIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIGRpbWVuc2lvbi51bml0ID09PSAnJScgPyBNYXRoLmZsb29yKGNvbnRleHQud2lkdGggKiAoZGltZW5zaW9uLnZhbHVlIC8gMTAwKSkgOiBudWxsO1xuICAgIH0sXG59O1xuXG5leHBvcnQgZnVuY3Rpb24gY29tcHV0ZUltYWdlQXJlYShpbnB1dFdpZHRoLCBpbnB1dEhlaWdodCwgYXJlYSkge1xuICAgIGNvbnN0IGNvbnRleHQgPSB7IHdpZHRoOiBpbnB1dFdpZHRoLCBoZWlnaHQ6IGlucHV0SGVpZ2h0IH07XG5cbiAgICBjb25zdCBwYXJzZWRBcmVhID0gT2JqZWN0LmtleXMoYXJlYSkucmVkdWNlKChyZXN1bHQsIGtleSkgPT4ge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IGFyZWFba2V5XTtcbiAgICAgICAgY29uc3QgcGFyc2VkID0gX3BhcnNlQ1NTRGltZW5zaW9uVmFsdWVzKHZhbHVlKTtcbiAgICAgICAgY29uc3QgY2FsY3VsYXRlZCA9IF9kaW1lbnNpb25zQ29udmVydGVyc1trZXldKHBhcnNlZCwgY29udGV4dCk7XG5cbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICAgIHJlc3VsdFtrZXldID0gY2FsY3VsYXRlZDtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LCB7fSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBzeDogcGFyc2VkQXJlYS5sZWZ0LFxuICAgICAgICBzeTogcGFyc2VkQXJlYS50b3AsXG4gICAgICAgIHN3OiBwYXJzZWRBcmVhLnJpZ2h0IC0gcGFyc2VkQXJlYS5sZWZ0LFxuICAgICAgICBzaDogcGFyc2VkQXJlYS5ib3R0b20gLSBwYXJzZWRBcmVhLnRvcCxcbiAgICB9O1xufVxuIiwiaW1wb3J0IHsgWFlTaXplIH0gZnJvbSAnLi4vLi4vdHlwZS1kZWZpbml0aW9ucy9xdWFnZ2EuZCc7XG5cbi8vIFRPRE86IFhZUG9zaXRpb24gc2hvdWxkIGJlIGFuIFhZT2JqZWN0LCBidXQgdGhhdCBicmVha3MgWFlEZWZpbml0aW9uLCB3aGljaCBicmVha3MgZHJhd1BhdGgoKSBiZWxvdy5cbmRlY2xhcmUgaW50ZXJmYWNlIFhZUG9zaXRpb24ge1xuICAgIHg6IG51bWJlcjtcbiAgICB5OiBudW1iZXI7XG59XG5cbmRlY2xhcmUgaW50ZXJmYWNlIENhbnZhc1N0eWxlIHtcbiAgICBjb2xvcjogc3RyaW5nO1xuICAgIGxpbmVXaWR0aDogbnVtYmVyO1xufVxuXG4vLyBYWURlZmluaXRpb24gdGVsbHMgdXMgd2hpY2ggY29tcG9uZW50IG9mIGEgZ2l2ZW4gYXJyYXkgb3Igb2JqZWN0IGlzIHRoZSBcIlhcIiBhbmQgd2hpY2ggaXMgdGhlIFwiWVwiLlxuLy8gVXN1YWxseSB0aGlzIGlzIDAgZm9yIFggYW5kIDEgZm9yIFksIGJ1dCBtaWdodCBiZSB1c2VkIGFzICd4JyBmb3IgeCBhbmQgJ3knIGZvciBZLlxuZGVjbGFyZSBpbnRlcmZhY2UgWFlEZWZpbml0aW9uIHtcbiAgICB4OiBrZXlvZiBYWVBvc2l0aW9uO1xuICAgIHk6IGtleW9mIFhZUG9zaXRpb247XG59XG5cbmRlY2xhcmUgdHlwZSBQYXRoID0gQXJyYXk8WFlQb3NpdGlvbj47XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgICBkcmF3UmVjdChwb3M6IFhZUG9zaXRpb24sIHNpemU6IFhZU2l6ZSwgY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQsIHN0eWxlOiBDYW52YXNTdHlsZSk6IHZvaWQge1xuICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBzdHlsZS5jb2xvcjtcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IHN0eWxlLmNvbG9yO1xuICAgICAgICBjdHgubGluZVdpZHRoID0gc3R5bGUubGluZVdpZHRoIHx8IDE7XG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgY3R4LnN0cm9rZVJlY3QocG9zLngsIHBvcy55LCBzaXplLngsIHNpemUueSk7XG4gICAgfSxcbiAgICBkcmF3UGF0aChwYXRoOiBQYXRoLCBkZWY6IFhZRGVmaW5pdGlvbiwgY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQsIHN0eWxlOiBDYW52YXNTdHlsZSk6IHZvaWQge1xuICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBzdHlsZS5jb2xvcjtcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IHN0eWxlLmNvbG9yO1xuICAgICAgICBjdHgubGluZVdpZHRoID0gc3R5bGUubGluZVdpZHRoO1xuICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIGN0eC5tb3ZlVG8ocGF0aFswXVtkZWYueF0sIHBhdGhbMF1bZGVmLnldKTtcbiAgICAgICAgZm9yIChsZXQgaiA9IDE7IGogPCBwYXRoLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICBjdHgubGluZVRvKHBhdGhbal1bZGVmLnhdLCBwYXRoW2pdW2RlZi55XSk7XG4gICAgICAgIH1cbiAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgfSxcbiAgICBkcmF3SW1hZ2UoaW1hZ2VEYXRhOiBBcnJheTxudW1iZXI+LCBzaXplOiBYWVNpemUsIGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEKTogYm9vbGVhbiB7XG4gICAgICAgIGNvbnN0IGNhbnZhc0RhdGEgPSBjdHguZ2V0SW1hZ2VEYXRhKDAsIDAsIHNpemUueCwgc2l6ZS55KTtcbiAgICAgICAgY29uc3QgeyBkYXRhIH0gPSBjYW52YXNEYXRhO1xuICAgICAgICBsZXQgY2FudmFzRGF0YVBvcyA9IGRhdGEubGVuZ3RoO1xuICAgICAgICBsZXQgaW1hZ2VEYXRhUG9zID0gaW1hZ2VEYXRhLmxlbmd0aDtcblxuICAgICAgICBpZiAoY2FudmFzRGF0YVBvcyAvIGltYWdlRGF0YVBvcyAhPT0gNCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlIChpbWFnZURhdGFQb3MtLSkge1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBpbWFnZURhdGFbaW1hZ2VEYXRhUG9zXTtcbiAgICAgICAgICAgIGRhdGFbLS1jYW52YXNEYXRhUG9zXSA9IDI1NTtcbiAgICAgICAgICAgIGRhdGFbLS1jYW52YXNEYXRhUG9zXSA9IHZhbHVlO1xuICAgICAgICAgICAgZGF0YVstLWNhbnZhc0RhdGFQb3NdID0gdmFsdWU7XG4gICAgICAgICAgICBkYXRhWy0tY2FudmFzRGF0YVBvc10gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBjdHgucHV0SW1hZ2VEYXRhKGNhbnZhc0RhdGEsIDAsIDApO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxufTtcbiIsIi8qIGVzbGludC1kaXNhYmxlIG5vLXBhcmFtLXJlYXNzaWduICovXG5pbXBvcnQgeyBUeXBlZEFycmF5IH0gZnJvbSAnLi4vLi4vdHlwZS1kZWZpbml0aW9ucy9xdWFnZ2EnO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gICAgaW5pdChhcnI6IFR5cGVkQXJyYXkgfCBBcnJheTxudW1iZXI+LCB2YWw6IG51bWJlcikge1xuICAgICAgICBhcnIuZmlsbCh2YWwpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBJTi1QTEFDRSBTaHVmZmxlcyB0aGUgY29udGVudCBvZiBhbiBhcnJheVxuICAgICAqL1xuICAgIHNodWZmbGUoYXJyOiBBcnJheTxudW1iZXI+KSB7XG4gICAgICAgIC8vIER1cnN0ZW5mZWxkIHNodWZmbGUgYWxnb3JpdGhtXG4gICAgICAgIC8vIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzI0NTA5NTQvaG93LXRvLXJhbmRvbWl6ZS1zaHVmZmxlLWEtamF2YXNjcmlwdC1hcnJheVxuICAgICAgICBmb3IgKGxldCBpID0gYXJyLmxlbmd0aCAtIDE7IGkgPiAwOyBpLS0pIHtcbiAgICAgICAgICAgIGNvbnN0IGogPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAoaSArIDEpKTtcbiAgICAgICAgICAgIFthcnJbaV0sIGFycltqXV0gPSBbYXJyW2pdLCBhcnJbaV1dO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhcnI7XG4gICAgfSxcblxuICAgIHRvUG9pbnRMaXN0KGFycjogQXJyYXk8QXJyYXk8bnVtYmVyPj4pIHtcbiAgICAgICAgY29uc3Qgcm93cyA9IGFyci5yZWR1Y2UoKHAsIG4pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHJvdyA9IGBbJHtuLmpvaW4oJywnKX1dYDtcbiAgICAgICAgICAgIHAucHVzaChyb3cpO1xuICAgICAgICAgICAgcmV0dXJuIHA7XG4gICAgICAgIH0sIFtdIGFzIEFycmF5PHN0cmluZz4pO1xuICAgICAgICByZXR1cm4gYFske3Jvd3Muam9pbignLFxcclxcbicpfV1gO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiByZXR1cm5zIHRoZSBlbGVtZW50cyB3aGljaCdzIHNjb3JlIGlzIGJpZ2dlciB0aGFuIHRoZSB0aHJlc2hvbGRcbiAgICAgKi9cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICB0aHJlc2hvbGQoYXJyOiBBcnJheTxudW1iZXI+LCB0aHJlc2hvbGQ6IG51bWJlciwgc2NvcmVGdW5jOiAoKHNjb3JlOiBudW1iZXIpID0+IG51bWJlcikpIHtcbiAgICAgICAgY29uc3QgcXVldWUgPSBhcnIucmVkdWNlKChwcmV2OiBBcnJheTxudW1iZXI+LCBuZXh0KSA9PiB7XG4gICAgICAgICAgICBpZiAoc2NvcmVGdW5jLmFwcGx5KGFyciwgW25leHRdKSA+PSB0aHJlc2hvbGQpIHtcbiAgICAgICAgICAgICAgICBwcmV2LnB1c2gobmV4dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcHJldjtcbiAgICAgICAgfSwgW10pO1xuICAgICAgICByZXR1cm4gcXVldWU7XG4gICAgfSxcblxuICAgIG1heEluZGV4KGFycjogQXJyYXk8bnVtYmVyPikge1xuICAgICAgICBsZXQgbWF4ID0gMDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChhcnJbaV0gPiBhcnJbbWF4XSkge1xuICAgICAgICAgICAgICAgIG1heCA9IGk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1heDtcbiAgICB9LFxuXG4gICAgbWF4KGFycjogQXJyYXk8bnVtYmVyPikge1xuICAgICAgICBsZXQgbWF4ID0gMDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChhcnJbaV0gPiBtYXgpIHtcbiAgICAgICAgICAgICAgICBtYXggPSBhcnJbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1heDtcbiAgICB9LFxuXG4gICAgc3VtKGFycjogQXJyYXk8bnVtYmVyPiB8IFR5cGVkQXJyYXkpOiBudW1iZXIge1xuICAgICAgICBsZXQgeyBsZW5ndGggfSA9IGFycjtcbiAgICAgICAgbGV0IHN1bSA9IDA7XG5cbiAgICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgICAgICBzdW0gKz0gYXJyW2xlbmd0aF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN1bTtcbiAgICB9LFxufTtcbiIsImltcG9ydCB7IGdsTWF0cml4LCB2ZWMyIH0gZnJvbSAnZ2wtbWF0cml4JztcbmltcG9ydCB7XG4gICAgWFlTaXplLFxuICAgIFR5cGVkQXJyYXlDb25zdHJ1Y3RvcixcbiAgICBUeXBlZEFycmF5LFxuICAgIFdyYXBwZXJJbmRleE1hcHBpbmcsXG4gICAgTW9tZW50LFxuICAgIFNwYXJzZUltYWdlV3JhcHBlcixcbn0gZnJvbSAnLi4vLi4vdHlwZS1kZWZpbml0aW9ucy9xdWFnZ2EuZCc7XG5pbXBvcnQgQXJyYXlIZWxwZXIgZnJvbSAnLi9hcnJheV9oZWxwZXInO1xuaW1wb3J0IHsgaHN2MnJnYiB9IGZyb20gJy4vY3ZfdXRpbHMnO1xuXG5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoQXJyYXkpO1xuXG50eXBlIFBvc2l0aXZlTnVtYmVyID0gbnVtYmVyO1xuZnVuY3Rpb24gYXNzZXJ0TnVtYmVyUG9zaXRpdmUodmFsOiBudW1iZXIpOiBhc3NlcnRzIHZhbCBpcyBQb3NpdGl2ZU51bWJlciB7XG4gICAgaWYgKHZhbCA8IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBleHBlY3RlZCBwb3NpdGl2ZSBudW1iZXIsIHJlY2VpdmVkICR7dmFsfWApO1xuICAgIH1cbn1cblxuY2xhc3MgSW1hZ2VXcmFwcGVyIGltcGxlbWVudHMgU3BhcnNlSW1hZ2VXcmFwcGVyIHtcbiAgICBkYXRhOiBUeXBlZEFycmF5IHwgQXJyYXk8bnVtYmVyPjtcblxuICAgIHNpemU6IFhZU2l6ZTtcblxuICAgIGluZGV4TWFwcGluZz86IFdyYXBwZXJJbmRleE1hcHBpbmc7XG5cbiAgICAvLyBSZXByZXNlbnRzIGEgYmFzaWMgaW1hZ2UgY29tYmluaW5nIHRoZSBkYXRhIGFuZCBzaXplLiBJbiBhZGRpdGlvbiwgc29tZSBtZXRob2RzIGZvclxuICAgIC8vIG1hbmlwdWxhdGlvbiBhcmUgY29udGFpbmVkIHdpdGhpbi5cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAgICAgc2l6ZTogWFlTaXplLFxuICAgICAgICBkYXRhPzogVHlwZWRBcnJheSB8IEFycmF5PG51bWJlcj4sXG4gICAgICAgIEFycmF5VHlwZTogVHlwZWRBcnJheUNvbnN0cnVjdG9yIHwgQXJyYXlDb25zdHJ1Y3RvciA9IFVpbnQ4QXJyYXksXG4gICAgICAgIGluaXRpYWxpemU/OiBib29sZWFuLFxuICAgICkge1xuICAgICAgICBpZiAoIWRhdGEpIHtcbiAgICAgICAgICAgIHRoaXMuZGF0YSA9IG5ldyAoQXJyYXlUeXBlKShzaXplLnggKiBzaXplLnkpO1xuICAgICAgICAgICAgaWYgKGluaXRpYWxpemUpIHtcbiAgICAgICAgICAgICAgICBBcnJheUhlbHBlci5pbml0KHRoaXMuZGF0YSwgMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2l6ZSA9IHNpemU7XG4gICAgfVxuXG4gICAgLy8gdGVzdHMgaWYgYSBwb3NpdGlvbiBpcyB3aXRoaW4gdGhlIGltYWdlLCBleHRlbmRlZCBvdXQgYnkgYSBib3JkZXIgb24gZWFjaCBzaWRlXG4gICAgaW5JbWFnZVdpdGhCb3JkZXIoaW1nUmVmOiBYWVNpemUsIGJvcmRlcjogUG9zaXRpdmVOdW1iZXIgPSAwKTogYm9vbGVhbiB7XG4gICAgICAgIGFzc2VydE51bWJlclBvc2l0aXZlKGJvcmRlcik7XG4gICAgICAgIHJldHVybiAoaW1nUmVmLnggPj0gMClcbiAgICAgICAgICAgICYmIChpbWdSZWYueSA+PSAwKVxuICAgICAgICAgICAgJiYgKGltZ1JlZi54IDwgKHRoaXMuc2l6ZS54ICsgKGJvcmRlciAqIDIpKSlcbiAgICAgICAgICAgICYmIChpbWdSZWYueSA8ICh0aGlzLnNpemUueSArIChib3JkZXIgKiAyKSkpO1xuICAgIH1cblxuICAgIC8vIENvcHkgZnJvbSBUSElTIEltYWdlV3JhcHBlciB0byB0aGUgbmV3IGltYWdlV3JhcHBlciBwYXJhbWV0ZXIsIHN0YXJ0aW5nIGF0IGZyb20sIHN0b3BwaW5nIGF0XG4gICAgLy8gZW5kIG9mIG5ldyBpbWFnZVdyYXBwZXIgc2l6ZS5cbiAgICBzdWJJbWFnZUFzQ29weShpbWFnZVdyYXBwZXI6IEltYWdlV3JhcHBlciwgZnJvbTogWFlTaXplKTogSW1hZ2VXcmFwcGVyIHtcbiAgICAgICAgYXNzZXJ0TnVtYmVyUG9zaXRpdmUoZnJvbS54KTtcbiAgICAgICAgYXNzZXJ0TnVtYmVyUG9zaXRpdmUoZnJvbS55KTtcbiAgICAgICAgY29uc3QgeyB4OiBzaXplWCwgeTogc2l6ZVkgfSA9IGltYWdlV3JhcHBlci5zaXplO1xuICAgICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IHNpemVYOyB4KyspIHtcbiAgICAgICAgICAgIGZvciAobGV0IHkgPSAwOyB5IDwgc2l6ZVk7IHkrKykge1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgICAgICAgICAgIGltYWdlV3JhcHBlci5kYXRhW3kgKiBzaXplWCArIHhdID0gdGhpcy5kYXRhWyhmcm9tLnkgKyB5KSAqIHRoaXMuc2l6ZS54ICsgZnJvbS54ICsgeF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGltYWdlV3JhcHBlcjtcbiAgICAgICAgLy8gVE9ETzogdGhpcyBmdW5jdGlvbiByZWFsbHkgcHJvYmFibHkgc2hvdWxkIGNhbGwgaW50byBJbWFnZVdyYXBwZXIgc29tZXdoZXJlIHRvIG1ha2VcbiAgICAgICAgLy8gc3VyZSB0aGF0IGFsbCBvZiBpdCdzIHBhcmFtZXRlcnMgYXJlIHNldCBwcm9wZXJseSwgc29tZXRoaW5nIGxpa2VcbiAgICAgICAgLy8gSW1hZ2VXcmFwcGVyLlVwZGF0ZUZyb20oKVxuICAgICAgICAvLyB0aGF0IG1pZ2h0IHRha2UgYSBwcm92aWRlZCBkYXRhIGFuZCBzaXplLCBhbmQgbWFrZSBzdXJlIHRoZXJlJ3Mgbm8gaW52YWxpZCBpbmRleE1hcHBpbmdcbiAgICAgICAgLy8gaGFuZ2luZyBhcm91bmQsIGFuZCBzdWNoLlxuICAgIH1cblxuICAgIC8vIFJldHJpZXZlIGEgZ3JheXNjYWxlIHZhbHVlIGF0IHRoZSBnaXZlbiBwaXhlbCBwb3NpdGlvbiBvZiB0aGUgaW1hZ2VcbiAgICBnZXQoeDogbnVtYmVyLCB5OiBudW1iZXIpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhW3kgKiB0aGlzLnNpemUueCArIHhdO1xuICAgIH1cblxuICAgIC8vIFJldHJpZXZlIGEgZ3JheXNjYWxlIHZhbHVlIGF0IHRoZSBnaXZlbiBwaXhlbCBwb3NpdGlvbiBvZiB0aGUgaW1hZ2UgKHNhZmUsIHdoYXRldmVyIHRoYXRcbiAgICAvLyBtZWFucylcbiAgICBnZXRTYWZlKHg6IG51bWJlciwgeTogbnVtYmVyKTogbnVtYmVyIHtcbiAgICAgICAgLy8gY2FjaGUgaW5kZXhNYXBwaW5nIGJlY2F1c2UgaWYgd2UncmUgdXNpbmcgaXQgb25jZSwgd2UnbGwgcHJvYmFibHkgbmVlZCBpdCBhIGJ1bmNoIG1vcmVcbiAgICAgICAgLy8gdG9vXG4gICAgICAgIGlmICghdGhpcy5pbmRleE1hcHBpbmcpIHtcbiAgICAgICAgICAgIHRoaXMuaW5kZXhNYXBwaW5nID0ge1xuICAgICAgICAgICAgICAgIHg6IFtdLFxuICAgICAgICAgICAgICAgIHk6IFtdLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5zaXplLng7IGkrKykge1xuICAgICAgICAgICAgICAgIHRoaXMuaW5kZXhNYXBwaW5nLnhbaV0gPSBpO1xuICAgICAgICAgICAgICAgIHRoaXMuaW5kZXhNYXBwaW5nLnhbaSArIHRoaXMuc2l6ZS54XSA9IGk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuc2l6ZS55OyBpKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLmluZGV4TWFwcGluZy55W2ldID0gaTtcbiAgICAgICAgICAgICAgICB0aGlzLmluZGV4TWFwcGluZy55W2kgKyB0aGlzLnNpemUueV0gPSBpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGFbKHRoaXMuaW5kZXhNYXBwaW5nLnlbeSArIHRoaXMuc2l6ZS55XSkgKiB0aGlzLnNpemUueCArIHRoaXMuaW5kZXhNYXBwaW5nLnhbeCArIHRoaXMuc2l6ZS54XV07XG4gICAgfVxuXG4gICAgLy8gU2V0cyBhIGdpdmVuIHBpeGVsIHBvc2l0aW9uIGluIHRoZSBpbWFnZSB0byB0aGUgZ2l2ZW4gZ3JheXNjYWxlIHZhbHVlXG4gICAgc2V0KHg6IG51bWJlciwgeTogbnVtYmVyLCB2YWx1ZTogbnVtYmVyKTogSW1hZ2VXcmFwcGVyIHtcbiAgICAgICAgdGhpcy5kYXRhW3kgKiB0aGlzLnNpemUueCArIHhdID0gdmFsdWU7XG4gICAgICAgIGRlbGV0ZSB0aGlzLmluZGV4TWFwcGluZztcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8gU2V0cyB0aGUgYm9yZGVyIG9mIHRoZSBpbWFnZSAoMSBwaXhlbCkgdG8gemVyb1xuICAgIHplcm9Cb3JkZXIoKTogSW1hZ2VXcmFwcGVyIHtcbiAgICAgICAgY29uc3QgeyB4OiB3aWR0aCwgeTogaGVpZ2h0IH0gPSB0aGlzLnNpemU7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgd2lkdGg7IGkrKykge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLW11bHRpLWFzc2lnblxuICAgICAgICAgICAgdGhpcy5kYXRhW2ldID0gdGhpcy5kYXRhWyhoZWlnaHQgLSAxKSAqIHdpZHRoICsgaV0gPSAwO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgaGVpZ2h0IC0gMTsgaSsrKSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbXVsdGktYXNzaWduXG4gICAgICAgICAgICB0aGlzLmRhdGFbaSAqIHdpZHRoXSA9IHRoaXMuZGF0YVtpICogd2lkdGggKyAod2lkdGggLSAxKV0gPSAwO1xuICAgICAgICB9XG4gICAgICAgIGRlbGV0ZSB0aGlzLmluZGV4TWFwcGluZztcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8gVE9ETzogdGhpcyBmdW5jdGlvbiBpcyBlbnRpcmVseSB0b28gbGFyZ2UgZm9yIG1lIHRvIHJlYXNvbiBvdXQgcmlnaHQgYXQgdGhpcyBtb21lbnQgdGhhdCBpJ20gaGFuZGxpbmdcbiAgICAvLyBhbGwgdGhlIHJlc3Qgb2YgaXQsIHNvIHRoaXMgaXMgYSB2ZXJiYXRpbSBjb3B5IG9mIHRoZSBqYXZhc2NyaXB0IHNvdXJjZSwgd2l0aCBvbmx5IHR3ZWFrc1xuICAgIC8vIG5lY2Vzc2FyeSB0byBnZXQgaXQgdG8gcnVuLCBubyB0aG91Z2h0IHB1dCBpbnRvIGl0IHlldC5cbiAgICBtb21lbnRzKGxhYmVsQ291bnQ6IG51bWJlcik6IEFycmF5PE1vbWVudD4ge1xuICAgICAgICBjb25zdCB7IGRhdGEgfSA9IHRoaXM7XG4gICAgICAgIGxldCB4O1xuICAgICAgICBsZXQgeTtcbiAgICAgICAgY29uc3QgaGVpZ2h0ID0gdGhpcy5zaXplLnk7XG4gICAgICAgIGNvbnN0IHdpZHRoID0gdGhpcy5zaXplLng7XG4gICAgICAgIGxldCB2YWw7XG4gICAgICAgIGxldCB5c3E7XG4gICAgICAgIGNvbnN0IGxhYmVsU3VtOiBBcnJheTxNb21lbnQ+ID0gW107XG4gICAgICAgIGxldCBpO1xuICAgICAgICBsZXQgbGFiZWw7XG4gICAgICAgIGxldCBtdTExO1xuICAgICAgICBsZXQgbXUwMjtcbiAgICAgICAgbGV0IG11MjA7XG4gICAgICAgIGxldCB4XztcbiAgICAgICAgbGV0IHlfO1xuICAgICAgICBsZXQgdG1wO1xuICAgICAgICBjb25zdCByZXN1bHQ6IEFycmF5PE1vbWVudD4gPSBbXTtcbiAgICAgICAgY29uc3QgeyBQSSB9ID0gTWF0aDtcbiAgICAgICAgY29uc3QgUElfNCA9IFBJIC8gNDtcblxuICAgICAgICBpZiAobGFiZWxDb3VudCA8PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxhYmVsQ291bnQ7IGkrKykge1xuICAgICAgICAgICAgbGFiZWxTdW1baV0gPSB7XG4gICAgICAgICAgICAgICAgbTAwOiAwLFxuICAgICAgICAgICAgICAgIG0wMTogMCxcbiAgICAgICAgICAgICAgICBtMTA6IDAsXG4gICAgICAgICAgICAgICAgbTExOiAwLFxuICAgICAgICAgICAgICAgIG0wMjogMCxcbiAgICAgICAgICAgICAgICBtMjA6IDAsXG4gICAgICAgICAgICAgICAgdGhldGE6IDAsXG4gICAgICAgICAgICAgICAgcmFkOiAwLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoeSA9IDA7IHkgPCBoZWlnaHQ7IHkrKykge1xuICAgICAgICAgICAgeXNxID0geSAqIHk7XG4gICAgICAgICAgICBmb3IgKHggPSAwOyB4IDwgd2lkdGg7IHgrKykge1xuICAgICAgICAgICAgICAgIHZhbCA9IGRhdGFbeSAqIHdpZHRoICsgeF07XG4gICAgICAgICAgICAgICAgaWYgKHZhbCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgbGFiZWwgPSBsYWJlbFN1bVt2YWwgLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgbGFiZWwubTAwICs9IDE7XG4gICAgICAgICAgICAgICAgICAgIGxhYmVsLm0wMSArPSB5O1xuICAgICAgICAgICAgICAgICAgICBsYWJlbC5tMTAgKz0geDtcbiAgICAgICAgICAgICAgICAgICAgbGFiZWwubTExICs9IHggKiB5O1xuICAgICAgICAgICAgICAgICAgICBsYWJlbC5tMDIgKz0geXNxO1xuICAgICAgICAgICAgICAgICAgICBsYWJlbC5tMjAgKz0geCAqIHg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxhYmVsQ291bnQ7IGkrKykge1xuICAgICAgICAgICAgbGFiZWwgPSBsYWJlbFN1bVtpXTtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZXN0cmljdGVkLWdsb2JhbHNcbiAgICAgICAgICAgIGlmICghaXNOYU4obGFiZWwubTAwKSAmJiBsYWJlbC5tMDAgIT09IDApIHtcbiAgICAgICAgICAgICAgICB4XyA9IGxhYmVsLm0xMCAvIGxhYmVsLm0wMDtcbiAgICAgICAgICAgICAgICB5XyA9IGxhYmVsLm0wMSAvIGxhYmVsLm0wMDtcbiAgICAgICAgICAgICAgICBtdTExID0gbGFiZWwubTExIC8gbGFiZWwubTAwIC0geF8gKiB5XztcbiAgICAgICAgICAgICAgICBtdTAyID0gbGFiZWwubTAyIC8gbGFiZWwubTAwIC0geV8gKiB5XztcbiAgICAgICAgICAgICAgICBtdTIwID0gbGFiZWwubTIwIC8gbGFiZWwubTAwIC0geF8gKiB4XztcbiAgICAgICAgICAgICAgICB0bXAgPSAobXUwMiAtIG11MjApIC8gKDIgKiBtdTExKTtcbiAgICAgICAgICAgICAgICB0bXAgPSAwLjUgKiBNYXRoLmF0YW4odG1wKSArIChtdTExID49IDAgPyBQSV80IDogLVBJXzQpICsgUEk7XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLW1peGVkLW9wZXJhdG9yc1xuICAgICAgICAgICAgICAgIGxhYmVsLnRoZXRhID0gKHRtcCAqIDE4MCAvIFBJICsgOTApICUgMTgwIC0gOTA7XG4gICAgICAgICAgICAgICAgaWYgKGxhYmVsLnRoZXRhIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICBsYWJlbC50aGV0YSArPSAxODA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxhYmVsLnJhZCA9IHRtcCA+IFBJID8gdG1wIC0gUEkgOiB0bXA7XG4gICAgICAgICAgICAgICAgbGFiZWwudmVjID0gdmVjMi5jbG9uZShbTWF0aC5jb3ModG1wKSwgTWF0aC5zaW4odG1wKV0pO1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGxhYmVsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8vIHJldHVybiBhIFVpbnQ4Q2xhbXBlZEFycmF5IGNvbnRhaW5pbmcgdGhpcyBncmF5c2NhbGUgaW1hZ2UgY29udmVydGVkIHRvIFJHQkEgZm9ybVxuICAgIGdldEFzUkdCQShzY2FsZSA9IDEuMCk6IFVpbnQ4Q2xhbXBlZEFycmF5IHtcbiAgICAgICAgY29uc3QgcmV0ID0gbmV3IFVpbnQ4Q2xhbXBlZEFycmF5KDQgKiB0aGlzLnNpemUueCAqIHRoaXMuc2l6ZS55KTtcbiAgICAgICAgZm9yIChsZXQgeSA9IDA7IHkgPCB0aGlzLnNpemUueTsgeSsrKSB7XG4gICAgICAgICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IHRoaXMuc2l6ZS54OyB4KyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwaXhlbCA9IHkgKiB0aGlzLnNpemUueCArIHg7XG4gICAgICAgICAgICAgICAgY29uc3QgY3VycmVudCA9IHRoaXMuZ2V0KHgsIHkpICogc2NhbGU7XG4gICAgICAgICAgICAgICAgcmV0W3BpeGVsICogNCArIDBdID0gY3VycmVudDtcbiAgICAgICAgICAgICAgICByZXRbcGl4ZWwgKiA0ICsgMV0gPSBjdXJyZW50O1xuICAgICAgICAgICAgICAgIHJldFtwaXhlbCAqIDQgKyAyXSA9IGN1cnJlbnQ7XG4gICAgICAgICAgICAgICAgcmV0W3BpeGVsICogNCArIDNdID0gMjU1O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuXG4gICAgLy8gRGlzcGxheSB0aGlzIEltYWdlV3JhcHBlciBpbiBhIGdpdmVuIENhbnZhcyBlbGVtZW50IGF0IHRoZSBzcGVjaWZpZWQgc2NhbGVcbiAgICBzaG93KGNhbnZhczogSFRNTENhbnZhc0VsZW1lbnQsIHNjYWxlID0gMS4wKTogdm9pZCB7XG4gICAgICAgIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgICBpZiAoIWN0eCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmFibGUgdG8gZ2V0IGNhbnZhcyBjb250ZXh0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZnJhbWUgPSBjdHguZ2V0SW1hZ2VEYXRhKDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG4gICAgICAgIGNvbnN0IGRhdGEgPSB0aGlzLmdldEFzUkdCQShzY2FsZSk7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgICBjYW52YXMud2lkdGggPSB0aGlzLnNpemUueDtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICAgIGNhbnZhcy5oZWlnaHQgPSB0aGlzLnNpemUueTtcbiAgICAgICAgY29uc3QgbmV3RnJhbWUgPSBuZXcgSW1hZ2VEYXRhKGRhdGEsIGZyYW1lLndpZHRoLCBmcmFtZS5oZWlnaHQpO1xuICAgICAgICBjdHgucHV0SW1hZ2VEYXRhKG5ld0ZyYW1lLCAwLCAwKTtcbiAgICB9XG5cbiAgICAvLyBEaXNwbGF5cyBhIHNwZWNpZmllZCBTdWJJbWFnZSBhcmVhIGluIGEgZ2l2ZW4gY2FudmFzLiBUaGlzIGRpZmZlcnMgZHJhc3RpY2FsbHkgZnJvbVxuICAgIC8vIGNyZWF0aW5nIGEgbmV3IFN1YkltYWdlIGFuZCB1c2luZyBpdCdzIHNob3coKSBtZXRob2QuIFdoeT8gSSBkb24ndCBoYXZlIHRoZSBhbnN3ZXIgdG8gdGhhdFxuICAgIC8vIHlldC4gIEkgc3VzcGVjdCB0aGUgSFNWL1JHQiBvcGVyYXRpb25zIGludm9sdmVkIGhlcmUgYXJlIG1ha2luZyBpdCBzaWduaWZpY2FudGx5IGRpZmZlcmVudCxcbiAgICAvLyBidXQgdW50aWwgSSBjYW4gdmlzdWFsaXplIHRoZXNlIGZ1bmN0aW9ucyBzaWRlIGJ5IHNpZGUsIEknbSBqdXN0IGdvaW5nIHRvIGNvcHkgdGhlIGV4aXN0aW5nXG4gICAgLy8gaW1wbGVtZW50YXRpb24uXG4gICAgb3ZlcmxheShjYW52YXM6IEhUTUxDYW52YXNFbGVtZW50LCBpblNjYWxlOiBudW1iZXIsIGZyb206IFhZU2l6ZSk6IHZvaWQge1xuICAgICAgICBjb25zdCBhZGp1c3RlZFNjYWxlID0gKGluU2NhbGUgPCAwIHx8IGluU2NhbGUgPiAzNjApID8gMzYwIDogaW5TY2FsZTtcbiAgICAgICAgY29uc3QgaHN2ID0gWzAsIDEsIDFdO1xuICAgICAgICBjb25zdCByZ2IgPSBbMCwgMCwgMF07XG4gICAgICAgIGNvbnN0IHdoaXRlUmdiID0gWzI1NSwgMjU1LCAyNTVdO1xuICAgICAgICBjb25zdCBibGFja1JnYiA9IFswLCAwLCAwXTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgICAgICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgICAgaWYgKCFjdHgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5hYmxlIHRvIGdldCBjYW52YXMgY29udGV4dCcpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZyYW1lID0gY3R4LmdldEltYWdlRGF0YShmcm9tLngsIGZyb20ueSwgdGhpcy5zaXplLngsIHRoaXMuc2l6ZS55KTtcbiAgICAgICAgY29uc3QgeyBkYXRhIH0gPSBmcmFtZTtcbiAgICAgICAgbGV0IHsgbGVuZ3RoIH0gPSB0aGlzLmRhdGE7XG4gICAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICAgICAgaHN2WzBdID0gdGhpcy5kYXRhW2xlbmd0aF0gKiBhZGp1c3RlZFNjYWxlO1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLW5lc3RlZC10ZXJuYXJ5XG4gICAgICAgICAgICByZXN1bHQgPSBoc3ZbMF0gPD0gMCA/IHdoaXRlUmdiIDogaHN2WzBdID49IDM2MCA/IGJsYWNrUmdiIDogaHN2MnJnYihoc3YsIHJnYik7XG4gICAgICAgICAgICBjb25zdCBwb3MgPSBsZW5ndGggKiA0O1xuICAgICAgICAgICAgW2RhdGFbcG9zXSwgZGF0YVtwb3MgKyAxXSwgZGF0YVtwb3MgKyAyXV0gPSByZXN1bHQ7XG4gICAgICAgICAgICBkYXRhW3BvcyArIDNdID0gMjU1O1xuICAgICAgICB9XG4gICAgICAgIGN0eC5wdXRJbWFnZURhdGEoZnJhbWUsIGZyb20ueCwgZnJvbS55KTtcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEltYWdlV3JhcHBlcjtcbiIsImZ1bmN0aW9uIGFzeW5jR2VuZXJhdG9yU3RlcChnZW4sIHJlc29sdmUsIHJlamVjdCwgX25leHQsIF90aHJvdywga2V5LCBhcmcpIHtcbiAgdHJ5IHtcbiAgICB2YXIgaW5mbyA9IGdlbltrZXldKGFyZyk7XG4gICAgdmFyIHZhbHVlID0gaW5mby52YWx1ZTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZWplY3QoZXJyb3IpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChpbmZvLmRvbmUpIHtcbiAgICByZXNvbHZlKHZhbHVlKTtcbiAgfSBlbHNlIHtcbiAgICBQcm9taXNlLnJlc29sdmUodmFsdWUpLnRoZW4oX25leHQsIF90aHJvdyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gX2FzeW5jVG9HZW5lcmF0b3IoZm4pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXMsXG4gICAgICAgIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHZhciBnZW4gPSBmbi5hcHBseShzZWxmLCBhcmdzKTtcblxuICAgICAgZnVuY3Rpb24gX25leHQodmFsdWUpIHtcbiAgICAgICAgYXN5bmNHZW5lcmF0b3JTdGVwKGdlbiwgcmVzb2x2ZSwgcmVqZWN0LCBfbmV4dCwgX3Rocm93LCBcIm5leHRcIiwgdmFsdWUpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBfdGhyb3coZXJyKSB7XG4gICAgICAgIGFzeW5jR2VuZXJhdG9yU3RlcChnZW4sIHJlc29sdmUsIHJlamVjdCwgX25leHQsIF90aHJvdywgXCJ0aHJvd1wiLCBlcnIpO1xuICAgICAgfVxuXG4gICAgICBfbmV4dCh1bmRlZmluZWQpO1xuICAgIH0pO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9hc3luY1RvR2VuZXJhdG9yLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZSwgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHM7IiwidmFyIHN1cGVyUHJvcEJhc2UgPSByZXF1aXJlKFwiLi9zdXBlclByb3BCYXNlLmpzXCIpO1xuXG5mdW5jdGlvbiBfZ2V0KCkge1xuICBpZiAodHlwZW9mIFJlZmxlY3QgIT09IFwidW5kZWZpbmVkXCIgJiYgUmVmbGVjdC5nZXQpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IF9nZXQgPSBSZWZsZWN0LmdldC5iaW5kKCksIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlLCBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0cztcbiAgfSBlbHNlIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IF9nZXQgPSBmdW5jdGlvbiBfZ2V0KHRhcmdldCwgcHJvcGVydHksIHJlY2VpdmVyKSB7XG4gICAgICB2YXIgYmFzZSA9IHN1cGVyUHJvcEJhc2UodGFyZ2V0LCBwcm9wZXJ0eSk7XG4gICAgICBpZiAoIWJhc2UpIHJldHVybjtcbiAgICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihiYXNlLCBwcm9wZXJ0eSk7XG5cbiAgICAgIGlmIChkZXNjLmdldCkge1xuICAgICAgICByZXR1cm4gZGVzYy5nZXQuY2FsbChhcmd1bWVudHMubGVuZ3RoIDwgMyA/IHRhcmdldCA6IHJlY2VpdmVyKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGRlc2MudmFsdWU7XG4gICAgfSwgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzO1xuICB9XG5cbiAgcmV0dXJuIF9nZXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfZ2V0LCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZSwgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHM7IiwiLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyB0aGVcbiAqIFtsYW5ndWFnZSB0eXBlXShodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtZWNtYXNjcmlwdC1sYW5ndWFnZS10eXBlcylcbiAqIG9mIGBPYmplY3RgLiAoZS5nLiBhcnJheXMsIGZ1bmN0aW9ucywgb2JqZWN0cywgcmVnZXhlcywgYG5ldyBOdW1iZXIoMClgLCBhbmQgYG5ldyBTdHJpbmcoJycpYClcbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdCh7fSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoXy5ub29wKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmICh0eXBlID09ICdvYmplY3QnIHx8IHR5cGUgPT0gJ2Z1bmN0aW9uJyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNPYmplY3Q7XG4iLCIvKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYW4gYEFycmF5YCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYXJyYXksIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FycmF5KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5KGRvY3VtZW50LmJvZHkuY2hpbGRyZW4pO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzQXJyYXkoJ2FiYycpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzQXJyYXkoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcblxubW9kdWxlLmV4cG9ydHMgPSBpc0FycmF5O1xuIiwiZnVuY3Rpb24gX3R5cGVvZihvYmopIHtcbiAgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiO1xuXG4gIHJldHVybiAobW9kdWxlLmV4cG9ydHMgPSBfdHlwZW9mID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgXCJzeW1ib2xcIiA9PSB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID8gZnVuY3Rpb24gKG9iaikge1xuICAgIHJldHVybiB0eXBlb2Ygb2JqO1xuICB9IDogZnVuY3Rpb24gKG9iaikge1xuICAgIHJldHVybiBvYmogJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7XG4gIH0sIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlLCBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0cyksIF90eXBlb2Yob2JqKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfdHlwZW9mLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZSwgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHM7IiwidmFyIGJhc2VNZXJnZSA9IHJlcXVpcmUoJy4vX2Jhc2VNZXJnZScpLFxuICAgIGNyZWF0ZUFzc2lnbmVyID0gcmVxdWlyZSgnLi9fY3JlYXRlQXNzaWduZXInKTtcblxuLyoqXG4gKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmFzc2lnbmAgZXhjZXB0IHRoYXQgaXQgcmVjdXJzaXZlbHkgbWVyZ2VzIG93biBhbmRcbiAqIGluaGVyaXRlZCBlbnVtZXJhYmxlIHN0cmluZyBrZXllZCBwcm9wZXJ0aWVzIG9mIHNvdXJjZSBvYmplY3RzIGludG8gdGhlXG4gKiBkZXN0aW5hdGlvbiBvYmplY3QuIFNvdXJjZSBwcm9wZXJ0aWVzIHRoYXQgcmVzb2x2ZSB0byBgdW5kZWZpbmVkYCBhcmVcbiAqIHNraXBwZWQgaWYgYSBkZXN0aW5hdGlvbiB2YWx1ZSBleGlzdHMuIEFycmF5IGFuZCBwbGFpbiBvYmplY3QgcHJvcGVydGllc1xuICogYXJlIG1lcmdlZCByZWN1cnNpdmVseS4gT3RoZXIgb2JqZWN0cyBhbmQgdmFsdWUgdHlwZXMgYXJlIG92ZXJyaWRkZW4gYnlcbiAqIGFzc2lnbm1lbnQuIFNvdXJjZSBvYmplY3RzIGFyZSBhcHBsaWVkIGZyb20gbGVmdCB0byByaWdodC4gU3Vic2VxdWVudFxuICogc291cmNlcyBvdmVyd3JpdGUgcHJvcGVydHkgYXNzaWdubWVudHMgb2YgcHJldmlvdXMgc291cmNlcy5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgbXV0YXRlcyBgb2JqZWN0YC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuNS4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gKiBAcGFyYW0gey4uLk9iamVjdH0gW3NvdXJjZXNdIFRoZSBzb3VyY2Ugb2JqZWN0cy5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7XG4gKiAgICdhJzogW3sgJ2InOiAyIH0sIHsgJ2QnOiA0IH1dXG4gKiB9O1xuICpcbiAqIHZhciBvdGhlciA9IHtcbiAqICAgJ2EnOiBbeyAnYyc6IDMgfSwgeyAnZSc6IDUgfV1cbiAqIH07XG4gKlxuICogXy5tZXJnZShvYmplY3QsIG90aGVyKTtcbiAqIC8vID0+IHsgJ2EnOiBbeyAnYic6IDIsICdjJzogMyB9LCB7ICdkJzogNCwgJ2UnOiA1IH1dIH1cbiAqL1xudmFyIG1lcmdlID0gY3JlYXRlQXNzaWduZXIoZnVuY3Rpb24ob2JqZWN0LCBzb3VyY2UsIHNyY0luZGV4KSB7XG4gIGJhc2VNZXJnZShvYmplY3QsIHNvdXJjZSwgc3JjSW5kZXgpO1xufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gbWVyZ2U7XG4iLCJ2YXIgZnJlZUdsb2JhbCA9IHJlcXVpcmUoJy4vX2ZyZWVHbG9iYWwnKTtcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBzZWxmYC4gKi9cbnZhciBmcmVlU2VsZiA9IHR5cGVvZiBzZWxmID09ICdvYmplY3QnICYmIHNlbGYgJiYgc2VsZi5PYmplY3QgPT09IE9iamVjdCAmJiBzZWxmO1xuXG4vKiogVXNlZCBhcyBhIHJlZmVyZW5jZSB0byB0aGUgZ2xvYmFsIG9iamVjdC4gKi9cbnZhciByb290ID0gZnJlZUdsb2JhbCB8fCBmcmVlU2VsZiB8fCBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJvb3Q7XG4iLCIvKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLiBBIHZhbHVlIGlzIG9iamVjdC1saWtlIGlmIGl0J3Mgbm90IGBudWxsYFxuICogYW5kIGhhcyBhIGB0eXBlb2ZgIHJlc3VsdCBvZiBcIm9iamVjdFwiLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKHt9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3RMaWtlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0Jztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc09iamVjdExpa2U7XG4iLCIvKipcbiAqIGh0dHA6Ly93d3cuY29kZXByb2plY3QuY29tL1RpcHMvNDA3MTcyL0Nvbm5lY3RlZC1Db21wb25lbnQtTGFiZWxpbmctYW5kLVZlY3Rvcml6YXRpb25cbiAqL1xuY29uc3QgVHJhY2VyID0ge1xuICAgIHNlYXJjaERpcmVjdGlvbnM6IFtbMCwgMV0sIFsxLCAxXSwgWzEsIDBdLCBbMSwgLTFdLCBbMCwgLTFdLCBbLTEsIC0xXSwgWy0xLCAwXSwgWy0xLCAxXV0sXG4gICAgY3JlYXRlKGltYWdlV3JhcHBlciwgbGFiZWxXcmFwcGVyKSB7XG4gICAgICAgIGNvbnN0IGltYWdlRGF0YSA9IGltYWdlV3JhcHBlci5kYXRhO1xuICAgICAgICBjb25zdCBsYWJlbERhdGEgPSBsYWJlbFdyYXBwZXIuZGF0YTtcbiAgICAgICAgY29uc3QgeyBzZWFyY2hEaXJlY3Rpb25zIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCB3aWR0aCA9IGltYWdlV3JhcHBlci5zaXplLng7XG4gICAgICAgIGxldCBwb3M7XG5cbiAgICAgICAgZnVuY3Rpb24gdHJhY2UoY3VycmVudCwgY29sb3IsIGxhYmVsLCBlZGdlbGFiZWwpIHtcbiAgICAgICAgICAgIGxldCBpO1xuICAgICAgICAgICAgbGV0IHk7XG4gICAgICAgICAgICBsZXQgeDtcblxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHNlYXJjaERpcmVjdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB5ID0gY3VycmVudC5jeSArIHNlYXJjaERpcmVjdGlvbnNbY3VycmVudC5kaXJdWzBdO1xuICAgICAgICAgICAgICAgIHggPSBjdXJyZW50LmN4ICsgc2VhcmNoRGlyZWN0aW9uc1tjdXJyZW50LmRpcl1bMV07XG4gICAgICAgICAgICAgICAgcG9zID0geSAqIHdpZHRoICsgeDtcbiAgICAgICAgICAgICAgICBpZiAoKGltYWdlRGF0YVtwb3NdID09PSBjb2xvcikgJiYgKChsYWJlbERhdGFbcG9zXSA9PT0gMCkgfHwgKGxhYmVsRGF0YVtwb3NdID09PSBsYWJlbCkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGxhYmVsRGF0YVtwb3NdID0gbGFiZWw7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnQuY3kgPSB5O1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50LmN4ID0geDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChsYWJlbERhdGFbcG9zXSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBsYWJlbERhdGFbcG9zXSA9IGVkZ2VsYWJlbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY3VycmVudC5kaXIgPSAoY3VycmVudC5kaXIgKyAxKSAlIDg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiB2ZXJ0ZXgyRCh4LCB5LCBkaXIpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZGlyLFxuICAgICAgICAgICAgICAgIHgsXG4gICAgICAgICAgICAgICAgeSxcbiAgICAgICAgICAgICAgICBuZXh0OiBudWxsLFxuICAgICAgICAgICAgICAgIHByZXY6IG51bGwsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gY29udG91clRyYWNpbmcoc3ksIHN4LCBsYWJlbCwgY29sb3IsIGVkZ2VsYWJlbCkge1xuICAgICAgICAgICAgbGV0IEZ2ID0gbnVsbDtcbiAgICAgICAgICAgIGxldCBDdjtcbiAgICAgICAgICAgIGxldCBQO1xuICAgICAgICAgICAgbGV0IGxkaXI7XG4gICAgICAgICAgICBjb25zdCBjdXJyZW50ID0ge1xuICAgICAgICAgICAgICAgIGN4OiBzeCxcbiAgICAgICAgICAgICAgICBjeTogc3ksXG4gICAgICAgICAgICAgICAgZGlyOiAwLFxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgaWYgKHRyYWNlKGN1cnJlbnQsIGNvbG9yLCBsYWJlbCwgZWRnZWxhYmVsKSkge1xuICAgICAgICAgICAgICAgIEZ2ID0gdmVydGV4MkQoc3gsIHN5LCBjdXJyZW50LmRpcik7XG4gICAgICAgICAgICAgICAgQ3YgPSBGdjtcbiAgICAgICAgICAgICAgICBsZGlyID0gY3VycmVudC5kaXI7XG4gICAgICAgICAgICAgICAgUCA9IHZlcnRleDJEKGN1cnJlbnQuY3gsIGN1cnJlbnQuY3ksIDApO1xuICAgICAgICAgICAgICAgIFAucHJldiA9IEN2O1xuICAgICAgICAgICAgICAgIEN2Lm5leHQgPSBQO1xuICAgICAgICAgICAgICAgIFAubmV4dCA9IG51bGw7XG4gICAgICAgICAgICAgICAgQ3YgPSBQO1xuXG4gICAgICAgICAgICAgICAgbGV0IHRvdGFsUGl4ZWxDb3VudCA9IGltYWdlV3JhcHBlci5zaXplLnggKiBpbWFnZVdyYXBwZXIuc2l6ZS55O1xuICAgICAgICAgICAgICAgIGxldCBwaXhlbENvdW50ZXIgPSAwO1xuICAgICAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudC5kaXIgPSAoY3VycmVudC5kaXIgKyA2KSAlIDg7XG4gICAgICAgICAgICAgICAgICAgIHRyYWNlKGN1cnJlbnQsIGNvbG9yLCBsYWJlbCwgZWRnZWxhYmVsKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxkaXIgIT09IGN1cnJlbnQuZGlyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBDdi5kaXIgPSBjdXJyZW50LmRpcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIFAgPSB2ZXJ0ZXgyRChjdXJyZW50LmN4LCBjdXJyZW50LmN5LCAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIFAucHJldiA9IEN2O1xuICAgICAgICAgICAgICAgICAgICAgICAgQ3YubmV4dCA9IFA7XG4gICAgICAgICAgICAgICAgICAgICAgICBQLm5leHQgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgQ3YgPSBQO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgQ3YuZGlyID0gbGRpcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIEN2LnggPSBjdXJyZW50LmN4O1xuICAgICAgICAgICAgICAgICAgICAgICAgQ3YueSA9IGN1cnJlbnQuY3k7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbGRpciA9IGN1cnJlbnQuZGlyO1xuICAgICAgICAgICAgICAgIH0gd2hpbGUgKChjdXJyZW50LmN4ICE9PSBzeCB8fCBjdXJyZW50LmN5ICE9PSBzeSkgJiYgKytwaXhlbENvdW50ZXIgPCB0b3RhbFBpeGVsQ291bnQpO1xuICAgICAgICAgICAgICAgIEZ2LnByZXYgPSBDdi5wcmV2O1xuICAgICAgICAgICAgICAgIEN2LnByZXYubmV4dCA9IEZ2O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIEZ2O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHRyYWNlKGN1cnJlbnQsIGNvbG9yLCBsYWJlbCwgZWRnZWxhYmVsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRyYWNlKGN1cnJlbnQsIGNvbG9yLCBsYWJlbCwgZWRnZWxhYmVsKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjb250b3VyVHJhY2luZyhzeSwgc3gsIGxhYmVsLCBjb2xvciwgZWRnZWxhYmVsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRvdXJUcmFjaW5nKHN5LCBzeCwgbGFiZWwsIGNvbG9yLCBlZGdlbGFiZWwpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9LFxufTtcblxuZXhwb3J0IGRlZmF1bHQgKFRyYWNlcik7XG4iLCJ2YXIgU3ltYm9sID0gcmVxdWlyZSgnLi9fU3ltYm9sJyksXG4gICAgZ2V0UmF3VGFnID0gcmVxdWlyZSgnLi9fZ2V0UmF3VGFnJyksXG4gICAgb2JqZWN0VG9TdHJpbmcgPSByZXF1aXJlKCcuL19vYmplY3RUb1N0cmluZycpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgbnVsbFRhZyA9ICdbb2JqZWN0IE51bGxdJyxcbiAgICB1bmRlZmluZWRUYWcgPSAnW29iamVjdCBVbmRlZmluZWRdJztcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgc3ltVG9TdHJpbmdUYWcgPSBTeW1ib2wgPyBTeW1ib2wudG9TdHJpbmdUYWcgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGdldFRhZ2Agd2l0aG91dCBmYWxsYmFja3MgZm9yIGJ1Z2d5IGVudmlyb25tZW50cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBgdG9TdHJpbmdUYWdgLlxuICovXG5mdW5jdGlvbiBiYXNlR2V0VGFnKHZhbHVlKSB7XG4gIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWRUYWcgOiBudWxsVGFnO1xuICB9XG4gIHJldHVybiAoc3ltVG9TdHJpbmdUYWcgJiYgc3ltVG9TdHJpbmdUYWcgaW4gT2JqZWN0KHZhbHVlKSlcbiAgICA/IGdldFJhd1RhZyh2YWx1ZSlcbiAgICA6IG9iamVjdFRvU3RyaW5nKHZhbHVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlR2V0VGFnO1xuIiwiaW1wb3J0IHsgZ2xNYXRyaXgsIHZlYzIsIG1hdDIgfSBmcm9tICdnbC1tYXRyaXgnO1xuaW1wb3J0IEltYWdlV3JhcHBlciBmcm9tICcuLi9jb21tb24vaW1hZ2Vfd3JhcHBlcic7XG5pbXBvcnQge1xuICAgIGNhbGN1bGF0ZVBhdGNoU2l6ZSxcbiAgICBvdHN1VGhyZXNob2xkLFxuICAgIGhzdjJyZ2IsXG4gICAgY2x1c3RlcixcbiAgICB0b3BHZW5lcmljLFxuICAgIGltYWdlUmVmLFxuICAgIGhhbGZTYW1wbGUsXG4gICAgY29tcHV0ZUltYWdlQXJlYSxcbn0gZnJvbSAnLi4vY29tbW9uL2N2X3V0aWxzJztcbmltcG9ydCBBcnJheUhlbHBlciBmcm9tICcuLi9jb21tb24vYXJyYXlfaGVscGVyJztcbmltcG9ydCBJbWFnZURlYnVnIGZyb20gJy4uL2NvbW1vbi9pbWFnZV9kZWJ1Zyc7XG5pbXBvcnQgUmFzdGVyaXplciBmcm9tICcuL3Jhc3Rlcml6ZXInO1xuaW1wb3J0IFRyYWNlciBmcm9tICcuL3RyYWNlcic7XG5pbXBvcnQgc2tlbGV0b25pemVyIGZyb20gJy4vc2tlbGV0b25pemVyJztcblxuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtcblxubGV0IF9jb25maWc7XG5sZXQgX2N1cnJlbnRJbWFnZVdyYXBwZXI7XG5sZXQgX3NrZWxJbWFnZVdyYXBwZXI7XG5sZXQgX3N1YkltYWdlV3JhcHBlcjtcbmxldCBfbGFiZWxJbWFnZVdyYXBwZXI7XG5sZXQgX3BhdGNoR3JpZDtcbmxldCBfcGF0Y2hMYWJlbEdyaWQ7XG5sZXQgX2ltYWdlVG9QYXRjaEdyaWQ7XG5sZXQgX2JpbmFyeUltYWdlV3JhcHBlcjtcbmxldCBfcGF0Y2hTaXplO1xuY29uc3QgX2NhbnZhc0NvbnRhaW5lciA9IHtcbiAgICBjdHg6IHtcbiAgICAgICAgYmluYXJ5OiBudWxsLFxuICAgIH0sXG4gICAgZG9tOiB7XG4gICAgICAgIGJpbmFyeTogbnVsbCxcbiAgICB9LFxufTtcbmNvbnN0IF9udW1QYXRjaGVzID0geyB4OiAwLCB5OiAwIH07XG5sZXQgX2lucHV0SW1hZ2VXcmFwcGVyO1xubGV0IF9za2VsZXRvbml6ZXI7XG5cbmZ1bmN0aW9uIGluaXRCdWZmZXJzKCkge1xuICAgIGlmIChfY29uZmlnLmhhbGZTYW1wbGUpIHtcbiAgICAgICAgX2N1cnJlbnRJbWFnZVdyYXBwZXIgPSBuZXcgSW1hZ2VXcmFwcGVyKHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1iaXR3aXNlXG4gICAgICAgICAgICB4OiBfaW5wdXRJbWFnZVdyYXBwZXIuc2l6ZS54IC8gMiB8IDAsXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tYml0d2lzZVxuICAgICAgICAgICAgeTogX2lucHV0SW1hZ2VXcmFwcGVyLnNpemUueSAvIDIgfCAwLFxuICAgICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBfY3VycmVudEltYWdlV3JhcHBlciA9IF9pbnB1dEltYWdlV3JhcHBlcjtcbiAgICB9XG5cbiAgICBfcGF0Y2hTaXplID0gY2FsY3VsYXRlUGF0Y2hTaXplKF9jb25maWcucGF0Y2hTaXplLCBfY3VycmVudEltYWdlV3JhcHBlci5zaXplKTtcblxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1iaXR3aXNlXG4gICAgX251bVBhdGNoZXMueCA9IF9jdXJyZW50SW1hZ2VXcmFwcGVyLnNpemUueCAvIF9wYXRjaFNpemUueCB8IDA7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWJpdHdpc2VcbiAgICBfbnVtUGF0Y2hlcy55ID0gX2N1cnJlbnRJbWFnZVdyYXBwZXIuc2l6ZS55IC8gX3BhdGNoU2l6ZS55IHwgMDtcblxuICAgIF9iaW5hcnlJbWFnZVdyYXBwZXIgPSBuZXcgSW1hZ2VXcmFwcGVyKF9jdXJyZW50SW1hZ2VXcmFwcGVyLnNpemUsIHVuZGVmaW5lZCwgVWludDhBcnJheSwgZmFsc2UpO1xuXG4gICAgX2xhYmVsSW1hZ2VXcmFwcGVyID0gbmV3IEltYWdlV3JhcHBlcihfcGF0Y2hTaXplLCB1bmRlZmluZWQsIEFycmF5LCB0cnVlKTtcblxuICAgIGNvbnN0IHNrZWxldG9uSW1hZ2VEYXRhID0gbmV3IEFycmF5QnVmZmVyKDY0ICogMTAyNCk7XG4gICAgX3N1YkltYWdlV3JhcHBlciA9IG5ldyBJbWFnZVdyYXBwZXIoX3BhdGNoU2l6ZSxcbiAgICAgICAgbmV3IFVpbnQ4QXJyYXkoc2tlbGV0b25JbWFnZURhdGEsIDAsIF9wYXRjaFNpemUueCAqIF9wYXRjaFNpemUueSkpO1xuICAgIF9za2VsSW1hZ2VXcmFwcGVyID0gbmV3IEltYWdlV3JhcHBlcihfcGF0Y2hTaXplLFxuICAgICAgICBuZXcgVWludDhBcnJheShza2VsZXRvbkltYWdlRGF0YSwgX3BhdGNoU2l6ZS54ICogX3BhdGNoU2l6ZS55ICogMywgX3BhdGNoU2l6ZS54ICogX3BhdGNoU2l6ZS55KSxcbiAgICAgICAgdW5kZWZpbmVkLCB0cnVlKTtcbiAgICBfc2tlbGV0b25pemVyID0gc2tlbGV0b25pemVyKFxuICAgICAgICAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpID8gd2luZG93IDogKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJykgPyBzZWxmIDogZ2xvYmFsLFxuICAgICAgICB7IHNpemU6IF9wYXRjaFNpemUueCB9LFxuICAgICAgICBza2VsZXRvbkltYWdlRGF0YSxcbiAgICApO1xuXG4gICAgX2ltYWdlVG9QYXRjaEdyaWQgPSBuZXcgSW1hZ2VXcmFwcGVyKHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWJpdHdpc2VcbiAgICAgICAgeDogKF9jdXJyZW50SW1hZ2VXcmFwcGVyLnNpemUueCAvIF9zdWJJbWFnZVdyYXBwZXIuc2l6ZS54KSB8IDAsXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1iaXR3aXNlXG4gICAgICAgIHk6IChfY3VycmVudEltYWdlV3JhcHBlci5zaXplLnkgLyBfc3ViSW1hZ2VXcmFwcGVyLnNpemUueSkgfCAwLFxuICAgIH0sIHVuZGVmaW5lZCwgQXJyYXksIHRydWUpO1xuICAgIF9wYXRjaEdyaWQgPSBuZXcgSW1hZ2VXcmFwcGVyKF9pbWFnZVRvUGF0Y2hHcmlkLnNpemUsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB0cnVlKTtcbiAgICBfcGF0Y2hMYWJlbEdyaWQgPSBuZXcgSW1hZ2VXcmFwcGVyKF9pbWFnZVRvUGF0Y2hHcmlkLnNpemUsIHVuZGVmaW5lZCwgSW50MzJBcnJheSwgdHJ1ZSk7XG59XG5cbmZ1bmN0aW9uIGluaXRDYW52YXMoKSB7XG4gICAgaWYgKF9jb25maWcudXNlV29ya2VyIHx8IHR5cGVvZiBkb2N1bWVudCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBfY2FudmFzQ29udGFpbmVyLmRvbS5iaW5hcnkgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICBfY2FudmFzQ29udGFpbmVyLmRvbS5iaW5hcnkuY2xhc3NOYW1lID0gJ2JpbmFyeUJ1ZmZlcic7XG4gICAgaWYgKEVOVi5kZXZlbG9wbWVudCAmJiBfY29uZmlnLmRlYnVnLnNob3dDYW52YXMgPT09IHRydWUpIHtcbiAgICAgICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI2RlYnVnJykuYXBwZW5kQ2hpbGQoX2NhbnZhc0NvbnRhaW5lci5kb20uYmluYXJ5KTtcbiAgICB9XG4gICAgX2NhbnZhc0NvbnRhaW5lci5jdHguYmluYXJ5ID0gX2NhbnZhc0NvbnRhaW5lci5kb20uYmluYXJ5LmdldENvbnRleHQoJzJkJyk7XG4gICAgX2NhbnZhc0NvbnRhaW5lci5kb20uYmluYXJ5LndpZHRoID0gX2JpbmFyeUltYWdlV3JhcHBlci5zaXplLng7XG4gICAgX2NhbnZhc0NvbnRhaW5lci5kb20uYmluYXJ5LmhlaWdodCA9IF9iaW5hcnlJbWFnZVdyYXBwZXIuc2l6ZS55O1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBib3VuZGluZyBib3ggd2hpY2ggZW5jbG9zZXMgYWxsIHRoZSBnaXZlbiBwYXRjaGVzXG4gKiBAcmV0dXJucyB7QXJyYXl9IFRoZSBtaW5pbWFsIGJvdW5kaW5nIGJveFxuICovXG5mdW5jdGlvbiBib3hGcm9tUGF0Y2hlcyhwYXRjaGVzKSB7XG4gICAgbGV0IG92ZXJBdmc7XG4gICAgbGV0IGk7XG4gICAgbGV0IGo7XG4gICAgbGV0IHBhdGNoO1xuICAgIGxldCB0cmFuc01hdDtcbiAgICBsZXQgbWlueCA9IF9iaW5hcnlJbWFnZVdyYXBwZXIuc2l6ZS54O1xuICAgIGxldCBtaW55ID0gX2JpbmFyeUltYWdlV3JhcHBlci5zaXplLnk7XG4gICAgbGV0IG1heHggPSAtX2JpbmFyeUltYWdlV3JhcHBlci5zaXplLng7XG4gICAgbGV0IG1heHkgPSAtX2JpbmFyeUltYWdlV3JhcHBlci5zaXplLnk7XG4gICAgbGV0IGJveDtcbiAgICBsZXQgc2NhbGU7XG5cbiAgICAvLyBkcmF3IGFsbCBwYXRjaGVzIHdoaWNoIGFyZSB0byBiZSB0YWtlbiBpbnRvIGNvbnNpZGVyYXRpb25cbiAgICBvdmVyQXZnID0gMDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgcGF0Y2hlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBwYXRjaCA9IHBhdGNoZXNbaV07XG4gICAgICAgIG92ZXJBdmcgKz0gcGF0Y2gucmFkO1xuICAgICAgICBpZiAoRU5WLmRldmVsb3BtZW50ICYmIF9jb25maWcuZGVidWcuc2hvd1BhdGNoZXMpIHtcbiAgICAgICAgICAgIEltYWdlRGVidWcuZHJhd1JlY3QocGF0Y2gucG9zLCBfc3ViSW1hZ2VXcmFwcGVyLnNpemUsIF9jYW52YXNDb250YWluZXIuY3R4LmJpbmFyeSwgeyBjb2xvcjogJ3JlZCcgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBvdmVyQXZnIC89IHBhdGNoZXMubGVuZ3RoO1xuICAgIG92ZXJBdmcgPSAob3ZlckF2ZyAqIDE4MCAvIE1hdGguUEkgKyA5MCkgJSAxODAgLSA5MDtcbiAgICBpZiAob3ZlckF2ZyA8IDApIHtcbiAgICAgICAgb3ZlckF2ZyArPSAxODA7XG4gICAgfVxuXG4gICAgb3ZlckF2ZyA9ICgxODAgLSBvdmVyQXZnKSAqIE1hdGguUEkgLyAxODA7XG4gICAgdHJhbnNNYXQgPSBtYXQyLmNvcHkobWF0Mi5jcmVhdGUoKSwgW01hdGguY29zKG92ZXJBdmcpLCBNYXRoLnNpbihvdmVyQXZnKSwgLU1hdGguc2luKG92ZXJBdmcpLCBNYXRoLmNvcyhvdmVyQXZnKV0pO1xuXG4gICAgLy8gaXRlcmF0ZSBvdmVyIHBhdGNoZXMgYW5kIHJvdGF0ZSBieSBhbmdsZVxuICAgIGZvciAoaSA9IDA7IGkgPCBwYXRjaGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHBhdGNoID0gcGF0Y2hlc1tpXTtcbiAgICAgICAgZm9yIChqID0gMDsgaiA8IDQ7IGorKykge1xuICAgICAgICAgICAgdmVjMi50cmFuc2Zvcm1NYXQyKHBhdGNoLmJveFtqXSwgcGF0Y2guYm94W2pdLCB0cmFuc01hdCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoRU5WLmRldmVsb3BtZW50ICYmIF9jb25maWcuZGVidWcuYm94RnJvbVBhdGNoZXMuc2hvd1RyYW5zZm9ybWVkKSB7XG4gICAgICAgICAgICBJbWFnZURlYnVnLmRyYXdQYXRoKHBhdGNoLmJveCwgeyB4OiAwLCB5OiAxIH0sIF9jYW52YXNDb250YWluZXIuY3R4LmJpbmFyeSwgeyBjb2xvcjogJyM5OWZmMDAnLCBsaW5lV2lkdGg6IDIgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBmaW5kIGJvdW5kaW5nIGJveFxuICAgIGZvciAoaSA9IDA7IGkgPCBwYXRjaGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHBhdGNoID0gcGF0Y2hlc1tpXTtcbiAgICAgICAgZm9yIChqID0gMDsgaiA8IDQ7IGorKykge1xuICAgICAgICAgICAgaWYgKHBhdGNoLmJveFtqXVswXSA8IG1pbngpIHtcbiAgICAgICAgICAgICAgICBtaW54ID0gcGF0Y2guYm94W2pdWzBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBhdGNoLmJveFtqXVswXSA+IG1heHgpIHtcbiAgICAgICAgICAgICAgICBtYXh4ID0gcGF0Y2guYm94W2pdWzBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBhdGNoLmJveFtqXVsxXSA8IG1pbnkpIHtcbiAgICAgICAgICAgICAgICBtaW55ID0gcGF0Y2guYm94W2pdWzFdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBhdGNoLmJveFtqXVsxXSA+IG1heHkpIHtcbiAgICAgICAgICAgICAgICBtYXh5ID0gcGF0Y2guYm94W2pdWzFdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgYm94ID0gW1ttaW54LCBtaW55XSwgW21heHgsIG1pbnldLCBbbWF4eCwgbWF4eV0sIFttaW54LCBtYXh5XV07XG5cbiAgICBpZiAoRU5WLmRldmVsb3BtZW50ICYmIF9jb25maWcuZGVidWcuYm94RnJvbVBhdGNoZXMuc2hvd1RyYW5zZm9ybWVkQm94KSB7XG4gICAgICAgIEltYWdlRGVidWcuZHJhd1BhdGgoYm94LCB7IHg6IDAsIHk6IDEgfSwgX2NhbnZhc0NvbnRhaW5lci5jdHguYmluYXJ5LCB7IGNvbG9yOiAnI2ZmMDAwMCcsIGxpbmVXaWR0aDogMiB9KTtcbiAgICB9XG5cbiAgICBzY2FsZSA9IF9jb25maWcuaGFsZlNhbXBsZSA/IDIgOiAxO1xuICAgIC8vIHJldmVyc2Ugcm90YXRpb247XG4gICAgdHJhbnNNYXQgPSBtYXQyLmludmVydCh0cmFuc01hdCwgdHJhbnNNYXQpO1xuICAgIGZvciAoaiA9IDA7IGogPCA0OyBqKyspIHtcbiAgICAgICAgdmVjMi50cmFuc2Zvcm1NYXQyKGJveFtqXSwgYm94W2pdLCB0cmFuc01hdCk7XG4gICAgfVxuXG4gICAgaWYgKEVOVi5kZXZlbG9wbWVudCAmJiBfY29uZmlnLmRlYnVnLmJveEZyb21QYXRjaGVzLnNob3dCQikge1xuICAgICAgICBJbWFnZURlYnVnLmRyYXdQYXRoKGJveCwgeyB4OiAwLCB5OiAxIH0sIF9jYW52YXNDb250YWluZXIuY3R4LmJpbmFyeSwgeyBjb2xvcjogJyNmZjAwMDAnLCBsaW5lV2lkdGg6IDIgfSk7XG4gICAgfVxuXG4gICAgZm9yIChqID0gMDsgaiA8IDQ7IGorKykge1xuICAgICAgICB2ZWMyLnNjYWxlKGJveFtqXSwgYm94W2pdLCBzY2FsZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGJveDtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgYmluYXJ5IGltYWdlIG9mIHRoZSBjdXJyZW50IGltYWdlXG4gKi9cbmZ1bmN0aW9uIGJpbmFyaXplSW1hZ2UoKSB7XG4gICAgb3RzdVRocmVzaG9sZChfY3VycmVudEltYWdlV3JhcHBlciwgX2JpbmFyeUltYWdlV3JhcHBlcik7XG4gICAgX2JpbmFyeUltYWdlV3JhcHBlci56ZXJvQm9yZGVyKCk7XG4gICAgaWYgKEVOVi5kZXZlbG9wbWVudCAmJiBfY29uZmlnLmRlYnVnLnNob3dDYW52YXMpIHtcbiAgICAgICAgX2JpbmFyeUltYWdlV3JhcHBlci5zaG93KF9jYW52YXNDb250YWluZXIuZG9tLmJpbmFyeSwgMjU1KTtcbiAgICB9XG59XG5cbi8qKlxuICogSXRlcmF0ZSBvdmVyIHRoZSBlbnRpcmUgaW1hZ2VcbiAqIGV4dHJhY3QgcGF0Y2hlc1xuICovXG5mdW5jdGlvbiBmaW5kUGF0Y2hlcygpIHtcbiAgICBsZXQgaTtcbiAgICBsZXQgajtcbiAgICBsZXQgeDtcbiAgICBsZXQgeTtcbiAgICBsZXQgbW9tZW50cztcbiAgICBsZXQgcGF0Y2hlc0ZvdW5kID0gW107XG4gICAgbGV0IHJhc3Rlcml6ZXI7XG4gICAgbGV0IHJhc3RlclJlc3VsdDtcbiAgICBsZXQgcGF0Y2g7XG4gICAgZm9yIChpID0gMDsgaSA8IF9udW1QYXRjaGVzLng7IGkrKykge1xuICAgICAgICBmb3IgKGogPSAwOyBqIDwgX251bVBhdGNoZXMueTsgaisrKSB7XG4gICAgICAgICAgICB4ID0gX3N1YkltYWdlV3JhcHBlci5zaXplLnggKiBpO1xuICAgICAgICAgICAgeSA9IF9zdWJJbWFnZVdyYXBwZXIuc2l6ZS55ICogajtcblxuICAgICAgICAgICAgLy8gc2VwZXJhdGUgcGFydHNcbiAgICAgICAgICAgIHNrZWxldG9uaXplKHgsIHkpO1xuXG4gICAgICAgICAgICAvLyBSYXN0ZXJpemUsIGZpbmQgaW5kaXZpZHVhbCBiYXJzXG4gICAgICAgICAgICBfc2tlbEltYWdlV3JhcHBlci56ZXJvQm9yZGVyKCk7XG4gICAgICAgICAgICBBcnJheUhlbHBlci5pbml0KF9sYWJlbEltYWdlV3JhcHBlci5kYXRhLCAwKTtcbiAgICAgICAgICAgIHJhc3Rlcml6ZXIgPSBSYXN0ZXJpemVyLmNyZWF0ZShfc2tlbEltYWdlV3JhcHBlciwgX2xhYmVsSW1hZ2VXcmFwcGVyKTtcbiAgICAgICAgICAgIHJhc3RlclJlc3VsdCA9IHJhc3Rlcml6ZXIucmFzdGVyaXplKDApO1xuXG4gICAgICAgICAgICBpZiAoRU5WLmRldmVsb3BtZW50ICYmIF9jb25maWcuZGVidWcuc2hvd0xhYmVscykge1xuICAgICAgICAgICAgICAgIF9sYWJlbEltYWdlV3JhcHBlci5vdmVybGF5KF9jYW52YXNDb250YWluZXIuZG9tLmJpbmFyeSwgTWF0aC5mbG9vcigzNjAgLyByYXN0ZXJSZXN1bHQuY291bnQpLFxuICAgICAgICAgICAgICAgICAgICB7IHgsIHkgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGNhbGN1bGF0ZSBtb21lbnRzIGZyb20gdGhlIHNrZWxldG9uaXplZCBwYXRjaFxuICAgICAgICAgICAgbW9tZW50cyA9IF9sYWJlbEltYWdlV3JhcHBlci5tb21lbnRzKHJhc3RlclJlc3VsdC5jb3VudCk7XG5cbiAgICAgICAgICAgIC8vIGV4dHJhY3QgZWxpZ2libGUgcGF0Y2hlc1xuICAgICAgICAgICAgcGF0Y2hlc0ZvdW5kID0gcGF0Y2hlc0ZvdW5kLmNvbmNhdChkZXNjcmliZVBhdGNoKG1vbWVudHMsIFtpLCBqXSwgeCwgeSkpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKEVOVi5kZXZlbG9wbWVudCAmJiBfY29uZmlnLmRlYnVnLnNob3dGb3VuZFBhdGNoZXMpIHtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHBhdGNoZXNGb3VuZC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgcGF0Y2ggPSBwYXRjaGVzRm91bmRbaV07XG4gICAgICAgICAgICBJbWFnZURlYnVnLmRyYXdSZWN0KHBhdGNoLnBvcywgX3N1YkltYWdlV3JhcHBlci5zaXplLCBfY2FudmFzQ29udGFpbmVyLmN0eC5iaW5hcnksXG4gICAgICAgICAgICAgICAgeyBjb2xvcjogJyM5OWZmMDAnLCBsaW5lV2lkdGg6IDIgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcGF0Y2hlc0ZvdW5kO1xufVxuXG4vKipcbiAqIEZpbmRzIHRob3NlIGNvbm5lY3RlZCBhcmVhcyB3aGljaCBjb250YWluIGF0IGxlYXN0IDYgcGF0Y2hlc1xuICogYW5kIHJldHVybnMgdGhlbSBvcmRlcmVkIERFU0MgYnkgdGhlIG51bWJlciBvZiBjb250YWluZWQgcGF0Y2hlc1xuICogQHBhcmFtIHtOdW1iZXJ9IG1heExhYmVsXG4gKi9cbmZ1bmN0aW9uIGZpbmRCaWdnZXN0Q29ubmVjdGVkQXJlYXMobWF4TGFiZWwpIHtcbiAgICBsZXQgaTtcbiAgICBsZXQgc3VtO1xuICAgIGxldCBsYWJlbEhpc3QgPSBbXTtcbiAgICBsZXQgdG9wTGFiZWxzID0gW107XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbWF4TGFiZWw7IGkrKykge1xuICAgICAgICBsYWJlbEhpc3QucHVzaCgwKTtcbiAgICB9XG4gICAgc3VtID0gX3BhdGNoTGFiZWxHcmlkLmRhdGEubGVuZ3RoO1xuICAgIHdoaWxlIChzdW0tLSkge1xuICAgICAgICBpZiAoX3BhdGNoTGFiZWxHcmlkLmRhdGFbc3VtXSA+IDApIHtcbiAgICAgICAgICAgIGxhYmVsSGlzdFtfcGF0Y2hMYWJlbEdyaWQuZGF0YVtzdW1dIC0gMV0rKztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGxhYmVsSGlzdCA9IGxhYmVsSGlzdC5tYXAoKHZhbCwgaWR4KSA9PiAoe1xuICAgICAgICB2YWwsXG4gICAgICAgIGxhYmVsOiBpZHggKyAxLFxuICAgIH0pKTtcblxuICAgIGxhYmVsSGlzdC5zb3J0KChhLCBiKSA9PiBiLnZhbCAtIGEudmFsKTtcblxuICAgIC8vIGV4dHJhY3QgdG9wIGFyZWFzIHdpdGggYXQgbGVhc3QgNiBwYXRjaGVzIHByZXNlbnRcbiAgICB0b3BMYWJlbHMgPSBsYWJlbEhpc3QuZmlsdGVyKChlbCkgPT4gZWwudmFsID49IDUpO1xuXG4gICAgcmV0dXJuIHRvcExhYmVscztcbn1cblxuLyoqXG4gKlxuICovXG5mdW5jdGlvbiBmaW5kQm94ZXModG9wTGFiZWxzLCBtYXhMYWJlbCkge1xuICAgIGxldCBpO1xuICAgIGxldCBqO1xuICAgIGxldCBzdW07XG4gICAgY29uc3QgcGF0Y2hlcyA9IFtdO1xuICAgIGxldCBwYXRjaDtcbiAgICBsZXQgYm94O1xuICAgIGNvbnN0IGJveGVzID0gW107XG4gICAgY29uc3QgaHN2ID0gWzAsIDEsIDFdO1xuICAgIGNvbnN0IHJnYiA9IFswLCAwLCAwXTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCB0b3BMYWJlbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgc3VtID0gX3BhdGNoTGFiZWxHcmlkLmRhdGEubGVuZ3RoO1xuICAgICAgICBwYXRjaGVzLmxlbmd0aCA9IDA7XG4gICAgICAgIHdoaWxlIChzdW0tLSkge1xuICAgICAgICAgICAgaWYgKF9wYXRjaExhYmVsR3JpZC5kYXRhW3N1bV0gPT09IHRvcExhYmVsc1tpXS5sYWJlbCkge1xuICAgICAgICAgICAgICAgIHBhdGNoID0gX2ltYWdlVG9QYXRjaEdyaWQuZGF0YVtzdW1dO1xuICAgICAgICAgICAgICAgIHBhdGNoZXMucHVzaChwYXRjaCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYm94ID0gYm94RnJvbVBhdGNoZXMocGF0Y2hlcyk7XG4gICAgICAgIGlmIChib3gpIHtcbiAgICAgICAgICAgIGJveGVzLnB1c2goYm94KTtcblxuICAgICAgICAgICAgLy8gZHJhdyBwYXRjaC1sYWJlbHMgaWYgcmVxdWVzdGVkXG4gICAgICAgICAgICBpZiAoRU5WLmRldmVsb3BtZW50ICYmIF9jb25maWcuZGVidWcuc2hvd1JlbWFpbmluZ1BhdGNoTGFiZWxzKSB7XG4gICAgICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IHBhdGNoZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgcGF0Y2ggPSBwYXRjaGVzW2pdO1xuICAgICAgICAgICAgICAgICAgICBoc3ZbMF0gPSAodG9wTGFiZWxzW2ldLmxhYmVsIC8gKG1heExhYmVsICsgMSkpICogMzYwO1xuICAgICAgICAgICAgICAgICAgICBoc3YycmdiKGhzdiwgcmdiKTtcbiAgICAgICAgICAgICAgICAgICAgSW1hZ2VEZWJ1Zy5kcmF3UmVjdChwYXRjaC5wb3MsIF9zdWJJbWFnZVdyYXBwZXIuc2l6ZSwgX2NhbnZhc0NvbnRhaW5lci5jdHguYmluYXJ5LFxuICAgICAgICAgICAgICAgICAgICAgICAgeyBjb2xvcjogYHJnYigke3JnYi5qb2luKCcsJyl9KWAsIGxpbmVXaWR0aDogMiB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGJveGVzO1xufVxuXG4vKipcbiAqIEZpbmQgc2ltaWxhciBtb21lbnRzICh2aWEgY2x1c3RlcilcbiAqIEBwYXJhbSB7T2JqZWN0fSBtb21lbnRzXG4gKi9cbmZ1bmN0aW9uIHNpbWlsYXJNb21lbnRzKG1vbWVudHMpIHtcbiAgICBjb25zdCBjbHVzdGVycyA9IGNsdXN0ZXIobW9tZW50cywgMC45MCk7XG4gICAgY29uc3QgdG9wQ2x1c3RlciA9IHRvcEdlbmVyaWMoY2x1c3RlcnMsIDEsIChlKSA9PiBlLmdldFBvaW50cygpLmxlbmd0aCk7XG4gICAgbGV0IHBvaW50cyA9IFtdOyBjb25zdFxuICAgICAgICByZXN1bHQgPSBbXTtcbiAgICBpZiAodG9wQ2x1c3Rlci5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgcG9pbnRzID0gdG9wQ2x1c3RlclswXS5pdGVtLmdldFBvaW50cygpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBvaW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2gocG9pbnRzW2ldLnBvaW50KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBza2VsZXRvbml6ZSh4LCB5KSB7XG4gICAgX2JpbmFyeUltYWdlV3JhcHBlci5zdWJJbWFnZUFzQ29weShfc3ViSW1hZ2VXcmFwcGVyLCBpbWFnZVJlZih4LCB5KSk7XG4gICAgX3NrZWxldG9uaXplci5za2VsZXRvbml6ZSgpO1xuXG4gICAgLy8gU2hvdyBza2VsZXRvbiBpZiByZXF1ZXN0ZWRcbiAgICBpZiAoRU5WLmRldmVsb3BtZW50ICYmIF9jb25maWcuZGVidWcuc2hvd1NrZWxldG9uKSB7XG4gICAgICAgIF9za2VsSW1hZ2VXcmFwcGVyLm92ZXJsYXkoX2NhbnZhc0NvbnRhaW5lci5kb20uYmluYXJ5LCAzNjAsIGltYWdlUmVmKHgsIHkpKTtcbiAgICB9XG59XG5cbi8qKlxuICogRXh0cmFjdHMgYW5kIGRlc2NyaWJlcyB0aG9zZSBwYXRjaGVzIHdoaWNoIHNlZW0gdG8gY29udGFpbiBhIGJhcmNvZGUgcGF0dGVyblxuICogQHBhcmFtIHtBcnJheX0gbW9tZW50c1xuICogQHBhcmFtIHtPYmplY3R9IHBhdGNoUG9zLFxuICogQHBhcmFtIHtOdW1iZXJ9IHhcbiAqIEBwYXJhbSB7TnVtYmVyfSB5XG4gKiBAcmV0dXJucyB7QXJyYXl9IGxpc3Qgb2YgcGF0Y2hlc1xuICovXG5mdW5jdGlvbiBkZXNjcmliZVBhdGNoKG1vbWVudHMsIHBhdGNoUG9zLCB4LCB5KSB7XG4gICAgbGV0IGs7XG4gICAgbGV0IGF2ZztcbiAgICBjb25zdCBlbGlnaWJsZU1vbWVudHMgPSBbXTtcbiAgICBsZXQgbWF0Y2hpbmdNb21lbnRzO1xuICAgIGxldCBwYXRjaDtcbiAgICBjb25zdCBwYXRjaGVzRm91bmQgPSBbXTtcbiAgICBjb25zdCBtaW5Db21wb25lbnRXZWlnaHQgPSBNYXRoLmNlaWwoX3BhdGNoU2l6ZS54IC8gMyk7XG5cbiAgICBpZiAobW9tZW50cy5sZW5ndGggPj0gMikge1xuICAgICAgICAvLyBvbmx5IGNvbGxlY3QgbW9tZW50cyB3aGljaCdzIGFyZWEgY292ZXJzIGF0IGxlYXN0IG1pbkNvbXBvbmVudFdlaWdodCBwaXhlbHMuXG4gICAgICAgIGZvciAoayA9IDA7IGsgPCBtb21lbnRzLmxlbmd0aDsgaysrKSB7XG4gICAgICAgICAgICBpZiAobW9tZW50c1trXS5tMDAgPiBtaW5Db21wb25lbnRXZWlnaHQpIHtcbiAgICAgICAgICAgICAgICBlbGlnaWJsZU1vbWVudHMucHVzaChtb21lbnRzW2tdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGlmIGF0IGxlYXN0IDIgbW9tZW50cyBhcmUgZm91bmQgd2hpY2ggaGF2ZSBhdCBsZWFzdCBtaW5Db21wb25lbnRXZWlnaHRzIGNvdmVyZWRcbiAgICAgICAgaWYgKGVsaWdpYmxlTW9tZW50cy5sZW5ndGggPj0gMikge1xuICAgICAgICAgICAgbWF0Y2hpbmdNb21lbnRzID0gc2ltaWxhck1vbWVudHMoZWxpZ2libGVNb21lbnRzKTtcbiAgICAgICAgICAgIGF2ZyA9IDA7XG4gICAgICAgICAgICAvLyBkZXRlcm1pbmUgdGhlIHNpbWlsYXJpdHkgb2YgdGhlIG1vbWVudHNcbiAgICAgICAgICAgIGZvciAoayA9IDA7IGsgPCBtYXRjaGluZ01vbWVudHMubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgICAgICAgICBhdmcgKz0gbWF0Y2hpbmdNb21lbnRzW2tdPy5yYWQgPz8gMDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gT25seSB0d28gb2YgdGhlIG1vbWVudHMgYXJlIGFsbG93ZWQgbm90IHRvIGZpdCBpbnRvIHRoZSBlcXVhdGlvblxuICAgICAgICAgICAgLy8gYWRkIHRoZSBwYXRjaCB0byB0aGUgc2V0XG4gICAgICAgICAgICBpZiAobWF0Y2hpbmdNb21lbnRzLmxlbmd0aCA+IDFcbiAgICAgICAgICAgICAgICAgICAgJiYgbWF0Y2hpbmdNb21lbnRzLmxlbmd0aCA+PSAoZWxpZ2libGVNb21lbnRzLmxlbmd0aCAvIDQpICogM1xuICAgICAgICAgICAgICAgICAgICAmJiBtYXRjaGluZ01vbWVudHMubGVuZ3RoID4gbW9tZW50cy5sZW5ndGggLyA0KSB7XG4gICAgICAgICAgICAgICAgYXZnIC89IG1hdGNoaW5nTW9tZW50cy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgcGF0Y2ggPSB7XG4gICAgICAgICAgICAgICAgICAgIGluZGV4OiBwYXRjaFBvc1sxXSAqIF9udW1QYXRjaGVzLnggKyBwYXRjaFBvc1swXSxcbiAgICAgICAgICAgICAgICAgICAgcG9zOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB4LFxuICAgICAgICAgICAgICAgICAgICAgICAgeSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgYm94OiBbXG4gICAgICAgICAgICAgICAgICAgICAgICB2ZWMyLmNsb25lKFt4LCB5XSksXG4gICAgICAgICAgICAgICAgICAgICAgICB2ZWMyLmNsb25lKFt4ICsgX3N1YkltYWdlV3JhcHBlci5zaXplLngsIHldKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZlYzIuY2xvbmUoW3ggKyBfc3ViSW1hZ2VXcmFwcGVyLnNpemUueCwgeSArIF9zdWJJbWFnZVdyYXBwZXIuc2l6ZS55XSksXG4gICAgICAgICAgICAgICAgICAgICAgICB2ZWMyLmNsb25lKFt4LCB5ICsgX3N1YkltYWdlV3JhcHBlci5zaXplLnldKSxcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgbW9tZW50czogbWF0Y2hpbmdNb21lbnRzLFxuICAgICAgICAgICAgICAgICAgICByYWQ6IGF2ZyxcbiAgICAgICAgICAgICAgICAgICAgdmVjOiB2ZWMyLmNsb25lKFtNYXRoLmNvcyhhdmcpLCBNYXRoLnNpbihhdmcpXSksXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBwYXRjaGVzRm91bmQucHVzaChwYXRjaCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHBhdGNoZXNGb3VuZDtcbn1cblxuLyoqXG4gKiBmaW5kcyBwYXRjaGVzIHdoaWNoIGFyZSBjb25uZWN0ZWQgYW5kIHNoYXJlIHRoZSBzYW1lIG9yaWVudGF0aW9uXG4gKiBAcGFyYW0ge09iamVjdH0gcGF0Y2hlc0ZvdW5kXG4gKi9cbmZ1bmN0aW9uIHJhc3Rlcml6ZUFuZ3VsYXJTaW1pbGFyaXR5KHBhdGNoZXNGb3VuZCkge1xuICAgIGxldCBsYWJlbCA9IDA7XG4gICAgY29uc3QgdGhyZXNob2xkID0gMC45NTtcbiAgICBsZXQgY3VycklkeCA9IDA7XG4gICAgbGV0IGo7XG4gICAgbGV0IHBhdGNoO1xuICAgIGNvbnN0IGhzdiA9IFswLCAxLCAxXTtcbiAgICBjb25zdCByZ2IgPSBbMCwgMCwgMF07XG5cbiAgICBmdW5jdGlvbiBub3RZZXRQcm9jZXNzZWQoKSB7XG4gICAgICAgIGxldCBpO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgX3BhdGNoTGFiZWxHcmlkLmRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChfcGF0Y2hMYWJlbEdyaWQuZGF0YVtpXSA9PT0gMCAmJiBfcGF0Y2hHcmlkLmRhdGFbaV0gPT09IDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX3BhdGNoTGFiZWxHcmlkLmRhdGEubGVuZ3RoO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRyYWNlKGN1cnJlbnRJZHgpIHtcbiAgICAgICAgbGV0IHg7XG4gICAgICAgIGxldCB5O1xuICAgICAgICBsZXQgY3VycmVudFBhdGNoO1xuICAgICAgICBsZXQgaWR4O1xuICAgICAgICBsZXQgZGlyO1xuICAgICAgICBjb25zdCBjdXJyZW50ID0ge1xuICAgICAgICAgICAgeDogY3VycmVudElkeCAlIF9wYXRjaExhYmVsR3JpZC5zaXplLngsXG4gICAgICAgICAgICB5OiAoY3VycmVudElkeCAvIF9wYXRjaExhYmVsR3JpZC5zaXplLngpIHwgMCxcbiAgICAgICAgfTtcbiAgICAgICAgbGV0IHNpbWlsYXJpdHk7XG5cbiAgICAgICAgaWYgKGN1cnJlbnRJZHggPCBfcGF0Y2hMYWJlbEdyaWQuZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGN1cnJlbnRQYXRjaCA9IF9pbWFnZVRvUGF0Y2hHcmlkLmRhdGFbY3VycmVudElkeF07XG4gICAgICAgICAgICAvLyBhc3NpZ24gbGFiZWxcbiAgICAgICAgICAgIF9wYXRjaExhYmVsR3JpZC5kYXRhW2N1cnJlbnRJZHhdID0gbGFiZWw7XG4gICAgICAgICAgICBmb3IgKGRpciA9IDA7IGRpciA8IFRyYWNlci5zZWFyY2hEaXJlY3Rpb25zLmxlbmd0aDsgZGlyKyspIHtcbiAgICAgICAgICAgICAgICB5ID0gY3VycmVudC55ICsgVHJhY2VyLnNlYXJjaERpcmVjdGlvbnNbZGlyXVswXTtcbiAgICAgICAgICAgICAgICB4ID0gY3VycmVudC54ICsgVHJhY2VyLnNlYXJjaERpcmVjdGlvbnNbZGlyXVsxXTtcbiAgICAgICAgICAgICAgICBpZHggPSB5ICogX3BhdGNoTGFiZWxHcmlkLnNpemUueCArIHg7XG5cbiAgICAgICAgICAgICAgICAvLyBjb250aW51ZSBpZiBwYXRjaCBlbXB0eVxuICAgICAgICAgICAgICAgIGlmIChfcGF0Y2hHcmlkLmRhdGFbaWR4XSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBfcGF0Y2hMYWJlbEdyaWQuZGF0YVtpZHhdID0gTnVtYmVyLk1BWF9WQUxVRTtcbiAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnRpbnVlXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChfcGF0Y2hMYWJlbEdyaWQuZGF0YVtpZHhdID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHNpbWlsYXJpdHkgPSBNYXRoLmFicyh2ZWMyLmRvdChfaW1hZ2VUb1BhdGNoR3JpZC5kYXRhW2lkeF0udmVjLCBjdXJyZW50UGF0Y2gudmVjKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzaW1pbGFyaXR5ID4gdGhyZXNob2xkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFjZShpZHgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gcHJlcGFyZSBmb3IgZmluZGluZyB0aGUgcmlnaHQgcGF0Y2hlc1xuICAgIEFycmF5SGVscGVyLmluaXQoX3BhdGNoR3JpZC5kYXRhLCAwKTtcbiAgICBBcnJheUhlbHBlci5pbml0KF9wYXRjaExhYmVsR3JpZC5kYXRhLCAwKTtcbiAgICBBcnJheUhlbHBlci5pbml0KF9pbWFnZVRvUGF0Y2hHcmlkLmRhdGEsIG51bGwpO1xuXG4gICAgZm9yIChqID0gMDsgaiA8IHBhdGNoZXNGb3VuZC5sZW5ndGg7IGorKykge1xuICAgICAgICBwYXRjaCA9IHBhdGNoZXNGb3VuZFtqXTtcbiAgICAgICAgX2ltYWdlVG9QYXRjaEdyaWQuZGF0YVtwYXRjaC5pbmRleF0gPSBwYXRjaDtcbiAgICAgICAgX3BhdGNoR3JpZC5kYXRhW3BhdGNoLmluZGV4XSA9IDE7XG4gICAgfVxuXG4gICAgLy8gcmFzdGVyaXplIHRoZSBwYXRjaGVzIGZvdW5kIHRvIGRldGVybWluZSBhcmVhXG4gICAgX3BhdGNoR3JpZC56ZXJvQm9yZGVyKCk7XG5cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uZC1hc3NpZ25cbiAgICB3aGlsZSAoKGN1cnJJZHggPSBub3RZZXRQcm9jZXNzZWQoKSkgPCBfcGF0Y2hMYWJlbEdyaWQuZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgbGFiZWwrKztcbiAgICAgICAgdHJhY2UoY3VycklkeCk7XG4gICAgfVxuXG4gICAgLy8gZHJhdyBwYXRjaC1sYWJlbHMgaWYgcmVxdWVzdGVkXG4gICAgaWYgKEVOVi5kZXZlbG9wbWVudCAmJiBfY29uZmlnLmRlYnVnLnNob3dQYXRjaExhYmVscykge1xuICAgICAgICBmb3IgKGogPSAwOyBqIDwgX3BhdGNoTGFiZWxHcmlkLmRhdGEubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIGlmIChfcGF0Y2hMYWJlbEdyaWQuZGF0YVtqXSA+IDAgJiYgX3BhdGNoTGFiZWxHcmlkLmRhdGFbal0gPD0gbGFiZWwpIHtcbiAgICAgICAgICAgICAgICBwYXRjaCA9IF9pbWFnZVRvUGF0Y2hHcmlkLmRhdGFbal07XG4gICAgICAgICAgICAgICAgaHN2WzBdID0gKF9wYXRjaExhYmVsR3JpZC5kYXRhW2pdIC8gKGxhYmVsICsgMSkpICogMzYwO1xuICAgICAgICAgICAgICAgIGhzdjJyZ2IoaHN2LCByZ2IpO1xuICAgICAgICAgICAgICAgIEltYWdlRGVidWcuZHJhd1JlY3QocGF0Y2gucG9zLCBfc3ViSW1hZ2VXcmFwcGVyLnNpemUsIF9jYW52YXNDb250YWluZXIuY3R4LmJpbmFyeSxcbiAgICAgICAgICAgICAgICAgICAgeyBjb2xvcjogYHJnYigke3JnYi5qb2luKCcsJyl9KWAsIGxpbmVXaWR0aDogMiB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBsYWJlbDtcbn1cblxuZXhwb3J0IGRlZmF1bHQge1xuICAgIGluaXQoaW5wdXRJbWFnZVdyYXBwZXIsIGNvbmZpZykge1xuICAgICAgICBfY29uZmlnID0gY29uZmlnO1xuICAgICAgICBfaW5wdXRJbWFnZVdyYXBwZXIgPSBpbnB1dEltYWdlV3JhcHBlcjtcblxuICAgICAgICBpbml0QnVmZmVycygpO1xuICAgICAgICBpbml0Q2FudmFzKCk7XG4gICAgfSxcblxuICAgIGxvY2F0ZSgpIHtcbiAgICAgICAgaWYgKF9jb25maWcuaGFsZlNhbXBsZSkge1xuICAgICAgICAgICAgaGFsZlNhbXBsZShfaW5wdXRJbWFnZVdyYXBwZXIsIF9jdXJyZW50SW1hZ2VXcmFwcGVyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGJpbmFyaXplSW1hZ2UoKTtcbiAgICAgICAgY29uc3QgcGF0Y2hlc0ZvdW5kID0gZmluZFBhdGNoZXMoKTtcbiAgICAgICAgLy8gcmV0dXJuIHVubGVzcyA1JSBvciBtb3JlIHBhdGNoZXMgYXJlIGZvdW5kXG4gICAgICAgIGlmIChwYXRjaGVzRm91bmQubGVuZ3RoIDwgX251bVBhdGNoZXMueCAqIF9udW1QYXRjaGVzLnkgKiAwLjA1KSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHJhc3RlcnJpemUgYXJlYSBieSBjb21wYXJpbmcgYW5ndWxhciBzaW1pbGFyaXR5O1xuICAgICAgICBjb25zdCBtYXhMYWJlbCA9IHJhc3Rlcml6ZUFuZ3VsYXJTaW1pbGFyaXR5KHBhdGNoZXNGb3VuZCk7XG4gICAgICAgIGlmIChtYXhMYWJlbCA8IDEpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gc2VhcmNoIGZvciBhcmVhIHdpdGggdGhlIG1vc3QgcGF0Y2hlcyAoYmlnZ2VzdCBjb25uZWN0ZWQgYXJlYSlcbiAgICAgICAgY29uc3QgdG9wTGFiZWxzID0gZmluZEJpZ2dlc3RDb25uZWN0ZWRBcmVhcyhtYXhMYWJlbCk7XG4gICAgICAgIGlmICh0b3BMYWJlbHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGJveGVzID0gZmluZEJveGVzKHRvcExhYmVscywgbWF4TGFiZWwpO1xuICAgICAgICByZXR1cm4gYm94ZXM7XG4gICAgfSxcblxuICAgIGNoZWNrSW1hZ2VDb25zdHJhaW50cyhpbnB1dFN0cmVhbSwgY29uZmlnKSB7XG4gICAgICAgIGxldCBwYXRjaFNpemU7XG4gICAgICAgIGxldCB3aWR0aCA9IGlucHV0U3RyZWFtLmdldFdpZHRoKCk7XG4gICAgICAgIGxldCBoZWlnaHQgPSBpbnB1dFN0cmVhbS5nZXRIZWlnaHQoKTtcbiAgICAgICAgY29uc3QgdGhpc0hhbGZTYW1wbGUgPSBjb25maWcuaGFsZlNhbXBsZSA/IDAuNSA6IDE7XG4gICAgICAgIGxldCBhcmVhO1xuXG4gICAgICAgIC8vIGNhbGN1bGF0ZSB3aWR0aCBhbmQgaGVpZ2h0IGJhc2VkIG9uIGFyZWFcbiAgICAgICAgaWYgKGlucHV0U3RyZWFtLmdldENvbmZpZygpLmFyZWEpIHtcbiAgICAgICAgICAgIGFyZWEgPSBjb21wdXRlSW1hZ2VBcmVhKHdpZHRoLCBoZWlnaHQsIGlucHV0U3RyZWFtLmdldENvbmZpZygpLmFyZWEpO1xuICAgICAgICAgICAgaW5wdXRTdHJlYW0uc2V0VG9wUmlnaHQoeyB4OiBhcmVhLnN4LCB5OiBhcmVhLnN5IH0pO1xuICAgICAgICAgICAgaW5wdXRTdHJlYW0uc2V0Q2FudmFzU2l6ZSh7IHg6IHdpZHRoLCB5OiBoZWlnaHQgfSk7XG4gICAgICAgICAgICB3aWR0aCA9IGFyZWEuc3c7XG4gICAgICAgICAgICBoZWlnaHQgPSBhcmVhLnNoO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgc2l6ZSA9IHtcbiAgICAgICAgICAgIHg6IE1hdGguZmxvb3Iod2lkdGggKiB0aGlzSGFsZlNhbXBsZSksXG4gICAgICAgICAgICB5OiBNYXRoLmZsb29yKGhlaWdodCAqIHRoaXNIYWxmU2FtcGxlKSxcbiAgICAgICAgfTtcblxuICAgICAgICBwYXRjaFNpemUgPSBjYWxjdWxhdGVQYXRjaFNpemUoY29uZmlnLnBhdGNoU2l6ZSwgc2l6ZSk7XG4gICAgICAgIGlmIChFTlYuZGV2ZWxvcG1lbnQpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGBQYXRjaC1TaXplOiAke0pTT04uc3RyaW5naWZ5KHBhdGNoU2l6ZSl9YCk7XG4gICAgICAgIH1cblxuICAgICAgICBpbnB1dFN0cmVhbS5zZXRXaWR0aChNYXRoLmZsb29yKE1hdGguZmxvb3Ioc2l6ZS54IC8gcGF0Y2hTaXplLngpICogKDEgLyB0aGlzSGFsZlNhbXBsZSkgKiBwYXRjaFNpemUueCkpO1xuICAgICAgICBpbnB1dFN0cmVhbS5zZXRIZWlnaHQoTWF0aC5mbG9vcihNYXRoLmZsb29yKHNpemUueSAvIHBhdGNoU2l6ZS55KSAqICgxIC8gdGhpc0hhbGZTYW1wbGUpICogcGF0Y2hTaXplLnkpKTtcblxuICAgICAgICBpZiAoKGlucHV0U3RyZWFtLmdldFdpZHRoKCkgJSBwYXRjaFNpemUueCkgPT09IDAgJiYgKGlucHV0U3RyZWFtLmdldEhlaWdodCgpICUgcGF0Y2hTaXplLnkpID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW1hZ2UgZGltZW5zaW9ucyBkbyBub3QgY29tcGx5IHdpdGggdGhlIGN1cnJlbnQgc2V0dGluZ3M6IFdpZHRoICgke1xuICAgICAgICAgICAgd2lkdGh9IClhbmQgaGVpZ2h0ICgke2hlaWdodFxuICAgICAgICB9KSBtdXN0IGEgbXVsdGlwbGUgb2YgJHtwYXRjaFNpemUueH1gKTtcbiAgICB9LFxufTtcbiIsInZhciBsaXN0Q2FjaGVDbGVhciA9IHJlcXVpcmUoJy4vX2xpc3RDYWNoZUNsZWFyJyksXG4gICAgbGlzdENhY2hlRGVsZXRlID0gcmVxdWlyZSgnLi9fbGlzdENhY2hlRGVsZXRlJyksXG4gICAgbGlzdENhY2hlR2V0ID0gcmVxdWlyZSgnLi9fbGlzdENhY2hlR2V0JyksXG4gICAgbGlzdENhY2hlSGFzID0gcmVxdWlyZSgnLi9fbGlzdENhY2hlSGFzJyksXG4gICAgbGlzdENhY2hlU2V0ID0gcmVxdWlyZSgnLi9fbGlzdENhY2hlU2V0Jyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBsaXN0IGNhY2hlIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gTGlzdENhY2hlKGVudHJpZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBlbnRyaWVzID09IG51bGwgPyAwIDogZW50cmllcy5sZW5ndGg7XG5cbiAgdGhpcy5jbGVhcigpO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaW5kZXhdO1xuICAgIHRoaXMuc2V0KGVudHJ5WzBdLCBlbnRyeVsxXSk7XG4gIH1cbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYExpc3RDYWNoZWAuXG5MaXN0Q2FjaGUucHJvdG90eXBlLmNsZWFyID0gbGlzdENhY2hlQ2xlYXI7XG5MaXN0Q2FjaGUucHJvdG90eXBlWydkZWxldGUnXSA9IGxpc3RDYWNoZURlbGV0ZTtcbkxpc3RDYWNoZS5wcm90b3R5cGUuZ2V0ID0gbGlzdENhY2hlR2V0O1xuTGlzdENhY2hlLnByb3RvdHlwZS5oYXMgPSBsaXN0Q2FjaGVIYXM7XG5MaXN0Q2FjaGUucHJvdG90eXBlLnNldCA9IGxpc3RDYWNoZVNldDtcblxubW9kdWxlLmV4cG9ydHMgPSBMaXN0Q2FjaGU7XG4iLCJ2YXIgZXEgPSByZXF1aXJlKCcuL2VxJyk7XG5cbi8qKlxuICogR2V0cyB0aGUgaW5kZXggYXQgd2hpY2ggdGhlIGBrZXlgIGlzIGZvdW5kIGluIGBhcnJheWAgb2Yga2V5LXZhbHVlIHBhaXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7Kn0ga2V5IFRoZSBrZXkgdG8gc2VhcmNoIGZvci5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlLCBlbHNlIGAtMWAuXG4gKi9cbmZ1bmN0aW9uIGFzc29jSW5kZXhPZihhcnJheSwga2V5KSB7XG4gIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG4gIHdoaWxlIChsZW5ndGgtLSkge1xuICAgIGlmIChlcShhcnJheVtsZW5ndGhdWzBdLCBrZXkpKSB7XG4gICAgICByZXR1cm4gbGVuZ3RoO1xuICAgIH1cbiAgfVxuICByZXR1cm4gLTE7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXNzb2NJbmRleE9mO1xuIiwiLyoqXG4gKiBQZXJmb3JtcyBhXG4gKiBbYFNhbWVWYWx1ZVplcm9gXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1zYW1ldmFsdWV6ZXJvKVxuICogY29tcGFyaXNvbiBiZXR3ZWVuIHR3byB2YWx1ZXMgdG8gZGV0ZXJtaW5lIGlmIHRoZXkgYXJlIGVxdWl2YWxlbnQuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSB2YWx1ZXMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxIH07XG4gKiB2YXIgb3RoZXIgPSB7ICdhJzogMSB9O1xuICpcbiAqIF8uZXEob2JqZWN0LCBvYmplY3QpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uZXEob2JqZWN0LCBvdGhlcik7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uZXEoJ2EnLCAnYScpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uZXEoJ2EnLCBPYmplY3QoJ2EnKSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uZXEoTmFOLCBOYU4pO1xuICogLy8gPT4gdHJ1ZVxuICovXG5mdW5jdGlvbiBlcSh2YWx1ZSwgb3RoZXIpIHtcbiAgcmV0dXJuIHZhbHVlID09PSBvdGhlciB8fCAodmFsdWUgIT09IHZhbHVlICYmIG90aGVyICE9PSBvdGhlcik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXE7XG4iLCJ2YXIgcm9vdCA9IHJlcXVpcmUoJy4vX3Jvb3QnKTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgU3ltYm9sID0gcm9vdC5TeW1ib2w7XG5cbm1vZHVsZS5leHBvcnRzID0gU3ltYm9sO1xuIiwidmFyIGdldE5hdGl2ZSA9IHJlcXVpcmUoJy4vX2dldE5hdGl2ZScpO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB0aGF0IGFyZSB2ZXJpZmllZCB0byBiZSBuYXRpdmUuICovXG52YXIgbmF0aXZlQ3JlYXRlID0gZ2V0TmF0aXZlKE9iamVjdCwgJ2NyZWF0ZScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IG5hdGl2ZUNyZWF0ZTtcbiIsInZhciBpc0tleWFibGUgPSByZXF1aXJlKCcuL19pc0tleWFibGUnKTtcblxuLyoqXG4gKiBHZXRzIHRoZSBkYXRhIGZvciBgbWFwYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG1hcCBUaGUgbWFwIHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUgcmVmZXJlbmNlIGtleS5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBtYXAgZGF0YS5cbiAqL1xuZnVuY3Rpb24gZ2V0TWFwRGF0YShtYXAsIGtleSkge1xuICB2YXIgZGF0YSA9IG1hcC5fX2RhdGFfXztcbiAgcmV0dXJuIGlzS2V5YWJsZShrZXkpXG4gICAgPyBkYXRhW3R5cGVvZiBrZXkgPT0gJ3N0cmluZycgPyAnc3RyaW5nJyA6ICdoYXNoJ11cbiAgICA6IGRhdGEubWFwO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldE1hcERhdGE7XG4iLCJ2YXIgYmFzZUlzQXJndW1lbnRzID0gcmVxdWlyZSgnLi9fYmFzZUlzQXJndW1lbnRzJyksXG4gICAgaXNPYmplY3RMaWtlID0gcmVxdWlyZSgnLi9pc09iamVjdExpa2UnKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgcHJvcGVydHlJc0VudW1lcmFibGUgPSBvYmplY3RQcm90by5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBsaWtlbHkgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGBhcmd1bWVudHNgIG9iamVjdCxcbiAqICBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcmd1bWVudHMoZnVuY3Rpb24oKSB7IHJldHVybiBhcmd1bWVudHM7IH0oKSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FyZ3VtZW50cyhbMSwgMiwgM10pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzQXJndW1lbnRzID0gYmFzZUlzQXJndW1lbnRzKGZ1bmN0aW9uKCkgeyByZXR1cm4gYXJndW1lbnRzOyB9KCkpID8gYmFzZUlzQXJndW1lbnRzIDogZnVuY3Rpb24odmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgJ2NhbGxlZScpICYmXG4gICAgIXByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwodmFsdWUsICdjYWxsZWUnKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gaXNBcmd1bWVudHM7XG4iLCIvKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbnZhciBNQVhfU0FGRV9JTlRFR0VSID0gOTAwNzE5OTI1NDc0MDk5MTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IHVuc2lnbmVkIGludGVnZXIgdmFsdWVzLiAqL1xudmFyIHJlSXNVaW50ID0gL14oPzowfFsxLTldXFxkKikkLztcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGFycmF5LWxpa2UgaW5kZXguXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHBhcmFtIHtudW1iZXJ9IFtsZW5ndGg9TUFYX1NBRkVfSU5URUdFUl0gVGhlIHVwcGVyIGJvdW5kcyBvZiBhIHZhbGlkIGluZGV4LlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBpbmRleCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0luZGV4KHZhbHVlLCBsZW5ndGgpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIGxlbmd0aCA9IGxlbmd0aCA9PSBudWxsID8gTUFYX1NBRkVfSU5URUdFUiA6IGxlbmd0aDtcblxuICByZXR1cm4gISFsZW5ndGggJiZcbiAgICAodHlwZSA9PSAnbnVtYmVyJyB8fFxuICAgICAgKHR5cGUgIT0gJ3N5bWJvbCcgJiYgcmVJc1VpbnQudGVzdCh2YWx1ZSkpKSAmJlxuICAgICAgICAodmFsdWUgPiAtMSAmJiB2YWx1ZSAlIDEgPT0gMCAmJiB2YWx1ZSA8IGxlbmd0aCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNJbmRleDtcbiIsInZhciBpc0FycmF5ID0gcmVxdWlyZSgnLi9pc0FycmF5JyksXG4gICAgaXNLZXkgPSByZXF1aXJlKCcuL19pc0tleScpLFxuICAgIHN0cmluZ1RvUGF0aCA9IHJlcXVpcmUoJy4vX3N0cmluZ1RvUGF0aCcpLFxuICAgIHRvU3RyaW5nID0gcmVxdWlyZSgnLi90b1N0cmluZycpO1xuXG4vKipcbiAqIENhc3RzIGB2YWx1ZWAgdG8gYSBwYXRoIGFycmF5IGlmIGl0J3Mgbm90IG9uZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHF1ZXJ5IGtleXMgb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGNhc3QgcHJvcGVydHkgcGF0aCBhcnJheS5cbiAqL1xuZnVuY3Rpb24gY2FzdFBhdGgodmFsdWUsIG9iamVjdCkge1xuICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgcmV0dXJuIGlzS2V5KHZhbHVlLCBvYmplY3QpID8gW3ZhbHVlXSA6IHN0cmluZ1RvUGF0aCh0b1N0cmluZyh2YWx1ZSkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNhc3RQYXRoO1xuIiwidmFyIGFycmF5V2l0aG91dEhvbGVzID0gcmVxdWlyZShcIi4vYXJyYXlXaXRob3V0SG9sZXMuanNcIik7XG5cbnZhciBpdGVyYWJsZVRvQXJyYXkgPSByZXF1aXJlKFwiLi9pdGVyYWJsZVRvQXJyYXkuanNcIik7XG5cbnZhciB1bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSA9IHJlcXVpcmUoXCIuL3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5LmpzXCIpO1xuXG52YXIgbm9uSXRlcmFibGVTcHJlYWQgPSByZXF1aXJlKFwiLi9ub25JdGVyYWJsZVNwcmVhZC5qc1wiKTtcblxuZnVuY3Rpb24gX3RvQ29uc3VtYWJsZUFycmF5KGFycikge1xuICByZXR1cm4gYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB8fCBpdGVyYWJsZVRvQXJyYXkoYXJyKSB8fCB1bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShhcnIpIHx8IG5vbkl0ZXJhYmxlU3ByZWFkKCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX3RvQ29uc3VtYWJsZUFycmF5LCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZSwgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHM7IiwidmFyIGJhc2VJc05hdGl2ZSA9IHJlcXVpcmUoJy4vX2Jhc2VJc05hdGl2ZScpLFxuICAgIGdldFZhbHVlID0gcmVxdWlyZSgnLi9fZ2V0VmFsdWUnKTtcblxuLyoqXG4gKiBHZXRzIHRoZSBuYXRpdmUgZnVuY3Rpb24gYXQgYGtleWAgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgbWV0aG9kIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBmdW5jdGlvbiBpZiBpdCdzIG5hdGl2ZSwgZWxzZSBgdW5kZWZpbmVkYC5cbiAqL1xuZnVuY3Rpb24gZ2V0TmF0aXZlKG9iamVjdCwga2V5KSB7XG4gIHZhciB2YWx1ZSA9IGdldFZhbHVlKG9iamVjdCwga2V5KTtcbiAgcmV0dXJuIGJhc2VJc05hdGl2ZSh2YWx1ZSkgPyB2YWx1ZSA6IHVuZGVmaW5lZDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXROYXRpdmU7XG4iLCJ2YXIgYmFzZUdldFRhZyA9IHJlcXVpcmUoJy4vX2Jhc2VHZXRUYWcnKSxcbiAgICBpc09iamVjdCA9IHJlcXVpcmUoJy4vaXNPYmplY3QnKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGFzeW5jVGFnID0gJ1tvYmplY3QgQXN5bmNGdW5jdGlvbl0nLFxuICAgIGZ1bmNUYWcgPSAnW29iamVjdCBGdW5jdGlvbl0nLFxuICAgIGdlblRhZyA9ICdbb2JqZWN0IEdlbmVyYXRvckZ1bmN0aW9uXScsXG4gICAgcHJveHlUYWcgPSAnW29iamVjdCBQcm94eV0nO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgRnVuY3Rpb25gIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIGZ1bmN0aW9uLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNGdW5jdGlvbihfKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzRnVuY3Rpb24oL2FiYy8pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNGdW5jdGlvbih2YWx1ZSkge1xuICBpZiAoIWlzT2JqZWN0KHZhbHVlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvLyBUaGUgdXNlIG9mIGBPYmplY3QjdG9TdHJpbmdgIGF2b2lkcyBpc3N1ZXMgd2l0aCB0aGUgYHR5cGVvZmAgb3BlcmF0b3JcbiAgLy8gaW4gU2FmYXJpIDkgd2hpY2ggcmV0dXJucyAnb2JqZWN0JyBmb3IgdHlwZWQgYXJyYXlzIGFuZCBvdGhlciBjb25zdHJ1Y3RvcnMuXG4gIHZhciB0YWcgPSBiYXNlR2V0VGFnKHZhbHVlKTtcbiAgcmV0dXJuIHRhZyA9PSBmdW5jVGFnIHx8IHRhZyA9PSBnZW5UYWcgfHwgdGFnID09IGFzeW5jVGFnIHx8IHRhZyA9PSBwcm94eVRhZztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0Z1bmN0aW9uO1xuIiwidmFyIGRlZmluZVByb3BlcnR5ID0gcmVxdWlyZSgnLi9fZGVmaW5lUHJvcGVydHknKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgYXNzaWduVmFsdWVgIGFuZCBgYXNzaWduTWVyZ2VWYWx1ZWAgd2l0aG91dFxuICogdmFsdWUgY2hlY2tzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBhc3NpZ24uXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBhc3NpZ24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VBc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgaWYgKGtleSA9PSAnX19wcm90b19fJyAmJiBkZWZpbmVQcm9wZXJ0eSkge1xuICAgIGRlZmluZVByb3BlcnR5KG9iamVjdCwga2V5LCB7XG4gICAgICAnY29uZmlndXJhYmxlJzogdHJ1ZSxcbiAgICAgICdlbnVtZXJhYmxlJzogdHJ1ZSxcbiAgICAgICd2YWx1ZSc6IHZhbHVlLFxuICAgICAgJ3dyaXRhYmxlJzogdHJ1ZVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIG9iamVjdFtrZXldID0gdmFsdWU7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlQXNzaWduVmFsdWU7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuXHRpZiAoIW1vZHVsZS53ZWJwYWNrUG9seWZpbGwpIHtcblx0XHRtb2R1bGUuZGVwcmVjYXRlID0gZnVuY3Rpb24oKSB7fTtcblx0XHRtb2R1bGUucGF0aHMgPSBbXTtcblx0XHQvLyBtb2R1bGUucGFyZW50ID0gdW5kZWZpbmVkIGJ5IGRlZmF1bHRcblx0XHRpZiAoIW1vZHVsZS5jaGlsZHJlbikgbW9kdWxlLmNoaWxkcmVuID0gW107XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG1vZHVsZSwgXCJsb2FkZWRcIiwge1xuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdGdldDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiBtb2R1bGUubDtcblx0XHRcdH1cblx0XHR9KTtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobW9kdWxlLCBcImlkXCIsIHtcblx0XHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gbW9kdWxlLmk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdFx0bW9kdWxlLndlYnBhY2tQb2x5ZmlsbCA9IDE7XG5cdH1cblx0cmV0dXJuIG1vZHVsZTtcbn07XG4iLCJ2YXIgaXNGdW5jdGlvbiA9IHJlcXVpcmUoJy4vaXNGdW5jdGlvbicpLFxuICAgIGlzTGVuZ3RoID0gcmVxdWlyZSgnLi9pc0xlbmd0aCcpO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGFycmF5LWxpa2UuIEEgdmFsdWUgaXMgY29uc2lkZXJlZCBhcnJheS1saWtlIGlmIGl0J3NcbiAqIG5vdCBhIGZ1bmN0aW9uIGFuZCBoYXMgYSBgdmFsdWUubGVuZ3RoYCB0aGF0J3MgYW4gaW50ZWdlciBncmVhdGVyIHRoYW4gb3JcbiAqIGVxdWFsIHRvIGAwYCBhbmQgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIGBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUmAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYXJyYXktbGlrZSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZShkb2N1bWVudC5ib2R5LmNoaWxkcmVuKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKCdhYmMnKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0FycmF5TGlrZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiBpc0xlbmd0aCh2YWx1ZS5sZW5ndGgpICYmICFpc0Z1bmN0aW9uKHZhbHVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0FycmF5TGlrZTtcbiIsIi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIE1BWF9TQUZFX0lOVEVHRVIgPSA5MDA3MTk5MjU0NzQwOTkxO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgYXJyYXktbGlrZSBsZW5ndGguXG4gKlxuICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGxvb3NlbHkgYmFzZWQgb25cbiAqIFtgVG9MZW5ndGhgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy10b2xlbmd0aCkuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBsZW5ndGgsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0xlbmd0aCgzKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzTGVuZ3RoKE51bWJlci5NSU5fVkFMVUUpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzTGVuZ3RoKEluZmluaXR5KTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0xlbmd0aCgnMycpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNMZW5ndGgodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJyAmJlxuICAgIHZhbHVlID4gLTEgJiYgdmFsdWUgJSAxID09IDAgJiYgdmFsdWUgPD0gTUFYX1NBRkVfSU5URUdFUjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0xlbmd0aDtcbiIsImZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mLmJpbmQoKSA6IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gICAgby5fX3Byb3RvX18gPSBwO1xuICAgIHJldHVybiBvO1xuICB9LCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZSwgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHM7XG4gIHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX3NldFByb3RvdHlwZU9mLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZSwgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHM7IiwidmFyIGJhc2VHZXRUYWcgPSByZXF1aXJlKCcuL19iYXNlR2V0VGFnJyksXG4gICAgaXNPYmplY3RMaWtlID0gcmVxdWlyZSgnLi9pc09iamVjdExpa2UnKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIHN5bWJvbFRhZyA9ICdbb2JqZWN0IFN5bWJvbF0nO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgU3ltYm9sYCBwcmltaXRpdmUgb3Igb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgc3ltYm9sLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNTeW1ib2woU3ltYm9sLml0ZXJhdG9yKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzU3ltYm9sKCdhYmMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzU3ltYm9sKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ3N5bWJvbCcgfHxcbiAgICAoaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBiYXNlR2V0VGFnKHZhbHVlKSA9PSBzeW1ib2xUYWcpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzU3ltYm9sO1xuIiwidmFyIGlzU3ltYm9sID0gcmVxdWlyZSgnLi9pc1N5bWJvbCcpO1xuXG4vKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbnZhciBJTkZJTklUWSA9IDEgLyAwO1xuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBzdHJpbmcga2V5IGlmIGl0J3Mgbm90IGEgc3RyaW5nIG9yIHN5bWJvbC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gaW5zcGVjdC5cbiAqIEByZXR1cm5zIHtzdHJpbmd8c3ltYm9sfSBSZXR1cm5zIHRoZSBrZXkuXG4gKi9cbmZ1bmN0aW9uIHRvS2V5KHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT0gJ3N0cmluZycgfHwgaXNTeW1ib2wodmFsdWUpKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIHZhciByZXN1bHQgPSAodmFsdWUgKyAnJyk7XG4gIHJldHVybiAocmVzdWx0ID09ICcwJyAmJiAoMSAvIHZhbHVlKSA9PSAtSU5GSU5JVFkpID8gJy0wJyA6IHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB0b0tleTtcbiIsInZhciBnZXROYXRpdmUgPSByZXF1aXJlKCcuL19nZXROYXRpdmUnKSxcbiAgICByb290ID0gcmVxdWlyZSgnLi9fcm9vdCcpO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB0aGF0IGFyZSB2ZXJpZmllZCB0byBiZSBuYXRpdmUuICovXG52YXIgTWFwID0gZ2V0TmF0aXZlKHJvb3QsICdNYXAnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBNYXA7XG4iLCIvKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGdsb2JhbGAgZnJvbSBOb2RlLmpzLiAqL1xudmFyIGZyZWVHbG9iYWwgPSB0eXBlb2YgZ2xvYmFsID09ICdvYmplY3QnICYmIGdsb2JhbCAmJiBnbG9iYWwuT2JqZWN0ID09PSBPYmplY3QgJiYgZ2xvYmFsO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZyZWVHbG9iYWw7XG4iLCJ2YXIgZztcblxuLy8gVGhpcyB3b3JrcyBpbiBub24tc3RyaWN0IG1vZGVcbmcgPSAoZnVuY3Rpb24oKSB7XG5cdHJldHVybiB0aGlzO1xufSkoKTtcblxudHJ5IHtcblx0Ly8gVGhpcyB3b3JrcyBpZiBldmFsIGlzIGFsbG93ZWQgKHNlZSBDU1ApXG5cdGcgPSBnIHx8IG5ldyBGdW5jdGlvbihcInJldHVybiB0aGlzXCIpKCk7XG59IGNhdGNoIChlKSB7XG5cdC8vIFRoaXMgd29ya3MgaWYgdGhlIHdpbmRvdyByZWZlcmVuY2UgaXMgYXZhaWxhYmxlXG5cdGlmICh0eXBlb2Ygd2luZG93ID09PSBcIm9iamVjdFwiKSBnID0gd2luZG93O1xufVxuXG4vLyBnIGNhbiBzdGlsbCBiZSB1bmRlZmluZWQsIGJ1dCBub3RoaW5nIHRvIGRvIGFib3V0IGl0Li4uXG4vLyBXZSByZXR1cm4gdW5kZWZpbmVkLCBpbnN0ZWFkIG9mIG5vdGhpbmcgaGVyZSwgc28gaXQnc1xuLy8gZWFzaWVyIHRvIGhhbmRsZSB0aGlzIGNhc2UuIGlmKCFnbG9iYWwpIHsgLi4ufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGc7XG4iLCJ2YXIgbWFwQ2FjaGVDbGVhciA9IHJlcXVpcmUoJy4vX21hcENhY2hlQ2xlYXInKSxcbiAgICBtYXBDYWNoZURlbGV0ZSA9IHJlcXVpcmUoJy4vX21hcENhY2hlRGVsZXRlJyksXG4gICAgbWFwQ2FjaGVHZXQgPSByZXF1aXJlKCcuL19tYXBDYWNoZUdldCcpLFxuICAgIG1hcENhY2hlSGFzID0gcmVxdWlyZSgnLi9fbWFwQ2FjaGVIYXMnKSxcbiAgICBtYXBDYWNoZVNldCA9IHJlcXVpcmUoJy4vX21hcENhY2hlU2V0Jyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIG1hcCBjYWNoZSBvYmplY3QgdG8gc3RvcmUga2V5LXZhbHVlIHBhaXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBNYXBDYWNoZShlbnRyaWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gZW50cmllcyA9PSBudWxsID8gMCA6IGVudHJpZXMubGVuZ3RoO1xuXG4gIHRoaXMuY2xlYXIoKTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgZW50cnkgPSBlbnRyaWVzW2luZGV4XTtcbiAgICB0aGlzLnNldChlbnRyeVswXSwgZW50cnlbMV0pO1xuICB9XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBNYXBDYWNoZWAuXG5NYXBDYWNoZS5wcm90b3R5cGUuY2xlYXIgPSBtYXBDYWNoZUNsZWFyO1xuTWFwQ2FjaGUucHJvdG90eXBlWydkZWxldGUnXSA9IG1hcENhY2hlRGVsZXRlO1xuTWFwQ2FjaGUucHJvdG90eXBlLmdldCA9IG1hcENhY2hlR2V0O1xuTWFwQ2FjaGUucHJvdG90eXBlLmhhcyA9IG1hcENhY2hlSGFzO1xuTWFwQ2FjaGUucHJvdG90eXBlLnNldCA9IG1hcENhY2hlU2V0O1xuXG5tb2R1bGUuZXhwb3J0cyA9IE1hcENhY2hlO1xuIiwidmFyIGJhc2VBc3NpZ25WYWx1ZSA9IHJlcXVpcmUoJy4vX2Jhc2VBc3NpZ25WYWx1ZScpLFxuICAgIGVxID0gcmVxdWlyZSgnLi9lcScpO1xuXG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gaXMgbGlrZSBgYXNzaWduVmFsdWVgIGV4Y2VwdCB0aGF0IGl0IGRvZXNuJ3QgYXNzaWduXG4gKiBgdW5kZWZpbmVkYCB2YWx1ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGFzc2lnbi5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGFzc2lnbi5cbiAqL1xuZnVuY3Rpb24gYXNzaWduTWVyZ2VWYWx1ZShvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgaWYgKCh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmICFlcShvYmplY3Rba2V5XSwgdmFsdWUpKSB8fFxuICAgICAgKHZhbHVlID09PSB1bmRlZmluZWQgJiYgIShrZXkgaW4gb2JqZWN0KSkpIHtcbiAgICBiYXNlQXNzaWduVmFsdWUob2JqZWN0LCBrZXksIHZhbHVlKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFzc2lnbk1lcmdlVmFsdWU7XG4iLCJ2YXIgZ2V0TmF0aXZlID0gcmVxdWlyZSgnLi9fZ2V0TmF0aXZlJyk7XG5cbnZhciBkZWZpbmVQcm9wZXJ0eSA9IChmdW5jdGlvbigpIHtcbiAgdHJ5IHtcbiAgICB2YXIgZnVuYyA9IGdldE5hdGl2ZShPYmplY3QsICdkZWZpbmVQcm9wZXJ0eScpO1xuICAgIGZ1bmMoe30sICcnLCB7fSk7XG4gICAgcmV0dXJuIGZ1bmM7XG4gIH0gY2F0Y2ggKGUpIHt9XG59KCkpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGRlZmluZVByb3BlcnR5O1xuIiwidmFyIG92ZXJBcmcgPSByZXF1aXJlKCcuL19vdmVyQXJnJyk7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIGdldFByb3RvdHlwZSA9IG92ZXJBcmcoT2JqZWN0LmdldFByb3RvdHlwZU9mLCBPYmplY3QpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGdldFByb3RvdHlwZTtcbiIsIi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgbGlrZWx5IGEgcHJvdG90eXBlIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHByb3RvdHlwZSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc1Byb3RvdHlwZSh2YWx1ZSkge1xuICB2YXIgQ3RvciA9IHZhbHVlICYmIHZhbHVlLmNvbnN0cnVjdG9yLFxuICAgICAgcHJvdG8gPSAodHlwZW9mIEN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBDdG9yLnByb3RvdHlwZSkgfHwgb2JqZWN0UHJvdG87XG5cbiAgcmV0dXJuIHZhbHVlID09PSBwcm90bztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc1Byb3RvdHlwZTtcbiIsInZhciByb290ID0gcmVxdWlyZSgnLi9fcm9vdCcpLFxuICAgIHN0dWJGYWxzZSA9IHJlcXVpcmUoJy4vc3R1YkZhbHNlJyk7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZXhwb3J0c2AuICovXG52YXIgZnJlZUV4cG9ydHMgPSB0eXBlb2YgZXhwb3J0cyA9PSAnb2JqZWN0JyAmJiBleHBvcnRzICYmICFleHBvcnRzLm5vZGVUeXBlICYmIGV4cG9ydHM7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgbW9kdWxlYC4gKi9cbnZhciBmcmVlTW9kdWxlID0gZnJlZUV4cG9ydHMgJiYgdHlwZW9mIG1vZHVsZSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUgJiYgIW1vZHVsZS5ub2RlVHlwZSAmJiBtb2R1bGU7XG5cbi8qKiBEZXRlY3QgdGhlIHBvcHVsYXIgQ29tbW9uSlMgZXh0ZW5zaW9uIGBtb2R1bGUuZXhwb3J0c2AuICovXG52YXIgbW9kdWxlRXhwb3J0cyA9IGZyZWVNb2R1bGUgJiYgZnJlZU1vZHVsZS5leHBvcnRzID09PSBmcmVlRXhwb3J0cztcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgQnVmZmVyID0gbW9kdWxlRXhwb3J0cyA/IHJvb3QuQnVmZmVyIDogdW5kZWZpbmVkO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlSXNCdWZmZXIgPSBCdWZmZXIgPyBCdWZmZXIuaXNCdWZmZXIgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBidWZmZXIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjMuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBidWZmZXIsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0J1ZmZlcihuZXcgQnVmZmVyKDIpKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQnVmZmVyKG5ldyBVaW50OEFycmF5KDIpKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc0J1ZmZlciA9IG5hdGl2ZUlzQnVmZmVyIHx8IHN0dWJGYWxzZTtcblxubW9kdWxlLmV4cG9ydHMgPSBpc0J1ZmZlcjtcbiIsInZhciBiYXNlSXNUeXBlZEFycmF5ID0gcmVxdWlyZSgnLi9fYmFzZUlzVHlwZWRBcnJheScpLFxuICAgIGJhc2VVbmFyeSA9IHJlcXVpcmUoJy4vX2Jhc2VVbmFyeScpLFxuICAgIG5vZGVVdGlsID0gcmVxdWlyZSgnLi9fbm9kZVV0aWwnKTtcblxuLyogTm9kZS5qcyBoZWxwZXIgcmVmZXJlbmNlcy4gKi9cbnZhciBub2RlSXNUeXBlZEFycmF5ID0gbm9kZVV0aWwgJiYgbm9kZVV0aWwuaXNUeXBlZEFycmF5O1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSB0eXBlZCBhcnJheS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDMuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHR5cGVkIGFycmF5LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNUeXBlZEFycmF5KG5ldyBVaW50OEFycmF5KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzVHlwZWRBcnJheShbXSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNUeXBlZEFycmF5ID0gbm9kZUlzVHlwZWRBcnJheSA/IGJhc2VVbmFyeShub2RlSXNUeXBlZEFycmF5KSA6IGJhc2VJc1R5cGVkQXJyYXk7XG5cbm1vZHVsZS5leHBvcnRzID0gaXNUeXBlZEFycmF5O1xuIiwiLyoqXG4gKiBHZXRzIHRoZSB2YWx1ZSBhdCBga2V5YCwgdW5sZXNzIGBrZXlgIGlzIFwiX19wcm90b19fXCIgb3IgXCJjb25zdHJ1Y3RvclwiLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBwcm9wZXJ0eSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gc2FmZUdldChvYmplY3QsIGtleSkge1xuICBpZiAoa2V5ID09PSAnY29uc3RydWN0b3InICYmIHR5cGVvZiBvYmplY3Rba2V5XSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChrZXkgPT0gJ19fcHJvdG9fXycpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICByZXR1cm4gb2JqZWN0W2tleV07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc2FmZUdldDtcbiIsInZhciBiYXNlQXNzaWduVmFsdWUgPSByZXF1aXJlKCcuL19iYXNlQXNzaWduVmFsdWUnKSxcbiAgICBlcSA9IHJlcXVpcmUoJy4vZXEnKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBBc3NpZ25zIGB2YWx1ZWAgdG8gYGtleWAgb2YgYG9iamVjdGAgaWYgdGhlIGV4aXN0aW5nIHZhbHVlIGlzIG5vdCBlcXVpdmFsZW50XG4gKiB1c2luZyBbYFNhbWVWYWx1ZVplcm9gXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1zYW1ldmFsdWV6ZXJvKVxuICogZm9yIGVxdWFsaXR5IGNvbXBhcmlzb25zLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBhc3NpZ24uXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBhc3NpZ24uXG4gKi9cbmZ1bmN0aW9uIGFzc2lnblZhbHVlKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICB2YXIgb2JqVmFsdWUgPSBvYmplY3Rba2V5XTtcbiAgaWYgKCEoaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkgJiYgZXEob2JqVmFsdWUsIHZhbHVlKSkgfHxcbiAgICAgICh2YWx1ZSA9PT0gdW5kZWZpbmVkICYmICEoa2V5IGluIG9iamVjdCkpKSB7XG4gICAgYmFzZUFzc2lnblZhbHVlKG9iamVjdCwga2V5LCB2YWx1ZSk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhc3NpZ25WYWx1ZTtcbiIsInZhciBhcnJheUxpa2VLZXlzID0gcmVxdWlyZSgnLi9fYXJyYXlMaWtlS2V5cycpLFxuICAgIGJhc2VLZXlzSW4gPSByZXF1aXJlKCcuL19iYXNlS2V5c0luJyksXG4gICAgaXNBcnJheUxpa2UgPSByZXF1aXJlKCcuL2lzQXJyYXlMaWtlJyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGFuZCBpbmhlcml0ZWQgZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBvZiBgb2JqZWN0YC5cbiAqXG4gKiAqKk5vdGU6KiogTm9uLW9iamVjdCB2YWx1ZXMgYXJlIGNvZXJjZWQgdG8gb2JqZWN0cy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDMuMC4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICogQGV4YW1wbGVcbiAqXG4gKiBmdW5jdGlvbiBGb28oKSB7XG4gKiAgIHRoaXMuYSA9IDE7XG4gKiAgIHRoaXMuYiA9IDI7XG4gKiB9XG4gKlxuICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAqXG4gKiBfLmtleXNJbihuZXcgRm9vKTtcbiAqIC8vID0+IFsnYScsICdiJywgJ2MnXSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICovXG5mdW5jdGlvbiBrZXlzSW4ob2JqZWN0KSB7XG4gIHJldHVybiBpc0FycmF5TGlrZShvYmplY3QpID8gYXJyYXlMaWtlS2V5cyhvYmplY3QsIHRydWUpIDogYmFzZUtleXNJbihvYmplY3QpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGtleXNJbjtcbiIsIi8qKlxuICogVGhpcyBtZXRob2QgcmV0dXJucyB0aGUgZmlyc3QgYXJndW1lbnQgaXQgcmVjZWl2ZXMuXG4gKlxuICogQHN0YXRpY1xuICogQHNpbmNlIDAuMS4wXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IFV0aWxcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgQW55IHZhbHVlLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgYHZhbHVlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxIH07XG4gKlxuICogY29uc29sZS5sb2coXy5pZGVudGl0eShvYmplY3QpID09PSBvYmplY3QpO1xuICogLy8gPT4gdHJ1ZVxuICovXG5mdW5jdGlvbiBpZGVudGl0eSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWU7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaWRlbnRpdHk7XG4iLCJ2YXIgYXBwbHkgPSByZXF1aXJlKCcuL19hcHBseScpO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlTWF4ID0gTWF0aC5tYXg7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlUmVzdGAgd2hpY2ggdHJhbnNmb3JtcyB0aGUgcmVzdCBhcnJheS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gYXBwbHkgYSByZXN0IHBhcmFtZXRlciB0by5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnQ9ZnVuYy5sZW5ndGgtMV0gVGhlIHN0YXJ0IHBvc2l0aW9uIG9mIHRoZSByZXN0IHBhcmFtZXRlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHRyYW5zZm9ybSBUaGUgcmVzdCBhcnJheSB0cmFuc2Zvcm0uXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gb3ZlclJlc3QoZnVuYywgc3RhcnQsIHRyYW5zZm9ybSkge1xuICBzdGFydCA9IG5hdGl2ZU1heChzdGFydCA9PT0gdW5kZWZpbmVkID8gKGZ1bmMubGVuZ3RoIC0gMSkgOiBzdGFydCwgMCk7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgYXJncyA9IGFyZ3VtZW50cyxcbiAgICAgICAgaW5kZXggPSAtMSxcbiAgICAgICAgbGVuZ3RoID0gbmF0aXZlTWF4KGFyZ3MubGVuZ3RoIC0gc3RhcnQsIDApLFxuICAgICAgICBhcnJheSA9IEFycmF5KGxlbmd0aCk7XG5cbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgYXJyYXlbaW5kZXhdID0gYXJnc1tzdGFydCArIGluZGV4XTtcbiAgICB9XG4gICAgaW5kZXggPSAtMTtcbiAgICB2YXIgb3RoZXJBcmdzID0gQXJyYXkoc3RhcnQgKyAxKTtcbiAgICB3aGlsZSAoKytpbmRleCA8IHN0YXJ0KSB7XG4gICAgICBvdGhlckFyZ3NbaW5kZXhdID0gYXJnc1tpbmRleF07XG4gICAgfVxuICAgIG90aGVyQXJnc1tzdGFydF0gPSB0cmFuc2Zvcm0oYXJyYXkpO1xuICAgIHJldHVybiBhcHBseShmdW5jLCB0aGlzLCBvdGhlckFyZ3MpO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG92ZXJSZXN0O1xuIiwidmFyIGJhc2VTZXRUb1N0cmluZyA9IHJlcXVpcmUoJy4vX2Jhc2VTZXRUb1N0cmluZycpLFxuICAgIHNob3J0T3V0ID0gcmVxdWlyZSgnLi9fc2hvcnRPdXQnKTtcblxuLyoqXG4gKiBTZXRzIHRoZSBgdG9TdHJpbmdgIG1ldGhvZCBvZiBgZnVuY2AgdG8gcmV0dXJuIGBzdHJpbmdgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBzdHJpbmcgVGhlIGB0b1N0cmluZ2AgcmVzdWx0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIGBmdW5jYC5cbiAqL1xudmFyIHNldFRvU3RyaW5nID0gc2hvcnRPdXQoYmFzZVNldFRvU3RyaW5nKTtcblxubW9kdWxlLmV4cG9ydHMgPSBzZXRUb1N0cmluZztcbiIsInZhciBhcnJheUxpa2VUb0FycmF5ID0gcmVxdWlyZShcIi4vYXJyYXlMaWtlVG9BcnJheS5qc1wiKTtcblxuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8sIG1pbkxlbikge1xuICBpZiAoIW8pIHJldHVybjtcbiAgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pO1xuICB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7XG4gIGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7XG4gIGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG8pO1xuICBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIGFycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXksIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlLCBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0czsiLCJmdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheShhcnIsIGxlbikge1xuICBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDtcblxuICBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIHtcbiAgICBhcnIyW2ldID0gYXJyW2ldO1xuICB9XG5cbiAgcmV0dXJuIGFycjI7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2FycmF5TGlrZVRvQXJyYXksIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlLCBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0czsiLCJ2YXIgYXJyYXlXaXRoSG9sZXMgPSByZXF1aXJlKFwiLi9hcnJheVdpdGhIb2xlcy5qc1wiKTtcblxudmFyIGl0ZXJhYmxlVG9BcnJheUxpbWl0ID0gcmVxdWlyZShcIi4vaXRlcmFibGVUb0FycmF5TGltaXQuanNcIik7XG5cbnZhciB1bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSA9IHJlcXVpcmUoXCIuL3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5LmpzXCIpO1xuXG52YXIgbm9uSXRlcmFibGVSZXN0ID0gcmVxdWlyZShcIi4vbm9uSXRlcmFibGVSZXN0LmpzXCIpO1xuXG5mdW5jdGlvbiBfc2xpY2VkVG9BcnJheShhcnIsIGkpIHtcbiAgcmV0dXJuIGFycmF5V2l0aEhvbGVzKGFycikgfHwgaXRlcmFibGVUb0FycmF5TGltaXQoYXJyLCBpKSB8fCB1bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShhcnIsIGkpIHx8IG5vbkl0ZXJhYmxlUmVzdCgpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9zbGljZWRUb0FycmF5LCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZSwgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHM7IiwidmFyIGJhc2VQaWNrID0gcmVxdWlyZSgnLi9fYmFzZVBpY2snKSxcbiAgICBmbGF0UmVzdCA9IHJlcXVpcmUoJy4vX2ZsYXRSZXN0Jyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBvYmplY3QgY29tcG9zZWQgb2YgdGhlIHBpY2tlZCBgb2JqZWN0YCBwcm9wZXJ0aWVzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBzaW5jZSAwLjEuMFxuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIHNvdXJjZSBvYmplY3QuXG4gKiBAcGFyYW0gey4uLihzdHJpbmd8c3RyaW5nW10pfSBbcGF0aHNdIFRoZSBwcm9wZXJ0eSBwYXRocyB0byBwaWNrLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxLCAnYic6ICcyJywgJ2MnOiAzIH07XG4gKlxuICogXy5waWNrKG9iamVjdCwgWydhJywgJ2MnXSk7XG4gKiAvLyA9PiB7ICdhJzogMSwgJ2MnOiAzIH1cbiAqL1xudmFyIHBpY2sgPSBmbGF0UmVzdChmdW5jdGlvbihvYmplY3QsIHBhdGhzKSB7XG4gIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IHt9IDogYmFzZVBpY2sob2JqZWN0LCBwYXRocyk7XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBwaWNrO1xuIiwidmFyIGdldFByb3RvdHlwZU9mID0gcmVxdWlyZShcIi4vZ2V0UHJvdG90eXBlT2YuanNcIik7XG5cbnZhciBzZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoXCIuL3NldFByb3RvdHlwZU9mLmpzXCIpO1xuXG52YXIgaXNOYXRpdmVGdW5jdGlvbiA9IHJlcXVpcmUoXCIuL2lzTmF0aXZlRnVuY3Rpb24uanNcIik7XG5cbnZhciBjb25zdHJ1Y3QgPSByZXF1aXJlKFwiLi9jb25zdHJ1Y3QuanNcIik7XG5cbmZ1bmN0aW9uIF93cmFwTmF0aXZlU3VwZXIoQ2xhc3MpIHtcbiAgdmFyIF9jYWNoZSA9IHR5cGVvZiBNYXAgPT09IFwiZnVuY3Rpb25cIiA/IG5ldyBNYXAoKSA6IHVuZGVmaW5lZDtcblxuICBtb2R1bGUuZXhwb3J0cyA9IF93cmFwTmF0aXZlU3VwZXIgPSBmdW5jdGlvbiBfd3JhcE5hdGl2ZVN1cGVyKENsYXNzKSB7XG4gICAgaWYgKENsYXNzID09PSBudWxsIHx8ICFpc05hdGl2ZUZ1bmN0aW9uKENsYXNzKSkgcmV0dXJuIENsYXNzO1xuXG4gICAgaWYgKHR5cGVvZiBDbGFzcyAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBfY2FjaGUgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIGlmIChfY2FjaGUuaGFzKENsYXNzKSkgcmV0dXJuIF9jYWNoZS5nZXQoQ2xhc3MpO1xuXG4gICAgICBfY2FjaGUuc2V0KENsYXNzLCBXcmFwcGVyKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBXcmFwcGVyKCkge1xuICAgICAgcmV0dXJuIGNvbnN0cnVjdChDbGFzcywgYXJndW1lbnRzLCBnZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3Rvcik7XG4gICAgfVxuXG4gICAgV3JhcHBlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKENsYXNzLnByb3RvdHlwZSwge1xuICAgICAgY29uc3RydWN0b3I6IHtcbiAgICAgICAgdmFsdWU6IFdyYXBwZXIsXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHNldFByb3RvdHlwZU9mKFdyYXBwZXIsIENsYXNzKTtcbiAgfSwgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzO1xuICByZXR1cm4gX3dyYXBOYXRpdmVTdXBlcihDbGFzcyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX3dyYXBOYXRpdmVTdXBlciwgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzOyIsImltcG9ydCBUcmFjZXIgZnJvbSAnLi90cmFjZXInO1xuXG4vKipcbiAqIGh0dHA6Ly93d3cuY29kZXByb2plY3QuY29tL1RpcHMvNDA3MTcyL0Nvbm5lY3RlZC1Db21wb25lbnQtTGFiZWxpbmctYW5kLVZlY3Rvcml6YXRpb25cbiAqL1xuY29uc3QgUmFzdGVyaXplciA9IHtcbiAgICBjcmVhdGVDb250b3VyMkQoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkaXI6IG51bGwsXG4gICAgICAgICAgICBpbmRleDogbnVsbCxcbiAgICAgICAgICAgIGZpcnN0VmVydGV4OiBudWxsLFxuICAgICAgICAgICAgaW5zaWRlQ29udG91cnM6IG51bGwsXG4gICAgICAgICAgICBuZXh0cGVlcjogbnVsbCxcbiAgICAgICAgICAgIHByZXZwZWVyOiBudWxsLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgQ09OVE9VUl9ESVI6IHtcbiAgICAgICAgQ1dfRElSOiAwLFxuICAgICAgICBDQ1dfRElSOiAxLFxuICAgICAgICBVTktOT1dOX0RJUjogMixcbiAgICB9LFxuICAgIERJUjoge1xuICAgICAgICBPVVRTSURFX0VER0U6IC0zMjc2NyxcbiAgICAgICAgSU5TSURFX0VER0U6IC0zMjc2NixcbiAgICB9LFxuICAgIGNyZWF0ZShpbWFnZVdyYXBwZXIsIGxhYmVsV3JhcHBlcikge1xuICAgICAgICBjb25zdCBpbWFnZURhdGEgPSBpbWFnZVdyYXBwZXIuZGF0YTtcbiAgICAgICAgY29uc3QgbGFiZWxEYXRhID0gbGFiZWxXcmFwcGVyLmRhdGE7XG4gICAgICAgIGNvbnN0IHdpZHRoID0gaW1hZ2VXcmFwcGVyLnNpemUueDtcbiAgICAgICAgY29uc3QgaGVpZ2h0ID0gaW1hZ2VXcmFwcGVyLnNpemUueTtcbiAgICAgICAgY29uc3QgdHJhY2VyID0gVHJhY2VyLmNyZWF0ZShpbWFnZVdyYXBwZXIsIGxhYmVsV3JhcHBlcik7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJhc3Rlcml6ZShkZXB0aGxhYmVsKSB7XG4gICAgICAgICAgICAgICAgbGV0IGNvbG9yO1xuICAgICAgICAgICAgICAgIGxldCBiYztcbiAgICAgICAgICAgICAgICBsZXQgbGM7XG4gICAgICAgICAgICAgICAgbGV0IGxhYmVsaW5kZXg7XG4gICAgICAgICAgICAgICAgbGV0IGN4O1xuICAgICAgICAgICAgICAgIGxldCBjeTtcbiAgICAgICAgICAgICAgICBjb25zdCBjb2xvck1hcCA9IFtdO1xuICAgICAgICAgICAgICAgIGxldCB2ZXJ0ZXg7XG4gICAgICAgICAgICAgICAgbGV0IHA7XG4gICAgICAgICAgICAgICAgbGV0IGNjO1xuICAgICAgICAgICAgICAgIGxldCBzYztcbiAgICAgICAgICAgICAgICBsZXQgcG9zO1xuICAgICAgICAgICAgICAgIGxldCBjb25uZWN0ZWRDb3VudCA9IDA7XG4gICAgICAgICAgICAgICAgbGV0IGk7XG5cbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgNDAwOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgY29sb3JNYXBbaV0gPSAwO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGNvbG9yTWFwWzBdID0gaW1hZ2VEYXRhWzBdO1xuICAgICAgICAgICAgICAgIGNjID0gbnVsbDtcbiAgICAgICAgICAgICAgICBmb3IgKGN5ID0gMTsgY3kgPCBoZWlnaHQgLSAxOyBjeSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGxhYmVsaW5kZXggPSAwO1xuICAgICAgICAgICAgICAgICAgICBiYyA9IGNvbG9yTWFwWzBdO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGN4ID0gMTsgY3ggPCB3aWR0aCAtIDE7IGN4KyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvcyA9IGN5ICogd2lkdGggKyBjeDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsYWJlbERhdGFbcG9zXSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yID0gaW1hZ2VEYXRhW3Bvc107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbG9yICE9PSBiYykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobGFiZWxpbmRleCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGMgPSBjb25uZWN0ZWRDb3VudCArIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xvck1hcFtsY10gPSBjb2xvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJjID0gY29sb3I7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2ZXJ0ZXggPSB0cmFjZXIuY29udG91clRyYWNpbmcoY3ksIGN4LCBsYywgY29sb3IsIFJhc3Rlcml6ZXIuRElSLk9VVFNJREVfRURHRSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodmVydGV4ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29ubmVjdGVkQ291bnQrKztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYWJlbGluZGV4ID0gbGM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcCA9IFJhc3Rlcml6ZXIuY3JlYXRlQ29udG91cjJEKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcC5kaXIgPSBSYXN0ZXJpemVyLkNPTlRPVVJfRElSLkNXX0RJUjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwLmluZGV4ID0gbGFiZWxpbmRleDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwLmZpcnN0VmVydGV4ID0gdmVydGV4O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHAubmV4dHBlZXIgPSBjYztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwLmluc2lkZUNvbnRvdXJzID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2MgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2MucHJldnBlZXIgPSBwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYyA9IHA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2ZXJ0ZXggPSB0cmFjZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuY29udG91clRyYWNpbmcoY3ksIGN4LCBSYXN0ZXJpemVyLkRJUi5JTlNJREVfRURHRSwgY29sb3IsIGxhYmVsaW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZlcnRleCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHAgPSBSYXN0ZXJpemVyLmNyZWF0ZUNvbnRvdXIyRCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHAuZmlyc3RWZXJ0ZXggPSB2ZXJ0ZXg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcC5pbnNpZGVDb250b3VycyA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRlcHRobGFiZWwgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcC5kaXIgPSBSYXN0ZXJpemVyLkNPTlRPVVJfRElSLkNDV19ESVI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcC5kaXIgPSBSYXN0ZXJpemVyLkNPTlRPVVJfRElSLkNXX0RJUjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcC5pbmRleCA9IGRlcHRobGFiZWw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2MgPSBjYztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoKHNjICE9PSBudWxsKSAmJiBzYy5pbmRleCAhPT0gbGFiZWxpbmRleCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzYyA9IHNjLm5leHRwZWVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2MgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcC5uZXh0cGVlciA9IHNjLmluc2lkZUNvbnRvdXJzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2MuaW5zaWRlQ29udG91cnMgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjLmluc2lkZUNvbnRvdXJzLnByZXZwZWVyID0gcDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzYy5pbnNpZGVDb250b3VycyA9IHA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWxEYXRhW3Bvc10gPSBsYWJlbGluZGV4O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobGFiZWxEYXRhW3Bvc10gPT09IFJhc3Rlcml6ZXIuRElSLk9VVFNJREVfRURHRVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8fCBsYWJlbERhdGFbcG9zXSA9PT0gUmFzdGVyaXplci5ESVIuSU5TSURFX0VER0UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYWJlbGluZGV4ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobGFiZWxEYXRhW3Bvc10gPT09IFJhc3Rlcml6ZXIuRElSLklOU0lERV9FREdFKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJjID0gaW1hZ2VEYXRhW3Bvc107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmMgPSBjb2xvck1hcFswXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsaW5kZXggPSBsYWJlbERhdGFbcG9zXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiYyA9IGNvbG9yTWFwW2xhYmVsaW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNjID0gY2M7XG4gICAgICAgICAgICAgICAgd2hpbGUgKHNjICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHNjLmluZGV4ID0gZGVwdGhsYWJlbDtcbiAgICAgICAgICAgICAgICAgICAgc2MgPSBzYy5uZXh0cGVlcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgY2MsXG4gICAgICAgICAgICAgICAgICAgIGNvdW50OiBjb25uZWN0ZWRDb3VudCxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGRlYnVnOiB7XG4gICAgICAgICAgICAgICAgZHJhd0NvbnRvdXIoY2FudmFzLCBmaXJzdENvbnRvdXIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBwcSA9IGZpcnN0Q29udG91cjtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGlxO1xuICAgICAgICAgICAgICAgICAgICBsZXQgcTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHA7XG5cbiAgICAgICAgICAgICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gJ3JlZCc7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSAncmVkJztcbiAgICAgICAgICAgICAgICAgICAgY3R4LmxpbmVXaWR0aCA9IDE7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHBxICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpcSA9IHBxLmluc2lkZUNvbnRvdXJzO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXEgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHBxICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXEgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBxID0gaXE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXEgPSBpcS5uZXh0cGVlcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcSA9IHBxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBxID0gcHEubmV4dHBlZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBxICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlxID0gcHEuaW5zaWRlQ29udG91cnM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXEgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChxLmRpcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgUmFzdGVyaXplci5DT05UT1VSX0RJUi5DV19ESVI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9ICdyZWQnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFJhc3Rlcml6ZXIuQ09OVE9VUl9ESVIuQ0NXX0RJUjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gJ2JsdWUnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFJhc3Rlcml6ZXIuQ09OVE9VUl9ESVIuVU5LTk9XTl9ESVI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9ICdncmVlbic7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBwID0gcS5maXJzdFZlcnRleDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5tb3ZlVG8ocC54LCBwLnkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHAgPSBwLm5leHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmxpbmVUbyhwLngsIHAueSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IHdoaWxlIChwICE9PSBxLmZpcnN0VmVydGV4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgIH0sXG59O1xuXG5leHBvcnQgZGVmYXVsdCBSYXN0ZXJpemVyO1xuIiwiLyogZXNsaW50LWRpc2FibGUgbm8tcGFyYW0tcmVhc3NpZ24gKi9cbi8qIGVzbGludC1kaXNhYmxlIG5vLWJpdHdpc2UgKi9cbi8qIGVzbGludC1kaXNhYmxlIGVxZXFlcSAqL1xuXG4vKiBAcHJlc2VydmUgQVNNIEJFR0lOICovXG5mdW5jdGlvbiBTa2VsZXRvbml6ZXIoc3RkbGliLCBmb3JlaWduLCBidWZmZXIpIHtcbiAgICAndXNlIGFzbSc7XG5cbiAgICBjb25zdCBpbWFnZXMgPSBuZXcgc3RkbGliLlVpbnQ4QXJyYXkoYnVmZmVyKTtcbiAgICBjb25zdCBzaXplID0gZm9yZWlnbi5zaXplIHwgMDtcbiAgICBjb25zdCB7IGltdWwgfSA9IHN0ZGxpYi5NYXRoO1xuXG4gICAgZnVuY3Rpb24gZXJvZGUoaW5JbWFnZVB0ciwgb3V0SW1hZ2VQdHIpIHtcbiAgICAgICAgaW5JbWFnZVB0ciB8PSAwO1xuICAgICAgICBvdXRJbWFnZVB0ciB8PSAwO1xuXG4gICAgICAgIGxldCB2ID0gMDtcbiAgICAgICAgbGV0IHUgPSAwO1xuICAgICAgICBsZXQgc3VtID0gMDtcbiAgICAgICAgbGV0IHlTdGFydDEgPSAwO1xuICAgICAgICBsZXQgeVN0YXJ0MiA9IDA7XG4gICAgICAgIGxldCB4U3RhcnQxID0gMDtcbiAgICAgICAgbGV0IHhTdGFydDIgPSAwO1xuICAgICAgICBsZXQgb2Zmc2V0ID0gMDtcblxuICAgICAgICBmb3IgKHYgPSAxOyAodiB8IDApIDwgKChzaXplIC0gMSkgfCAwKTsgdiA9ICh2ICsgMSkgfCAwKSB7XG4gICAgICAgICAgICBvZmZzZXQgPSAob2Zmc2V0ICsgc2l6ZSkgfCAwO1xuICAgICAgICAgICAgZm9yICh1ID0gMTsgKHUgfCAwKSA8ICgoc2l6ZSAtIDEpIHwgMCk7IHUgPSAodSArIDEpIHwgMCkge1xuICAgICAgICAgICAgICAgIHlTdGFydDEgPSAob2Zmc2V0IC0gc2l6ZSkgfCAwO1xuICAgICAgICAgICAgICAgIHlTdGFydDIgPSAob2Zmc2V0ICsgc2l6ZSkgfCAwO1xuICAgICAgICAgICAgICAgIHhTdGFydDEgPSAodSAtIDEpIHwgMDtcbiAgICAgICAgICAgICAgICB4U3RhcnQyID0gKHUgKyAxKSB8IDA7XG4gICAgICAgICAgICAgICAgc3VtID0gKChpbWFnZXNbKGluSW1hZ2VQdHIgKyB5U3RhcnQxICsgeFN0YXJ0MSkgfCAwXSB8IDApXG4gICAgICAgICAgICAgICAgICAgICsgKGltYWdlc1soaW5JbWFnZVB0ciArIHlTdGFydDEgKyB4U3RhcnQyKSB8IDBdIHwgMClcbiAgICAgICAgICAgICAgICAgICAgKyAoaW1hZ2VzWyhpbkltYWdlUHRyICsgb2Zmc2V0ICsgdSkgfCAwXSB8IDApXG4gICAgICAgICAgICAgICAgICAgICsgKGltYWdlc1soaW5JbWFnZVB0ciArIHlTdGFydDIgKyB4U3RhcnQxKSB8IDBdIHwgMClcbiAgICAgICAgICAgICAgICAgICAgKyAoaW1hZ2VzWyhpbkltYWdlUHRyICsgeVN0YXJ0MiArIHhTdGFydDIpIHwgMF0gfCAwKSkgfCAwO1xuICAgICAgICAgICAgICAgIGlmICgoc3VtIHwgMCkgPT0gKDUgfCAwKSkge1xuICAgICAgICAgICAgICAgICAgICBpbWFnZXNbKG91dEltYWdlUHRyICsgb2Zmc2V0ICsgdSkgfCAwXSA9IDE7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaW1hZ2VzWyhvdXRJbWFnZVB0ciArIG9mZnNldCArIHUpIHwgMF0gPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHN1YnRyYWN0KGFJbWFnZVB0ciwgYkltYWdlUHRyLCBvdXRJbWFnZVB0cikge1xuICAgICAgICBhSW1hZ2VQdHIgfD0gMDtcbiAgICAgICAgYkltYWdlUHRyIHw9IDA7XG4gICAgICAgIG91dEltYWdlUHRyIHw9IDA7XG5cbiAgICAgICAgbGV0IGxlbmd0aCA9IDA7XG5cbiAgICAgICAgbGVuZ3RoID0gaW11bChzaXplLCBzaXplKSB8IDA7XG5cbiAgICAgICAgd2hpbGUgKChsZW5ndGggfCAwKSA+IDApIHtcbiAgICAgICAgICAgIGxlbmd0aCA9IChsZW5ndGggLSAxKSB8IDA7XG4gICAgICAgICAgICBpbWFnZXNbKG91dEltYWdlUHRyICsgbGVuZ3RoKSB8IDBdID0gKChpbWFnZXNbKGFJbWFnZVB0ciArIGxlbmd0aCkgfCAwXSB8IDApIC0gKGltYWdlc1soYkltYWdlUHRyICsgbGVuZ3RoKSB8IDBdIHwgMCkpIHwgMDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGJpdHdpc2VPcihhSW1hZ2VQdHIsIGJJbWFnZVB0ciwgb3V0SW1hZ2VQdHIpIHtcbiAgICAgICAgYUltYWdlUHRyIHw9IDA7XG4gICAgICAgIGJJbWFnZVB0ciB8PSAwO1xuICAgICAgICBvdXRJbWFnZVB0ciB8PSAwO1xuXG4gICAgICAgIGxldCBsZW5ndGggPSAwO1xuXG4gICAgICAgIGxlbmd0aCA9IGltdWwoc2l6ZSwgc2l6ZSkgfCAwO1xuXG4gICAgICAgIHdoaWxlICgobGVuZ3RoIHwgMCkgPiAwKSB7XG4gICAgICAgICAgICBsZW5ndGggPSAobGVuZ3RoIC0gMSkgfCAwO1xuICAgICAgICAgICAgaW1hZ2VzWyhvdXRJbWFnZVB0ciArIGxlbmd0aCkgfCAwXSA9ICgoaW1hZ2VzWyhhSW1hZ2VQdHIgKyBsZW5ndGgpIHwgMF0gfCAwKSB8IChpbWFnZXNbKGJJbWFnZVB0ciArIGxlbmd0aCkgfCAwXSB8IDApKSB8IDA7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjb3VudE5vblplcm8oaW1hZ2VQdHIpIHtcbiAgICAgICAgaW1hZ2VQdHIgfD0gMDtcblxuICAgICAgICBsZXQgc3VtID0gMDtcbiAgICAgICAgbGV0IGxlbmd0aCA9IDA7XG5cbiAgICAgICAgbGVuZ3RoID0gaW11bChzaXplLCBzaXplKSB8IDA7XG5cbiAgICAgICAgd2hpbGUgKChsZW5ndGggfCAwKSA+IDApIHtcbiAgICAgICAgICAgIGxlbmd0aCA9IChsZW5ndGggLSAxKSB8IDA7XG4gICAgICAgICAgICBzdW0gPSAoKHN1bSB8IDApICsgKGltYWdlc1soaW1hZ2VQdHIgKyBsZW5ndGgpIHwgMF0gfCAwKSkgfCAwO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIChzdW0gfCAwKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbml0KGltYWdlUHRyLCB2YWx1ZSkge1xuICAgICAgICBpbWFnZVB0ciB8PSAwO1xuICAgICAgICB2YWx1ZSB8PSAwO1xuXG4gICAgICAgIGxldCBsZW5ndGggPSAwO1xuXG4gICAgICAgIGxlbmd0aCA9IGltdWwoc2l6ZSwgc2l6ZSkgfCAwO1xuXG4gICAgICAgIHdoaWxlICgobGVuZ3RoIHwgMCkgPiAwKSB7XG4gICAgICAgICAgICBsZW5ndGggPSAobGVuZ3RoIC0gMSkgfCAwO1xuICAgICAgICAgICAgaW1hZ2VzWyhpbWFnZVB0ciArIGxlbmd0aCkgfCAwXSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGlsYXRlKGluSW1hZ2VQdHIsIG91dEltYWdlUHRyKSB7XG4gICAgICAgIGluSW1hZ2VQdHIgfD0gMDtcbiAgICAgICAgb3V0SW1hZ2VQdHIgfD0gMDtcblxuICAgICAgICBsZXQgdiA9IDA7XG4gICAgICAgIGxldCB1ID0gMDtcbiAgICAgICAgbGV0IHN1bSA9IDA7XG4gICAgICAgIGxldCB5U3RhcnQxID0gMDtcbiAgICAgICAgbGV0IHlTdGFydDIgPSAwO1xuICAgICAgICBsZXQgeFN0YXJ0MSA9IDA7XG4gICAgICAgIGxldCB4U3RhcnQyID0gMDtcbiAgICAgICAgbGV0IG9mZnNldCA9IDA7XG5cbiAgICAgICAgZm9yICh2ID0gMTsgKHYgfCAwKSA8ICgoc2l6ZSAtIDEpIHwgMCk7IHYgPSAodiArIDEpIHwgMCkge1xuICAgICAgICAgICAgb2Zmc2V0ID0gKG9mZnNldCArIHNpemUpIHwgMDtcbiAgICAgICAgICAgIGZvciAodSA9IDE7ICh1IHwgMCkgPCAoKHNpemUgLSAxKSB8IDApOyB1ID0gKHUgKyAxKSB8IDApIHtcbiAgICAgICAgICAgICAgICB5U3RhcnQxID0gKG9mZnNldCAtIHNpemUpIHwgMDtcbiAgICAgICAgICAgICAgICB5U3RhcnQyID0gKG9mZnNldCArIHNpemUpIHwgMDtcbiAgICAgICAgICAgICAgICB4U3RhcnQxID0gKHUgLSAxKSB8IDA7XG4gICAgICAgICAgICAgICAgeFN0YXJ0MiA9ICh1ICsgMSkgfCAwO1xuICAgICAgICAgICAgICAgIHN1bSA9ICgoaW1hZ2VzWyhpbkltYWdlUHRyICsgeVN0YXJ0MSArIHhTdGFydDEpIHwgMF0gfCAwKVxuICAgICAgICAgICAgICAgICAgICArIChpbWFnZXNbKGluSW1hZ2VQdHIgKyB5U3RhcnQxICsgeFN0YXJ0MikgfCAwXSB8IDApXG4gICAgICAgICAgICAgICAgICAgICsgKGltYWdlc1soaW5JbWFnZVB0ciArIG9mZnNldCArIHUpIHwgMF0gfCAwKVxuICAgICAgICAgICAgICAgICAgICArIChpbWFnZXNbKGluSW1hZ2VQdHIgKyB5U3RhcnQyICsgeFN0YXJ0MSkgfCAwXSB8IDApXG4gICAgICAgICAgICAgICAgICAgICsgKGltYWdlc1soaW5JbWFnZVB0ciArIHlTdGFydDIgKyB4U3RhcnQyKSB8IDBdIHwgMCkpIHwgMDtcbiAgICAgICAgICAgICAgICBpZiAoKHN1bSB8IDApID4gKDAgfCAwKSkge1xuICAgICAgICAgICAgICAgICAgICBpbWFnZXNbKG91dEltYWdlUHRyICsgb2Zmc2V0ICsgdSkgfCAwXSA9IDE7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaW1hZ2VzWyhvdXRJbWFnZVB0ciArIG9mZnNldCArIHUpIHwgMF0gPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1lbWNweShzcmNJbWFnZVB0ciwgZHN0SW1hZ2VQdHIpIHtcbiAgICAgICAgc3JjSW1hZ2VQdHIgfD0gMDtcbiAgICAgICAgZHN0SW1hZ2VQdHIgfD0gMDtcblxuICAgICAgICBsZXQgbGVuZ3RoID0gMDtcblxuICAgICAgICBsZW5ndGggPSBpbXVsKHNpemUsIHNpemUpIHwgMDtcblxuICAgICAgICB3aGlsZSAoKGxlbmd0aCB8IDApID4gMCkge1xuICAgICAgICAgICAgbGVuZ3RoID0gKGxlbmd0aCAtIDEpIHwgMDtcbiAgICAgICAgICAgIGltYWdlc1soZHN0SW1hZ2VQdHIgKyBsZW5ndGgpIHwgMF0gPSAoaW1hZ2VzWyhzcmNJbWFnZVB0ciArIGxlbmd0aCkgfCAwXSB8IDApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gemVyb0JvcmRlcihpbWFnZVB0cikge1xuICAgICAgICBpbWFnZVB0ciB8PSAwO1xuXG4gICAgICAgIGxldCB4ID0gMDtcbiAgICAgICAgbGV0IHkgPSAwO1xuXG4gICAgICAgIGZvciAoeCA9IDA7ICh4IHwgMCkgPCAoKHNpemUgLSAxKSB8IDApOyB4ID0gKHggKyAxKSB8IDApIHtcbiAgICAgICAgICAgIGltYWdlc1soaW1hZ2VQdHIgKyB4KSB8IDBdID0gMDtcbiAgICAgICAgICAgIGltYWdlc1soaW1hZ2VQdHIgKyB5KSB8IDBdID0gMDtcbiAgICAgICAgICAgIHkgPSAoKHkgKyBzaXplKSAtIDEpIHwgMDtcbiAgICAgICAgICAgIGltYWdlc1soaW1hZ2VQdHIgKyB5KSB8IDBdID0gMDtcbiAgICAgICAgICAgIHkgPSAoeSArIDEpIHwgMDtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHggPSAwOyAoeCB8IDApIDwgKHNpemUgfCAwKTsgeCA9ICh4ICsgMSkgfCAwKSB7XG4gICAgICAgICAgICBpbWFnZXNbKGltYWdlUHRyICsgeSkgfCAwXSA9IDA7XG4gICAgICAgICAgICB5ID0gKHkgKyAxKSB8IDA7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBza2VsZXRvbml6ZSgpIHtcbiAgICAgICAgY29uc3Qgc3ViSW1hZ2VQdHIgPSAwO1xuICAgICAgICBsZXQgZXJvZGVkSW1hZ2VQdHIgPSAwO1xuICAgICAgICBsZXQgdGVtcEltYWdlUHRyID0gMDtcbiAgICAgICAgbGV0IHNrZWxJbWFnZVB0ciA9IDA7XG4gICAgICAgIGxldCBzdW0gPSAwO1xuICAgICAgICBsZXQgZG9uZSA9IDA7XG5cbiAgICAgICAgZXJvZGVkSW1hZ2VQdHIgPSBpbXVsKHNpemUsIHNpemUpIHwgMDtcbiAgICAgICAgdGVtcEltYWdlUHRyID0gKGVyb2RlZEltYWdlUHRyICsgZXJvZGVkSW1hZ2VQdHIpIHwgMDtcbiAgICAgICAgc2tlbEltYWdlUHRyID0gKHRlbXBJbWFnZVB0ciArIGVyb2RlZEltYWdlUHRyKSB8IDA7XG5cbiAgICAgICAgLy8gaW5pdCBza2VsLWltYWdlXG4gICAgICAgIGluaXQoc2tlbEltYWdlUHRyLCAwKTtcbiAgICAgICAgemVyb0JvcmRlcihzdWJJbWFnZVB0cik7XG5cbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgZXJvZGUoc3ViSW1hZ2VQdHIsIGVyb2RlZEltYWdlUHRyKTtcbiAgICAgICAgICAgIGRpbGF0ZShlcm9kZWRJbWFnZVB0ciwgdGVtcEltYWdlUHRyKTtcbiAgICAgICAgICAgIHN1YnRyYWN0KHN1YkltYWdlUHRyLCB0ZW1wSW1hZ2VQdHIsIHRlbXBJbWFnZVB0cik7XG4gICAgICAgICAgICBiaXR3aXNlT3Ioc2tlbEltYWdlUHRyLCB0ZW1wSW1hZ2VQdHIsIHNrZWxJbWFnZVB0cik7XG4gICAgICAgICAgICBtZW1jcHkoZXJvZGVkSW1hZ2VQdHIsIHN1YkltYWdlUHRyKTtcbiAgICAgICAgICAgIHN1bSA9IGNvdW50Tm9uWmVybyhzdWJJbWFnZVB0cikgfCAwO1xuICAgICAgICAgICAgZG9uZSA9ICgoc3VtIHwgMCkgPT0gMCB8IDApO1xuICAgICAgICB9IHdoaWxlICghZG9uZSk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIHNrZWxldG9uaXplLFxuICAgIH07XG59XG4vKiBAcHJlc2VydmUgQVNNIEVORCAqL1xuZXhwb3J0IGRlZmF1bHQgU2tlbGV0b25pemVyO1xuLyogZXNsaW50LWVuYWJsZSBlcWVxZXEgKi9cbiIsInZhciBTdGFjayA9IHJlcXVpcmUoJy4vX1N0YWNrJyksXG4gICAgYXNzaWduTWVyZ2VWYWx1ZSA9IHJlcXVpcmUoJy4vX2Fzc2lnbk1lcmdlVmFsdWUnKSxcbiAgICBiYXNlRm9yID0gcmVxdWlyZSgnLi9fYmFzZUZvcicpLFxuICAgIGJhc2VNZXJnZURlZXAgPSByZXF1aXJlKCcuL19iYXNlTWVyZ2VEZWVwJyksXG4gICAgaXNPYmplY3QgPSByZXF1aXJlKCcuL2lzT2JqZWN0JyksXG4gICAga2V5c0luID0gcmVxdWlyZSgnLi9rZXlzSW4nKSxcbiAgICBzYWZlR2V0ID0gcmVxdWlyZSgnLi9fc2FmZUdldCcpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLm1lcmdlYCB3aXRob3V0IHN1cHBvcnQgZm9yIG11bHRpcGxlIHNvdXJjZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIHNvdXJjZSBvYmplY3QuXG4gKiBAcGFyYW0ge251bWJlcn0gc3JjSW5kZXggVGhlIGluZGV4IG9mIGBzb3VyY2VgLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgbWVyZ2VkIHZhbHVlcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbc3RhY2tdIFRyYWNrcyB0cmF2ZXJzZWQgc291cmNlIHZhbHVlcyBhbmQgdGhlaXIgbWVyZ2VkXG4gKiAgY291bnRlcnBhcnRzLlxuICovXG5mdW5jdGlvbiBiYXNlTWVyZ2Uob2JqZWN0LCBzb3VyY2UsIHNyY0luZGV4LCBjdXN0b21pemVyLCBzdGFjaykge1xuICBpZiAob2JqZWN0ID09PSBzb3VyY2UpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgYmFzZUZvcihzb3VyY2UsIGZ1bmN0aW9uKHNyY1ZhbHVlLCBrZXkpIHtcbiAgICBzdGFjayB8fCAoc3RhY2sgPSBuZXcgU3RhY2spO1xuICAgIGlmIChpc09iamVjdChzcmNWYWx1ZSkpIHtcbiAgICAgIGJhc2VNZXJnZURlZXAob2JqZWN0LCBzb3VyY2UsIGtleSwgc3JjSW5kZXgsIGJhc2VNZXJnZSwgY3VzdG9taXplciwgc3RhY2spO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHZhciBuZXdWYWx1ZSA9IGN1c3RvbWl6ZXJcbiAgICAgICAgPyBjdXN0b21pemVyKHNhZmVHZXQob2JqZWN0LCBrZXkpLCBzcmNWYWx1ZSwgKGtleSArICcnKSwgb2JqZWN0LCBzb3VyY2UsIHN0YWNrKVxuICAgICAgICA6IHVuZGVmaW5lZDtcblxuICAgICAgaWYgKG5ld1ZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbmV3VmFsdWUgPSBzcmNWYWx1ZTtcbiAgICAgIH1cbiAgICAgIGFzc2lnbk1lcmdlVmFsdWUob2JqZWN0LCBrZXksIG5ld1ZhbHVlKTtcbiAgICB9XG4gIH0sIGtleXNJbik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZU1lcmdlO1xuIiwidmFyIExpc3RDYWNoZSA9IHJlcXVpcmUoJy4vX0xpc3RDYWNoZScpLFxuICAgIHN0YWNrQ2xlYXIgPSByZXF1aXJlKCcuL19zdGFja0NsZWFyJyksXG4gICAgc3RhY2tEZWxldGUgPSByZXF1aXJlKCcuL19zdGFja0RlbGV0ZScpLFxuICAgIHN0YWNrR2V0ID0gcmVxdWlyZSgnLi9fc3RhY2tHZXQnKSxcbiAgICBzdGFja0hhcyA9IHJlcXVpcmUoJy4vX3N0YWNrSGFzJyksXG4gICAgc3RhY2tTZXQgPSByZXF1aXJlKCcuL19zdGFja1NldCcpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBzdGFjayBjYWNoZSBvYmplY3QgdG8gc3RvcmUga2V5LXZhbHVlIHBhaXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBTdGFjayhlbnRyaWVzKSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyA9IG5ldyBMaXN0Q2FjaGUoZW50cmllcyk7XG4gIHRoaXMuc2l6ZSA9IGRhdGEuc2l6ZTtcbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYFN0YWNrYC5cblN0YWNrLnByb3RvdHlwZS5jbGVhciA9IHN0YWNrQ2xlYXI7XG5TdGFjay5wcm90b3R5cGVbJ2RlbGV0ZSddID0gc3RhY2tEZWxldGU7XG5TdGFjay5wcm90b3R5cGUuZ2V0ID0gc3RhY2tHZXQ7XG5TdGFjay5wcm90b3R5cGUuaGFzID0gc3RhY2tIYXM7XG5TdGFjay5wcm90b3R5cGUuc2V0ID0gc3RhY2tTZXQ7XG5cbm1vZHVsZS5leHBvcnRzID0gU3RhY2s7XG4iLCIvKipcbiAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIGxpc3QgY2FjaGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGNsZWFyXG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZUNsZWFyKCkge1xuICB0aGlzLl9fZGF0YV9fID0gW107XG4gIHRoaXMuc2l6ZSA9IDA7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbGlzdENhY2hlQ2xlYXI7XG4iLCJ2YXIgYXNzb2NJbmRleE9mID0gcmVxdWlyZSgnLi9fYXNzb2NJbmRleE9mJyk7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBhcnJheVByb3RvID0gQXJyYXkucHJvdG90eXBlO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBzcGxpY2UgPSBhcnJheVByb3RvLnNwbGljZTtcblxuLyoqXG4gKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgbGlzdCBjYWNoZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZGVsZXRlXG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlRGVsZXRlKGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICBpbmRleCA9IGFzc29jSW5kZXhPZihkYXRhLCBrZXkpO1xuXG4gIGlmIChpbmRleCA8IDApIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIGxhc3RJbmRleCA9IGRhdGEubGVuZ3RoIC0gMTtcbiAgaWYgKGluZGV4ID09IGxhc3RJbmRleCkge1xuICAgIGRhdGEucG9wKCk7XG4gIH0gZWxzZSB7XG4gICAgc3BsaWNlLmNhbGwoZGF0YSwgaW5kZXgsIDEpO1xuICB9XG4gIC0tdGhpcy5zaXplO1xuICByZXR1cm4gdHJ1ZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBsaXN0Q2FjaGVEZWxldGU7XG4iLCJ2YXIgYXNzb2NJbmRleE9mID0gcmVxdWlyZSgnLi9fYXNzb2NJbmRleE9mJyk7XG5cbi8qKlxuICogR2V0cyB0aGUgbGlzdCBjYWNoZSB2YWx1ZSBmb3IgYGtleWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGdldFxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZUdldChrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgaW5kZXggPSBhc3NvY0luZGV4T2YoZGF0YSwga2V5KTtcblxuICByZXR1cm4gaW5kZXggPCAwID8gdW5kZWZpbmVkIDogZGF0YVtpbmRleF1bMV07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbGlzdENhY2hlR2V0O1xuIiwidmFyIGFzc29jSW5kZXhPZiA9IHJlcXVpcmUoJy4vX2Fzc29jSW5kZXhPZicpO1xuXG4vKipcbiAqIENoZWNrcyBpZiBhIGxpc3QgY2FjaGUgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlSGFzKGtleSkge1xuICByZXR1cm4gYXNzb2NJbmRleE9mKHRoaXMuX19kYXRhX18sIGtleSkgPiAtMTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBsaXN0Q2FjaGVIYXM7XG4iLCJ2YXIgYXNzb2NJbmRleE9mID0gcmVxdWlyZSgnLi9fYXNzb2NJbmRleE9mJyk7XG5cbi8qKlxuICogU2V0cyB0aGUgbGlzdCBjYWNoZSBga2V5YCB0byBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBzZXRcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbGlzdCBjYWNoZSBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlU2V0KGtleSwgdmFsdWUpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgaW5kZXggPSBhc3NvY0luZGV4T2YoZGF0YSwga2V5KTtcblxuICBpZiAoaW5kZXggPCAwKSB7XG4gICAgKyt0aGlzLnNpemU7XG4gICAgZGF0YS5wdXNoKFtrZXksIHZhbHVlXSk7XG4gIH0gZWxzZSB7XG4gICAgZGF0YVtpbmRleF1bMV0gPSB2YWx1ZTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBsaXN0Q2FjaGVTZXQ7XG4iLCJ2YXIgTGlzdENhY2hlID0gcmVxdWlyZSgnLi9fTGlzdENhY2hlJyk7XG5cbi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgc3RhY2suXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGNsZWFyXG4gKiBAbWVtYmVyT2YgU3RhY2tcbiAqL1xuZnVuY3Rpb24gc3RhY2tDbGVhcigpIHtcbiAgdGhpcy5fX2RhdGFfXyA9IG5ldyBMaXN0Q2FjaGU7XG4gIHRoaXMuc2l6ZSA9IDA7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3RhY2tDbGVhcjtcbiIsIi8qKlxuICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIHN0YWNrLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBkZWxldGVcbiAqIEBtZW1iZXJPZiBTdGFja1xuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIHN0YWNrRGVsZXRlKGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICByZXN1bHQgPSBkYXRhWydkZWxldGUnXShrZXkpO1xuXG4gIHRoaXMuc2l6ZSA9IGRhdGEuc2l6ZTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdGFja0RlbGV0ZTtcbiIsIi8qKlxuICogR2V0cyB0aGUgc3RhY2sgdmFsdWUgZm9yIGBrZXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBnZXRcbiAqIEBtZW1iZXJPZiBTdGFja1xuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIHN0YWNrR2V0KGtleSkge1xuICByZXR1cm4gdGhpcy5fX2RhdGFfXy5nZXQoa2V5KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdGFja0dldDtcbiIsIi8qKlxuICogQ2hlY2tzIGlmIGEgc3RhY2sgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgU3RhY2tcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBzdGFja0hhcyhrZXkpIHtcbiAgcmV0dXJuIHRoaXMuX19kYXRhX18uaGFzKGtleSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3RhY2tIYXM7XG4iLCJ2YXIgTGlzdENhY2hlID0gcmVxdWlyZSgnLi9fTGlzdENhY2hlJyksXG4gICAgTWFwID0gcmVxdWlyZSgnLi9fTWFwJyksXG4gICAgTWFwQ2FjaGUgPSByZXF1aXJlKCcuL19NYXBDYWNoZScpO1xuXG4vKiogVXNlZCBhcyB0aGUgc2l6ZSB0byBlbmFibGUgbGFyZ2UgYXJyYXkgb3B0aW1pemF0aW9ucy4gKi9cbnZhciBMQVJHRV9BUlJBWV9TSVpFID0gMjAwO1xuXG4vKipcbiAqIFNldHMgdGhlIHN0YWNrIGBrZXlgIHRvIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIHNldFxuICogQG1lbWJlck9mIFN0YWNrXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIHN0YWNrIGNhY2hlIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBzdGFja1NldChrZXksIHZhbHVlKSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgaWYgKGRhdGEgaW5zdGFuY2VvZiBMaXN0Q2FjaGUpIHtcbiAgICB2YXIgcGFpcnMgPSBkYXRhLl9fZGF0YV9fO1xuICAgIGlmICghTWFwIHx8IChwYWlycy5sZW5ndGggPCBMQVJHRV9BUlJBWV9TSVpFIC0gMSkpIHtcbiAgICAgIHBhaXJzLnB1c2goW2tleSwgdmFsdWVdKTtcbiAgICAgIHRoaXMuc2l6ZSA9ICsrZGF0YS5zaXplO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGRhdGEgPSB0aGlzLl9fZGF0YV9fID0gbmV3IE1hcENhY2hlKHBhaXJzKTtcbiAgfVxuICBkYXRhLnNldChrZXksIHZhbHVlKTtcbiAgdGhpcy5zaXplID0gZGF0YS5zaXplO1xuICByZXR1cm4gdGhpcztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdGFja1NldDtcbiIsInZhciBpc0Z1bmN0aW9uID0gcmVxdWlyZSgnLi9pc0Z1bmN0aW9uJyksXG4gICAgaXNNYXNrZWQgPSByZXF1aXJlKCcuL19pc01hc2tlZCcpLFxuICAgIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9pc09iamVjdCcpLFxuICAgIHRvU291cmNlID0gcmVxdWlyZSgnLi9fdG9Tb3VyY2UnKTtcblxuLyoqXG4gKiBVc2VkIHRvIG1hdGNoIGBSZWdFeHBgXG4gKiBbc3ludGF4IGNoYXJhY3RlcnNdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXBhdHRlcm5zKS5cbiAqL1xudmFyIHJlUmVnRXhwQ2hhciA9IC9bXFxcXF4kLiorPygpW1xcXXt9fF0vZztcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IGhvc3QgY29uc3RydWN0b3JzIChTYWZhcmkpLiAqL1xudmFyIHJlSXNIb3N0Q3RvciA9IC9eXFxbb2JqZWN0IC4rP0NvbnN0cnVjdG9yXFxdJC87XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBmdW5jUHJvdG8gPSBGdW5jdGlvbi5wcm90b3R5cGUsXG4gICAgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byByZXNvbHZlIHRoZSBkZWNvbXBpbGVkIHNvdXJjZSBvZiBmdW5jdGlvbnMuICovXG52YXIgZnVuY1RvU3RyaW5nID0gZnVuY1Byb3RvLnRvU3RyaW5nO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKiogVXNlZCB0byBkZXRlY3QgaWYgYSBtZXRob2QgaXMgbmF0aXZlLiAqL1xudmFyIHJlSXNOYXRpdmUgPSBSZWdFeHAoJ14nICtcbiAgZnVuY1RvU3RyaW5nLmNhbGwoaGFzT3duUHJvcGVydHkpLnJlcGxhY2UocmVSZWdFeHBDaGFyLCAnXFxcXCQmJylcbiAgLnJlcGxhY2UoL2hhc093blByb3BlcnR5fChmdW5jdGlvbikuKj8oPz1cXFxcXFwoKXwgZm9yIC4rPyg/PVxcXFxcXF0pL2csICckMS4qPycpICsgJyQnXG4pO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzTmF0aXZlYCB3aXRob3V0IGJhZCBzaGltIGNoZWNrcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIG5hdGl2ZSBmdW5jdGlvbixcbiAqICBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc05hdGl2ZSh2YWx1ZSkge1xuICBpZiAoIWlzT2JqZWN0KHZhbHVlKSB8fCBpc01hc2tlZCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIHBhdHRlcm4gPSBpc0Z1bmN0aW9uKHZhbHVlKSA/IHJlSXNOYXRpdmUgOiByZUlzSG9zdEN0b3I7XG4gIHJldHVybiBwYXR0ZXJuLnRlc3QodG9Tb3VyY2UodmFsdWUpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlSXNOYXRpdmU7XG4iLCJ2YXIgU3ltYm9sID0gcmVxdWlyZSgnLi9fU3ltYm9sJyk7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogVXNlZCB0byByZXNvbHZlIHRoZVxuICogW2B0b1N0cmluZ1RhZ2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXG4gKiBvZiB2YWx1ZXMuXG4gKi9cbnZhciBuYXRpdmVPYmplY3RUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBzeW1Ub1N0cmluZ1RhZyA9IFN5bWJvbCA/IFN5bWJvbC50b1N0cmluZ1RhZyA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VHZXRUYWdgIHdoaWNoIGlnbm9yZXMgYFN5bWJvbC50b1N0cmluZ1RhZ2AgdmFsdWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHJhdyBgdG9TdHJpbmdUYWdgLlxuICovXG5mdW5jdGlvbiBnZXRSYXdUYWcodmFsdWUpIHtcbiAgdmFyIGlzT3duID0gaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgc3ltVG9TdHJpbmdUYWcpLFxuICAgICAgdGFnID0gdmFsdWVbc3ltVG9TdHJpbmdUYWddO1xuXG4gIHRyeSB7XG4gICAgdmFsdWVbc3ltVG9TdHJpbmdUYWddID0gdW5kZWZpbmVkO1xuICAgIHZhciB1bm1hc2tlZCA9IHRydWU7XG4gIH0gY2F0Y2ggKGUpIHt9XG5cbiAgdmFyIHJlc3VsdCA9IG5hdGl2ZU9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpO1xuICBpZiAodW5tYXNrZWQpIHtcbiAgICBpZiAoaXNPd24pIHtcbiAgICAgIHZhbHVlW3N5bVRvU3RyaW5nVGFnXSA9IHRhZztcbiAgICB9IGVsc2Uge1xuICAgICAgZGVsZXRlIHZhbHVlW3N5bVRvU3RyaW5nVGFnXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRSYXdUYWc7XG4iLCIvKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKipcbiAqIFVzZWQgdG8gcmVzb2x2ZSB0aGVcbiAqIFtgdG9TdHJpbmdUYWdgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nKVxuICogb2YgdmFsdWVzLlxuICovXG52YXIgbmF0aXZlT2JqZWN0VG9TdHJpbmcgPSBvYmplY3RQcm90by50b1N0cmluZztcblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgc3RyaW5nIHVzaW5nIGBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIG9iamVjdFRvU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiBuYXRpdmVPYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBvYmplY3RUb1N0cmluZztcbiIsInZhciBjb3JlSnNEYXRhID0gcmVxdWlyZSgnLi9fY29yZUpzRGF0YScpO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgbWV0aG9kcyBtYXNxdWVyYWRpbmcgYXMgbmF0aXZlLiAqL1xudmFyIG1hc2tTcmNLZXkgPSAoZnVuY3Rpb24oKSB7XG4gIHZhciB1aWQgPSAvW14uXSskLy5leGVjKGNvcmVKc0RhdGEgJiYgY29yZUpzRGF0YS5rZXlzICYmIGNvcmVKc0RhdGEua2V5cy5JRV9QUk9UTyB8fCAnJyk7XG4gIHJldHVybiB1aWQgPyAoJ1N5bWJvbChzcmMpXzEuJyArIHVpZCkgOiAnJztcbn0oKSk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGBmdW5jYCBoYXMgaXRzIHNvdXJjZSBtYXNrZWQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBmdW5jYCBpcyBtYXNrZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNNYXNrZWQoZnVuYykge1xuICByZXR1cm4gISFtYXNrU3JjS2V5ICYmIChtYXNrU3JjS2V5IGluIGZ1bmMpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzTWFza2VkO1xuIiwidmFyIHJvb3QgPSByZXF1aXJlKCcuL19yb290Jyk7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBvdmVycmVhY2hpbmcgY29yZS1qcyBzaGltcy4gKi9cbnZhciBjb3JlSnNEYXRhID0gcm9vdFsnX19jb3JlLWpzX3NoYXJlZF9fJ107XG5cbm1vZHVsZS5leHBvcnRzID0gY29yZUpzRGF0YTtcbiIsIi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBmdW5jUHJvdG8gPSBGdW5jdGlvbi5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIHJlc29sdmUgdGhlIGRlY29tcGlsZWQgc291cmNlIG9mIGZ1bmN0aW9ucy4gKi9cbnZhciBmdW5jVG9TdHJpbmcgPSBmdW5jUHJvdG8udG9TdHJpbmc7XG5cbi8qKlxuICogQ29udmVydHMgYGZ1bmNgIHRvIGl0cyBzb3VyY2UgY29kZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHNvdXJjZSBjb2RlLlxuICovXG5mdW5jdGlvbiB0b1NvdXJjZShmdW5jKSB7XG4gIGlmIChmdW5jICE9IG51bGwpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGZ1bmNUb1N0cmluZy5jYWxsKGZ1bmMpO1xuICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiAoZnVuYyArICcnKTtcbiAgICB9IGNhdGNoIChlKSB7fVxuICB9XG4gIHJldHVybiAnJztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB0b1NvdXJjZTtcbiIsIi8qKlxuICogR2V0cyB0aGUgdmFsdWUgYXQgYGtleWAgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcHJvcGVydHkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGdldFZhbHVlKG9iamVjdCwga2V5KSB7XG4gIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IG9iamVjdFtrZXldO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldFZhbHVlO1xuIiwidmFyIEhhc2ggPSByZXF1aXJlKCcuL19IYXNoJyksXG4gICAgTGlzdENhY2hlID0gcmVxdWlyZSgnLi9fTGlzdENhY2hlJyksXG4gICAgTWFwID0gcmVxdWlyZSgnLi9fTWFwJyk7XG5cbi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgbWFwLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBjbGVhclxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlQ2xlYXIoKSB7XG4gIHRoaXMuc2l6ZSA9IDA7XG4gIHRoaXMuX19kYXRhX18gPSB7XG4gICAgJ2hhc2gnOiBuZXcgSGFzaCxcbiAgICAnbWFwJzogbmV3IChNYXAgfHwgTGlzdENhY2hlKSxcbiAgICAnc3RyaW5nJzogbmV3IEhhc2hcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtYXBDYWNoZUNsZWFyO1xuIiwidmFyIGhhc2hDbGVhciA9IHJlcXVpcmUoJy4vX2hhc2hDbGVhcicpLFxuICAgIGhhc2hEZWxldGUgPSByZXF1aXJlKCcuL19oYXNoRGVsZXRlJyksXG4gICAgaGFzaEdldCA9IHJlcXVpcmUoJy4vX2hhc2hHZXQnKSxcbiAgICBoYXNoSGFzID0gcmVxdWlyZSgnLi9faGFzaEhhcycpLFxuICAgIGhhc2hTZXQgPSByZXF1aXJlKCcuL19oYXNoU2V0Jyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGhhc2ggb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBIYXNoKGVudHJpZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBlbnRyaWVzID09IG51bGwgPyAwIDogZW50cmllcy5sZW5ndGg7XG5cbiAgdGhpcy5jbGVhcigpO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaW5kZXhdO1xuICAgIHRoaXMuc2V0KGVudHJ5WzBdLCBlbnRyeVsxXSk7XG4gIH1cbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYEhhc2hgLlxuSGFzaC5wcm90b3R5cGUuY2xlYXIgPSBoYXNoQ2xlYXI7XG5IYXNoLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBoYXNoRGVsZXRlO1xuSGFzaC5wcm90b3R5cGUuZ2V0ID0gaGFzaEdldDtcbkhhc2gucHJvdG90eXBlLmhhcyA9IGhhc2hIYXM7XG5IYXNoLnByb3RvdHlwZS5zZXQgPSBoYXNoU2V0O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEhhc2g7XG4iLCJ2YXIgbmF0aXZlQ3JlYXRlID0gcmVxdWlyZSgnLi9fbmF0aXZlQ3JlYXRlJyk7XG5cbi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgaGFzaC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgY2xlYXJcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKi9cbmZ1bmN0aW9uIGhhc2hDbGVhcigpIHtcbiAgdGhpcy5fX2RhdGFfXyA9IG5hdGl2ZUNyZWF0ZSA/IG5hdGl2ZUNyZWF0ZShudWxsKSA6IHt9O1xuICB0aGlzLnNpemUgPSAwO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGhhc2hDbGVhcjtcbiIsIi8qKlxuICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIGhhc2guXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGRlbGV0ZVxuICogQG1lbWJlck9mIEhhc2hcbiAqIEBwYXJhbSB7T2JqZWN0fSBoYXNoIFRoZSBoYXNoIHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBoYXNoRGVsZXRlKGtleSkge1xuICB2YXIgcmVzdWx0ID0gdGhpcy5oYXMoa2V5KSAmJiBkZWxldGUgdGhpcy5fX2RhdGFfX1trZXldO1xuICB0aGlzLnNpemUgLT0gcmVzdWx0ID8gMSA6IDA7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaGFzaERlbGV0ZTtcbiIsInZhciBuYXRpdmVDcmVhdGUgPSByZXF1aXJlKCcuL19uYXRpdmVDcmVhdGUnKTtcblxuLyoqIFVzZWQgdG8gc3RhbmQtaW4gZm9yIGB1bmRlZmluZWRgIGhhc2ggdmFsdWVzLiAqL1xudmFyIEhBU0hfVU5ERUZJTkVEID0gJ19fbG9kYXNoX2hhc2hfdW5kZWZpbmVkX18nO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIEdldHMgdGhlIGhhc2ggdmFsdWUgZm9yIGBrZXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBnZXRcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gaGFzaEdldChrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICBpZiAobmF0aXZlQ3JlYXRlKSB7XG4gICAgdmFyIHJlc3VsdCA9IGRhdGFba2V5XTtcbiAgICByZXR1cm4gcmVzdWx0ID09PSBIQVNIX1VOREVGSU5FRCA/IHVuZGVmaW5lZCA6IHJlc3VsdDtcbiAgfVxuICByZXR1cm4gaGFzT3duUHJvcGVydHkuY2FsbChkYXRhLCBrZXkpID8gZGF0YVtrZXldIDogdW5kZWZpbmVkO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGhhc2hHZXQ7XG4iLCJ2YXIgbmF0aXZlQ3JlYXRlID0gcmVxdWlyZSgnLi9fbmF0aXZlQ3JlYXRlJyk7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgaGFzaCB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaGFzaEhhcyhrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICByZXR1cm4gbmF0aXZlQ3JlYXRlID8gKGRhdGFba2V5XSAhPT0gdW5kZWZpbmVkKSA6IGhhc093blByb3BlcnR5LmNhbGwoZGF0YSwga2V5KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBoYXNoSGFzO1xuIiwidmFyIG5hdGl2ZUNyZWF0ZSA9IHJlcXVpcmUoJy4vX25hdGl2ZUNyZWF0ZScpO1xuXG4vKiogVXNlZCB0byBzdGFuZC1pbiBmb3IgYHVuZGVmaW5lZGAgaGFzaCB2YWx1ZXMuICovXG52YXIgSEFTSF9VTkRFRklORUQgPSAnX19sb2Rhc2hfaGFzaF91bmRlZmluZWRfXyc7XG5cbi8qKlxuICogU2V0cyB0aGUgaGFzaCBga2V5YCB0byBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBzZXRcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGhhc2ggaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIGhhc2hTZXQoa2V5LCB2YWx1ZSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gIHRoaXMuc2l6ZSArPSB0aGlzLmhhcyhrZXkpID8gMCA6IDE7XG4gIGRhdGFba2V5XSA9IChuYXRpdmVDcmVhdGUgJiYgdmFsdWUgPT09IHVuZGVmaW5lZCkgPyBIQVNIX1VOREVGSU5FRCA6IHZhbHVlO1xuICByZXR1cm4gdGhpcztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBoYXNoU2V0O1xuIiwidmFyIGdldE1hcERhdGEgPSByZXF1aXJlKCcuL19nZXRNYXBEYXRhJyk7XG5cbi8qKlxuICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIG1hcC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZGVsZXRlXG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBtYXBDYWNoZURlbGV0ZShrZXkpIHtcbiAgdmFyIHJlc3VsdCA9IGdldE1hcERhdGEodGhpcywga2V5KVsnZGVsZXRlJ10oa2V5KTtcbiAgdGhpcy5zaXplIC09IHJlc3VsdCA/IDEgOiAwO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG1hcENhY2hlRGVsZXRlO1xuIiwiLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBzdWl0YWJsZSBmb3IgdXNlIGFzIHVuaXF1ZSBvYmplY3Qga2V5LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIHN1aXRhYmxlLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzS2V5YWJsZSh2YWx1ZSkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgcmV0dXJuICh0eXBlID09ICdzdHJpbmcnIHx8IHR5cGUgPT0gJ251bWJlcicgfHwgdHlwZSA9PSAnc3ltYm9sJyB8fCB0eXBlID09ICdib29sZWFuJylcbiAgICA/ICh2YWx1ZSAhPT0gJ19fcHJvdG9fXycpXG4gICAgOiAodmFsdWUgPT09IG51bGwpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzS2V5YWJsZTtcbiIsInZhciBnZXRNYXBEYXRhID0gcmVxdWlyZSgnLi9fZ2V0TWFwRGF0YScpO1xuXG4vKipcbiAqIEdldHMgdGhlIG1hcCB2YWx1ZSBmb3IgYGtleWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGdldFxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVHZXQoa2V5KSB7XG4gIHJldHVybiBnZXRNYXBEYXRhKHRoaXMsIGtleSkuZ2V0KGtleSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWFwQ2FjaGVHZXQ7XG4iLCJ2YXIgZ2V0TWFwRGF0YSA9IHJlcXVpcmUoJy4vX2dldE1hcERhdGEnKTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYSBtYXAgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBtYXBDYWNoZUhhcyhrZXkpIHtcbiAgcmV0dXJuIGdldE1hcERhdGEodGhpcywga2V5KS5oYXMoa2V5KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtYXBDYWNoZUhhcztcbiIsInZhciBnZXRNYXBEYXRhID0gcmVxdWlyZSgnLi9fZ2V0TWFwRGF0YScpO1xuXG4vKipcbiAqIFNldHMgdGhlIG1hcCBga2V5YCB0byBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBzZXRcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBtYXAgY2FjaGUgaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlU2V0KGtleSwgdmFsdWUpIHtcbiAgdmFyIGRhdGEgPSBnZXRNYXBEYXRhKHRoaXMsIGtleSksXG4gICAgICBzaXplID0gZGF0YS5zaXplO1xuXG4gIGRhdGEuc2V0KGtleSwgdmFsdWUpO1xuICB0aGlzLnNpemUgKz0gZGF0YS5zaXplID09IHNpemUgPyAwIDogMTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWFwQ2FjaGVTZXQ7XG4iLCJ2YXIgY3JlYXRlQmFzZUZvciA9IHJlcXVpcmUoJy4vX2NyZWF0ZUJhc2VGb3InKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgYmFzZUZvck93bmAgd2hpY2ggaXRlcmF0ZXMgb3ZlciBgb2JqZWN0YFxuICogcHJvcGVydGllcyByZXR1cm5lZCBieSBga2V5c0Z1bmNgIGFuZCBpbnZva2VzIGBpdGVyYXRlZWAgZm9yIGVhY2ggcHJvcGVydHkuXG4gKiBJdGVyYXRlZSBmdW5jdGlvbnMgbWF5IGV4aXQgaXRlcmF0aW9uIGVhcmx5IGJ5IGV4cGxpY2l0bHkgcmV0dXJuaW5nIGBmYWxzZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHBhcmFtIHtGdW5jdGlvbn0ga2V5c0Z1bmMgVGhlIGZ1bmN0aW9uIHRvIGdldCB0aGUga2V5cyBvZiBgb2JqZWN0YC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKi9cbnZhciBiYXNlRm9yID0gY3JlYXRlQmFzZUZvcigpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VGb3I7XG4iLCIvKipcbiAqIENyZWF0ZXMgYSBiYXNlIGZ1bmN0aW9uIGZvciBtZXRob2RzIGxpa2UgYF8uZm9ySW5gIGFuZCBgXy5mb3JPd25gLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtmcm9tUmlnaHRdIFNwZWNpZnkgaXRlcmF0aW5nIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGJhc2UgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUJhc2VGb3IoZnJvbVJpZ2h0KSB7XG4gIHJldHVybiBmdW5jdGlvbihvYmplY3QsIGl0ZXJhdGVlLCBrZXlzRnVuYykge1xuICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICBpdGVyYWJsZSA9IE9iamVjdChvYmplY3QpLFxuICAgICAgICBwcm9wcyA9IGtleXNGdW5jKG9iamVjdCksXG4gICAgICAgIGxlbmd0aCA9IHByb3BzLmxlbmd0aDtcblxuICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgdmFyIGtleSA9IHByb3BzW2Zyb21SaWdodCA/IGxlbmd0aCA6ICsraW5kZXhdO1xuICAgICAgaWYgKGl0ZXJhdGVlKGl0ZXJhYmxlW2tleV0sIGtleSwgaXRlcmFibGUpID09PSBmYWxzZSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG9iamVjdDtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVCYXNlRm9yO1xuIiwidmFyIGFzc2lnbk1lcmdlVmFsdWUgPSByZXF1aXJlKCcuL19hc3NpZ25NZXJnZVZhbHVlJyksXG4gICAgY2xvbmVCdWZmZXIgPSByZXF1aXJlKCcuL19jbG9uZUJ1ZmZlcicpLFxuICAgIGNsb25lVHlwZWRBcnJheSA9IHJlcXVpcmUoJy4vX2Nsb25lVHlwZWRBcnJheScpLFxuICAgIGNvcHlBcnJheSA9IHJlcXVpcmUoJy4vX2NvcHlBcnJheScpLFxuICAgIGluaXRDbG9uZU9iamVjdCA9IHJlcXVpcmUoJy4vX2luaXRDbG9uZU9iamVjdCcpLFxuICAgIGlzQXJndW1lbnRzID0gcmVxdWlyZSgnLi9pc0FyZ3VtZW50cycpLFxuICAgIGlzQXJyYXkgPSByZXF1aXJlKCcuL2lzQXJyYXknKSxcbiAgICBpc0FycmF5TGlrZU9iamVjdCA9IHJlcXVpcmUoJy4vaXNBcnJheUxpa2VPYmplY3QnKSxcbiAgICBpc0J1ZmZlciA9IHJlcXVpcmUoJy4vaXNCdWZmZXInKSxcbiAgICBpc0Z1bmN0aW9uID0gcmVxdWlyZSgnLi9pc0Z1bmN0aW9uJyksXG4gICAgaXNPYmplY3QgPSByZXF1aXJlKCcuL2lzT2JqZWN0JyksXG4gICAgaXNQbGFpbk9iamVjdCA9IHJlcXVpcmUoJy4vaXNQbGFpbk9iamVjdCcpLFxuICAgIGlzVHlwZWRBcnJheSA9IHJlcXVpcmUoJy4vaXNUeXBlZEFycmF5JyksXG4gICAgc2FmZUdldCA9IHJlcXVpcmUoJy4vX3NhZmVHZXQnKSxcbiAgICB0b1BsYWluT2JqZWN0ID0gcmVxdWlyZSgnLi90b1BsYWluT2JqZWN0Jyk7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlTWVyZ2VgIGZvciBhcnJheXMgYW5kIG9iamVjdHMgd2hpY2ggcGVyZm9ybXNcbiAqIGRlZXAgbWVyZ2VzIGFuZCB0cmFja3MgdHJhdmVyc2VkIG9iamVjdHMgZW5hYmxpbmcgb2JqZWN0cyB3aXRoIGNpcmN1bGFyXG4gKiByZWZlcmVuY2VzIHRvIGJlIG1lcmdlZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgc291cmNlIG9iamVjdC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gbWVyZ2UuXG4gKiBAcGFyYW0ge251bWJlcn0gc3JjSW5kZXggVGhlIGluZGV4IG9mIGBzb3VyY2VgLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gbWVyZ2VGdW5jIFRoZSBmdW5jdGlvbiB0byBtZXJnZSB2YWx1ZXMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBhc3NpZ25lZCB2YWx1ZXMuXG4gKiBAcGFyYW0ge09iamVjdH0gW3N0YWNrXSBUcmFja3MgdHJhdmVyc2VkIHNvdXJjZSB2YWx1ZXMgYW5kIHRoZWlyIG1lcmdlZFxuICogIGNvdW50ZXJwYXJ0cy5cbiAqL1xuZnVuY3Rpb24gYmFzZU1lcmdlRGVlcChvYmplY3QsIHNvdXJjZSwga2V5LCBzcmNJbmRleCwgbWVyZ2VGdW5jLCBjdXN0b21pemVyLCBzdGFjaykge1xuICB2YXIgb2JqVmFsdWUgPSBzYWZlR2V0KG9iamVjdCwga2V5KSxcbiAgICAgIHNyY1ZhbHVlID0gc2FmZUdldChzb3VyY2UsIGtleSksXG4gICAgICBzdGFja2VkID0gc3RhY2suZ2V0KHNyY1ZhbHVlKTtcblxuICBpZiAoc3RhY2tlZCkge1xuICAgIGFzc2lnbk1lcmdlVmFsdWUob2JqZWN0LCBrZXksIHN0YWNrZWQpO1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgbmV3VmFsdWUgPSBjdXN0b21pemVyXG4gICAgPyBjdXN0b21pemVyKG9ialZhbHVlLCBzcmNWYWx1ZSwgKGtleSArICcnKSwgb2JqZWN0LCBzb3VyY2UsIHN0YWNrKVxuICAgIDogdW5kZWZpbmVkO1xuXG4gIHZhciBpc0NvbW1vbiA9IG5ld1ZhbHVlID09PSB1bmRlZmluZWQ7XG5cbiAgaWYgKGlzQ29tbW9uKSB7XG4gICAgdmFyIGlzQXJyID0gaXNBcnJheShzcmNWYWx1ZSksXG4gICAgICAgIGlzQnVmZiA9ICFpc0FyciAmJiBpc0J1ZmZlcihzcmNWYWx1ZSksXG4gICAgICAgIGlzVHlwZWQgPSAhaXNBcnIgJiYgIWlzQnVmZiAmJiBpc1R5cGVkQXJyYXkoc3JjVmFsdWUpO1xuXG4gICAgbmV3VmFsdWUgPSBzcmNWYWx1ZTtcbiAgICBpZiAoaXNBcnIgfHwgaXNCdWZmIHx8IGlzVHlwZWQpIHtcbiAgICAgIGlmIChpc0FycmF5KG9ialZhbHVlKSkge1xuICAgICAgICBuZXdWYWx1ZSA9IG9ialZhbHVlO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoaXNBcnJheUxpa2VPYmplY3Qob2JqVmFsdWUpKSB7XG4gICAgICAgIG5ld1ZhbHVlID0gY29weUFycmF5KG9ialZhbHVlKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGlzQnVmZikge1xuICAgICAgICBpc0NvbW1vbiA9IGZhbHNlO1xuICAgICAgICBuZXdWYWx1ZSA9IGNsb25lQnVmZmVyKHNyY1ZhbHVlLCB0cnVlKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGlzVHlwZWQpIHtcbiAgICAgICAgaXNDb21tb24gPSBmYWxzZTtcbiAgICAgICAgbmV3VmFsdWUgPSBjbG9uZVR5cGVkQXJyYXkoc3JjVmFsdWUsIHRydWUpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIG5ld1ZhbHVlID0gW107XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzUGxhaW5PYmplY3Qoc3JjVmFsdWUpIHx8IGlzQXJndW1lbnRzKHNyY1ZhbHVlKSkge1xuICAgICAgbmV3VmFsdWUgPSBvYmpWYWx1ZTtcbiAgICAgIGlmIChpc0FyZ3VtZW50cyhvYmpWYWx1ZSkpIHtcbiAgICAgICAgbmV3VmFsdWUgPSB0b1BsYWluT2JqZWN0KG9ialZhbHVlKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKCFpc09iamVjdChvYmpWYWx1ZSkgfHwgaXNGdW5jdGlvbihvYmpWYWx1ZSkpIHtcbiAgICAgICAgbmV3VmFsdWUgPSBpbml0Q2xvbmVPYmplY3Qoc3JjVmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGlzQ29tbW9uID0gZmFsc2U7XG4gICAgfVxuICB9XG4gIGlmIChpc0NvbW1vbikge1xuICAgIC8vIFJlY3Vyc2l2ZWx5IG1lcmdlIG9iamVjdHMgYW5kIGFycmF5cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgIHN0YWNrLnNldChzcmNWYWx1ZSwgbmV3VmFsdWUpO1xuICAgIG1lcmdlRnVuYyhuZXdWYWx1ZSwgc3JjVmFsdWUsIHNyY0luZGV4LCBjdXN0b21pemVyLCBzdGFjayk7XG4gICAgc3RhY2tbJ2RlbGV0ZSddKHNyY1ZhbHVlKTtcbiAgfVxuICBhc3NpZ25NZXJnZVZhbHVlKG9iamVjdCwga2V5LCBuZXdWYWx1ZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZU1lcmdlRGVlcDtcbiIsInZhciByb290ID0gcmVxdWlyZSgnLi9fcm9vdCcpO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGV4cG9ydHNgLiAqL1xudmFyIGZyZWVFeHBvcnRzID0gdHlwZW9mIGV4cG9ydHMgPT0gJ29iamVjdCcgJiYgZXhwb3J0cyAmJiAhZXhwb3J0cy5ub2RlVHlwZSAmJiBleHBvcnRzO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYG1vZHVsZWAuICovXG52YXIgZnJlZU1vZHVsZSA9IGZyZWVFeHBvcnRzICYmIHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlICYmICFtb2R1bGUubm9kZVR5cGUgJiYgbW9kdWxlO1xuXG4vKiogRGV0ZWN0IHRoZSBwb3B1bGFyIENvbW1vbkpTIGV4dGVuc2lvbiBgbW9kdWxlLmV4cG9ydHNgLiAqL1xudmFyIG1vZHVsZUV4cG9ydHMgPSBmcmVlTW9kdWxlICYmIGZyZWVNb2R1bGUuZXhwb3J0cyA9PT0gZnJlZUV4cG9ydHM7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIEJ1ZmZlciA9IG1vZHVsZUV4cG9ydHMgPyByb290LkJ1ZmZlciA6IHVuZGVmaW5lZCxcbiAgICBhbGxvY1Vuc2FmZSA9IEJ1ZmZlciA/IEJ1ZmZlci5hbGxvY1Vuc2FmZSA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBDcmVhdGVzIGEgY2xvbmUgb2YgIGBidWZmZXJgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0J1ZmZlcn0gYnVmZmVyIFRoZSBidWZmZXIgdG8gY2xvbmUuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0RlZXBdIFNwZWNpZnkgYSBkZWVwIGNsb25lLlxuICogQHJldHVybnMge0J1ZmZlcn0gUmV0dXJucyB0aGUgY2xvbmVkIGJ1ZmZlci5cbiAqL1xuZnVuY3Rpb24gY2xvbmVCdWZmZXIoYnVmZmVyLCBpc0RlZXApIHtcbiAgaWYgKGlzRGVlcCkge1xuICAgIHJldHVybiBidWZmZXIuc2xpY2UoKTtcbiAgfVxuICB2YXIgbGVuZ3RoID0gYnVmZmVyLmxlbmd0aCxcbiAgICAgIHJlc3VsdCA9IGFsbG9jVW5zYWZlID8gYWxsb2NVbnNhZmUobGVuZ3RoKSA6IG5ldyBidWZmZXIuY29uc3RydWN0b3IobGVuZ3RoKTtcblxuICBidWZmZXIuY29weShyZXN1bHQpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsb25lQnVmZmVyO1xuIiwidmFyIGNsb25lQXJyYXlCdWZmZXIgPSByZXF1aXJlKCcuL19jbG9uZUFycmF5QnVmZmVyJyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGNsb25lIG9mIGB0eXBlZEFycmF5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHR5cGVkQXJyYXkgVGhlIHR5cGVkIGFycmF5IHRvIGNsb25lLlxuICogQHBhcmFtIHtib29sZWFufSBbaXNEZWVwXSBTcGVjaWZ5IGEgZGVlcCBjbG9uZS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNsb25lZCB0eXBlZCBhcnJheS5cbiAqL1xuZnVuY3Rpb24gY2xvbmVUeXBlZEFycmF5KHR5cGVkQXJyYXksIGlzRGVlcCkge1xuICB2YXIgYnVmZmVyID0gaXNEZWVwID8gY2xvbmVBcnJheUJ1ZmZlcih0eXBlZEFycmF5LmJ1ZmZlcikgOiB0eXBlZEFycmF5LmJ1ZmZlcjtcbiAgcmV0dXJuIG5ldyB0eXBlZEFycmF5LmNvbnN0cnVjdG9yKGJ1ZmZlciwgdHlwZWRBcnJheS5ieXRlT2Zmc2V0LCB0eXBlZEFycmF5Lmxlbmd0aCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2xvbmVUeXBlZEFycmF5O1xuIiwidmFyIFVpbnQ4QXJyYXkgPSByZXF1aXJlKCcuL19VaW50OEFycmF5Jyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGNsb25lIG9mIGBhcnJheUJ1ZmZlcmAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXlCdWZmZXJ9IGFycmF5QnVmZmVyIFRoZSBhcnJheSBidWZmZXIgdG8gY2xvbmUuXG4gKiBAcmV0dXJucyB7QXJyYXlCdWZmZXJ9IFJldHVybnMgdGhlIGNsb25lZCBhcnJheSBidWZmZXIuXG4gKi9cbmZ1bmN0aW9uIGNsb25lQXJyYXlCdWZmZXIoYXJyYXlCdWZmZXIpIHtcbiAgdmFyIHJlc3VsdCA9IG5ldyBhcnJheUJ1ZmZlci5jb25zdHJ1Y3RvcihhcnJheUJ1ZmZlci5ieXRlTGVuZ3RoKTtcbiAgbmV3IFVpbnQ4QXJyYXkocmVzdWx0KS5zZXQobmV3IFVpbnQ4QXJyYXkoYXJyYXlCdWZmZXIpKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjbG9uZUFycmF5QnVmZmVyO1xuIiwidmFyIHJvb3QgPSByZXF1aXJlKCcuL19yb290Jyk7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIFVpbnQ4QXJyYXkgPSByb290LlVpbnQ4QXJyYXk7XG5cbm1vZHVsZS5leHBvcnRzID0gVWludDhBcnJheTtcbiIsIi8qKlxuICogQ29waWVzIHRoZSB2YWx1ZXMgb2YgYHNvdXJjZWAgdG8gYGFycmF5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gc291cmNlIFRoZSBhcnJheSB0byBjb3B5IHZhbHVlcyBmcm9tLlxuICogQHBhcmFtIHtBcnJheX0gW2FycmF5PVtdXSBUaGUgYXJyYXkgdG8gY29weSB2YWx1ZXMgdG8uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAqL1xuZnVuY3Rpb24gY29weUFycmF5KHNvdXJjZSwgYXJyYXkpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBzb3VyY2UubGVuZ3RoO1xuXG4gIGFycmF5IHx8IChhcnJheSA9IEFycmF5KGxlbmd0aCkpO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGFycmF5W2luZGV4XSA9IHNvdXJjZVtpbmRleF07XG4gIH1cbiAgcmV0dXJuIGFycmF5O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNvcHlBcnJheTtcbiIsInZhciBiYXNlQ3JlYXRlID0gcmVxdWlyZSgnLi9fYmFzZUNyZWF0ZScpLFxuICAgIGdldFByb3RvdHlwZSA9IHJlcXVpcmUoJy4vX2dldFByb3RvdHlwZScpLFxuICAgIGlzUHJvdG90eXBlID0gcmVxdWlyZSgnLi9faXNQcm90b3R5cGUnKTtcblxuLyoqXG4gKiBJbml0aWFsaXplcyBhbiBvYmplY3QgY2xvbmUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjbG9uZS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGluaXRpYWxpemVkIGNsb25lLlxuICovXG5mdW5jdGlvbiBpbml0Q2xvbmVPYmplY3Qob2JqZWN0KSB7XG4gIHJldHVybiAodHlwZW9mIG9iamVjdC5jb25zdHJ1Y3RvciA9PSAnZnVuY3Rpb24nICYmICFpc1Byb3RvdHlwZShvYmplY3QpKVxuICAgID8gYmFzZUNyZWF0ZShnZXRQcm90b3R5cGUob2JqZWN0KSlcbiAgICA6IHt9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGluaXRDbG9uZU9iamVjdDtcbiIsInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vaXNPYmplY3QnKTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0Q3JlYXRlID0gT2JqZWN0LmNyZWF0ZTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5jcmVhdGVgIHdpdGhvdXQgc3VwcG9ydCBmb3IgYXNzaWduaW5nXG4gKiBwcm9wZXJ0aWVzIHRvIHRoZSBjcmVhdGVkIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHByb3RvIFRoZSBvYmplY3QgdG8gaW5oZXJpdCBmcm9tLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cbiAqL1xudmFyIGJhc2VDcmVhdGUgPSAoZnVuY3Rpb24oKSB7XG4gIGZ1bmN0aW9uIG9iamVjdCgpIHt9XG4gIHJldHVybiBmdW5jdGlvbihwcm90bykge1xuICAgIGlmICghaXNPYmplY3QocHJvdG8pKSB7XG4gICAgICByZXR1cm4ge307XG4gICAgfVxuICAgIGlmIChvYmplY3RDcmVhdGUpIHtcbiAgICAgIHJldHVybiBvYmplY3RDcmVhdGUocHJvdG8pO1xuICAgIH1cbiAgICBvYmplY3QucHJvdG90eXBlID0gcHJvdG87XG4gICAgdmFyIHJlc3VsdCA9IG5ldyBvYmplY3Q7XG4gICAgb2JqZWN0LnByb3RvdHlwZSA9IHVuZGVmaW5lZDtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xufSgpKTtcblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlQ3JlYXRlO1xuIiwiLyoqXG4gKiBDcmVhdGVzIGEgdW5hcnkgZnVuY3Rpb24gdGhhdCBpbnZva2VzIGBmdW5jYCB3aXRoIGl0cyBhcmd1bWVudCB0cmFuc2Zvcm1lZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gd3JhcC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHRyYW5zZm9ybSBUaGUgYXJndW1lbnQgdHJhbnNmb3JtLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIG92ZXJBcmcoZnVuYywgdHJhbnNmb3JtKSB7XG4gIHJldHVybiBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4gZnVuYyh0cmFuc2Zvcm0oYXJnKSk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gb3ZlckFyZztcbiIsInZhciBiYXNlR2V0VGFnID0gcmVxdWlyZSgnLi9fYmFzZUdldFRhZycpLFxuICAgIGlzT2JqZWN0TGlrZSA9IHJlcXVpcmUoJy4vaXNPYmplY3RMaWtlJyk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBhcmdzVGFnID0gJ1tvYmplY3QgQXJndW1lbnRzXSc7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNBcmd1bWVudHNgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGBhcmd1bWVudHNgIG9iamVjdCxcbiAqL1xuZnVuY3Rpb24gYmFzZUlzQXJndW1lbnRzKHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGJhc2VHZXRUYWcodmFsdWUpID09IGFyZ3NUYWc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUlzQXJndW1lbnRzO1xuIiwidmFyIGlzQXJyYXlMaWtlID0gcmVxdWlyZSgnLi9pc0FycmF5TGlrZScpLFxuICAgIGlzT2JqZWN0TGlrZSA9IHJlcXVpcmUoJy4vaXNPYmplY3RMaWtlJyk7XG5cbi8qKlxuICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5pc0FycmF5TGlrZWAgZXhjZXB0IHRoYXQgaXQgYWxzbyBjaGVja3MgaWYgYHZhbHVlYFxuICogaXMgYW4gb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGFycmF5LWxpa2Ugb2JqZWN0LFxuICogIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FycmF5TGlrZU9iamVjdChbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2VPYmplY3QoZG9jdW1lbnQuYm9keS5jaGlsZHJlbik7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZU9iamVjdCgnYWJjJyk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNBcnJheUxpa2VPYmplY3QoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzQXJyYXlMaWtlT2JqZWN0KHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGlzQXJyYXlMaWtlKHZhbHVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0FycmF5TGlrZU9iamVjdDtcbiIsIi8qKlxuICogVGhpcyBtZXRob2QgcmV0dXJucyBgZmFsc2VgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4xMy4wXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy50aW1lcygyLCBfLnN0dWJGYWxzZSk7XG4gKiAvLyA9PiBbZmFsc2UsIGZhbHNlXVxuICovXG5mdW5jdGlvbiBzdHViRmFsc2UoKSB7XG4gIHJldHVybiBmYWxzZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdHViRmFsc2U7XG4iLCJ2YXIgYmFzZUdldFRhZyA9IHJlcXVpcmUoJy4vX2Jhc2VHZXRUYWcnKSxcbiAgICBnZXRQcm90b3R5cGUgPSByZXF1aXJlKCcuL19nZXRQcm90b3R5cGUnKSxcbiAgICBpc09iamVjdExpa2UgPSByZXF1aXJlKCcuL2lzT2JqZWN0TGlrZScpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0VGFnID0gJ1tvYmplY3QgT2JqZWN0XSc7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBmdW5jUHJvdG8gPSBGdW5jdGlvbi5wcm90b3R5cGUsXG4gICAgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byByZXNvbHZlIHRoZSBkZWNvbXBpbGVkIHNvdXJjZSBvZiBmdW5jdGlvbnMuICovXG52YXIgZnVuY1RvU3RyaW5nID0gZnVuY1Byb3RvLnRvU3RyaW5nO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKiogVXNlZCB0byBpbmZlciB0aGUgYE9iamVjdGAgY29uc3RydWN0b3IuICovXG52YXIgb2JqZWN0Q3RvclN0cmluZyA9IGZ1bmNUb1N0cmluZy5jYWxsKE9iamVjdCk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBwbGFpbiBvYmplY3QsIHRoYXQgaXMsIGFuIG9iamVjdCBjcmVhdGVkIGJ5IHRoZVxuICogYE9iamVjdGAgY29uc3RydWN0b3Igb3Igb25lIHdpdGggYSBgW1tQcm90b3R5cGVdXWAgb2YgYG51bGxgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC44LjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgcGxhaW4gb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIGZ1bmN0aW9uIEZvbygpIHtcbiAqICAgdGhpcy5hID0gMTtcbiAqIH1cbiAqXG4gKiBfLmlzUGxhaW5PYmplY3QobmV3IEZvbyk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNQbGFpbk9iamVjdChbMSwgMiwgM10pO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzUGxhaW5PYmplY3QoeyAneCc6IDAsICd5JzogMCB9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzUGxhaW5PYmplY3QoT2JqZWN0LmNyZWF0ZShudWxsKSk7XG4gKiAvLyA9PiB0cnVlXG4gKi9cbmZ1bmN0aW9uIGlzUGxhaW5PYmplY3QodmFsdWUpIHtcbiAgaWYgKCFpc09iamVjdExpa2UodmFsdWUpIHx8IGJhc2VHZXRUYWcodmFsdWUpICE9IG9iamVjdFRhZykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgcHJvdG8gPSBnZXRQcm90b3R5cGUodmFsdWUpO1xuICBpZiAocHJvdG8gPT09IG51bGwpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICB2YXIgQ3RvciA9IGhhc093blByb3BlcnR5LmNhbGwocHJvdG8sICdjb25zdHJ1Y3RvcicpICYmIHByb3RvLmNvbnN0cnVjdG9yO1xuICByZXR1cm4gdHlwZW9mIEN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBDdG9yIGluc3RhbmNlb2YgQ3RvciAmJlxuICAgIGZ1bmNUb1N0cmluZy5jYWxsKEN0b3IpID09IG9iamVjdEN0b3JTdHJpbmc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNQbGFpbk9iamVjdDtcbiIsInZhciBiYXNlR2V0VGFnID0gcmVxdWlyZSgnLi9fYmFzZUdldFRhZycpLFxuICAgIGlzTGVuZ3RoID0gcmVxdWlyZSgnLi9pc0xlbmd0aCcpLFxuICAgIGlzT2JqZWN0TGlrZSA9IHJlcXVpcmUoJy4vaXNPYmplY3RMaWtlJyk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBhcmdzVGFnID0gJ1tvYmplY3QgQXJndW1lbnRzXScsXG4gICAgYXJyYXlUYWcgPSAnW29iamVjdCBBcnJheV0nLFxuICAgIGJvb2xUYWcgPSAnW29iamVjdCBCb29sZWFuXScsXG4gICAgZGF0ZVRhZyA9ICdbb2JqZWN0IERhdGVdJyxcbiAgICBlcnJvclRhZyA9ICdbb2JqZWN0IEVycm9yXScsXG4gICAgZnVuY1RhZyA9ICdbb2JqZWN0IEZ1bmN0aW9uXScsXG4gICAgbWFwVGFnID0gJ1tvYmplY3QgTWFwXScsXG4gICAgbnVtYmVyVGFnID0gJ1tvYmplY3QgTnVtYmVyXScsXG4gICAgb2JqZWN0VGFnID0gJ1tvYmplY3QgT2JqZWN0XScsXG4gICAgcmVnZXhwVGFnID0gJ1tvYmplY3QgUmVnRXhwXScsXG4gICAgc2V0VGFnID0gJ1tvYmplY3QgU2V0XScsXG4gICAgc3RyaW5nVGFnID0gJ1tvYmplY3QgU3RyaW5nXScsXG4gICAgd2Vha01hcFRhZyA9ICdbb2JqZWN0IFdlYWtNYXBdJztcblxudmFyIGFycmF5QnVmZmVyVGFnID0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJyxcbiAgICBkYXRhVmlld1RhZyA9ICdbb2JqZWN0IERhdGFWaWV3XScsXG4gICAgZmxvYXQzMlRhZyA9ICdbb2JqZWN0IEZsb2F0MzJBcnJheV0nLFxuICAgIGZsb2F0NjRUYWcgPSAnW29iamVjdCBGbG9hdDY0QXJyYXldJyxcbiAgICBpbnQ4VGFnID0gJ1tvYmplY3QgSW50OEFycmF5XScsXG4gICAgaW50MTZUYWcgPSAnW29iamVjdCBJbnQxNkFycmF5XScsXG4gICAgaW50MzJUYWcgPSAnW29iamVjdCBJbnQzMkFycmF5XScsXG4gICAgdWludDhUYWcgPSAnW29iamVjdCBVaW50OEFycmF5XScsXG4gICAgdWludDhDbGFtcGVkVGFnID0gJ1tvYmplY3QgVWludDhDbGFtcGVkQXJyYXldJyxcbiAgICB1aW50MTZUYWcgPSAnW29iamVjdCBVaW50MTZBcnJheV0nLFxuICAgIHVpbnQzMlRhZyA9ICdbb2JqZWN0IFVpbnQzMkFycmF5XSc7XG5cbi8qKiBVc2VkIHRvIGlkZW50aWZ5IGB0b1N0cmluZ1RhZ2AgdmFsdWVzIG9mIHR5cGVkIGFycmF5cy4gKi9cbnZhciB0eXBlZEFycmF5VGFncyA9IHt9O1xudHlwZWRBcnJheVRhZ3NbZmxvYXQzMlRhZ10gPSB0eXBlZEFycmF5VGFnc1tmbG9hdDY0VGFnXSA9XG50eXBlZEFycmF5VGFnc1tpbnQ4VGFnXSA9IHR5cGVkQXJyYXlUYWdzW2ludDE2VGFnXSA9XG50eXBlZEFycmF5VGFnc1tpbnQzMlRhZ10gPSB0eXBlZEFycmF5VGFnc1t1aW50OFRhZ10gPVxudHlwZWRBcnJheVRhZ3NbdWludDhDbGFtcGVkVGFnXSA9IHR5cGVkQXJyYXlUYWdzW3VpbnQxNlRhZ10gPVxudHlwZWRBcnJheVRhZ3NbdWludDMyVGFnXSA9IHRydWU7XG50eXBlZEFycmF5VGFnc1thcmdzVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2FycmF5VGFnXSA9XG50eXBlZEFycmF5VGFnc1thcnJheUJ1ZmZlclRhZ10gPSB0eXBlZEFycmF5VGFnc1tib29sVGFnXSA9XG50eXBlZEFycmF5VGFnc1tkYXRhVmlld1RhZ10gPSB0eXBlZEFycmF5VGFnc1tkYXRlVGFnXSA9XG50eXBlZEFycmF5VGFnc1tlcnJvclRhZ10gPSB0eXBlZEFycmF5VGFnc1tmdW5jVGFnXSA9XG50eXBlZEFycmF5VGFnc1ttYXBUYWddID0gdHlwZWRBcnJheVRhZ3NbbnVtYmVyVGFnXSA9XG50eXBlZEFycmF5VGFnc1tvYmplY3RUYWddID0gdHlwZWRBcnJheVRhZ3NbcmVnZXhwVGFnXSA9XG50eXBlZEFycmF5VGFnc1tzZXRUYWddID0gdHlwZWRBcnJheVRhZ3Nbc3RyaW5nVGFnXSA9XG50eXBlZEFycmF5VGFnc1t3ZWFrTWFwVGFnXSA9IGZhbHNlO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzVHlwZWRBcnJheWAgd2l0aG91dCBOb2RlLmpzIG9wdGltaXphdGlvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB0eXBlZCBhcnJheSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNUeXBlZEFycmF5KHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmXG4gICAgaXNMZW5ndGgodmFsdWUubGVuZ3RoKSAmJiAhIXR5cGVkQXJyYXlUYWdzW2Jhc2VHZXRUYWcodmFsdWUpXTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlSXNUeXBlZEFycmF5O1xuIiwiLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy51bmFyeWAgd2l0aG91dCBzdXBwb3J0IGZvciBzdG9yaW5nIG1ldGFkYXRhLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjYXAgYXJndW1lbnRzIGZvci5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGNhcHBlZCBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gYmFzZVVuYXJ5KGZ1bmMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgcmV0dXJuIGZ1bmModmFsdWUpO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VVbmFyeTtcbiIsInZhciBmcmVlR2xvYmFsID0gcmVxdWlyZSgnLi9fZnJlZUdsb2JhbCcpO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGV4cG9ydHNgLiAqL1xudmFyIGZyZWVFeHBvcnRzID0gdHlwZW9mIGV4cG9ydHMgPT0gJ29iamVjdCcgJiYgZXhwb3J0cyAmJiAhZXhwb3J0cy5ub2RlVHlwZSAmJiBleHBvcnRzO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYG1vZHVsZWAuICovXG52YXIgZnJlZU1vZHVsZSA9IGZyZWVFeHBvcnRzICYmIHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlICYmICFtb2R1bGUubm9kZVR5cGUgJiYgbW9kdWxlO1xuXG4vKiogRGV0ZWN0IHRoZSBwb3B1bGFyIENvbW1vbkpTIGV4dGVuc2lvbiBgbW9kdWxlLmV4cG9ydHNgLiAqL1xudmFyIG1vZHVsZUV4cG9ydHMgPSBmcmVlTW9kdWxlICYmIGZyZWVNb2R1bGUuZXhwb3J0cyA9PT0gZnJlZUV4cG9ydHM7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgcHJvY2Vzc2AgZnJvbSBOb2RlLmpzLiAqL1xudmFyIGZyZWVQcm9jZXNzID0gbW9kdWxlRXhwb3J0cyAmJiBmcmVlR2xvYmFsLnByb2Nlc3M7XG5cbi8qKiBVc2VkIHRvIGFjY2VzcyBmYXN0ZXIgTm9kZS5qcyBoZWxwZXJzLiAqL1xudmFyIG5vZGVVdGlsID0gKGZ1bmN0aW9uKCkge1xuICB0cnkge1xuICAgIC8vIFVzZSBgdXRpbC50eXBlc2AgZm9yIE5vZGUuanMgMTArLlxuICAgIHZhciB0eXBlcyA9IGZyZWVNb2R1bGUgJiYgZnJlZU1vZHVsZS5yZXF1aXJlICYmIGZyZWVNb2R1bGUucmVxdWlyZSgndXRpbCcpLnR5cGVzO1xuXG4gICAgaWYgKHR5cGVzKSB7XG4gICAgICByZXR1cm4gdHlwZXM7XG4gICAgfVxuXG4gICAgLy8gTGVnYWN5IGBwcm9jZXNzLmJpbmRpbmcoJ3V0aWwnKWAgZm9yIE5vZGUuanMgPCAxMC5cbiAgICByZXR1cm4gZnJlZVByb2Nlc3MgJiYgZnJlZVByb2Nlc3MuYmluZGluZyAmJiBmcmVlUHJvY2Vzcy5iaW5kaW5nKCd1dGlsJyk7XG4gIH0gY2F0Y2ggKGUpIHt9XG59KCkpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IG5vZGVVdGlsO1xuIiwidmFyIGNvcHlPYmplY3QgPSByZXF1aXJlKCcuL19jb3B5T2JqZWN0JyksXG4gICAga2V5c0luID0gcmVxdWlyZSgnLi9rZXlzSW4nKTtcblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgcGxhaW4gb2JqZWN0IGZsYXR0ZW5pbmcgaW5oZXJpdGVkIGVudW1lcmFibGUgc3RyaW5nXG4gKiBrZXllZCBwcm9wZXJ0aWVzIG9mIGB2YWx1ZWAgdG8gb3duIHByb3BlcnRpZXMgb2YgdGhlIHBsYWluIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDMuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBwbGFpbiBvYmplY3QuXG4gKiBAZXhhbXBsZVxuICpcbiAqIGZ1bmN0aW9uIEZvbygpIHtcbiAqICAgdGhpcy5iID0gMjtcbiAqIH1cbiAqXG4gKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICpcbiAqIF8uYXNzaWduKHsgJ2EnOiAxIH0sIG5ldyBGb28pO1xuICogLy8gPT4geyAnYSc6IDEsICdiJzogMiB9XG4gKlxuICogXy5hc3NpZ24oeyAnYSc6IDEgfSwgXy50b1BsYWluT2JqZWN0KG5ldyBGb28pKTtcbiAqIC8vID0+IHsgJ2EnOiAxLCAnYic6IDIsICdjJzogMyB9XG4gKi9cbmZ1bmN0aW9uIHRvUGxhaW5PYmplY3QodmFsdWUpIHtcbiAgcmV0dXJuIGNvcHlPYmplY3QodmFsdWUsIGtleXNJbih2YWx1ZSkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHRvUGxhaW5PYmplY3Q7XG4iLCJ2YXIgYXNzaWduVmFsdWUgPSByZXF1aXJlKCcuL19hc3NpZ25WYWx1ZScpLFxuICAgIGJhc2VBc3NpZ25WYWx1ZSA9IHJlcXVpcmUoJy4vX2Jhc2VBc3NpZ25WYWx1ZScpO1xuXG4vKipcbiAqIENvcGllcyBwcm9wZXJ0aWVzIG9mIGBzb3VyY2VgIHRvIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3QgdG8gY29weSBwcm9wZXJ0aWVzIGZyb20uXG4gKiBAcGFyYW0ge0FycmF5fSBwcm9wcyBUaGUgcHJvcGVydHkgaWRlbnRpZmllcnMgdG8gY29weS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0PXt9XSBUaGUgb2JqZWN0IHRvIGNvcHkgcHJvcGVydGllcyB0by5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvcGllZCB2YWx1ZXMuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICovXG5mdW5jdGlvbiBjb3B5T2JqZWN0KHNvdXJjZSwgcHJvcHMsIG9iamVjdCwgY3VzdG9taXplcikge1xuICB2YXIgaXNOZXcgPSAhb2JqZWN0O1xuICBvYmplY3QgfHwgKG9iamVjdCA9IHt9KTtcblxuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IHByb3BzLmxlbmd0aDtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBrZXkgPSBwcm9wc1tpbmRleF07XG5cbiAgICB2YXIgbmV3VmFsdWUgPSBjdXN0b21pemVyXG4gICAgICA/IGN1c3RvbWl6ZXIob2JqZWN0W2tleV0sIHNvdXJjZVtrZXldLCBrZXksIG9iamVjdCwgc291cmNlKVxuICAgICAgOiB1bmRlZmluZWQ7XG5cbiAgICBpZiAobmV3VmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgbmV3VmFsdWUgPSBzb3VyY2Vba2V5XTtcbiAgICB9XG4gICAgaWYgKGlzTmV3KSB7XG4gICAgICBiYXNlQXNzaWduVmFsdWUob2JqZWN0LCBrZXksIG5ld1ZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYXNzaWduVmFsdWUob2JqZWN0LCBrZXksIG5ld1ZhbHVlKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG9iamVjdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjb3B5T2JqZWN0O1xuIiwidmFyIGJhc2VUaW1lcyA9IHJlcXVpcmUoJy4vX2Jhc2VUaW1lcycpLFxuICAgIGlzQXJndW1lbnRzID0gcmVxdWlyZSgnLi9pc0FyZ3VtZW50cycpLFxuICAgIGlzQXJyYXkgPSByZXF1aXJlKCcuL2lzQXJyYXknKSxcbiAgICBpc0J1ZmZlciA9IHJlcXVpcmUoJy4vaXNCdWZmZXInKSxcbiAgICBpc0luZGV4ID0gcmVxdWlyZSgnLi9faXNJbmRleCcpLFxuICAgIGlzVHlwZWRBcnJheSA9IHJlcXVpcmUoJy4vaXNUeXBlZEFycmF5Jyk7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBvZiB0aGUgYXJyYXktbGlrZSBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaW5oZXJpdGVkIFNwZWNpZnkgcmV0dXJuaW5nIGluaGVyaXRlZCBwcm9wZXJ0eSBuYW1lcy5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKi9cbmZ1bmN0aW9uIGFycmF5TGlrZUtleXModmFsdWUsIGluaGVyaXRlZCkge1xuICB2YXIgaXNBcnIgPSBpc0FycmF5KHZhbHVlKSxcbiAgICAgIGlzQXJnID0gIWlzQXJyICYmIGlzQXJndW1lbnRzKHZhbHVlKSxcbiAgICAgIGlzQnVmZiA9ICFpc0FyciAmJiAhaXNBcmcgJiYgaXNCdWZmZXIodmFsdWUpLFxuICAgICAgaXNUeXBlID0gIWlzQXJyICYmICFpc0FyZyAmJiAhaXNCdWZmICYmIGlzVHlwZWRBcnJheSh2YWx1ZSksXG4gICAgICBza2lwSW5kZXhlcyA9IGlzQXJyIHx8IGlzQXJnIHx8IGlzQnVmZiB8fCBpc1R5cGUsXG4gICAgICByZXN1bHQgPSBza2lwSW5kZXhlcyA/IGJhc2VUaW1lcyh2YWx1ZS5sZW5ndGgsIFN0cmluZykgOiBbXSxcbiAgICAgIGxlbmd0aCA9IHJlc3VsdC5sZW5ndGg7XG5cbiAgZm9yICh2YXIga2V5IGluIHZhbHVlKSB7XG4gICAgaWYgKChpbmhlcml0ZWQgfHwgaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwga2V5KSkgJiZcbiAgICAgICAgIShza2lwSW5kZXhlcyAmJiAoXG4gICAgICAgICAgIC8vIFNhZmFyaSA5IGhhcyBlbnVtZXJhYmxlIGBhcmd1bWVudHMubGVuZ3RoYCBpbiBzdHJpY3QgbW9kZS5cbiAgICAgICAgICAga2V5ID09ICdsZW5ndGgnIHx8XG4gICAgICAgICAgIC8vIE5vZGUuanMgMC4xMCBoYXMgZW51bWVyYWJsZSBub24taW5kZXggcHJvcGVydGllcyBvbiBidWZmZXJzLlxuICAgICAgICAgICAoaXNCdWZmICYmIChrZXkgPT0gJ29mZnNldCcgfHwga2V5ID09ICdwYXJlbnQnKSkgfHxcbiAgICAgICAgICAgLy8gUGhhbnRvbUpTIDIgaGFzIGVudW1lcmFibGUgbm9uLWluZGV4IHByb3BlcnRpZXMgb24gdHlwZWQgYXJyYXlzLlxuICAgICAgICAgICAoaXNUeXBlICYmIChrZXkgPT0gJ2J1ZmZlcicgfHwga2V5ID09ICdieXRlTGVuZ3RoJyB8fCBrZXkgPT0gJ2J5dGVPZmZzZXQnKSkgfHxcbiAgICAgICAgICAgLy8gU2tpcCBpbmRleCBwcm9wZXJ0aWVzLlxuICAgICAgICAgICBpc0luZGV4KGtleSwgbGVuZ3RoKVxuICAgICAgICApKSkge1xuICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhcnJheUxpa2VLZXlzO1xuIiwiLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy50aW1lc2Agd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzXG4gKiBvciBtYXggYXJyYXkgbGVuZ3RoIGNoZWNrcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtudW1iZXJ9IG4gVGhlIG51bWJlciBvZiB0aW1lcyB0byBpbnZva2UgYGl0ZXJhdGVlYC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHJlc3VsdHMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VUaW1lcyhuLCBpdGVyYXRlZSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIHJlc3VsdCA9IEFycmF5KG4pO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbikge1xuICAgIHJlc3VsdFtpbmRleF0gPSBpdGVyYXRlZShpbmRleCk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlVGltZXM7XG4iLCJ2YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL2lzT2JqZWN0JyksXG4gICAgaXNQcm90b3R5cGUgPSByZXF1aXJlKCcuL19pc1Byb3RvdHlwZScpLFxuICAgIG5hdGl2ZUtleXNJbiA9IHJlcXVpcmUoJy4vX25hdGl2ZUtleXNJbicpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmtleXNJbmAgd2hpY2ggZG9lc24ndCB0cmVhdCBzcGFyc2UgYXJyYXlzIGFzIGRlbnNlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICovXG5mdW5jdGlvbiBiYXNlS2V5c0luKG9iamVjdCkge1xuICBpZiAoIWlzT2JqZWN0KG9iamVjdCkpIHtcbiAgICByZXR1cm4gbmF0aXZlS2V5c0luKG9iamVjdCk7XG4gIH1cbiAgdmFyIGlzUHJvdG8gPSBpc1Byb3RvdHlwZShvYmplY3QpLFxuICAgICAgcmVzdWx0ID0gW107XG5cbiAgZm9yICh2YXIga2V5IGluIG9iamVjdCkge1xuICAgIGlmICghKGtleSA9PSAnY29uc3RydWN0b3InICYmIChpc1Byb3RvIHx8ICFoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSkpKSB7XG4gICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VLZXlzSW47XG4iLCIvKipcbiAqIFRoaXMgZnVuY3Rpb24gaXMgbGlrZVxuICogW2BPYmplY3Qua2V5c2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5rZXlzKVxuICogZXhjZXB0IHRoYXQgaXQgaW5jbHVkZXMgaW5oZXJpdGVkIGVudW1lcmFibGUgcHJvcGVydGllcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqL1xuZnVuY3Rpb24gbmF0aXZlS2V5c0luKG9iamVjdCkge1xuICB2YXIgcmVzdWx0ID0gW107XG4gIGlmIChvYmplY3QgIT0gbnVsbCkge1xuICAgIGZvciAodmFyIGtleSBpbiBPYmplY3Qob2JqZWN0KSkge1xuICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBuYXRpdmVLZXlzSW47XG4iLCJ2YXIgYmFzZVJlc3QgPSByZXF1aXJlKCcuL19iYXNlUmVzdCcpLFxuICAgIGlzSXRlcmF0ZWVDYWxsID0gcmVxdWlyZSgnLi9faXNJdGVyYXRlZUNhbGwnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gbGlrZSBgXy5hc3NpZ25gLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBhc3NpZ25lciBUaGUgZnVuY3Rpb24gdG8gYXNzaWduIHZhbHVlcy5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGFzc2lnbmVyIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBjcmVhdGVBc3NpZ25lcihhc3NpZ25lcikge1xuICByZXR1cm4gYmFzZVJlc3QoZnVuY3Rpb24ob2JqZWN0LCBzb3VyY2VzKSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIGxlbmd0aCA9IHNvdXJjZXMubGVuZ3RoLFxuICAgICAgICBjdXN0b21pemVyID0gbGVuZ3RoID4gMSA/IHNvdXJjZXNbbGVuZ3RoIC0gMV0gOiB1bmRlZmluZWQsXG4gICAgICAgIGd1YXJkID0gbGVuZ3RoID4gMiA/IHNvdXJjZXNbMl0gOiB1bmRlZmluZWQ7XG5cbiAgICBjdXN0b21pemVyID0gKGFzc2lnbmVyLmxlbmd0aCA+IDMgJiYgdHlwZW9mIGN1c3RvbWl6ZXIgPT0gJ2Z1bmN0aW9uJylcbiAgICAgID8gKGxlbmd0aC0tLCBjdXN0b21pemVyKVxuICAgICAgOiB1bmRlZmluZWQ7XG5cbiAgICBpZiAoZ3VhcmQgJiYgaXNJdGVyYXRlZUNhbGwoc291cmNlc1swXSwgc291cmNlc1sxXSwgZ3VhcmQpKSB7XG4gICAgICBjdXN0b21pemVyID0gbGVuZ3RoIDwgMyA/IHVuZGVmaW5lZCA6IGN1c3RvbWl6ZXI7XG4gICAgICBsZW5ndGggPSAxO1xuICAgIH1cbiAgICBvYmplY3QgPSBPYmplY3Qob2JqZWN0KTtcbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgdmFyIHNvdXJjZSA9IHNvdXJjZXNbaW5kZXhdO1xuICAgICAgaWYgKHNvdXJjZSkge1xuICAgICAgICBhc3NpZ25lcihvYmplY3QsIHNvdXJjZSwgaW5kZXgsIGN1c3RvbWl6ZXIpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb2JqZWN0O1xuICB9KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVBc3NpZ25lcjtcbiIsInZhciBpZGVudGl0eSA9IHJlcXVpcmUoJy4vaWRlbnRpdHknKSxcbiAgICBvdmVyUmVzdCA9IHJlcXVpcmUoJy4vX292ZXJSZXN0JyksXG4gICAgc2V0VG9TdHJpbmcgPSByZXF1aXJlKCcuL19zZXRUb1N0cmluZycpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnJlc3RgIHdoaWNoIGRvZXNuJ3QgdmFsaWRhdGUgb3IgY29lcmNlIGFyZ3VtZW50cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gYXBwbHkgYSByZXN0IHBhcmFtZXRlciB0by5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnQ9ZnVuYy5sZW5ndGgtMV0gVGhlIHN0YXJ0IHBvc2l0aW9uIG9mIHRoZSByZXN0IHBhcmFtZXRlci5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBiYXNlUmVzdChmdW5jLCBzdGFydCkge1xuICByZXR1cm4gc2V0VG9TdHJpbmcob3ZlclJlc3QoZnVuYywgc3RhcnQsIGlkZW50aXR5KSwgZnVuYyArICcnKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlUmVzdDtcbiIsIi8qKlxuICogQSBmYXN0ZXIgYWx0ZXJuYXRpdmUgdG8gYEZ1bmN0aW9uI2FwcGx5YCwgdGhpcyBmdW5jdGlvbiBpbnZva2VzIGBmdW5jYFxuICogd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgb2YgYHRoaXNBcmdgIGFuZCB0aGUgYXJndW1lbnRzIG9mIGBhcmdzYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gaW52b2tlLlxuICogQHBhcmFtIHsqfSB0aGlzQXJnIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgZnVuY2AuXG4gKiBAcGFyYW0ge0FycmF5fSBhcmdzIFRoZSBhcmd1bWVudHMgdG8gaW52b2tlIGBmdW5jYCB3aXRoLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc3VsdCBvZiBgZnVuY2AuXG4gKi9cbmZ1bmN0aW9uIGFwcGx5KGZ1bmMsIHRoaXNBcmcsIGFyZ3MpIHtcbiAgc3dpdGNoIChhcmdzLmxlbmd0aCkge1xuICAgIGNhc2UgMDogcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnKTtcbiAgICBjYXNlIDE6IHJldHVybiBmdW5jLmNhbGwodGhpc0FyZywgYXJnc1swXSk7XG4gICAgY2FzZSAyOiByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcsIGFyZ3NbMF0sIGFyZ3NbMV0pO1xuICAgIGNhc2UgMzogcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnLCBhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdKTtcbiAgfVxuICByZXR1cm4gZnVuYy5hcHBseSh0aGlzQXJnLCBhcmdzKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhcHBseTtcbiIsInZhciBjb25zdGFudCA9IHJlcXVpcmUoJy4vY29uc3RhbnQnKSxcbiAgICBkZWZpbmVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vX2RlZmluZVByb3BlcnR5JyksXG4gICAgaWRlbnRpdHkgPSByZXF1aXJlKCcuL2lkZW50aXR5Jyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYHNldFRvU3RyaW5nYCB3aXRob3V0IHN1cHBvcnQgZm9yIGhvdCBsb29wIHNob3J0aW5nLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBzdHJpbmcgVGhlIGB0b1N0cmluZ2AgcmVzdWx0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIGBmdW5jYC5cbiAqL1xudmFyIGJhc2VTZXRUb1N0cmluZyA9ICFkZWZpbmVQcm9wZXJ0eSA/IGlkZW50aXR5IDogZnVuY3Rpb24oZnVuYywgc3RyaW5nKSB7XG4gIHJldHVybiBkZWZpbmVQcm9wZXJ0eShmdW5jLCAndG9TdHJpbmcnLCB7XG4gICAgJ2NvbmZpZ3VyYWJsZSc6IHRydWUsXG4gICAgJ2VudW1lcmFibGUnOiBmYWxzZSxcbiAgICAndmFsdWUnOiBjb25zdGFudChzdHJpbmcpLFxuICAgICd3cml0YWJsZSc6IHRydWVcbiAgfSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VTZXRUb1N0cmluZztcbiIsIi8qKlxuICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBgdmFsdWVgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMi40LjBcbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byByZXR1cm4gZnJvbSB0aGUgbmV3IGZ1bmN0aW9uLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgY29uc3RhbnQgZnVuY3Rpb24uXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3RzID0gXy50aW1lcygyLCBfLmNvbnN0YW50KHsgJ2EnOiAxIH0pKTtcbiAqXG4gKiBjb25zb2xlLmxvZyhvYmplY3RzKTtcbiAqIC8vID0+IFt7ICdhJzogMSB9LCB7ICdhJzogMSB9XVxuICpcbiAqIGNvbnNvbGUubG9nKG9iamVjdHNbMF0gPT09IG9iamVjdHNbMV0pO1xuICogLy8gPT4gdHJ1ZVxuICovXG5mdW5jdGlvbiBjb25zdGFudCh2YWx1ZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNvbnN0YW50O1xuIiwiLyoqIFVzZWQgdG8gZGV0ZWN0IGhvdCBmdW5jdGlvbnMgYnkgbnVtYmVyIG9mIGNhbGxzIHdpdGhpbiBhIHNwYW4gb2YgbWlsbGlzZWNvbmRzLiAqL1xudmFyIEhPVF9DT1VOVCA9IDgwMCxcbiAgICBIT1RfU1BBTiA9IDE2O1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlTm93ID0gRGF0ZS5ub3c7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQnbGwgc2hvcnQgb3V0IGFuZCBpbnZva2UgYGlkZW50aXR5YCBpbnN0ZWFkXG4gKiBvZiBgZnVuY2Agd2hlbiBpdCdzIGNhbGxlZCBgSE9UX0NPVU5UYCBvciBtb3JlIHRpbWVzIGluIGBIT1RfU1BBTmBcbiAqIG1pbGxpc2Vjb25kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gcmVzdHJpY3QuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBzaG9ydGFibGUgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIHNob3J0T3V0KGZ1bmMpIHtcbiAgdmFyIGNvdW50ID0gMCxcbiAgICAgIGxhc3RDYWxsZWQgPSAwO1xuXG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgc3RhbXAgPSBuYXRpdmVOb3coKSxcbiAgICAgICAgcmVtYWluaW5nID0gSE9UX1NQQU4gLSAoc3RhbXAgLSBsYXN0Q2FsbGVkKTtcblxuICAgIGxhc3RDYWxsZWQgPSBzdGFtcDtcbiAgICBpZiAocmVtYWluaW5nID4gMCkge1xuICAgICAgaWYgKCsrY291bnQgPj0gSE9UX0NPVU5UKSB7XG4gICAgICAgIHJldHVybiBhcmd1bWVudHNbMF07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvdW50ID0gMDtcbiAgICB9XG4gICAgcmV0dXJuIGZ1bmMuYXBwbHkodW5kZWZpbmVkLCBhcmd1bWVudHMpO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNob3J0T3V0O1xuIiwidmFyIGVxID0gcmVxdWlyZSgnLi9lcScpLFxuICAgIGlzQXJyYXlMaWtlID0gcmVxdWlyZSgnLi9pc0FycmF5TGlrZScpLFxuICAgIGlzSW5kZXggPSByZXF1aXJlKCcuL19pc0luZGV4JyksXG4gICAgaXNPYmplY3QgPSByZXF1aXJlKCcuL2lzT2JqZWN0Jyk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIHRoZSBnaXZlbiBhcmd1bWVudHMgYXJlIGZyb20gYW4gaXRlcmF0ZWUgY2FsbC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgcG90ZW50aWFsIGl0ZXJhdGVlIHZhbHVlIGFyZ3VtZW50LlxuICogQHBhcmFtIHsqfSBpbmRleCBUaGUgcG90ZW50aWFsIGl0ZXJhdGVlIGluZGV4IG9yIGtleSBhcmd1bWVudC5cbiAqIEBwYXJhbSB7Kn0gb2JqZWN0IFRoZSBwb3RlbnRpYWwgaXRlcmF0ZWUgb2JqZWN0IGFyZ3VtZW50LlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBhcmd1bWVudHMgYXJlIGZyb20gYW4gaXRlcmF0ZWUgY2FsbCxcbiAqICBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzSXRlcmF0ZWVDYWxsKHZhbHVlLCBpbmRleCwgb2JqZWN0KSB7XG4gIGlmICghaXNPYmplY3Qob2JqZWN0KSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgdHlwZSA9IHR5cGVvZiBpbmRleDtcbiAgaWYgKHR5cGUgPT0gJ251bWJlcidcbiAgICAgICAgPyAoaXNBcnJheUxpa2Uob2JqZWN0KSAmJiBpc0luZGV4KGluZGV4LCBvYmplY3QubGVuZ3RoKSlcbiAgICAgICAgOiAodHlwZSA9PSAnc3RyaW5nJyAmJiBpbmRleCBpbiBvYmplY3QpXG4gICAgICApIHtcbiAgICByZXR1cm4gZXEob2JqZWN0W2luZGV4XSwgdmFsdWUpO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0l0ZXJhdGVlQ2FsbDtcbiIsIi8qXG4gKiB0eXBlZGVmcy5qc1xuICogTm9ybWFsaXplcyBicm93c2VyLXNwZWNpZmljIHByZWZpeGVzIGFuZCBwcm92aWRlIHNvbWUgYmFzaWMgcG9seWZpbGxzXG4gKi9cblxuaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgaWYgKCF3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKSB7XG4gICAgICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHdpbmRvdy53ZWJraXRSZXF1ZXN0QW5pbWF0aW9uRnJhbWVcbiAgICAgICAgICAgICAgICB8fCB3aW5kb3cubW96UmVxdWVzdEFuaW1hdGlvbkZyYW1lXG4gICAgICAgICAgICAgICAgfHwgd2luZG93Lm9SZXF1ZXN0QW5pbWF0aW9uRnJhbWVcbiAgICAgICAgICAgICAgICB8fCB3aW5kb3cubXNSZXF1ZXN0QW5pbWF0aW9uRnJhbWVcbiAgICAgICAgICAgICAgICB8fCBmdW5jdGlvbiAoLyogZnVuY3Rpb24gRnJhbWVSZXF1ZXN0Q2FsbGJhY2sgKi8gY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgd2luZG93LnNldFRpbWVvdXQoY2FsbGJhY2ssIDEwMDAgLyA2MCk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgfSgpKTtcbiAgICB9XG59XG5cbmlmICh0eXBlb2YgTWF0aC5pbXVsICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgLyogZXNsaW50LWRpc2FibGUgbm8tYml0d2lzZSAqL1xuICAgIE1hdGguaW11bCA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIGNvbnN0IGFoID0gKGEgPj4+IDE2KSAmIDB4ZmZmZjtcbiAgICAgICAgY29uc3QgYWwgPSBhICYgMHhmZmZmO1xuICAgICAgICBjb25zdCBiaCA9IChiID4+PiAxNikgJiAweGZmZmY7XG4gICAgICAgIGNvbnN0IGJsID0gYiAmIDB4ZmZmZjtcbiAgICAgICAgLy8gdGhlIHNoaWZ0IGJ5IDAgZml4ZXMgdGhlIHNpZ24gb24gdGhlIGhpZ2ggcGFydFxuICAgICAgICAvLyB0aGUgZmluYWwgfDAgY29udmVydHMgdGhlIHVuc2lnbmVkIHZhbHVlIGludG8gYSBzaWduZWQgdmFsdWVcbiAgICAgICAgcmV0dXJuICgoYWwgKiBibCkgKyAoKChhaCAqIGJsICsgYWwgKiBiaCkgPDwgMTYpID4+PiAwKSB8IDApO1xuICAgIH07XG4gICAgLyogZXNsaW50LWVuYWJsZSBuby1iaXR3aXNlICovXG59XG5cbmlmICh0eXBlb2YgT2JqZWN0LmFzc2lnbiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIE9iamVjdC5hc3NpZ24gPSBmdW5jdGlvbiAodGFyZ2V0KSB7IC8vIC5sZW5ndGggb2YgZnVuY3Rpb24gaXMgMlxuXG4ndXNlIHN0cmljdCc7XG5cbiAgICAgICAgaWYgKHRhcmdldCA9PT0gbnVsbCkgeyAvLyBUeXBlRXJyb3IgaWYgdW5kZWZpbmVkIG9yIG51bGxcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBjb252ZXJ0IHVuZGVmaW5lZCBvciBudWxsIHRvIG9iamVjdCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgdG8gPSBPYmplY3QodGFyZ2V0KTtcblxuICAgICAgICBmb3IgKGxldCBpbmRleCA9IDE7IGluZGV4IDwgYXJndW1lbnRzLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHByZWZlci1yZXN0LXBhcmFtc1xuICAgICAgICAgICAgY29uc3QgbmV4dFNvdXJjZSA9IGFyZ3VtZW50c1tpbmRleF07XG5cbiAgICAgICAgICAgIGlmIChuZXh0U291cmNlICE9PSBudWxsKSB7IC8vIFNraXAgb3ZlciBpZiB1bmRlZmluZWQgb3IgbnVsbFxuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZXN0cmljdGVkLXN5bnRheFxuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgbmV4dEtleSBpbiBuZXh0U291cmNlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEF2b2lkIGJ1Z3Mgd2hlbiBoYXNPd25Qcm9wZXJ0eSBpcyBzaGFkb3dlZFxuICAgICAgICAgICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG5leHRTb3VyY2UsIG5leHRLZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0b1tuZXh0S2V5XSA9IG5leHRTb3VyY2VbbmV4dEtleV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRvO1xuICAgIH07XG59XG4iLCJmdW5jdGlvbiBfYXJyYXlXaXRoSG9sZXMoYXJyKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGFycikpIHJldHVybiBhcnI7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2FycmF5V2l0aEhvbGVzLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZSwgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHM7IiwiZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheUxpbWl0KGFyciwgaSkge1xuICB2YXIgX2kgPSBhcnIgPT0gbnVsbCA/IG51bGwgOiB0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIGFycltTeW1ib2wuaXRlcmF0b3JdIHx8IGFycltcIkBAaXRlcmF0b3JcIl07XG5cbiAgaWYgKF9pID09IG51bGwpIHJldHVybjtcbiAgdmFyIF9hcnIgPSBbXTtcbiAgdmFyIF9uID0gdHJ1ZTtcbiAgdmFyIF9kID0gZmFsc2U7XG5cbiAgdmFyIF9zLCBfZTtcblxuICB0cnkge1xuICAgIGZvciAoX2kgPSBfaS5jYWxsKGFycik7ICEoX24gPSAoX3MgPSBfaS5uZXh0KCkpLmRvbmUpOyBfbiA9IHRydWUpIHtcbiAgICAgIF9hcnIucHVzaChfcy52YWx1ZSk7XG5cbiAgICAgIGlmIChpICYmIF9hcnIubGVuZ3RoID09PSBpKSBicmVhaztcbiAgICB9XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIF9kID0gdHJ1ZTtcbiAgICBfZSA9IGVycjtcbiAgfSBmaW5hbGx5IHtcbiAgICB0cnkge1xuICAgICAgaWYgKCFfbiAmJiBfaVtcInJldHVyblwiXSAhPSBudWxsKSBfaVtcInJldHVyblwiXSgpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBpZiAoX2QpIHRocm93IF9lO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBfYXJyO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9pdGVyYWJsZVRvQXJyYXlMaW1pdCwgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzOyIsImZ1bmN0aW9uIF9ub25JdGVyYWJsZVJlc3QoKSB7XG4gIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX25vbkl0ZXJhYmxlUmVzdCwgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzOyIsInZhciBfdHlwZW9mID0gcmVxdWlyZShcIi4vdHlwZW9mLmpzXCIpW1wiZGVmYXVsdFwiXTtcblxuZnVuY3Rpb24gX3JlZ2VuZXJhdG9yUnVudGltZSgpIHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG4gIC8qISByZWdlbmVyYXRvci1ydW50aW1lIC0tIENvcHlyaWdodCAoYykgMjAxNC1wcmVzZW50LCBGYWNlYm9vaywgSW5jLiAtLSBsaWNlbnNlIChNSVQpOiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVnZW5lcmF0b3IvYmxvYi9tYWluL0xJQ0VOU0UgKi9cblxuICBtb2R1bGUuZXhwb3J0cyA9IF9yZWdlbmVyYXRvclJ1bnRpbWUgPSBmdW5jdGlvbiBfcmVnZW5lcmF0b3JSdW50aW1lKCkge1xuICAgIHJldHVybiBleHBvcnRzO1xuICB9LCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZSwgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHM7XG4gIHZhciBleHBvcnRzID0ge30sXG4gICAgICBPcCA9IE9iamVjdC5wcm90b3R5cGUsXG4gICAgICBoYXNPd24gPSBPcC5oYXNPd25Qcm9wZXJ0eSxcbiAgICAgICRTeW1ib2wgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCA/IFN5bWJvbCA6IHt9LFxuICAgICAgaXRlcmF0b3JTeW1ib2wgPSAkU3ltYm9sLml0ZXJhdG9yIHx8IFwiQEBpdGVyYXRvclwiLFxuICAgICAgYXN5bmNJdGVyYXRvclN5bWJvbCA9ICRTeW1ib2wuYXN5bmNJdGVyYXRvciB8fCBcIkBAYXN5bmNJdGVyYXRvclwiLFxuICAgICAgdG9TdHJpbmdUYWdTeW1ib2wgPSAkU3ltYm9sLnRvU3RyaW5nVGFnIHx8IFwiQEB0b1N0cmluZ1RhZ1wiO1xuXG4gIGZ1bmN0aW9uIGRlZmluZShvYmosIGtleSwgdmFsdWUpIHtcbiAgICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICBlbnVtZXJhYmxlOiAhMCxcbiAgICAgIGNvbmZpZ3VyYWJsZTogITAsXG4gICAgICB3cml0YWJsZTogITBcbiAgICB9KSwgb2JqW2tleV07XG4gIH1cblxuICB0cnkge1xuICAgIGRlZmluZSh7fSwgXCJcIik7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGRlZmluZSA9IGZ1bmN0aW9uIGRlZmluZShvYmosIGtleSwgdmFsdWUpIHtcbiAgICAgIHJldHVybiBvYmpba2V5XSA9IHZhbHVlO1xuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiB3cmFwKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0KSB7XG4gICAgdmFyIHByb3RvR2VuZXJhdG9yID0gb3V0ZXJGbiAmJiBvdXRlckZuLnByb3RvdHlwZSBpbnN0YW5jZW9mIEdlbmVyYXRvciA/IG91dGVyRm4gOiBHZW5lcmF0b3IsXG4gICAgICAgIGdlbmVyYXRvciA9IE9iamVjdC5jcmVhdGUocHJvdG9HZW5lcmF0b3IucHJvdG90eXBlKSxcbiAgICAgICAgY29udGV4dCA9IG5ldyBDb250ZXh0KHRyeUxvY3NMaXN0IHx8IFtdKTtcbiAgICByZXR1cm4gZ2VuZXJhdG9yLl9pbnZva2UgPSBmdW5jdGlvbiAoaW5uZXJGbiwgc2VsZiwgY29udGV4dCkge1xuICAgICAgdmFyIHN0YXRlID0gXCJzdXNwZW5kZWRTdGFydFwiO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChtZXRob2QsIGFyZykge1xuICAgICAgICBpZiAoXCJleGVjdXRpbmdcIiA9PT0gc3RhdGUpIHRocm93IG5ldyBFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IHJ1bm5pbmdcIik7XG5cbiAgICAgICAgaWYgKFwiY29tcGxldGVkXCIgPT09IHN0YXRlKSB7XG4gICAgICAgICAgaWYgKFwidGhyb3dcIiA9PT0gbWV0aG9kKSB0aHJvdyBhcmc7XG4gICAgICAgICAgcmV0dXJuIGRvbmVSZXN1bHQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoY29udGV4dC5tZXRob2QgPSBtZXRob2QsIGNvbnRleHQuYXJnID0gYXJnOzspIHtcbiAgICAgICAgICB2YXIgZGVsZWdhdGUgPSBjb250ZXh0LmRlbGVnYXRlO1xuXG4gICAgICAgICAgaWYgKGRlbGVnYXRlKSB7XG4gICAgICAgICAgICB2YXIgZGVsZWdhdGVSZXN1bHQgPSBtYXliZUludm9rZURlbGVnYXRlKGRlbGVnYXRlLCBjb250ZXh0KTtcblxuICAgICAgICAgICAgaWYgKGRlbGVnYXRlUmVzdWx0KSB7XG4gICAgICAgICAgICAgIGlmIChkZWxlZ2F0ZVJlc3VsdCA9PT0gQ29udGludWVTZW50aW5lbCkgY29udGludWU7XG4gICAgICAgICAgICAgIHJldHVybiBkZWxlZ2F0ZVJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoXCJuZXh0XCIgPT09IGNvbnRleHQubWV0aG9kKSBjb250ZXh0LnNlbnQgPSBjb250ZXh0Ll9zZW50ID0gY29udGV4dC5hcmc7ZWxzZSBpZiAoXCJ0aHJvd1wiID09PSBjb250ZXh0Lm1ldGhvZCkge1xuICAgICAgICAgICAgaWYgKFwic3VzcGVuZGVkU3RhcnRcIiA9PT0gc3RhdGUpIHRocm93IHN0YXRlID0gXCJjb21wbGV0ZWRcIiwgY29udGV4dC5hcmc7XG4gICAgICAgICAgICBjb250ZXh0LmRpc3BhdGNoRXhjZXB0aW9uKGNvbnRleHQuYXJnKTtcbiAgICAgICAgICB9IGVsc2UgXCJyZXR1cm5cIiA9PT0gY29udGV4dC5tZXRob2QgJiYgY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwgY29udGV4dC5hcmcpO1xuICAgICAgICAgIHN0YXRlID0gXCJleGVjdXRpbmdcIjtcbiAgICAgICAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2goaW5uZXJGbiwgc2VsZiwgY29udGV4dCk7XG5cbiAgICAgICAgICBpZiAoXCJub3JtYWxcIiA9PT0gcmVjb3JkLnR5cGUpIHtcbiAgICAgICAgICAgIGlmIChzdGF0ZSA9IGNvbnRleHQuZG9uZSA/IFwiY29tcGxldGVkXCIgOiBcInN1c3BlbmRlZFlpZWxkXCIsIHJlY29yZC5hcmcgPT09IENvbnRpbnVlU2VudGluZWwpIGNvbnRpbnVlO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgdmFsdWU6IHJlY29yZC5hcmcsXG4gICAgICAgICAgICAgIGRvbmU6IGNvbnRleHQuZG9uZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBcInRocm93XCIgPT09IHJlY29yZC50eXBlICYmIChzdGF0ZSA9IFwiY29tcGxldGVkXCIsIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiLCBjb250ZXh0LmFyZyA9IHJlY29yZC5hcmcpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0oaW5uZXJGbiwgc2VsZiwgY29udGV4dCksIGdlbmVyYXRvcjtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRyeUNhdGNoKGZuLCBvYmosIGFyZykge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcIm5vcm1hbFwiLFxuICAgICAgICBhcmc6IGZuLmNhbGwob2JqLCBhcmcpXG4gICAgICB9O1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJ0aHJvd1wiLFxuICAgICAgICBhcmc6IGVyclxuICAgICAgfTtcbiAgICB9XG4gIH1cblxuICBleHBvcnRzLndyYXAgPSB3cmFwO1xuICB2YXIgQ29udGludWVTZW50aW5lbCA9IHt9O1xuXG4gIGZ1bmN0aW9uIEdlbmVyYXRvcigpIHt9XG5cbiAgZnVuY3Rpb24gR2VuZXJhdG9yRnVuY3Rpb24oKSB7fVxuXG4gIGZ1bmN0aW9uIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlKCkge31cblxuICB2YXIgSXRlcmF0b3JQcm90b3R5cGUgPSB7fTtcbiAgZGVmaW5lKEl0ZXJhdG9yUHJvdG90eXBlLCBpdGVyYXRvclN5bWJvbCwgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9KTtcbiAgdmFyIGdldFByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mLFxuICAgICAgTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUgPSBnZXRQcm90byAmJiBnZXRQcm90byhnZXRQcm90byh2YWx1ZXMoW10pKSk7XG4gIE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlICYmIE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlICE9PSBPcCAmJiBoYXNPd24uY2FsbChOYXRpdmVJdGVyYXRvclByb3RvdHlwZSwgaXRlcmF0b3JTeW1ib2wpICYmIChJdGVyYXRvclByb3RvdHlwZSA9IE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlKTtcbiAgdmFyIEdwID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUucHJvdG90eXBlID0gR2VuZXJhdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoSXRlcmF0b3JQcm90b3R5cGUpO1xuXG4gIGZ1bmN0aW9uIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhwcm90b3R5cGUpIHtcbiAgICBbXCJuZXh0XCIsIFwidGhyb3dcIiwgXCJyZXR1cm5cIl0uZm9yRWFjaChmdW5jdGlvbiAobWV0aG9kKSB7XG4gICAgICBkZWZpbmUocHJvdG90eXBlLCBtZXRob2QsIGZ1bmN0aW9uIChhcmcpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ludm9rZShtZXRob2QsIGFyZyk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIEFzeW5jSXRlcmF0b3IoZ2VuZXJhdG9yLCBQcm9taXNlSW1wbCkge1xuICAgIGZ1bmN0aW9uIGludm9rZShtZXRob2QsIGFyZywgcmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2goZ2VuZXJhdG9yW21ldGhvZF0sIGdlbmVyYXRvciwgYXJnKTtcblxuICAgICAgaWYgKFwidGhyb3dcIiAhPT0gcmVjb3JkLnR5cGUpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHJlY29yZC5hcmcsXG4gICAgICAgICAgICB2YWx1ZSA9IHJlc3VsdC52YWx1ZTtcbiAgICAgICAgcmV0dXJuIHZhbHVlICYmIFwib2JqZWN0XCIgPT0gX3R5cGVvZih2YWx1ZSkgJiYgaGFzT3duLmNhbGwodmFsdWUsIFwiX19hd2FpdFwiKSA/IFByb21pc2VJbXBsLnJlc29sdmUodmFsdWUuX19hd2FpdCkudGhlbihmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICBpbnZva2UoXCJuZXh0XCIsIHZhbHVlLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICB9LCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgaW52b2tlKFwidGhyb3dcIiwgZXJyLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICB9KSA6IFByb21pc2VJbXBsLnJlc29sdmUodmFsdWUpLnRoZW4oZnVuY3Rpb24gKHVud3JhcHBlZCkge1xuICAgICAgICAgIHJlc3VsdC52YWx1ZSA9IHVud3JhcHBlZCwgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICB9LCBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICByZXR1cm4gaW52b2tlKFwidGhyb3dcIiwgZXJyb3IsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICByZWplY3QocmVjb3JkLmFyZyk7XG4gICAgfVxuXG4gICAgdmFyIHByZXZpb3VzUHJvbWlzZTtcblxuICAgIHRoaXMuX2ludm9rZSA9IGZ1bmN0aW9uIChtZXRob2QsIGFyZykge1xuICAgICAgZnVuY3Rpb24gY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZUltcGwoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgIGludm9rZShtZXRob2QsIGFyZywgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwcmV2aW91c1Byb21pc2UgPSBwcmV2aW91c1Byb21pc2UgPyBwcmV2aW91c1Byb21pc2UudGhlbihjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZywgY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcpIDogY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcoKTtcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gbWF5YmVJbnZva2VEZWxlZ2F0ZShkZWxlZ2F0ZSwgY29udGV4dCkge1xuICAgIHZhciBtZXRob2QgPSBkZWxlZ2F0ZS5pdGVyYXRvcltjb250ZXh0Lm1ldGhvZF07XG5cbiAgICBpZiAodW5kZWZpbmVkID09PSBtZXRob2QpIHtcbiAgICAgIGlmIChjb250ZXh0LmRlbGVnYXRlID0gbnVsbCwgXCJ0aHJvd1wiID09PSBjb250ZXh0Lm1ldGhvZCkge1xuICAgICAgICBpZiAoZGVsZWdhdGUuaXRlcmF0b3JbXCJyZXR1cm5cIl0gJiYgKGNvbnRleHQubWV0aG9kID0gXCJyZXR1cm5cIiwgY29udGV4dC5hcmcgPSB1bmRlZmluZWQsIG1heWJlSW52b2tlRGVsZWdhdGUoZGVsZWdhdGUsIGNvbnRleHQpLCBcInRocm93XCIgPT09IGNvbnRleHQubWV0aG9kKSkgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiLCBjb250ZXh0LmFyZyA9IG5ldyBUeXBlRXJyb3IoXCJUaGUgaXRlcmF0b3IgZG9lcyBub3QgcHJvdmlkZSBhICd0aHJvdycgbWV0aG9kXCIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9XG5cbiAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2gobWV0aG9kLCBkZWxlZ2F0ZS5pdGVyYXRvciwgY29udGV4dC5hcmcpO1xuICAgIGlmIChcInRocm93XCIgPT09IHJlY29yZC50eXBlKSByZXR1cm4gY29udGV4dC5tZXRob2QgPSBcInRocm93XCIsIGNvbnRleHQuYXJnID0gcmVjb3JkLmFyZywgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGwsIENvbnRpbnVlU2VudGluZWw7XG4gICAgdmFyIGluZm8gPSByZWNvcmQuYXJnO1xuICAgIHJldHVybiBpbmZvID8gaW5mby5kb25lID8gKGNvbnRleHRbZGVsZWdhdGUucmVzdWx0TmFtZV0gPSBpbmZvLnZhbHVlLCBjb250ZXh0Lm5leHQgPSBkZWxlZ2F0ZS5uZXh0TG9jLCBcInJldHVyblwiICE9PSBjb250ZXh0Lm1ldGhvZCAmJiAoY29udGV4dC5tZXRob2QgPSBcIm5leHRcIiwgY29udGV4dC5hcmcgPSB1bmRlZmluZWQpLCBjb250ZXh0LmRlbGVnYXRlID0gbnVsbCwgQ29udGludWVTZW50aW5lbCkgOiBpbmZvIDogKGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiLCBjb250ZXh0LmFyZyA9IG5ldyBUeXBlRXJyb3IoXCJpdGVyYXRvciByZXN1bHQgaXMgbm90IGFuIG9iamVjdFwiKSwgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGwsIENvbnRpbnVlU2VudGluZWwpO1xuICB9XG5cbiAgZnVuY3Rpb24gcHVzaFRyeUVudHJ5KGxvY3MpIHtcbiAgICB2YXIgZW50cnkgPSB7XG4gICAgICB0cnlMb2M6IGxvY3NbMF1cbiAgICB9O1xuICAgIDEgaW4gbG9jcyAmJiAoZW50cnkuY2F0Y2hMb2MgPSBsb2NzWzFdKSwgMiBpbiBsb2NzICYmIChlbnRyeS5maW5hbGx5TG9jID0gbG9jc1syXSwgZW50cnkuYWZ0ZXJMb2MgPSBsb2NzWzNdKSwgdGhpcy50cnlFbnRyaWVzLnB1c2goZW50cnkpO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVzZXRUcnlFbnRyeShlbnRyeSkge1xuICAgIHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uIHx8IHt9O1xuICAgIHJlY29yZC50eXBlID0gXCJub3JtYWxcIiwgZGVsZXRlIHJlY29yZC5hcmcsIGVudHJ5LmNvbXBsZXRpb24gPSByZWNvcmQ7XG4gIH1cblxuICBmdW5jdGlvbiBDb250ZXh0KHRyeUxvY3NMaXN0KSB7XG4gICAgdGhpcy50cnlFbnRyaWVzID0gW3tcbiAgICAgIHRyeUxvYzogXCJyb290XCJcbiAgICB9XSwgdHJ5TG9jc0xpc3QuZm9yRWFjaChwdXNoVHJ5RW50cnksIHRoaXMpLCB0aGlzLnJlc2V0KCEwKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHZhbHVlcyhpdGVyYWJsZSkge1xuICAgIGlmIChpdGVyYWJsZSkge1xuICAgICAgdmFyIGl0ZXJhdG9yTWV0aG9kID0gaXRlcmFibGVbaXRlcmF0b3JTeW1ib2xdO1xuICAgICAgaWYgKGl0ZXJhdG9yTWV0aG9kKSByZXR1cm4gaXRlcmF0b3JNZXRob2QuY2FsbChpdGVyYWJsZSk7XG4gICAgICBpZiAoXCJmdW5jdGlvblwiID09IHR5cGVvZiBpdGVyYWJsZS5uZXh0KSByZXR1cm4gaXRlcmFibGU7XG5cbiAgICAgIGlmICghaXNOYU4oaXRlcmFibGUubGVuZ3RoKSkge1xuICAgICAgICB2YXIgaSA9IC0xLFxuICAgICAgICAgICAgbmV4dCA9IGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICAgICAgZm9yICg7ICsraSA8IGl0ZXJhYmxlLmxlbmd0aDspIHtcbiAgICAgICAgICAgIGlmIChoYXNPd24uY2FsbChpdGVyYWJsZSwgaSkpIHJldHVybiBuZXh0LnZhbHVlID0gaXRlcmFibGVbaV0sIG5leHQuZG9uZSA9ICExLCBuZXh0O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBuZXh0LnZhbHVlID0gdW5kZWZpbmVkLCBuZXh0LmRvbmUgPSAhMCwgbmV4dDtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gbmV4dC5uZXh0ID0gbmV4dDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgbmV4dDogZG9uZVJlc3VsdFxuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBkb25lUmVzdWx0KCkge1xuICAgIHJldHVybiB7XG4gICAgICB2YWx1ZTogdW5kZWZpbmVkLFxuICAgICAgZG9uZTogITBcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIEdlbmVyYXRvckZ1bmN0aW9uLnByb3RvdHlwZSA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLCBkZWZpbmUoR3AsIFwiY29uc3RydWN0b3JcIiwgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUpLCBkZWZpbmUoR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUsIFwiY29uc3RydWN0b3JcIiwgR2VuZXJhdG9yRnVuY3Rpb24pLCBHZW5lcmF0b3JGdW5jdGlvbi5kaXNwbGF5TmFtZSA9IGRlZmluZShHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSwgdG9TdHJpbmdUYWdTeW1ib2wsIFwiR2VuZXJhdG9yRnVuY3Rpb25cIiksIGV4cG9ydHMuaXNHZW5lcmF0b3JGdW5jdGlvbiA9IGZ1bmN0aW9uIChnZW5GdW4pIHtcbiAgICB2YXIgY3RvciA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgZ2VuRnVuICYmIGdlbkZ1bi5jb25zdHJ1Y3RvcjtcbiAgICByZXR1cm4gISFjdG9yICYmIChjdG9yID09PSBHZW5lcmF0b3JGdW5jdGlvbiB8fCBcIkdlbmVyYXRvckZ1bmN0aW9uXCIgPT09IChjdG9yLmRpc3BsYXlOYW1lIHx8IGN0b3IubmFtZSkpO1xuICB9LCBleHBvcnRzLm1hcmsgPSBmdW5jdGlvbiAoZ2VuRnVuKSB7XG4gICAgcmV0dXJuIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihnZW5GdW4sIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlKSA6IChnZW5GdW4uX19wcm90b19fID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUsIGRlZmluZShnZW5GdW4sIHRvU3RyaW5nVGFnU3ltYm9sLCBcIkdlbmVyYXRvckZ1bmN0aW9uXCIpKSwgZ2VuRnVuLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoR3ApLCBnZW5GdW47XG4gIH0sIGV4cG9ydHMuYXdyYXAgPSBmdW5jdGlvbiAoYXJnKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIF9fYXdhaXQ6IGFyZ1xuICAgIH07XG4gIH0sIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhBc3luY0l0ZXJhdG9yLnByb3RvdHlwZSksIGRlZmluZShBc3luY0l0ZXJhdG9yLnByb3RvdHlwZSwgYXN5bmNJdGVyYXRvclN5bWJvbCwgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9KSwgZXhwb3J0cy5Bc3luY0l0ZXJhdG9yID0gQXN5bmNJdGVyYXRvciwgZXhwb3J0cy5hc3luYyA9IGZ1bmN0aW9uIChpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdCwgUHJvbWlzZUltcGwpIHtcbiAgICB2b2lkIDAgPT09IFByb21pc2VJbXBsICYmIChQcm9taXNlSW1wbCA9IFByb21pc2UpO1xuICAgIHZhciBpdGVyID0gbmV3IEFzeW5jSXRlcmF0b3Iod3JhcChpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdCksIFByb21pc2VJbXBsKTtcbiAgICByZXR1cm4gZXhwb3J0cy5pc0dlbmVyYXRvckZ1bmN0aW9uKG91dGVyRm4pID8gaXRlciA6IGl0ZXIubmV4dCgpLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgcmV0dXJuIHJlc3VsdC5kb25lID8gcmVzdWx0LnZhbHVlIDogaXRlci5uZXh0KCk7XG4gICAgfSk7XG4gIH0sIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhHcCksIGRlZmluZShHcCwgdG9TdHJpbmdUYWdTeW1ib2wsIFwiR2VuZXJhdG9yXCIpLCBkZWZpbmUoR3AsIGl0ZXJhdG9yU3ltYm9sLCBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0pLCBkZWZpbmUoR3AsIFwidG9TdHJpbmdcIiwgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBcIltvYmplY3QgR2VuZXJhdG9yXVwiO1xuICB9KSwgZXhwb3J0cy5rZXlzID0gZnVuY3Rpb24gKG9iamVjdCkge1xuICAgIHZhciBrZXlzID0gW107XG5cbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqZWN0KSB7XG4gICAgICBrZXlzLnB1c2goa2V5KTtcbiAgICB9XG5cbiAgICByZXR1cm4ga2V5cy5yZXZlcnNlKCksIGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICBmb3IgKDsga2V5cy5sZW5ndGg7KSB7XG4gICAgICAgIHZhciBrZXkgPSBrZXlzLnBvcCgpO1xuICAgICAgICBpZiAoa2V5IGluIG9iamVjdCkgcmV0dXJuIG5leHQudmFsdWUgPSBrZXksIG5leHQuZG9uZSA9ICExLCBuZXh0O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmV4dC5kb25lID0gITAsIG5leHQ7XG4gICAgfTtcbiAgfSwgZXhwb3J0cy52YWx1ZXMgPSB2YWx1ZXMsIENvbnRleHQucHJvdG90eXBlID0ge1xuICAgIGNvbnN0cnVjdG9yOiBDb250ZXh0LFxuICAgIHJlc2V0OiBmdW5jdGlvbiByZXNldChza2lwVGVtcFJlc2V0KSB7XG4gICAgICBpZiAodGhpcy5wcmV2ID0gMCwgdGhpcy5uZXh0ID0gMCwgdGhpcy5zZW50ID0gdGhpcy5fc2VudCA9IHVuZGVmaW5lZCwgdGhpcy5kb25lID0gITEsIHRoaXMuZGVsZWdhdGUgPSBudWxsLCB0aGlzLm1ldGhvZCA9IFwibmV4dFwiLCB0aGlzLmFyZyA9IHVuZGVmaW5lZCwgdGhpcy50cnlFbnRyaWVzLmZvckVhY2gocmVzZXRUcnlFbnRyeSksICFza2lwVGVtcFJlc2V0KSBmb3IgKHZhciBuYW1lIGluIHRoaXMpIHtcbiAgICAgICAgXCJ0XCIgPT09IG5hbWUuY2hhckF0KDApICYmIGhhc093bi5jYWxsKHRoaXMsIG5hbWUpICYmICFpc05hTigrbmFtZS5zbGljZSgxKSkgJiYgKHRoaXNbbmFtZV0gPSB1bmRlZmluZWQpO1xuICAgICAgfVxuICAgIH0sXG4gICAgc3RvcDogZnVuY3Rpb24gc3RvcCgpIHtcbiAgICAgIHRoaXMuZG9uZSA9ICEwO1xuICAgICAgdmFyIHJvb3RSZWNvcmQgPSB0aGlzLnRyeUVudHJpZXNbMF0uY29tcGxldGlvbjtcbiAgICAgIGlmIChcInRocm93XCIgPT09IHJvb3RSZWNvcmQudHlwZSkgdGhyb3cgcm9vdFJlY29yZC5hcmc7XG4gICAgICByZXR1cm4gdGhpcy5ydmFsO1xuICAgIH0sXG4gICAgZGlzcGF0Y2hFeGNlcHRpb246IGZ1bmN0aW9uIGRpc3BhdGNoRXhjZXB0aW9uKGV4Y2VwdGlvbikge1xuICAgICAgaWYgKHRoaXMuZG9uZSkgdGhyb3cgZXhjZXB0aW9uO1xuICAgICAgdmFyIGNvbnRleHQgPSB0aGlzO1xuXG4gICAgICBmdW5jdGlvbiBoYW5kbGUobG9jLCBjYXVnaHQpIHtcbiAgICAgICAgcmV0dXJuIHJlY29yZC50eXBlID0gXCJ0aHJvd1wiLCByZWNvcmQuYXJnID0gZXhjZXB0aW9uLCBjb250ZXh0Lm5leHQgPSBsb2MsIGNhdWdodCAmJiAoY29udGV4dC5tZXRob2QgPSBcIm5leHRcIiwgY29udGV4dC5hcmcgPSB1bmRlZmluZWQpLCAhIWNhdWdodDtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV0sXG4gICAgICAgICAgICByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uO1xuICAgICAgICBpZiAoXCJyb290XCIgPT09IGVudHJ5LnRyeUxvYykgcmV0dXJuIGhhbmRsZShcImVuZFwiKTtcblxuICAgICAgICBpZiAoZW50cnkudHJ5TG9jIDw9IHRoaXMucHJldikge1xuICAgICAgICAgIHZhciBoYXNDYXRjaCA9IGhhc093bi5jYWxsKGVudHJ5LCBcImNhdGNoTG9jXCIpLFxuICAgICAgICAgICAgICBoYXNGaW5hbGx5ID0gaGFzT3duLmNhbGwoZW50cnksIFwiZmluYWxseUxvY1wiKTtcblxuICAgICAgICAgIGlmIChoYXNDYXRjaCAmJiBoYXNGaW5hbGx5KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuY2F0Y2hMb2MpIHJldHVybiBoYW5kbGUoZW50cnkuY2F0Y2hMb2MsICEwKTtcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSByZXR1cm4gaGFuZGxlKGVudHJ5LmZpbmFsbHlMb2MpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoaGFzQ2F0Y2gpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5jYXRjaExvYykgcmV0dXJuIGhhbmRsZShlbnRyeS5jYXRjaExvYywgITApO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoIWhhc0ZpbmFsbHkpIHRocm93IG5ldyBFcnJvcihcInRyeSBzdGF0ZW1lbnQgd2l0aG91dCBjYXRjaCBvciBmaW5hbGx5XCIpO1xuICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHJldHVybiBoYW5kbGUoZW50cnkuZmluYWxseUxvYyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBhYnJ1cHQ6IGZ1bmN0aW9uIGFicnVwdCh0eXBlLCBhcmcpIHtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuXG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPD0gdGhpcy5wcmV2ICYmIGhhc093bi5jYWxsKGVudHJ5LCBcImZpbmFsbHlMb2NcIikgJiYgdGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAgIHZhciBmaW5hbGx5RW50cnkgPSBlbnRyeTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmaW5hbGx5RW50cnkgJiYgKFwiYnJlYWtcIiA9PT0gdHlwZSB8fCBcImNvbnRpbnVlXCIgPT09IHR5cGUpICYmIGZpbmFsbHlFbnRyeS50cnlMb2MgPD0gYXJnICYmIGFyZyA8PSBmaW5hbGx5RW50cnkuZmluYWxseUxvYyAmJiAoZmluYWxseUVudHJ5ID0gbnVsbCk7XG4gICAgICB2YXIgcmVjb3JkID0gZmluYWxseUVudHJ5ID8gZmluYWxseUVudHJ5LmNvbXBsZXRpb24gOiB7fTtcbiAgICAgIHJldHVybiByZWNvcmQudHlwZSA9IHR5cGUsIHJlY29yZC5hcmcgPSBhcmcsIGZpbmFsbHlFbnRyeSA/ICh0aGlzLm1ldGhvZCA9IFwibmV4dFwiLCB0aGlzLm5leHQgPSBmaW5hbGx5RW50cnkuZmluYWxseUxvYywgQ29udGludWVTZW50aW5lbCkgOiB0aGlzLmNvbXBsZXRlKHJlY29yZCk7XG4gICAgfSxcbiAgICBjb21wbGV0ZTogZnVuY3Rpb24gY29tcGxldGUocmVjb3JkLCBhZnRlckxvYykge1xuICAgICAgaWYgKFwidGhyb3dcIiA9PT0gcmVjb3JkLnR5cGUpIHRocm93IHJlY29yZC5hcmc7XG4gICAgICByZXR1cm4gXCJicmVha1wiID09PSByZWNvcmQudHlwZSB8fCBcImNvbnRpbnVlXCIgPT09IHJlY29yZC50eXBlID8gdGhpcy5uZXh0ID0gcmVjb3JkLmFyZyA6IFwicmV0dXJuXCIgPT09IHJlY29yZC50eXBlID8gKHRoaXMucnZhbCA9IHRoaXMuYXJnID0gcmVjb3JkLmFyZywgdGhpcy5tZXRob2QgPSBcInJldHVyblwiLCB0aGlzLm5leHQgPSBcImVuZFwiKSA6IFwibm9ybWFsXCIgPT09IHJlY29yZC50eXBlICYmIGFmdGVyTG9jICYmICh0aGlzLm5leHQgPSBhZnRlckxvYyksIENvbnRpbnVlU2VudGluZWw7XG4gICAgfSxcbiAgICBmaW5pc2g6IGZ1bmN0aW9uIGZpbmlzaChmaW5hbGx5TG9jKSB7XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgaWYgKGVudHJ5LmZpbmFsbHlMb2MgPT09IGZpbmFsbHlMb2MpIHJldHVybiB0aGlzLmNvbXBsZXRlKGVudHJ5LmNvbXBsZXRpb24sIGVudHJ5LmFmdGVyTG9jKSwgcmVzZXRUcnlFbnRyeShlbnRyeSksIENvbnRpbnVlU2VudGluZWw7XG4gICAgICB9XG4gICAgfSxcbiAgICBcImNhdGNoXCI6IGZ1bmN0aW9uIF9jYXRjaCh0cnlMb2MpIHtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuXG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPT09IHRyeUxvYykge1xuICAgICAgICAgIHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uO1xuXG4gICAgICAgICAgaWYgKFwidGhyb3dcIiA9PT0gcmVjb3JkLnR5cGUpIHtcbiAgICAgICAgICAgIHZhciB0aHJvd24gPSByZWNvcmQuYXJnO1xuICAgICAgICAgICAgcmVzZXRUcnlFbnRyeShlbnRyeSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHRocm93bjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbGxlZ2FsIGNhdGNoIGF0dGVtcHRcIik7XG4gICAgfSxcbiAgICBkZWxlZ2F0ZVlpZWxkOiBmdW5jdGlvbiBkZWxlZ2F0ZVlpZWxkKGl0ZXJhYmxlLCByZXN1bHROYW1lLCBuZXh0TG9jKSB7XG4gICAgICByZXR1cm4gdGhpcy5kZWxlZ2F0ZSA9IHtcbiAgICAgICAgaXRlcmF0b3I6IHZhbHVlcyhpdGVyYWJsZSksXG4gICAgICAgIHJlc3VsdE5hbWU6IHJlc3VsdE5hbWUsXG4gICAgICAgIG5leHRMb2M6IG5leHRMb2NcbiAgICAgIH0sIFwibmV4dFwiID09PSB0aGlzLm1ldGhvZCAmJiAodGhpcy5hcmcgPSB1bmRlZmluZWQpLCBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cbiAgfSwgZXhwb3J0cztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfcmVnZW5lcmF0b3JSdW50aW1lLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZSwgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHM7IiwidmFyIGdldFByb3RvdHlwZU9mID0gcmVxdWlyZShcIi4vZ2V0UHJvdG90eXBlT2YuanNcIik7XG5cbmZ1bmN0aW9uIF9zdXBlclByb3BCYXNlKG9iamVjdCwgcHJvcGVydHkpIHtcbiAgd2hpbGUgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSkpIHtcbiAgICBvYmplY3QgPSBnZXRQcm90b3R5cGVPZihvYmplY3QpO1xuICAgIGlmIChvYmplY3QgPT09IG51bGwpIGJyZWFrO1xuICB9XG5cbiAgcmV0dXJuIG9iamVjdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfc3VwZXJQcm9wQmFzZSwgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzOyIsInZhciBhcnJheUxpa2VUb0FycmF5ID0gcmVxdWlyZShcIi4vYXJyYXlMaWtlVG9BcnJheS5qc1wiKTtcblxuZnVuY3Rpb24gX2FycmF5V2l0aG91dEhvbGVzKGFycikge1xuICBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSByZXR1cm4gYXJyYXlMaWtlVG9BcnJheShhcnIpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9hcnJheVdpdGhvdXRIb2xlcywgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzOyIsImZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXkoaXRlcikge1xuICBpZiAodHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBpdGVyW1N5bWJvbC5pdGVyYXRvcl0gIT0gbnVsbCB8fCBpdGVyW1wiQEBpdGVyYXRvclwiXSAhPSBudWxsKSByZXR1cm4gQXJyYXkuZnJvbShpdGVyKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfaXRlcmFibGVUb0FycmF5LCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZSwgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHM7IiwiZnVuY3Rpb24gX25vbkl0ZXJhYmxlU3ByZWFkKCkge1xuICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIHNwcmVhZCBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfbm9uSXRlcmFibGVTcHJlYWQsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlLCBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0czsiLCJ2YXIgYmFzZVBpY2tCeSA9IHJlcXVpcmUoJy4vX2Jhc2VQaWNrQnknKSxcbiAgICBoYXNJbiA9IHJlcXVpcmUoJy4vaGFzSW4nKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5waWNrYCB3aXRob3V0IHN1cHBvcnQgZm9yIGluZGl2aWR1YWxcbiAqIHByb3BlcnR5IGlkZW50aWZpZXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBzb3VyY2Ugb2JqZWN0LlxuICogQHBhcmFtIHtzdHJpbmdbXX0gcGF0aHMgVGhlIHByb3BlcnR5IHBhdGhzIHRvIHBpY2suXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgb2JqZWN0LlxuICovXG5mdW5jdGlvbiBiYXNlUGljayhvYmplY3QsIHBhdGhzKSB7XG4gIHJldHVybiBiYXNlUGlja0J5KG9iamVjdCwgcGF0aHMsIGZ1bmN0aW9uKHZhbHVlLCBwYXRoKSB7XG4gICAgcmV0dXJuIGhhc0luKG9iamVjdCwgcGF0aCk7XG4gIH0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VQaWNrO1xuIiwidmFyIGJhc2VHZXQgPSByZXF1aXJlKCcuL19iYXNlR2V0JyksXG4gICAgYmFzZVNldCA9IHJlcXVpcmUoJy4vX2Jhc2VTZXQnKSxcbiAgICBjYXN0UGF0aCA9IHJlcXVpcmUoJy4vX2Nhc3RQYXRoJyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgIGBfLnBpY2tCeWAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBzb3VyY2Ugb2JqZWN0LlxuICogQHBhcmFtIHtzdHJpbmdbXX0gcGF0aHMgVGhlIHByb3BlcnR5IHBhdGhzIHRvIHBpY2suXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIHByb3BlcnR5LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gYmFzZVBpY2tCeShvYmplY3QsIHBhdGhzLCBwcmVkaWNhdGUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBwYXRocy5sZW5ndGgsXG4gICAgICByZXN1bHQgPSB7fTtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBwYXRoID0gcGF0aHNbaW5kZXhdLFxuICAgICAgICB2YWx1ZSA9IGJhc2VHZXQob2JqZWN0LCBwYXRoKTtcblxuICAgIGlmIChwcmVkaWNhdGUodmFsdWUsIHBhdGgpKSB7XG4gICAgICBiYXNlU2V0KHJlc3VsdCwgY2FzdFBhdGgocGF0aCwgb2JqZWN0KSwgdmFsdWUpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VQaWNrQnk7XG4iLCJ2YXIgY2FzdFBhdGggPSByZXF1aXJlKCcuL19jYXN0UGF0aCcpLFxuICAgIHRvS2V5ID0gcmVxdWlyZSgnLi9fdG9LZXknKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5nZXRgIHdpdGhvdXQgc3VwcG9ydCBmb3IgZGVmYXVsdCB2YWx1ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmVzb2x2ZWQgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGJhc2VHZXQob2JqZWN0LCBwYXRoKSB7XG4gIHBhdGggPSBjYXN0UGF0aChwYXRoLCBvYmplY3QpO1xuXG4gIHZhciBpbmRleCA9IDAsXG4gICAgICBsZW5ndGggPSBwYXRoLmxlbmd0aDtcblxuICB3aGlsZSAob2JqZWN0ICE9IG51bGwgJiYgaW5kZXggPCBsZW5ndGgpIHtcbiAgICBvYmplY3QgPSBvYmplY3RbdG9LZXkocGF0aFtpbmRleCsrXSldO1xuICB9XG4gIHJldHVybiAoaW5kZXggJiYgaW5kZXggPT0gbGVuZ3RoKSA/IG9iamVjdCA6IHVuZGVmaW5lZDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlR2V0O1xuIiwidmFyIGlzQXJyYXkgPSByZXF1aXJlKCcuL2lzQXJyYXknKSxcbiAgICBpc1N5bWJvbCA9IHJlcXVpcmUoJy4vaXNTeW1ib2wnKTtcblxuLyoqIFVzZWQgdG8gbWF0Y2ggcHJvcGVydHkgbmFtZXMgd2l0aGluIHByb3BlcnR5IHBhdGhzLiAqL1xudmFyIHJlSXNEZWVwUHJvcCA9IC9cXC58XFxbKD86W15bXFxdXSp8KFtcIiddKSg/Oig/IVxcMSlbXlxcXFxdfFxcXFwuKSo/XFwxKVxcXS8sXG4gICAgcmVJc1BsYWluUHJvcCA9IC9eXFx3KiQvO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgcHJvcGVydHkgbmFtZSBhbmQgbm90IGEgcHJvcGVydHkgcGF0aC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIG9iamVjdCB0byBxdWVyeSBrZXlzIG9uLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBwcm9wZXJ0eSBuYW1lLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzS2V5KHZhbHVlLCBvYmplY3QpIHtcbiAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICBpZiAodHlwZSA9PSAnbnVtYmVyJyB8fCB0eXBlID09ICdzeW1ib2wnIHx8IHR5cGUgPT0gJ2Jvb2xlYW4nIHx8XG4gICAgICB2YWx1ZSA9PSBudWxsIHx8IGlzU3ltYm9sKHZhbHVlKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiByZUlzUGxhaW5Qcm9wLnRlc3QodmFsdWUpIHx8ICFyZUlzRGVlcFByb3AudGVzdCh2YWx1ZSkgfHxcbiAgICAob2JqZWN0ICE9IG51bGwgJiYgdmFsdWUgaW4gT2JqZWN0KG9iamVjdCkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzS2V5O1xuIiwidmFyIG1lbW9pemVDYXBwZWQgPSByZXF1aXJlKCcuL19tZW1vaXplQ2FwcGVkJyk7XG5cbi8qKiBVc2VkIHRvIG1hdGNoIHByb3BlcnR5IG5hbWVzIHdpdGhpbiBwcm9wZXJ0eSBwYXRocy4gKi9cbnZhciByZVByb3BOYW1lID0gL1teLltcXF1dK3xcXFsoPzooLT9cXGQrKD86XFwuXFxkKyk/KXwoW1wiJ10pKCg/Oig/IVxcMilbXlxcXFxdfFxcXFwuKSo/KVxcMilcXF18KD89KD86XFwufFxcW1xcXSkoPzpcXC58XFxbXFxdfCQpKS9nO1xuXG4vKiogVXNlZCB0byBtYXRjaCBiYWNrc2xhc2hlcyBpbiBwcm9wZXJ0eSBwYXRocy4gKi9cbnZhciByZUVzY2FwZUNoYXIgPSAvXFxcXChcXFxcKT8vZztcblxuLyoqXG4gKiBDb252ZXJ0cyBgc3RyaW5nYCB0byBhIHByb3BlcnR5IHBhdGggYXJyYXkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBwcm9wZXJ0eSBwYXRoIGFycmF5LlxuICovXG52YXIgc3RyaW5nVG9QYXRoID0gbWVtb2l6ZUNhcHBlZChmdW5jdGlvbihzdHJpbmcpIHtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICBpZiAoc3RyaW5nLmNoYXJDb2RlQXQoMCkgPT09IDQ2IC8qIC4gKi8pIHtcbiAgICByZXN1bHQucHVzaCgnJyk7XG4gIH1cbiAgc3RyaW5nLnJlcGxhY2UocmVQcm9wTmFtZSwgZnVuY3Rpb24obWF0Y2gsIG51bWJlciwgcXVvdGUsIHN1YlN0cmluZykge1xuICAgIHJlc3VsdC5wdXNoKHF1b3RlID8gc3ViU3RyaW5nLnJlcGxhY2UocmVFc2NhcGVDaGFyLCAnJDEnKSA6IChudW1iZXIgfHwgbWF0Y2gpKTtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBzdHJpbmdUb1BhdGg7XG4iLCJ2YXIgbWVtb2l6ZSA9IHJlcXVpcmUoJy4vbWVtb2l6ZScpO1xuXG4vKiogVXNlZCBhcyB0aGUgbWF4aW11bSBtZW1vaXplIGNhY2hlIHNpemUuICovXG52YXIgTUFYX01FTU9JWkVfU0laRSA9IDUwMDtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8ubWVtb2l6ZWAgd2hpY2ggY2xlYXJzIHRoZSBtZW1vaXplZCBmdW5jdGlvbidzXG4gKiBjYWNoZSB3aGVuIGl0IGV4Y2VlZHMgYE1BWF9NRU1PSVpFX1NJWkVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBoYXZlIGl0cyBvdXRwdXQgbWVtb2l6ZWQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBtZW1vaXplZCBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gbWVtb2l6ZUNhcHBlZChmdW5jKSB7XG4gIHZhciByZXN1bHQgPSBtZW1vaXplKGZ1bmMsIGZ1bmN0aW9uKGtleSkge1xuICAgIGlmIChjYWNoZS5zaXplID09PSBNQVhfTUVNT0laRV9TSVpFKSB7XG4gICAgICBjYWNoZS5jbGVhcigpO1xuICAgIH1cbiAgICByZXR1cm4ga2V5O1xuICB9KTtcblxuICB2YXIgY2FjaGUgPSByZXN1bHQuY2FjaGU7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWVtb2l6ZUNhcHBlZDtcbiIsInZhciBNYXBDYWNoZSA9IHJlcXVpcmUoJy4vX01hcENhY2hlJyk7XG5cbi8qKiBFcnJvciBtZXNzYWdlIGNvbnN0YW50cy4gKi9cbnZhciBGVU5DX0VSUk9SX1RFWFQgPSAnRXhwZWN0ZWQgYSBmdW5jdGlvbic7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgbWVtb2l6ZXMgdGhlIHJlc3VsdCBvZiBgZnVuY2AuIElmIGByZXNvbHZlcmAgaXNcbiAqIHByb3ZpZGVkLCBpdCBkZXRlcm1pbmVzIHRoZSBjYWNoZSBrZXkgZm9yIHN0b3JpbmcgdGhlIHJlc3VsdCBiYXNlZCBvbiB0aGVcbiAqIGFyZ3VtZW50cyBwcm92aWRlZCB0byB0aGUgbWVtb2l6ZWQgZnVuY3Rpb24uIEJ5IGRlZmF1bHQsIHRoZSBmaXJzdCBhcmd1bWVudFxuICogcHJvdmlkZWQgdG8gdGhlIG1lbW9pemVkIGZ1bmN0aW9uIGlzIHVzZWQgYXMgdGhlIG1hcCBjYWNoZSBrZXkuIFRoZSBgZnVuY2BcbiAqIGlzIGludm9rZWQgd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgb2YgdGhlIG1lbW9pemVkIGZ1bmN0aW9uLlxuICpcbiAqICoqTm90ZToqKiBUaGUgY2FjaGUgaXMgZXhwb3NlZCBhcyB0aGUgYGNhY2hlYCBwcm9wZXJ0eSBvbiB0aGUgbWVtb2l6ZWRcbiAqIGZ1bmN0aW9uLiBJdHMgY3JlYXRpb24gbWF5IGJlIGN1c3RvbWl6ZWQgYnkgcmVwbGFjaW5nIHRoZSBgXy5tZW1vaXplLkNhY2hlYFxuICogY29uc3RydWN0b3Igd2l0aCBvbmUgd2hvc2UgaW5zdGFuY2VzIGltcGxlbWVudCB0aGVcbiAqIFtgTWFwYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtcHJvcGVydGllcy1vZi10aGUtbWFwLXByb3RvdHlwZS1vYmplY3QpXG4gKiBtZXRob2QgaW50ZXJmYWNlIG9mIGBjbGVhcmAsIGBkZWxldGVgLCBgZ2V0YCwgYGhhc2AsIGFuZCBgc2V0YC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGhhdmUgaXRzIG91dHB1dCBtZW1vaXplZC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtyZXNvbHZlcl0gVGhlIGZ1bmN0aW9uIHRvIHJlc29sdmUgdGhlIGNhY2hlIGtleS5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IG1lbW9pemVkIGZ1bmN0aW9uLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEsICdiJzogMiB9O1xuICogdmFyIG90aGVyID0geyAnYyc6IDMsICdkJzogNCB9O1xuICpcbiAqIHZhciB2YWx1ZXMgPSBfLm1lbW9pemUoXy52YWx1ZXMpO1xuICogdmFsdWVzKG9iamVjdCk7XG4gKiAvLyA9PiBbMSwgMl1cbiAqXG4gKiB2YWx1ZXMob3RoZXIpO1xuICogLy8gPT4gWzMsIDRdXG4gKlxuICogb2JqZWN0LmEgPSAyO1xuICogdmFsdWVzKG9iamVjdCk7XG4gKiAvLyA9PiBbMSwgMl1cbiAqXG4gKiAvLyBNb2RpZnkgdGhlIHJlc3VsdCBjYWNoZS5cbiAqIHZhbHVlcy5jYWNoZS5zZXQob2JqZWN0LCBbJ2EnLCAnYiddKTtcbiAqIHZhbHVlcyhvYmplY3QpO1xuICogLy8gPT4gWydhJywgJ2InXVxuICpcbiAqIC8vIFJlcGxhY2UgYF8ubWVtb2l6ZS5DYWNoZWAuXG4gKiBfLm1lbW9pemUuQ2FjaGUgPSBXZWFrTWFwO1xuICovXG5mdW5jdGlvbiBtZW1vaXplKGZ1bmMsIHJlc29sdmVyKSB7XG4gIGlmICh0eXBlb2YgZnVuYyAhPSAnZnVuY3Rpb24nIHx8IChyZXNvbHZlciAhPSBudWxsICYmIHR5cGVvZiByZXNvbHZlciAhPSAnZnVuY3Rpb24nKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcbiAgfVxuICB2YXIgbWVtb2l6ZWQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgYXJncyA9IGFyZ3VtZW50cyxcbiAgICAgICAga2V5ID0gcmVzb2x2ZXIgPyByZXNvbHZlci5hcHBseSh0aGlzLCBhcmdzKSA6IGFyZ3NbMF0sXG4gICAgICAgIGNhY2hlID0gbWVtb2l6ZWQuY2FjaGU7XG5cbiAgICBpZiAoY2FjaGUuaGFzKGtleSkpIHtcbiAgICAgIHJldHVybiBjYWNoZS5nZXQoa2V5KTtcbiAgICB9XG4gICAgdmFyIHJlc3VsdCA9IGZ1bmMuYXBwbHkodGhpcywgYXJncyk7XG4gICAgbWVtb2l6ZWQuY2FjaGUgPSBjYWNoZS5zZXQoa2V5LCByZXN1bHQpIHx8IGNhY2hlO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG4gIG1lbW9pemVkLmNhY2hlID0gbmV3IChtZW1vaXplLkNhY2hlIHx8IE1hcENhY2hlKTtcbiAgcmV0dXJuIG1lbW9pemVkO1xufVxuXG4vLyBFeHBvc2UgYE1hcENhY2hlYC5cbm1lbW9pemUuQ2FjaGUgPSBNYXBDYWNoZTtcblxubW9kdWxlLmV4cG9ydHMgPSBtZW1vaXplO1xuIiwidmFyIGJhc2VUb1N0cmluZyA9IHJlcXVpcmUoJy4vX2Jhc2VUb1N0cmluZycpO1xuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBzdHJpbmcuIEFuIGVtcHR5IHN0cmluZyBpcyByZXR1cm5lZCBmb3IgYG51bGxgXG4gKiBhbmQgYHVuZGVmaW5lZGAgdmFsdWVzLiBUaGUgc2lnbiBvZiBgLTBgIGlzIHByZXNlcnZlZC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBzdHJpbmcuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8udG9TdHJpbmcobnVsbCk7XG4gKiAvLyA9PiAnJ1xuICpcbiAqIF8udG9TdHJpbmcoLTApO1xuICogLy8gPT4gJy0wJ1xuICpcbiAqIF8udG9TdHJpbmcoWzEsIDIsIDNdKTtcbiAqIC8vID0+ICcxLDIsMydcbiAqL1xuZnVuY3Rpb24gdG9TdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID09IG51bGwgPyAnJyA6IGJhc2VUb1N0cmluZyh2YWx1ZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdG9TdHJpbmc7XG4iLCJ2YXIgU3ltYm9sID0gcmVxdWlyZSgnLi9fU3ltYm9sJyksXG4gICAgYXJyYXlNYXAgPSByZXF1aXJlKCcuL19hcnJheU1hcCcpLFxuICAgIGlzQXJyYXkgPSByZXF1aXJlKCcuL2lzQXJyYXknKSxcbiAgICBpc1N5bWJvbCA9IHJlcXVpcmUoJy4vaXNTeW1ib2wnKTtcblxuLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG52YXIgSU5GSU5JVFkgPSAxIC8gMDtcblxuLyoqIFVzZWQgdG8gY29udmVydCBzeW1ib2xzIHRvIHByaW1pdGl2ZXMgYW5kIHN0cmluZ3MuICovXG52YXIgc3ltYm9sUHJvdG8gPSBTeW1ib2wgPyBTeW1ib2wucHJvdG90eXBlIDogdW5kZWZpbmVkLFxuICAgIHN5bWJvbFRvU3RyaW5nID0gc3ltYm9sUHJvdG8gPyBzeW1ib2xQcm90by50b1N0cmluZyA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy50b1N0cmluZ2Agd2hpY2ggZG9lc24ndCBjb252ZXJ0IG51bGxpc2hcbiAqIHZhbHVlcyB0byBlbXB0eSBzdHJpbmdzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBwcm9jZXNzLlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgc3RyaW5nLlxuICovXG5mdW5jdGlvbiBiYXNlVG9TdHJpbmcodmFsdWUpIHtcbiAgLy8gRXhpdCBlYXJseSBmb3Igc3RyaW5ncyB0byBhdm9pZCBhIHBlcmZvcm1hbmNlIGhpdCBpbiBzb21lIGVudmlyb25tZW50cy5cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAvLyBSZWN1cnNpdmVseSBjb252ZXJ0IHZhbHVlcyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgIHJldHVybiBhcnJheU1hcCh2YWx1ZSwgYmFzZVRvU3RyaW5nKSArICcnO1xuICB9XG4gIGlmIChpc1N5bWJvbCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gc3ltYm9sVG9TdHJpbmcgPyBzeW1ib2xUb1N0cmluZy5jYWxsKHZhbHVlKSA6ICcnO1xuICB9XG4gIHZhciByZXN1bHQgPSAodmFsdWUgKyAnJyk7XG4gIHJldHVybiAocmVzdWx0ID09ICcwJyAmJiAoMSAvIHZhbHVlKSA9PSAtSU5GSU5JVFkpID8gJy0wJyA6IHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlVG9TdHJpbmc7XG4iLCIvKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5tYXBgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZVxuICogc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IG1hcHBlZCBhcnJheS5cbiAqL1xuZnVuY3Rpb24gYXJyYXlNYXAoYXJyYXksIGl0ZXJhdGVlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGgsXG4gICAgICByZXN1bHQgPSBBcnJheShsZW5ndGgpO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgcmVzdWx0W2luZGV4XSA9IGl0ZXJhdGVlKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFycmF5TWFwO1xuIiwidmFyIGFzc2lnblZhbHVlID0gcmVxdWlyZSgnLi9fYXNzaWduVmFsdWUnKSxcbiAgICBjYXN0UGF0aCA9IHJlcXVpcmUoJy4vX2Nhc3RQYXRoJyksXG4gICAgaXNJbmRleCA9IHJlcXVpcmUoJy4vX2lzSW5kZXgnKSxcbiAgICBpc09iamVjdCA9IHJlcXVpcmUoJy4vaXNPYmplY3QnKSxcbiAgICB0b0tleSA9IHJlcXVpcmUoJy4vX3RvS2V5Jyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uc2V0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBwYXRoIGNyZWF0aW9uLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqL1xuZnVuY3Rpb24gYmFzZVNldChvYmplY3QsIHBhdGgsIHZhbHVlLCBjdXN0b21pemVyKSB7XG4gIGlmICghaXNPYmplY3Qob2JqZWN0KSkge1xuICAgIHJldHVybiBvYmplY3Q7XG4gIH1cbiAgcGF0aCA9IGNhc3RQYXRoKHBhdGgsIG9iamVjdCk7XG5cbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBwYXRoLmxlbmd0aCxcbiAgICAgIGxhc3RJbmRleCA9IGxlbmd0aCAtIDEsXG4gICAgICBuZXN0ZWQgPSBvYmplY3Q7XG5cbiAgd2hpbGUgKG5lc3RlZCAhPSBudWxsICYmICsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIga2V5ID0gdG9LZXkocGF0aFtpbmRleF0pLFxuICAgICAgICBuZXdWYWx1ZSA9IHZhbHVlO1xuXG4gICAgaWYgKGtleSA9PT0gJ19fcHJvdG9fXycgfHwga2V5ID09PSAnY29uc3RydWN0b3InIHx8IGtleSA9PT0gJ3Byb3RvdHlwZScpIHtcbiAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgfVxuXG4gICAgaWYgKGluZGV4ICE9IGxhc3RJbmRleCkge1xuICAgICAgdmFyIG9ialZhbHVlID0gbmVzdGVkW2tleV07XG4gICAgICBuZXdWYWx1ZSA9IGN1c3RvbWl6ZXIgPyBjdXN0b21pemVyKG9ialZhbHVlLCBrZXksIG5lc3RlZCkgOiB1bmRlZmluZWQ7XG4gICAgICBpZiAobmV3VmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBuZXdWYWx1ZSA9IGlzT2JqZWN0KG9ialZhbHVlKVxuICAgICAgICAgID8gb2JqVmFsdWVcbiAgICAgICAgICA6IChpc0luZGV4KHBhdGhbaW5kZXggKyAxXSkgPyBbXSA6IHt9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgYXNzaWduVmFsdWUobmVzdGVkLCBrZXksIG5ld1ZhbHVlKTtcbiAgICBuZXN0ZWQgPSBuZXN0ZWRba2V5XTtcbiAgfVxuICByZXR1cm4gb2JqZWN0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VTZXQ7XG4iLCJ2YXIgYmFzZUhhc0luID0gcmVxdWlyZSgnLi9fYmFzZUhhc0luJyksXG4gICAgaGFzUGF0aCA9IHJlcXVpcmUoJy4vX2hhc1BhdGgnKTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHBhdGhgIGlzIGEgZGlyZWN0IG9yIGluaGVyaXRlZCBwcm9wZXJ0eSBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgcGF0aGAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSBfLmNyZWF0ZSh7ICdhJzogXy5jcmVhdGUoeyAnYic6IDIgfSkgfSk7XG4gKlxuICogXy5oYXNJbihvYmplY3QsICdhJyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5oYXNJbihvYmplY3QsICdhLmInKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmhhc0luKG9iamVjdCwgWydhJywgJ2InXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5oYXNJbihvYmplY3QsICdiJyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBoYXNJbihvYmplY3QsIHBhdGgpIHtcbiAgcmV0dXJuIG9iamVjdCAhPSBudWxsICYmIGhhc1BhdGgob2JqZWN0LCBwYXRoLCBiYXNlSGFzSW4pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGhhc0luO1xuIiwiLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5oYXNJbmAgd2l0aG91dCBzdXBwb3J0IGZvciBkZWVwIHBhdGhzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBrZXkgVGhlIGtleSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUhhc0luKG9iamVjdCwga2V5KSB7XG4gIHJldHVybiBvYmplY3QgIT0gbnVsbCAmJiBrZXkgaW4gT2JqZWN0KG9iamVjdCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUhhc0luO1xuIiwidmFyIGNhc3RQYXRoID0gcmVxdWlyZSgnLi9fY2FzdFBhdGgnKSxcbiAgICBpc0FyZ3VtZW50cyA9IHJlcXVpcmUoJy4vaXNBcmd1bWVudHMnKSxcbiAgICBpc0FycmF5ID0gcmVxdWlyZSgnLi9pc0FycmF5JyksXG4gICAgaXNJbmRleCA9IHJlcXVpcmUoJy4vX2lzSW5kZXgnKSxcbiAgICBpc0xlbmd0aCA9IHJlcXVpcmUoJy4vaXNMZW5ndGgnKSxcbiAgICB0b0tleSA9IHJlcXVpcmUoJy4vX3RvS2V5Jyk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGBwYXRoYCBleGlzdHMgb24gYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIHRvIGNoZWNrLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaGFzRnVuYyBUaGUgZnVuY3Rpb24gdG8gY2hlY2sgcHJvcGVydGllcy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgcGF0aGAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGhhc1BhdGgob2JqZWN0LCBwYXRoLCBoYXNGdW5jKSB7XG4gIHBhdGggPSBjYXN0UGF0aChwYXRoLCBvYmplY3QpO1xuXG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gcGF0aC5sZW5ndGgsXG4gICAgICByZXN1bHQgPSBmYWxzZTtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBrZXkgPSB0b0tleShwYXRoW2luZGV4XSk7XG4gICAgaWYgKCEocmVzdWx0ID0gb2JqZWN0ICE9IG51bGwgJiYgaGFzRnVuYyhvYmplY3QsIGtleSkpKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgb2JqZWN0ID0gb2JqZWN0W2tleV07XG4gIH1cbiAgaWYgKHJlc3VsdCB8fCArK2luZGV4ICE9IGxlbmd0aCkge1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgbGVuZ3RoID0gb2JqZWN0ID09IG51bGwgPyAwIDogb2JqZWN0Lmxlbmd0aDtcbiAgcmV0dXJuICEhbGVuZ3RoICYmIGlzTGVuZ3RoKGxlbmd0aCkgJiYgaXNJbmRleChrZXksIGxlbmd0aCkgJiZcbiAgICAoaXNBcnJheShvYmplY3QpIHx8IGlzQXJndW1lbnRzKG9iamVjdCkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGhhc1BhdGg7XG4iLCJ2YXIgZmxhdHRlbiA9IHJlcXVpcmUoJy4vZmxhdHRlbicpLFxuICAgIG92ZXJSZXN0ID0gcmVxdWlyZSgnLi9fb3ZlclJlc3QnKSxcbiAgICBzZXRUb1N0cmluZyA9IHJlcXVpcmUoJy4vX3NldFRvU3RyaW5nJyk7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlUmVzdGAgd2hpY2ggZmxhdHRlbnMgdGhlIHJlc3QgYXJyYXkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGFwcGx5IGEgcmVzdCBwYXJhbWV0ZXIgdG8uXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gZmxhdFJlc3QoZnVuYykge1xuICByZXR1cm4gc2V0VG9TdHJpbmcob3ZlclJlc3QoZnVuYywgdW5kZWZpbmVkLCBmbGF0dGVuKSwgZnVuYyArICcnKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmbGF0UmVzdDtcbiIsInZhciBiYXNlRmxhdHRlbiA9IHJlcXVpcmUoJy4vX2Jhc2VGbGF0dGVuJyk7XG5cbi8qKlxuICogRmxhdHRlbnMgYGFycmF5YCBhIHNpbmdsZSBsZXZlbCBkZWVwLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBBcnJheVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGZsYXR0ZW4uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBmbGF0dGVuZWQgYXJyYXkuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uZmxhdHRlbihbMSwgWzIsIFszLCBbNF1dLCA1XV0pO1xuICogLy8gPT4gWzEsIDIsIFszLCBbNF1dLCA1XVxuICovXG5mdW5jdGlvbiBmbGF0dGVuKGFycmF5KSB7XG4gIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgcmV0dXJuIGxlbmd0aCA/IGJhc2VGbGF0dGVuKGFycmF5LCAxKSA6IFtdO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZsYXR0ZW47XG4iLCJ2YXIgYXJyYXlQdXNoID0gcmVxdWlyZSgnLi9fYXJyYXlQdXNoJyksXG4gICAgaXNGbGF0dGVuYWJsZSA9IHJlcXVpcmUoJy4vX2lzRmxhdHRlbmFibGUnKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5mbGF0dGVuYCB3aXRoIHN1cHBvcnQgZm9yIHJlc3RyaWN0aW5nIGZsYXR0ZW5pbmcuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBmbGF0dGVuLlxuICogQHBhcmFtIHtudW1iZXJ9IGRlcHRoIFRoZSBtYXhpbXVtIHJlY3Vyc2lvbiBkZXB0aC5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3ByZWRpY2F0ZT1pc0ZsYXR0ZW5hYmxlXSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHBhcmFtIHtib29sZWFufSBbaXNTdHJpY3RdIFJlc3RyaWN0IHRvIHZhbHVlcyB0aGF0IHBhc3MgYHByZWRpY2F0ZWAgY2hlY2tzLlxuICogQHBhcmFtIHtBcnJheX0gW3Jlc3VsdD1bXV0gVGhlIGluaXRpYWwgcmVzdWx0IHZhbHVlLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmxhdHRlbmVkIGFycmF5LlxuICovXG5mdW5jdGlvbiBiYXNlRmxhdHRlbihhcnJheSwgZGVwdGgsIHByZWRpY2F0ZSwgaXNTdHJpY3QsIHJlc3VsdCkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICBwcmVkaWNhdGUgfHwgKHByZWRpY2F0ZSA9IGlzRmxhdHRlbmFibGUpO1xuICByZXN1bHQgfHwgKHJlc3VsdCA9IFtdKTtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XTtcbiAgICBpZiAoZGVwdGggPiAwICYmIHByZWRpY2F0ZSh2YWx1ZSkpIHtcbiAgICAgIGlmIChkZXB0aCA+IDEpIHtcbiAgICAgICAgLy8gUmVjdXJzaXZlbHkgZmxhdHRlbiBhcnJheXMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICAgICAgYmFzZUZsYXR0ZW4odmFsdWUsIGRlcHRoIC0gMSwgcHJlZGljYXRlLCBpc1N0cmljdCwgcmVzdWx0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFycmF5UHVzaChyZXN1bHQsIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCFpc1N0cmljdCkge1xuICAgICAgcmVzdWx0W3Jlc3VsdC5sZW5ndGhdID0gdmFsdWU7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUZsYXR0ZW47XG4iLCIvKipcbiAqIEFwcGVuZHMgdGhlIGVsZW1lbnRzIG9mIGB2YWx1ZXNgIHRvIGBhcnJheWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge0FycmF5fSB2YWx1ZXMgVGhlIHZhbHVlcyB0byBhcHBlbmQuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAqL1xuZnVuY3Rpb24gYXJyYXlQdXNoKGFycmF5LCB2YWx1ZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSB2YWx1ZXMubGVuZ3RoLFxuICAgICAgb2Zmc2V0ID0gYXJyYXkubGVuZ3RoO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgYXJyYXlbb2Zmc2V0ICsgaW5kZXhdID0gdmFsdWVzW2luZGV4XTtcbiAgfVxuICByZXR1cm4gYXJyYXk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXJyYXlQdXNoO1xuIiwidmFyIFN5bWJvbCA9IHJlcXVpcmUoJy4vX1N5bWJvbCcpLFxuICAgIGlzQXJndW1lbnRzID0gcmVxdWlyZSgnLi9pc0FyZ3VtZW50cycpLFxuICAgIGlzQXJyYXkgPSByZXF1aXJlKCcuL2lzQXJyYXknKTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgc3ByZWFkYWJsZVN5bWJvbCA9IFN5bWJvbCA/IFN5bWJvbC5pc0NvbmNhdFNwcmVhZGFibGUgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBmbGF0dGVuYWJsZSBgYXJndW1lbnRzYCBvYmplY3Qgb3IgYXJyYXkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgZmxhdHRlbmFibGUsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNGbGF0dGVuYWJsZSh2YWx1ZSkge1xuICByZXR1cm4gaXNBcnJheSh2YWx1ZSkgfHwgaXNBcmd1bWVudHModmFsdWUpIHx8XG4gICAgISEoc3ByZWFkYWJsZVN5bWJvbCAmJiB2YWx1ZSAmJiB2YWx1ZVtzcHJlYWRhYmxlU3ltYm9sXSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNGbGF0dGVuYWJsZTtcbiIsImZ1bmN0aW9uIF9pc05hdGl2ZUZ1bmN0aW9uKGZuKSB7XG4gIHJldHVybiBGdW5jdGlvbi50b1N0cmluZy5jYWxsKGZuKS5pbmRleE9mKFwiW25hdGl2ZSBjb2RlXVwiKSAhPT0gLTE7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2lzTmF0aXZlRnVuY3Rpb24sIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlLCBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0czsiLCJ2YXIgc2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKFwiLi9zZXRQcm90b3R5cGVPZi5qc1wiKTtcblxudmFyIGlzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IHJlcXVpcmUoXCIuL2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdC5qc1wiKTtcblxuZnVuY3Rpb24gX2NvbnN0cnVjdChQYXJlbnQsIGFyZ3MsIENsYXNzKSB7XG4gIGlmIChpc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSkge1xuICAgIG1vZHVsZS5leHBvcnRzID0gX2NvbnN0cnVjdCA9IFJlZmxlY3QuY29uc3RydWN0LmJpbmQoKSwgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzO1xuICB9IGVsc2Uge1xuICAgIG1vZHVsZS5leHBvcnRzID0gX2NvbnN0cnVjdCA9IGZ1bmN0aW9uIF9jb25zdHJ1Y3QoUGFyZW50LCBhcmdzLCBDbGFzcykge1xuICAgICAgdmFyIGEgPSBbbnVsbF07XG4gICAgICBhLnB1c2guYXBwbHkoYSwgYXJncyk7XG4gICAgICB2YXIgQ29uc3RydWN0b3IgPSBGdW5jdGlvbi5iaW5kLmFwcGx5KFBhcmVudCwgYSk7XG4gICAgICB2YXIgaW5zdGFuY2UgPSBuZXcgQ29uc3RydWN0b3IoKTtcbiAgICAgIGlmIChDbGFzcykgc2V0UHJvdG90eXBlT2YoaW5zdGFuY2UsIENsYXNzLnByb3RvdHlwZSk7XG4gICAgICByZXR1cm4gaW5zdGFuY2U7XG4gICAgfSwgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzO1xuICB9XG5cbiAgcmV0dXJuIF9jb25zdHJ1Y3QuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfY29uc3RydWN0LCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZSwgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHM7IiwiZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHtcbiAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlO1xuICBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlO1xuICBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlO1xuXG4gIHRyeSB7XG4gICAgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpO1xuICAgIHJldHVybiB0cnVlO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCwgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzOyIsIi8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzICovXG4vKiBlc2xpbnQtZGlzYWJsZSBjbGFzcy1tZXRob2RzLXVzZS10aGlzICovXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLWN5Y2xlXG5pbXBvcnQgeyBJbWFnZVdyYXBwZXIgfSBmcm9tICdxdWFnZ2EnO1xuaW1wb3J0IHsgUXVhZ2dhSlNSZXN1bHRPYmplY3QgfSBmcm9tICcuLi8uLi90eXBlLWRlZmluaXRpb25zL3F1YWdnYSc7XG5pbXBvcnQgQXJyYXlIZWxwZXIgZnJvbSAnLi4vY29tbW9uL2FycmF5X2hlbHBlcic7XG5cbi8vIGZvciBzb21lIHJlYXNvbiB0aGlzIHRocm93cyBhIHNoYWRvdyBlcnJvciBvbiBpdHNlbGY/IVxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNoYWRvd1xuZXhwb3J0IGVudW0gQmFyY29kZURpcmVjdGlvbiB7XG4gICAgRm9yd2FyZCA9IDEsXG4gICAgUmV2ZXJzZSA9IC0xXG59XG5cbmV4cG9ydCB0eXBlIEJhcmNvZGVSZWFkZXJUeXBlID0gc3RyaW5nO1xuZXhwb3J0IHR5cGUgQmFyY29kZUZvcm1hdCA9IHN0cmluZztcblxuZXhwb3J0IGludGVyZmFjZSBCYXJjb2RlUmVhZGVyQ29uZmlnIHtcbiAgICBub3JtYWxpemVCYXJTcGFjZVdpZHRoPzogYm9vbGVhbixcbiAgICBzdXBwbGVtZW50cz86IEFycmF5PEJhcmNvZGVSZWFkZXJUeXBlPixcbn1cblxuZXhwb3J0IGludGVyZmFjZSBCYXJjb2RlQ29ycmVjdGlvbiB7XG4gICAgYmFyOiBudW1iZXIsXG4gICAgc3BhY2U6IG51bWJlcixcbn1cblxuZXhwb3J0IGludGVyZmFjZSBCYXJjb2RlUG9zaXRpb24ge1xuICAgIGVuZDogbnVtYmVyLFxuICAgIGVuZENvdW50ZXI/OiBudW1iZXIsXG4gICAgZXJyb3I/OiBudW1iZXIsXG4gICAgc3RhcnQ6IG51bWJlcixcbiAgICBzdGFydENvdW50ZXI/OiBudW1iZXJcbn1cblxuZXhwb3J0IGludGVyZmFjZSBCYXJjb2RlSW5mbyBleHRlbmRzIEJhcmNvZGVQb3NpdGlvbiB7XG4gICAgY29kZTogbnVtYmVyLFxuICAgIGNvcnJlY3Rpb24/OiBCYXJjb2RlQ29ycmVjdGlvbixcbn1cblxuZXhwb3J0IGludGVyZmFjZSBCYXJjb2RlIHtcbiAgICBjb2RlOiBzdHJpbmcsXG4gICAgY29kZXNldD86IG51bWJlcixcbiAgICBjb3JyZWN0aW9uPzogQmFyY29kZUNvcnJlY3Rpb24sXG4gICAgZGVjb2RlZENvZGVzPzogQXJyYXk8c3RyaW5nIHwgQmFyY29kZUluZm8gfCBCYXJjb2RlUG9zaXRpb24+LFxuICAgIGRpcmVjdGlvbj86IEJhcmNvZGVEaXJlY3Rpb24sXG4gICAgZW5kOiBudW1iZXIsXG4gICAgZW5kSW5mbz86IEJhcmNvZGVQb3NpdGlvbixcbiAgICBmb3JtYXQ6IEJhcmNvZGVGb3JtYXQsXG4gICAgc3RhcnQ6IG51bWJlcixcbiAgICBzdGFydEluZm86IEJhcmNvZGVQb3NpdGlvbixcbiAgICBzdXBwbGVtZW50PzogQmFyY29kZSxcbn1cblxuZXhwb3J0IGFic3RyYWN0IGNsYXNzIEJhcmNvZGVSZWFkZXIge1xuICAgIF9yb3c6IEFycmF5PG51bWJlcj4gPSBbXTtcblxuICAgIGNvbmZpZzogQmFyY29kZVJlYWRlckNvbmZpZyA9IHt9O1xuXG4gICAgc3VwcGxlbWVudHM6IEFycmF5PEJhcmNvZGVSZWFkZXI+ID0gW107XG5cbiAgICBTSU5HTEVfQ09ERV9FUlJPUiA9IDA7XG5cbiAgICBGT1JNQVQ6IEJhcmNvZGVGb3JtYXQgPSAndW5rbm93bic7XG5cbiAgICBDT05GSUdfS0VZUzogQmFyY29kZVJlYWRlckNvbmZpZyA9IHt9O1xuICAgIC8vIFRPRE86IHNob3VsZCBhZGQgQUxQSEFCRVRIX1NUUklORywgQUxQSEFCRVQsIENIQVJBQ1RFUl9FTkNPRElOR1MgdG8gYmFzZSBjbGFzcywgaWYgdGhleVxuICAgIC8vIGFyZSB1c2VmdWwgaW4gbW9zdCByZWFkZXJzLlxuXG4gICAgcHVibGljIGFic3RyYWN0IGRlY29kZShyb3c/OiBBcnJheTxudW1iZXI+LCBzdGFydD86IEJhcmNvZGVQb3NpdGlvbiB8IG51bWJlcik6IEJhcmNvZGUgfCBudWxsO1xuXG4gICAgc3RhdGljIGdldCBFeGNlcHRpb24oKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBTdGFydE5vdEZvdW5kRXhjZXB0aW9uOiAnU3RhcnQtSW5mbyB3YXMgbm90IGZvdW5kIScsXG4gICAgICAgICAgICBDb2RlTm90Rm91bmRFeGNlcHRpb246ICdDb2RlIGNvdWxkIG5vdCBiZSBmb3VuZCEnLFxuICAgICAgICAgICAgUGF0dGVybk5vdEZvdW5kRXhjZXB0aW9uOiAnUGF0dGVybiBjb3VsZCBub3QgYmUgZm91bmQhJyxcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBjb25zdHJ1Y3Rvcihjb25maWc6IEJhcmNvZGVSZWFkZXJDb25maWcsIHN1cHBsZW1lbnRzPzogQXJyYXk8QmFyY29kZVJlYWRlcj4pIHtcbiAgICAgICAgdGhpcy5fcm93ID0gW107XG4gICAgICAgIHRoaXMuY29uZmlnID0gY29uZmlnIHx8IHt9O1xuICAgICAgICBpZiAoc3VwcGxlbWVudHMpIHtcbiAgICAgICAgICAgIHRoaXMuc3VwcGxlbWVudHMgPSBzdXBwbGVtZW50cztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByb3RlY3RlZCBfbmV4dFVuc2V0KGxpbmU6IFJlYWRvbmx5QXJyYXk8bnVtYmVyPiwgc3RhcnQgPSAwKTogbnVtYmVyIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDwgbGluZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKCFsaW5lW2ldKSByZXR1cm4gaTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbGluZS5sZW5ndGg7XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIF9tYXRjaFBhdHRlcm4oY291bnRlcjogUmVhZG9ubHlBcnJheTxudW1iZXI+LCBjb2RlOiBSZWFkb25seUFycmF5PG51bWJlcj4sIG1heFNpbmdsZUVycm9yID0gdGhpcy5TSU5HTEVfQ09ERV9FUlJPUiB8fCAxKTogbnVtYmVyIHtcbiAgICAgICAgbGV0IGVycm9yID0gMDtcbiAgICAgICAgbGV0IHNpbmdsZUVycm9yID0gMDtcbiAgICAgICAgbGV0IHN1bSA9IDA7XG4gICAgICAgIGxldCBtb2R1bG8gPSAwO1xuICAgICAgICBsZXQgYmFyV2lkdGggPSAwO1xuICAgICAgICBsZXQgY291bnQgPSAwO1xuICAgICAgICBsZXQgc2NhbGVkID0gMDtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvdW50ZXIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHN1bSArPSBjb3VudGVyW2ldO1xuICAgICAgICAgICAgbW9kdWxvICs9IGNvZGVbaV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN1bSA8IG1vZHVsbykge1xuICAgICAgICAgICAgcmV0dXJuIE51bWJlci5NQVhfVkFMVUU7XG4gICAgICAgIH1cblxuICAgICAgICBiYXJXaWR0aCA9IHN1bSAvIG1vZHVsbztcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICAgIG1heFNpbmdsZUVycm9yICo9IGJhcldpZHRoO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvdW50ZXIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvdW50ID0gY291bnRlcltpXTtcbiAgICAgICAgICAgIHNjYWxlZCA9IGNvZGVbaV0gKiBiYXJXaWR0aDtcbiAgICAgICAgICAgIHNpbmdsZUVycm9yID0gTWF0aC5hYnMoY291bnQgLSBzY2FsZWQpIC8gc2NhbGVkO1xuICAgICAgICAgICAgaWYgKHNpbmdsZUVycm9yID4gbWF4U2luZ2xlRXJyb3IpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gTnVtYmVyLk1BWF9WQUxVRTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVycm9yICs9IHNpbmdsZUVycm9yO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlcnJvciAvIG1vZHVsbztcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgX25leHRTZXQobGluZTogUmVhZG9ubHlBcnJheTxudW1iZXI+LCBvZmZzZXQgPSAwKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSBvZmZzZXQ7IGkgPCBsaW5lLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAobGluZVtpXSkgcmV0dXJuIGk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxpbmUubGVuZ3RoO1xuICAgIH1cblxuICAgIHByb3RlY3RlZCBfY29ycmVjdEJhcnMoY291bnRlcjogQXJyYXk8bnVtYmVyPiwgY29ycmVjdGlvbjogbnVtYmVyLCBpbmRpY2VzOiBBcnJheTxudW1iZXI+KSB7XG4gICAgICAgIGxldCB7IGxlbmd0aCB9ID0gaW5kaWNlcztcbiAgICAgICAgbGV0IHRtcCA9IDA7XG4gICAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICAgICAgdG1wID0gY291bnRlcltpbmRpY2VzW2xlbmd0aF1dICogKDEgLSAoKDEgLSBjb3JyZWN0aW9uKSAvIDIpKTtcbiAgICAgICAgICAgIGlmICh0bXAgPiAxKSB7XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICAgICAgICAgICAgY291bnRlcltpbmRpY2VzW2xlbmd0aF1dID0gdG1wO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHVibGljIGRlY29kZVBhdHRlcm4ocGF0dGVybjogQXJyYXk8bnVtYmVyPikge1xuICAgICAgICAvLyBjb25zb2xlLndhcm4oJyogZGVjb2RlUGF0dGVybicsIHBhdHRlcm4pO1xuICAgICAgICB0aGlzLl9yb3cgPSBwYXR0ZXJuO1xuICAgICAgICAvLyBjb25zb2xlLndhcm4oJyogZGVjb2RlUGF0dGVybiBjYWxsaW5nIGRlY29kZScsIHR5cGVvZiB0aGlzLCB0aGlzLmNvbnN0cnVjdG9yLCB0aGlzLkZPUk1BVCwgSlNPTi5zdHJpbmdpZnkodGhpcykpO1xuICAgICAgICBsZXQgcmVzdWx0ID0gdGhpcy5kZWNvZGUoKTtcbiAgICAgICAgLy8gY29uc29sZS53YXJuKCcqIGZpcnN0IHJlc3VsdD0nLCByZXN1bHQpO1xuICAgICAgICBpZiAocmVzdWx0ID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLl9yb3cucmV2ZXJzZSgpO1xuICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5kZWNvZGUoKTtcbiAgICAgICAgICAgIC8vIGNvbnNvbGUud2FybignKiByZXZlcnNlZCByZXN1bHQ9JywgcmVzdWx0KTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQuZGlyZWN0aW9uID0gQmFyY29kZURpcmVjdGlvbi5SZXZlcnNlO1xuICAgICAgICAgICAgICAgIHJlc3VsdC5zdGFydCA9IHRoaXMuX3Jvdy5sZW5ndGggLSByZXN1bHQuc3RhcnQ7XG4gICAgICAgICAgICAgICAgcmVzdWx0LmVuZCA9IHRoaXMuX3Jvdy5sZW5ndGggLSByZXN1bHQuZW5kO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0LmRpcmVjdGlvbiA9IEJhcmNvZGVEaXJlY3Rpb24uRm9yd2FyZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgICByZXN1bHQuZm9ybWF0ID0gdGhpcy5GT1JNQVQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gY29uc29sZS53YXJuKCcqIHJldHVybmluZycsIHJlc3VsdCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIF9tYXRjaFJhbmdlKHN0YXJ0OiBudW1iZXIsIGVuZDogbnVtYmVyLCB2YWx1ZTogbnVtYmVyKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgICBzdGFydCA9IHN0YXJ0IDwgMCA/IDAgOiBzdGFydDtcbiAgICAgICAgbGV0IGk7XG4gICAgICAgIGZvciAoaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9yb3dbaV0gIT09IHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHByb3RlY3RlZCBfZmlsbENvdW50ZXJzKG9mZnNldDogbnVtYmVyID0gdGhpcy5fbmV4dFVuc2V0KHRoaXMuX3JvdyksIGVuZDogbnVtYmVyID0gdGhpcy5fcm93Lmxlbmd0aCwgaXNXaGl0ZSA9IHRydWUpIHtcbiAgICAgICAgY29uc3QgY291bnRlcnM6IEFycmF5PG51bWJlcj4gPSBbXTtcbiAgICAgICAgbGV0IGNvdW50ZXJQb3MgPSAwO1xuICAgICAgICBjb3VudGVyc1tjb3VudGVyUG9zXSA9IDA7XG4gICAgICAgIGZvciAobGV0IGkgPSBvZmZzZXQ7IGkgPCBlbmQ7IGkrKykge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWJpdHdpc2VcbiAgICAgICAgICAgIGlmICh0aGlzLl9yb3dbaV0gXiAoaXNXaGl0ZSA/IDEgOiAwKSkge1xuICAgICAgICAgICAgICAgIGNvdW50ZXJzW2NvdW50ZXJQb3NdKys7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvdW50ZXJQb3MrKztcbiAgICAgICAgICAgICAgICBjb3VudGVyc1tjb3VudGVyUG9zXSA9IDE7XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICAgICAgICAgICAgaXNXaGl0ZSA9ICFpc1doaXRlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb3VudGVycztcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgX3RvQ291bnRlcnMoc3RhcnQ6IG51bWJlciwgY291bnRlcnM6IFVpbnQxNkFycmF5IHwgQXJyYXk8bnVtYmVyPikge1xuICAgICAgICBjb25zdCBudW1Db3VudGVycyA9IGNvdW50ZXJzLmxlbmd0aDtcbiAgICAgICAgY29uc3QgZW5kID0gdGhpcy5fcm93Lmxlbmd0aDtcbiAgICAgICAgbGV0IGlzV2hpdGUgPSAhdGhpcy5fcm93W3N0YXJ0XTtcbiAgICAgICAgbGV0IGNvdW50ZXJQb3MgPSAwO1xuXG4gICAgICAgIEFycmF5SGVscGVyLmluaXQoY291bnRlcnMsIDApO1xuICAgICAgICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWJpdHdpc2VcbiAgICAgICAgICAgIGlmICh0aGlzLl9yb3dbaV0gXiAoaXNXaGl0ZSA/IDEgOiAwKSkge1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgICAgICAgICAgIGNvdW50ZXJzW2NvdW50ZXJQb3NdKys7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvdW50ZXJQb3MrKztcbiAgICAgICAgICAgICAgICBpZiAoY291bnRlclBvcyA9PT0gbnVtQ291bnRlcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICAgICAgICAgICAgICAgIGNvdW50ZXJzW2NvdW50ZXJQb3NdID0gMTtcbiAgICAgICAgICAgICAgICAgICAgaXNXaGl0ZSA9ICFpc1doaXRlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY291bnRlcnM7XG4gICAgfVxuXG4gICAgLy8gb3ZlcnJpZGUvaW1wbGVtZW50IHRoaXMgaW4geW91ciBjdXN0b20gcmVhZGVycy5cbiAgICBwcm90ZWN0ZWQgZGVjb2RlSW1hZ2UoaW1hZ2VXcmFwcGVyOiBJbWFnZVdyYXBwZXIpOiBRdWFnZ2FKU1Jlc3VsdE9iamVjdCB8IG51bGwge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdm9pZFxuICAgICAgICB2b2lkIGltYWdlV3JhcHBlcjtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBCYXJjb2RlUmVhZGVyO1xuIiwiaW1wb3J0IEJhcmNvZGVSZWFkZXIsIHsgQmFyY29kZSwgQmFyY29kZUluZm8sIEJhcmNvZGVQb3NpdGlvbiB9IGZyb20gJy4vYmFyY29kZV9yZWFkZXInO1xuXG5jb25zdCBOID0gMTtcbmNvbnN0IFcgPSAzO1xuY29uc3QgU1RBUlRfUEFUVEVSTiA9IFtXLCBOLCBXLCBOLCBOLCBOXTtcbmNvbnN0IFNUT1BfUEFUVEVSTiA9IFtXLCBOLCBOLCBOLCBXXTtcbmNvbnN0IENPREVfUEFUVEVSTiA9IFtcbiAgICBbTiwgTiwgVywgVywgTl0sXG4gICAgW1csIE4sIE4sIE4sIFddLFxuICAgIFtOLCBXLCBOLCBOLCBXXSxcbiAgICBbVywgVywgTiwgTiwgTl0sXG4gICAgW04sIE4sIFcsIE4sIFddLFxuICAgIFtXLCBOLCBXLCBOLCBOXSxcbiAgICBbTiwgVywgVywgTiwgTl0sXG4gICAgW04sIE4sIE4sIFcsIFddLFxuICAgIFtXLCBOLCBOLCBXLCBOXSxcbiAgICBbTiwgVywgTiwgVywgTl0sXG5dO1xuY29uc3QgU1RBUlRfUEFUVEVSTl9MRU5HVEggPSBTVEFSVF9QQVRURVJOLnJlZHVjZSgoc3VtLCB2YWwpID0+IHN1bSArIHZhbCwgMCk7XG5cbmNsYXNzIFR3b09mRml2ZVJlYWRlciBleHRlbmRzIEJhcmNvZGVSZWFkZXIge1xuICAgIGJhclNwYWNlUmF0aW8gPSBbMSwgMV07XG5cbiAgICBGT1JNQVQgPSAnMm9mNSc7XG5cbiAgICBTSU5HTEVfQ09ERV9FUlJPUiA9IDAuNzg7XG5cbiAgICBBVkdfQ09ERV9FUlJPUiA9IDAuMzA7XG5cbiAgICBwcm90ZWN0ZWQgX2ZpbmRQYXR0ZXJuKHBhdHRlcm46IFJlYWRvbmx5QXJyYXk8bnVtYmVyPiwgb2Zmc2V0OiBudW1iZXIsIGlzV2hpdGUgPSBmYWxzZSwgdHJ5SGFyZGVyID0gZmFsc2UpOiBCYXJjb2RlSW5mbyB8IG51bGwge1xuICAgICAgICBjb25zdCBjb3VudGVyID0gW107XG4gICAgICAgIGxldCBjb3VudGVyUG9zID0gMDtcbiAgICAgICAgY29uc3QgYmVzdE1hdGNoID0ge1xuICAgICAgICAgICAgZXJyb3I6IE51bWJlci5NQVhfVkFMVUUsXG4gICAgICAgICAgICBjb2RlOiAtMSxcbiAgICAgICAgICAgIHN0YXJ0OiAwLFxuICAgICAgICAgICAgZW5kOiAwLFxuICAgICAgICB9O1xuICAgICAgICBsZXQgc3VtID0gMDtcbiAgICAgICAgbGV0IGVycm9yID0gMDtcbiAgICAgICAgY29uc3QgZXBzaWxvbiA9IHRoaXMuQVZHX0NPREVfRVJST1I7XG5cbiAgICAgICAgaWYgKCFvZmZzZXQpIHtcbiAgICAgICAgICAgIG9mZnNldCA9IHRoaXMuX25leHRTZXQodGhpcy5fcm93KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGF0dGVybi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY291bnRlcltpXSA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGxldCBpID0gb2Zmc2V0OyBpIDwgdGhpcy5fcm93Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fcm93W2ldIF4gKGlzV2hpdGUgPyAxIDogMCkpIHtcbiAgICAgICAgICAgICAgICBjb3VudGVyW2NvdW50ZXJQb3NdKys7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChjb3VudGVyUG9zID09PSBjb3VudGVyLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgc3VtID0gMDtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBjb3VudGVyLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdW0gKz0gY291bnRlcltqXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlcnJvciA9IHRoaXMuX21hdGNoUGF0dGVybihjb3VudGVyLCBwYXR0ZXJuKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yIDwgZXBzaWxvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgYmVzdE1hdGNoLmVycm9yID0gZXJyb3I7XG4gICAgICAgICAgICAgICAgICAgICAgICBiZXN0TWF0Y2guc3RhcnQgPSBpIC0gc3VtO1xuICAgICAgICAgICAgICAgICAgICAgICAgYmVzdE1hdGNoLmVuZCA9IGk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYmVzdE1hdGNoO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0cnlIYXJkZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgY291bnRlci5sZW5ndGggLSAyOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb3VudGVyW2pdID0gY291bnRlcltqICsgMl07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjb3VudGVyW2NvdW50ZXIubGVuZ3RoIC0gMl0gPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgY291bnRlcltjb3VudGVyLmxlbmd0aCAtIDFdID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50ZXJQb3MtLTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY291bnRlclBvcysrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb3VudGVyW2NvdW50ZXJQb3NdID0gMTtcbiAgICAgICAgICAgICAgICBpc1doaXRlID0gIWlzV2hpdGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIF9maW5kU3RhcnQoKTogQmFyY29kZVBvc2l0aW9uIHwgbnVsbCB7XG4gICAgICAgIGxldCBzdGFydEluZm8gPSBudWxsO1xuICAgICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5fbmV4dFNldCh0aGlzLl9yb3cpO1xuICAgICAgICBsZXQgbmFycm93QmFyV2lkdGggPSAxO1xuICAgICAgICBsZXQgbGVhZGluZ1doaXRlc3BhY2VTdGFydCA9IDA7XG5cbiAgICAgICAgd2hpbGUgKCFzdGFydEluZm8pIHtcbiAgICAgICAgICAgIHN0YXJ0SW5mbyA9IHRoaXMuX2ZpbmRQYXR0ZXJuKFNUQVJUX1BBVFRFUk4sIG9mZnNldCwgZmFsc2UsIHRydWUpO1xuICAgICAgICAgICAgaWYgKCFzdGFydEluZm8pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5hcnJvd0JhcldpZHRoID0gTWF0aC5mbG9vcigoc3RhcnRJbmZvLmVuZCAtIHN0YXJ0SW5mby5zdGFydCkgLyBTVEFSVF9QQVRURVJOX0xFTkdUSCk7XG4gICAgICAgICAgICBsZWFkaW5nV2hpdGVzcGFjZVN0YXJ0ID0gc3RhcnRJbmZvLnN0YXJ0IC0gbmFycm93QmFyV2lkdGggKiA1O1xuICAgICAgICAgICAgaWYgKGxlYWRpbmdXaGl0ZXNwYWNlU3RhcnQgPj0gMCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9tYXRjaFJhbmdlKGxlYWRpbmdXaGl0ZXNwYWNlU3RhcnQsIHN0YXJ0SW5mby5zdGFydCwgMCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0YXJ0SW5mbztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvZmZzZXQgPSBzdGFydEluZm8uZW5kO1xuICAgICAgICAgICAgc3RhcnRJbmZvID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RhcnRJbmZvO1xuICAgIH1cblxuICAgIHByb3RlY3RlZCBfdmVyaWZ5VHJhaWxpbmdXaGl0ZXNwYWNlKGVuZEluZm86IEJhcmNvZGVJbmZvKTogQmFyY29kZVBvc2l0aW9uIHwgbnVsbCB7XG4gICAgICAgIGNvbnN0IHRyYWlsaW5nV2hpdGVzcGFjZUVuZCA9IGVuZEluZm8uZW5kICsgKChlbmRJbmZvLmVuZCAtIGVuZEluZm8uc3RhcnQpIC8gMik7XG4gICAgICAgIGlmICh0cmFpbGluZ1doaXRlc3BhY2VFbmQgPCB0aGlzLl9yb3cubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fbWF0Y2hSYW5nZShlbmRJbmZvLmVuZCwgdHJhaWxpbmdXaGl0ZXNwYWNlRW5kLCAwKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBlbmRJbmZvO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHByb3RlY3RlZCBfZmluZEVuZCgpOiBCYXJjb2RlUG9zaXRpb24gfCBudWxsIHtcbiAgICAgICAgLy8gVE9ETzogcmV2ZXJzZSwgZm9sbG93ZWQgYnkgc29tZSBjYWxjcywgZm9sbG93ZWQgYnkgYW5vdGhlciByZXZlcnNlPyByZWFsbHk/XG4gICAgICAgIHRoaXMuX3Jvdy5yZXZlcnNlKCk7XG4gICAgICAgIGNvbnN0IG9mZnNldCA9IHRoaXMuX25leHRTZXQodGhpcy5fcm93KTtcbiAgICAgICAgY29uc3QgZW5kSW5mbyA9IHRoaXMuX2ZpbmRQYXR0ZXJuKFNUT1BfUEFUVEVSTiwgb2Zmc2V0LCBmYWxzZSwgdHJ1ZSk7XG4gICAgICAgIHRoaXMuX3Jvdy5yZXZlcnNlKCk7XG5cbiAgICAgICAgaWYgKGVuZEluZm8gPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcmV2ZXJzZSBudW1iZXJzXG4gICAgICAgIGNvbnN0IHRtcCA9IGVuZEluZm8uc3RhcnQ7XG4gICAgICAgIGVuZEluZm8uc3RhcnQgPSB0aGlzLl9yb3cubGVuZ3RoIC0gZW5kSW5mby5lbmQ7XG4gICAgICAgIGVuZEluZm8uZW5kID0gdGhpcy5fcm93Lmxlbmd0aCAtIHRtcDtcblxuICAgICAgICByZXR1cm4gZW5kSW5mbyAhPT0gbnVsbCA/IHRoaXMuX3ZlcmlmeVRyYWlsaW5nV2hpdGVzcGFjZShlbmRJbmZvKSA6IG51bGw7XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIF92ZXJpZnlDb3VudGVyTGVuZ3RoKGNvdW50ZXJzOiBBcnJheTxudW1iZXI+KSB7XG4gICAgICAgIHJldHVybiAoY291bnRlcnMubGVuZ3RoICUgMTAgPT09IDApO1xuICAgIH1cblxuICAgIHByb3RlY3RlZCBfZGVjb2RlQ29kZShjb3VudGVyOiBSZWFkb25seUFycmF5PG51bWJlcj4pOiBCYXJjb2RlSW5mbyB8IG51bGwge1xuICAgICAgICBjb25zdCBlcHNpbG9uID0gdGhpcy5BVkdfQ09ERV9FUlJPUjtcbiAgICAgICAgY29uc3QgYmVzdE1hdGNoID0ge1xuICAgICAgICAgICAgZXJyb3I6IE51bWJlci5NQVhfVkFMVUUsXG4gICAgICAgICAgICBjb2RlOiAtMSxcbiAgICAgICAgICAgIHN0YXJ0OiAwLFxuICAgICAgICAgICAgZW5kOiAwLFxuICAgICAgICB9O1xuXG4gICAgICAgIGZvciAobGV0IGNvZGUgPSAwOyBjb2RlIDwgQ09ERV9QQVRURVJOLmxlbmd0aDsgY29kZSsrKSB7XG4gICAgICAgICAgICBjb25zdCBlcnJvciA9IHRoaXMuX21hdGNoUGF0dGVybihjb3VudGVyLCBDT0RFX1BBVFRFUk5bY29kZV0pO1xuICAgICAgICAgICAgaWYgKGVycm9yIDwgYmVzdE1hdGNoLmVycm9yISkge1xuICAgICAgICAgICAgICAgIGJlc3RNYXRjaC5jb2RlID0gY29kZTtcbiAgICAgICAgICAgICAgICBiZXN0TWF0Y2guZXJyb3IgPSBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoYmVzdE1hdGNoLmVycm9yISA8IGVwc2lsb24pIHtcbiAgICAgICAgICAgIHJldHVybiBiZXN0TWF0Y2g7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIF9kZWNvZGVQYXlsb2FkKGNvdW50ZXJzOiBSZWFkb25seUFycmF5PG51bWJlcj4sIHJlc3VsdDogQXJyYXk8c3RyaW5nPiwgZGVjb2RlZENvZGVzOiBBcnJheTxCYXJjb2RlSW5mbyB8IEJhcmNvZGVQb3NpdGlvbj4pOiBCYXJjb2RlSW5mbyB8IG51bGwge1xuICAgICAgICBsZXQgcG9zID0gMDtcbiAgICAgICAgY29uc3QgY291bnRlckxlbmd0aCA9IGNvdW50ZXJzLmxlbmd0aDtcbiAgICAgICAgY29uc3QgY291bnRlciA9IFswLCAwLCAwLCAwLCAwXTtcbiAgICAgICAgbGV0IGNvZGU6IEJhcmNvZGVJbmZvIHwgbnVsbCA9IG51bGw7XG5cbiAgICAgICAgd2hpbGUgKHBvcyA8IGNvdW50ZXJMZW5ndGgpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY291bnRlcltpXSA9IGNvdW50ZXJzW3Bvc10gKiB0aGlzLmJhclNwYWNlUmF0aW9bMF07XG4gICAgICAgICAgICAgICAgcG9zICs9IDI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb2RlID0gdGhpcy5fZGVjb2RlQ29kZShjb3VudGVyKTtcbiAgICAgICAgICAgIGlmICghY29kZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0LnB1c2goYCR7Y29kZS5jb2RlfWApO1xuICAgICAgICAgICAgZGVjb2RlZENvZGVzLnB1c2goY29kZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvZGU7XG4gICAgfVxuXG5cbiAgICBwdWJsaWMgZGVjb2RlKHJvdz86IEFycmF5PG51bWJlcj4sIHN0YXJ0PzogQmFyY29kZVBvc2l0aW9uKTogQmFyY29kZSB8IG51bGwge1xuICAgICAgICBjb25zdCBzdGFydEluZm8gPSB0aGlzLl9maW5kU3RhcnQoKTtcbiAgICAgICAgaWYgKCFzdGFydEluZm8pIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgZW5kSW5mbyA9IHRoaXMuX2ZpbmRFbmQoKTtcbiAgICAgICAgaWYgKCFlbmRJbmZvKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGNvdW50ZXJzID0gdGhpcy5fZmlsbENvdW50ZXJzKHN0YXJ0SW5mby5lbmQsIGVuZEluZm8uc3RhcnQsIGZhbHNlKTtcbiAgICAgICAgaWYgKCF0aGlzLl92ZXJpZnlDb3VudGVyTGVuZ3RoKGNvdW50ZXJzKSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGVjb2RlZENvZGVzID0gW107XG4gICAgICAgIGRlY29kZWRDb2Rlcy5wdXNoKHN0YXJ0SW5mbyk7XG5cbiAgICAgICAgY29uc3QgcmVzdWx0OiBBcnJheTxzdHJpbmc+ID0gW107XG4gICAgICAgIGNvbnN0IGNvZGUgPSB0aGlzLl9kZWNvZGVQYXlsb2FkKGNvdW50ZXJzLCByZXN1bHQsIGRlY29kZWRDb2Rlcyk7XG4gICAgICAgIGlmICghY29kZSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdC5sZW5ndGggPCA1KSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGRlY29kZWRDb2Rlcy5wdXNoKGVuZEluZm8pO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY29kZTogcmVzdWx0LmpvaW4oJycpLFxuICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0SW5mby5zdGFydCxcbiAgICAgICAgICAgIGVuZDogZW5kSW5mby5lbmQsXG4gICAgICAgICAgICBzdGFydEluZm8sXG4gICAgICAgICAgICBkZWNvZGVkQ29kZXMsXG4gICAgICAgICAgICBmb3JtYXQ6IHRoaXMuRk9STUFULFxuICAgICAgICB9O1xuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgVHdvT2ZGaXZlUmVhZGVyO1xuIiwiaW1wb3J0IEJhcmNvZGVSZWFkZXIsIHsgQmFyY29kZSwgQmFyY29kZVBvc2l0aW9uIH0gZnJvbSAnLi9iYXJjb2RlX3JlYWRlcic7XG5cbi8vIGNvbnN0IEFMUEhBQkVUSF9TVFJJTkcgPSAnMDEyMzQ1Njc4OS0kOi8uK0FCQ0QnO1xuY29uc3QgQUxQSEFCRVQgPSBbNDgsIDQ5LCA1MCwgNTEsIDUyLCA1MywgNTQsIDU1LCA1NiwgNTcsIDQ1LCAzNiwgNTgsIDQ3LCA0NiwgNDMsIDY1LCA2NiwgNjcsIDY4XTtcbmNvbnN0IENIQVJBQ1RFUl9FTkNPRElOR1MgPVxuICAgIFsweDAwMywgMHgwMDYsIDB4MDA5LCAweDA2MCwgMHgwMTIsIDB4MDQyLCAweDAyMSwgMHgwMjQsIDB4MDMwLCAweDA0OCwgMHgwMGMsIDB4MDE4LFxuICAgICAgICAweDA0NSwgMHgwNTEsIDB4MDU0LCAweDAxNSwgMHgwMUEsIDB4MDI5LCAweDAwQiwgMHgwMEVdO1xuY29uc3QgU1RBUlRfRU5EID0gWzB4MDFBLCAweDAyOSwgMHgwMEIsIDB4MDBFXTtcbmNvbnN0IE1JTl9FTkNPREVEX0NIQVJTID0gNDtcbmNvbnN0IE1BWF9BQ0NFUFRBQkxFID0gMi4wO1xuY29uc3QgUEFERElORyA9IDEuNTtcblxuaW50ZXJmYWNlIFRocmVzaG9sZFNpemUge1xuICAgIHNpemU6IG51bWJlcixcbiAgICBjb3VudHM6IG51bWJlcixcbiAgICBtaW46IG51bWJlcixcbiAgICBtYXg6IG51bWJlcixcbn07XG5cbmludGVyZmFjZSBUaHJlc2hvbGQge1xuICAgIHNwYWNlOiB7XG4gICAgICAgIG5hcnJvdzogVGhyZXNob2xkU2l6ZSxcbiAgICAgICAgd2lkZTogVGhyZXNob2xkU2l6ZSxcbiAgICB9LFxuICAgIGJhcjoge1xuICAgICAgICBuYXJyb3c6IFRocmVzaG9sZFNpemUsXG4gICAgICAgIHdpZGU6IFRocmVzaG9sZFNpemUsXG4gICAgfSxcbn07XG5cbmNsYXNzIE5ld0NvZGFiYXJSZWFkZXIgZXh0ZW5kcyBCYXJjb2RlUmVhZGVyIHtcbiAgICBfY291bnRlcnM6IEFycmF5PG51bWJlcj4gPSBbXTtcbiAgICBGT1JNQVQgPSAnY29kYWJhcic7XG5cbiAgICBwcm90ZWN0ZWQgX2NvbXB1dGVBbHRlcm5hdGluZ1RocmVzaG9sZChvZmZzZXQ6IG51bWJlciwgZW5kOiBudW1iZXIpIHtcbiAgICAgICAgbGV0IG1pbiA9IE51bWJlci5NQVhfVkFMVUU7XG4gICAgICAgIGxldCBtYXggPSAwO1xuICAgICAgICBsZXQgY291bnRlciA9IDA7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IG9mZnNldDsgaSA8IGVuZDsgaSArPSAyKSB7XG4gICAgICAgICAgICBjb3VudGVyID0gdGhpcy5fY291bnRlcnNbaV07XG4gICAgICAgICAgICBpZiAoY291bnRlciA+IG1heCkge1xuICAgICAgICAgICAgICAgIG1heCA9IGNvdW50ZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY291bnRlciA8IG1pbikge1xuICAgICAgICAgICAgICAgIG1pbiA9IGNvdW50ZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gKChtaW4gKyBtYXgpIC8gMi4wKSB8IDA7XG4gICAgfTtcblxuICAgIHByb3RlY3RlZCBfdG9QYXR0ZXJuKG9mZnNldDogbnVtYmVyKSB7XG4gICAgICAgIGNvbnN0IG51bUNvdW50ZXJzID0gNztcbiAgICAgICAgY29uc3QgZW5kID0gb2Zmc2V0ICsgbnVtQ291bnRlcnM7XG5cbiAgICAgICAgaWYgKGVuZCA+IHRoaXMuX2NvdW50ZXJzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgYmFyVGhyZXNob2xkID0gdGhpcy5fY29tcHV0ZUFsdGVybmF0aW5nVGhyZXNob2xkKG9mZnNldCwgZW5kKTtcbiAgICAgICAgY29uc3Qgc3BhY2VUaHJlc2hvbGQgPSB0aGlzLl9jb21wdXRlQWx0ZXJuYXRpbmdUaHJlc2hvbGQob2Zmc2V0ICsgMSwgZW5kKTtcblxuICAgICAgICBsZXQgYml0bWFzayA9IDEgPDwgKG51bUNvdW50ZXJzIC0gMSk7XG4gICAgICAgIGxldCB0aHJlc2hvbGQgPSAwO1xuICAgICAgICBsZXQgcGF0dGVybiA9IDA7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1Db3VudGVyczsgaSsrKSB7XG4gICAgICAgICAgICB0aHJlc2hvbGQgPSAoaSAmIDEpID09PSAwID8gYmFyVGhyZXNob2xkIDogc3BhY2VUaHJlc2hvbGQ7XG4gICAgICAgICAgICBpZiAodGhpcy5fY291bnRlcnNbb2Zmc2V0ICsgaV0gPiB0aHJlc2hvbGQpIHtcbiAgICAgICAgICAgICAgICBwYXR0ZXJuIHw9IGJpdG1hc2s7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBiaXRtYXNrID4+PSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHBhdHRlcm47XG4gICAgfTtcblxuICAgIHByb3RlY3RlZCBfaXNTdGFydEVuZChwYXR0ZXJuOiBudW1iZXIpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBTVEFSVF9FTkQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChTVEFSVF9FTkRbaV0gPT09IHBhdHRlcm4pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcblxuICAgIHByb3RlY3RlZCBfc3VtQ291bnRlcnMoc3RhcnQ6IG51bWJlciwgZW5kOiBudW1iZXIpIHtcbiAgICAgICAgbGV0IHN1bSA9IDA7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcbiAgICAgICAgICAgIHN1bSArPSB0aGlzLl9jb3VudGVyc1tpXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3VtO1xuICAgIH07XG5cbiAgICBwcm90ZWN0ZWQgX2ZpbmRTdGFydCgpOiBCYXJjb2RlUG9zaXRpb24gfCBudWxsIHtcbiAgICAgICAgbGV0IHN0YXJ0ID0gdGhpcy5fbmV4dFVuc2V0KHRoaXMuX3Jvdyk7XG4gICAgICAgIGxldCBlbmQgPSBzdGFydDtcblxuICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IHRoaXMuX2NvdW50ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBwYXR0ZXJuID0gdGhpcy5fdG9QYXR0ZXJuKGkpO1xuICAgICAgICAgICAgaWYgKHBhdHRlcm4gIT09IC0xICYmIHRoaXMuX2lzU3RhcnRFbmQocGF0dGVybikpIHtcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBMb29rIGZvciB3aGl0ZXNwYWNlIGFoZWFkXG4gICAgICAgICAgICAgICAgc3RhcnQgKz0gdGhpcy5fc3VtQ291bnRlcnMoMCwgaSk7XG4gICAgICAgICAgICAgICAgZW5kID0gc3RhcnQgKyB0aGlzLl9zdW1Db3VudGVycyhpLCBpICsgOCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0LFxuICAgICAgICAgICAgICAgICAgICBlbmQ6IGVuZCxcbiAgICAgICAgICAgICAgICAgICAgc3RhcnRDb3VudGVyOiBpLFxuICAgICAgICAgICAgICAgICAgICBlbmRDb3VudGVyOiBpICsgOCxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHByb3RlY3RlZCBfcGF0dGVyblRvQ2hhcihwYXR0ZXJuOiBudW1iZXIpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBDSEFSQUNURVJfRU5DT0RJTkdTLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoQ0hBUkFDVEVSX0VOQ09ESU5HU1tpXSA9PT0gcGF0dGVybikge1xuICAgICAgICAgICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKEFMUEhBQkVUW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuXG4gICAgcHJvdGVjdGVkIF9jYWxjdWxhdGVQYXR0ZXJuTGVuZ3RoKG9mZnNldDogbnVtYmVyKSB7XG4gICAgICAgIGxldCBzdW0gPSAwO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSBvZmZzZXQ7IGkgPCBvZmZzZXQgKyA3OyBpKyspIHtcbiAgICAgICAgICAgIHN1bSArPSB0aGlzLl9jb3VudGVyc1tpXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzdW07XG4gICAgfTtcblxuICAgIHByb3RlY3RlZCBfdmVyaWZ5V2hpdGVzcGFjZShzdGFydENvdW50ZXI6IG51bWJlciwgZW5kQ291bnRlcjogbnVtYmVyKSB7XG4gICAgICAgIGlmICgoc3RhcnRDb3VudGVyIC0gMSA8PSAwKVxuICAgICAgICAgICAgfHwgdGhpcy5fY291bnRlcnNbc3RhcnRDb3VudGVyIC0gMV0gPj0gKHRoaXMuX2NhbGN1bGF0ZVBhdHRlcm5MZW5ndGgoc3RhcnRDb3VudGVyKSAvIDIuMCkpIHtcbiAgICAgICAgICAgIGlmICgoZW5kQ291bnRlciArIDggPj0gdGhpcy5fY291bnRlcnMubGVuZ3RoKVxuICAgICAgICAgICAgICAgIHx8IHRoaXMuX2NvdW50ZXJzW2VuZENvdW50ZXIgKyA3XSA+PSAodGhpcy5fY2FsY3VsYXRlUGF0dGVybkxlbmd0aChlbmRDb3VudGVyKSAvIDIuMCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcblxuICAgIHByb3RlY3RlZCBfY2hhclRvUGF0dGVybihjaGFyOiBzdHJpbmcpIHtcbiAgICAgICAgY29uc3QgY2hhckNvZGUgPSBjaGFyLmNoYXJDb2RlQXQoMCk7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBBTFBIQUJFVC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKEFMUEhBQkVUW2ldID09PSBjaGFyQ29kZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBDSEFSQUNURVJfRU5DT0RJTkdTW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAweDA7XG4gICAgfTtcblxuICAgIHByb3RlY3RlZCBfdGhyZXNob2xkUmVzdWx0UGF0dGVybihyZXN1bHQ6IFJlYWRvbmx5QXJyYXk8c3RyaW5nPiwgc3RhcnRDb3VudGVyOiBudW1iZXIpIHtcbiAgICAgICAgY29uc3QgY2F0ZWdvcml6YXRpb246IFRocmVzaG9sZCA9IHtcbiAgICAgICAgICAgICAgICBzcGFjZToge1xuICAgICAgICAgICAgICAgICAgICBuYXJyb3c6IHsgc2l6ZTogMCwgY291bnRzOiAwLCBtaW46IDAsIG1heDogTnVtYmVyLk1BWF9WQUxVRSB9LFxuICAgICAgICAgICAgICAgICAgICB3aWRlOiB7IHNpemU6IDAsIGNvdW50czogMCwgbWluOiAwLCBtYXg6IE51bWJlci5NQVhfVkFMVUUgfSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGJhcjoge1xuICAgICAgICAgICAgICAgICAgICBuYXJyb3c6IHsgc2l6ZTogMCwgY291bnRzOiAwLCBtaW46IDAsIG1heDogTnVtYmVyLk1BWF9WQUxVRSB9LFxuICAgICAgICAgICAgICAgICAgICB3aWRlOiB7IHNpemU6IDAsIGNvdW50czogMCwgbWluOiAwLCBtYXg6IE51bWJlci5NQVhfVkFMVUUgfSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgbGV0IHBvcyA9IHN0YXJ0Q291bnRlcjtcbiAgICAgICAgbGV0IHBhdHRlcm46IG51bWJlcjtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlc3VsdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgcGF0dGVybiA9IHRoaXMuX2NoYXJUb1BhdHRlcm4ocmVzdWx0W2ldKTtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSA2OyBqID49IDA7IGotLSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGtpbmQgPSAoaiAmIDEpID09PSAyID8gY2F0ZWdvcml6YXRpb24uYmFyIDogY2F0ZWdvcml6YXRpb24uc3BhY2U7XG4gICAgICAgICAgICAgICAgY29uc3QgY2F0ID0gKHBhdHRlcm4gJiAxKSA9PT0gMSA/IGtpbmQud2lkZSA6IGtpbmQubmFycm93O1xuICAgICAgICAgICAgICAgIGNhdC5zaXplICs9IHRoaXMuX2NvdW50ZXJzW3BvcyArIGpdO1xuICAgICAgICAgICAgICAgIGNhdC5jb3VudHMrKztcbiAgICAgICAgICAgICAgICBwYXR0ZXJuID4+PSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcG9zICs9IDg7XG4gICAgICAgIH1cblxuICAgICAgICAoWydzcGFjZScsICdiYXInXSBhcyBjb25zdCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICBjb25zdCBuZXdraW5kID0gY2F0ZWdvcml6YXRpb25ba2V5XTtcbiAgICAgICAgICAgIG5ld2tpbmQud2lkZS5taW4gPVxuICAgICAgICAgICAgICAgIE1hdGguZmxvb3IoKG5ld2tpbmQubmFycm93LnNpemUgLyBuZXdraW5kLm5hcnJvdy5jb3VudHMgKyBuZXdraW5kLndpZGUuc2l6ZSAvIG5ld2tpbmQud2lkZS5jb3VudHMpIC8gMik7XG4gICAgICAgICAgICBuZXdraW5kLm5hcnJvdy5tYXggPSBNYXRoLmNlaWwobmV3a2luZC53aWRlLm1pbik7XG4gICAgICAgICAgICBuZXdraW5kLndpZGUubWF4ID0gTWF0aC5jZWlsKChuZXdraW5kLndpZGUuc2l6ZSAqIE1BWF9BQ0NFUFRBQkxFICsgUEFERElORykgLyBuZXdraW5kLndpZGUuY291bnRzKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIGNhdGVnb3JpemF0aW9uO1xuICAgIH07XG5cbiAgICBwcm90ZWN0ZWQgX3ZhbGlkYXRlUmVzdWx0KHJlc3VsdDogUmVhZG9ubHlBcnJheTxzdHJpbmc+LCBzdGFydENvdW50ZXI6IG51bWJlcikge1xuICAgICAgICBjb25zdCB0aHJlc2hvbGRzID0gdGhpcy5fdGhyZXNob2xkUmVzdWx0UGF0dGVybihyZXN1bHQsIHN0YXJ0Q291bnRlcik7XG4gICAgICAgIGxldCBwb3MgPSBzdGFydENvdW50ZXI7XG4gICAgICAgIGxldCBwYXR0ZXJuOiBudW1iZXI7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZXN1bHQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHBhdHRlcm4gPSB0aGlzLl9jaGFyVG9QYXR0ZXJuKHJlc3VsdFtpXSk7XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gNjsgaiA+PSAwOyBqLS0pIHtcbiAgICAgICAgICAgICAgICBjb25zdCBraW5kID0gKGogJiAxKSA9PT0gMCA/IHRocmVzaG9sZHMuYmFyIDogdGhyZXNob2xkcy5zcGFjZTtcbiAgICAgICAgICAgICAgICBjb25zdCBjYXQgPSAocGF0dGVybiAmIDEpID09PSAxID8ga2luZC53aWRlIDoga2luZC5uYXJyb3c7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2l6ZSA9IHRoaXMuX2NvdW50ZXJzW3BvcyArIGpdO1xuICAgICAgICAgICAgICAgIGlmIChzaXplIDwgY2F0Lm1pbiB8fCBzaXplID4gY2F0Lm1heCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHBhdHRlcm4gPj49IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwb3MgKz0gODtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuXG4gICAgcHVibGljIGRlY29kZShyb3c/OiBBcnJheTxudW1iZXI+LCBzdGFydD86IEJhcmNvZGVQb3NpdGlvbiB8IG51bWJlciB8IG51bGwpOiBCYXJjb2RlIHwgbnVsbCB7XG5cbiAgICAgICAgdGhpcy5fY291bnRlcnMgPSB0aGlzLl9maWxsQ291bnRlcnMoKTtcbiAgICAgICAgc3RhcnQgPSB0aGlzLl9maW5kU3RhcnQoKTtcbiAgICAgICAgaWYgKCFzdGFydCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG5leHRTdGFydCA9IHN0YXJ0LnN0YXJ0Q291bnRlciBhcyBudW1iZXI7XG5cbiAgICAgICAgY29uc3QgcmVzdWx0OiBBcnJheTxzdHJpbmc+ID0gW107XG4gICAgICAgIGxldCBwYXR0ZXJuOiBudW1iZXI7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIHBhdHRlcm4gPSB0aGlzLl90b1BhdHRlcm4obmV4dFN0YXJ0KTtcbiAgICAgICAgICAgIGlmIChwYXR0ZXJuIDwgMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZGVjb2RlZENoYXIgPSB0aGlzLl9wYXR0ZXJuVG9DaGFyKHBhdHRlcm4pO1xuICAgICAgICAgICAgaWYgKGRlY29kZWRDaGFyID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQucHVzaChkZWNvZGVkQ2hhcik7XG4gICAgICAgICAgICBuZXh0U3RhcnQgKz0gODtcbiAgICAgICAgICAgIGlmIChyZXN1bHQubGVuZ3RoID4gMSAmJiB0aGlzLl9pc1N0YXJ0RW5kKHBhdHRlcm4pKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gd2hpbGUgKG5leHRTdGFydCA8IHRoaXMuX2NvdW50ZXJzLmxlbmd0aCk7XG5cbiAgICAgICAgLy8gdmVyaWZ5IGVuZFxuICAgICAgICBpZiAoKHJlc3VsdC5sZW5ndGggLSAyKSA8IE1JTl9FTkNPREVEX0NIQVJTIHx8ICF0aGlzLl9pc1N0YXJ0RW5kKHBhdHRlcm4pKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHZlcmlmeSBlbmQgd2hpdGUgc3BhY2VcbiAgICAgICAgaWYgKCF0aGlzLl92ZXJpZnlXaGl0ZXNwYWNlKHN0YXJ0LnN0YXJ0Q291bnRlciBhcyBudW1iZXIsIG5leHRTdGFydCAtIDgpKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGhpcy5fdmFsaWRhdGVSZXN1bHQocmVzdWx0LCBzdGFydC5zdGFydENvdW50ZXIgYXMgbnVtYmVyKSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBuZXh0U3RhcnQgPSBuZXh0U3RhcnQgPiB0aGlzLl9jb3VudGVycy5sZW5ndGggPyB0aGlzLl9jb3VudGVycy5sZW5ndGggOiBuZXh0U3RhcnQ7XG4gICAgICAgIGNvbnN0IGVuZCA9IHN0YXJ0LnN0YXJ0ICsgdGhpcy5fc3VtQ291bnRlcnMoc3RhcnQuc3RhcnRDb3VudGVyIGFzIG51bWJlciwgbmV4dFN0YXJ0IC0gOCk7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNvZGU6IHJlc3VsdC5qb2luKCcnKSxcbiAgICAgICAgICAgIHN0YXJ0OiBzdGFydC5zdGFydCxcbiAgICAgICAgICAgIGVuZDogZW5kLFxuICAgICAgICAgICAgc3RhcnRJbmZvOiBzdGFydCxcbiAgICAgICAgICAgIGRlY29kZWRDb2RlczogcmVzdWx0LFxuICAgICAgICAgICAgZm9ybWF0OiB0aGlzLkZPUk1BVCwgLy8gVE9ETzogaSB0aGluayBpdCBzaG91bGQgbm90IGJlIHJlcXVpcmVkIHRvIHJldHVybiBmb3JtYXQgZnJvbSB0aGlzLCBhcyBiYXJjb2RlX3JlYWRlciBmb3JjZSBzZXRzIHRoZSBmb3JtYXQgYW55d2F5XG4gICAgICAgIH07XG4gICAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgTmV3Q29kYWJhclJlYWRlcjtcbiIsImltcG9ydCBCYXJjb2RlUmVhZGVyLCB7IEJhcmNvZGVDb3JyZWN0aW9uLCBCYXJjb2RlUG9zaXRpb24sIEJhcmNvZGUsIEJhcmNvZGVJbmZvIH0gZnJvbSAnLi9iYXJjb2RlX3JlYWRlcic7XG5cbmNsYXNzIENvZGUxMjhSZWFkZXIgZXh0ZW5kcyBCYXJjb2RlUmVhZGVyIHtcbiAgICBDT0RFX1NISUZUID0gOTg7XG4gICAgQ09ERV9DID0gOTk7XG4gICAgQ09ERV9CID0gMTAwO1xuICAgIENPREVfQSA9IDEwMTtcbiAgICBTVEFSVF9DT0RFX0EgPSAxMDM7XG4gICAgU1RBUlRfQ09ERV9CID0gMTA0O1xuICAgIFNUQVJUX0NPREVfQyA9IDEwNTtcbiAgICBTVE9QX0NPREUgPSAxMDY7XG4gICAgQ09ERV9QQVRURVJOID0gW1xuICAgICAgICAgICAgWzIsIDEsIDIsIDIsIDIsIDJdLFxuICAgICAgICAgICAgWzIsIDIsIDIsIDEsIDIsIDJdLFxuICAgICAgICAgICAgWzIsIDIsIDIsIDIsIDIsIDFdLFxuICAgICAgICAgICAgWzEsIDIsIDEsIDIsIDIsIDNdLFxuICAgICAgICAgICAgWzEsIDIsIDEsIDMsIDIsIDJdLFxuICAgICAgICAgICAgWzEsIDMsIDEsIDIsIDIsIDJdLFxuICAgICAgICAgICAgWzEsIDIsIDIsIDIsIDEsIDNdLFxuICAgICAgICAgICAgWzEsIDIsIDIsIDMsIDEsIDJdLFxuICAgICAgICAgICAgWzEsIDMsIDIsIDIsIDEsIDJdLFxuICAgICAgICAgICAgWzIsIDIsIDEsIDIsIDEsIDNdLFxuICAgICAgICAgICAgWzIsIDIsIDEsIDMsIDEsIDJdLFxuICAgICAgICAgICAgWzIsIDMsIDEsIDIsIDEsIDJdLFxuICAgICAgICAgICAgWzEsIDEsIDIsIDIsIDMsIDJdLFxuICAgICAgICAgICAgWzEsIDIsIDIsIDEsIDMsIDJdLFxuICAgICAgICAgICAgWzEsIDIsIDIsIDIsIDMsIDFdLFxuICAgICAgICAgICAgWzEsIDEsIDMsIDIsIDIsIDJdLFxuICAgICAgICAgICAgWzEsIDIsIDMsIDEsIDIsIDJdLFxuICAgICAgICAgICAgWzEsIDIsIDMsIDIsIDIsIDFdLFxuICAgICAgICAgICAgWzIsIDIsIDMsIDIsIDEsIDFdLFxuICAgICAgICAgICAgWzIsIDIsIDEsIDEsIDMsIDJdLFxuICAgICAgICAgICAgWzIsIDIsIDEsIDIsIDMsIDFdLFxuICAgICAgICAgICAgWzIsIDEsIDMsIDIsIDEsIDJdLFxuICAgICAgICAgICAgWzIsIDIsIDMsIDEsIDEsIDJdLFxuICAgICAgICAgICAgWzMsIDEsIDIsIDEsIDMsIDFdLFxuICAgICAgICAgICAgWzMsIDEsIDEsIDIsIDIsIDJdLFxuICAgICAgICAgICAgWzMsIDIsIDEsIDEsIDIsIDJdLFxuICAgICAgICAgICAgWzMsIDIsIDEsIDIsIDIsIDFdLFxuICAgICAgICAgICAgWzMsIDEsIDIsIDIsIDEsIDJdLFxuICAgICAgICAgICAgWzMsIDIsIDIsIDEsIDEsIDJdLFxuICAgICAgICAgICAgWzMsIDIsIDIsIDIsIDEsIDFdLFxuICAgICAgICAgICAgWzIsIDEsIDIsIDEsIDIsIDNdLFxuICAgICAgICAgICAgWzIsIDEsIDIsIDMsIDIsIDFdLFxuICAgICAgICAgICAgWzIsIDMsIDIsIDEsIDIsIDFdLFxuICAgICAgICAgICAgWzEsIDEsIDEsIDMsIDIsIDNdLFxuICAgICAgICAgICAgWzEsIDMsIDEsIDEsIDIsIDNdLFxuICAgICAgICAgICAgWzEsIDMsIDEsIDMsIDIsIDFdLFxuICAgICAgICAgICAgWzEsIDEsIDIsIDMsIDEsIDNdLFxuICAgICAgICAgICAgWzEsIDMsIDIsIDEsIDEsIDNdLFxuICAgICAgICAgICAgWzEsIDMsIDIsIDMsIDEsIDFdLFxuICAgICAgICAgICAgWzIsIDEsIDEsIDMsIDEsIDNdLFxuICAgICAgICAgICAgWzIsIDMsIDEsIDEsIDEsIDNdLFxuICAgICAgICAgICAgWzIsIDMsIDEsIDMsIDEsIDFdLFxuICAgICAgICAgICAgWzEsIDEsIDIsIDEsIDMsIDNdLFxuICAgICAgICAgICAgWzEsIDEsIDIsIDMsIDMsIDFdLFxuICAgICAgICAgICAgWzEsIDMsIDIsIDEsIDMsIDFdLFxuICAgICAgICAgICAgWzEsIDEsIDMsIDEsIDIsIDNdLFxuICAgICAgICAgICAgWzEsIDEsIDMsIDMsIDIsIDFdLFxuICAgICAgICAgICAgWzEsIDMsIDMsIDEsIDIsIDFdLFxuICAgICAgICAgICAgWzMsIDEsIDMsIDEsIDIsIDFdLFxuICAgICAgICAgICAgWzIsIDEsIDEsIDMsIDMsIDFdLFxuICAgICAgICAgICAgWzIsIDMsIDEsIDEsIDMsIDFdLFxuICAgICAgICAgICAgWzIsIDEsIDMsIDEsIDEsIDNdLFxuICAgICAgICAgICAgWzIsIDEsIDMsIDMsIDEsIDFdLFxuICAgICAgICAgICAgWzIsIDEsIDMsIDEsIDMsIDFdLFxuICAgICAgICAgICAgWzMsIDEsIDEsIDEsIDIsIDNdLFxuICAgICAgICAgICAgWzMsIDEsIDEsIDMsIDIsIDFdLFxuICAgICAgICAgICAgWzMsIDMsIDEsIDEsIDIsIDFdLFxuICAgICAgICAgICAgWzMsIDEsIDIsIDEsIDEsIDNdLFxuICAgICAgICAgICAgWzMsIDEsIDIsIDMsIDEsIDFdLFxuICAgICAgICAgICAgWzMsIDMsIDIsIDEsIDEsIDFdLFxuICAgICAgICAgICAgWzMsIDEsIDQsIDEsIDEsIDFdLFxuICAgICAgICAgICAgWzIsIDIsIDEsIDQsIDEsIDFdLFxuICAgICAgICAgICAgWzQsIDMsIDEsIDEsIDEsIDFdLFxuICAgICAgICAgICAgWzEsIDEsIDEsIDIsIDIsIDRdLFxuICAgICAgICAgICAgWzEsIDEsIDEsIDQsIDIsIDJdLFxuICAgICAgICAgICAgWzEsIDIsIDEsIDEsIDIsIDRdLFxuICAgICAgICAgICAgWzEsIDIsIDEsIDQsIDIsIDFdLFxuICAgICAgICAgICAgWzEsIDQsIDEsIDEsIDIsIDJdLFxuICAgICAgICAgICAgWzEsIDQsIDEsIDIsIDIsIDFdLFxuICAgICAgICAgICAgWzEsIDEsIDIsIDIsIDEsIDRdLFxuICAgICAgICAgICAgWzEsIDEsIDIsIDQsIDEsIDJdLFxuICAgICAgICAgICAgWzEsIDIsIDIsIDEsIDEsIDRdLFxuICAgICAgICAgICAgWzEsIDIsIDIsIDQsIDEsIDFdLFxuICAgICAgICAgICAgWzEsIDQsIDIsIDEsIDEsIDJdLFxuICAgICAgICAgICAgWzEsIDQsIDIsIDIsIDEsIDFdLFxuICAgICAgICAgICAgWzIsIDQsIDEsIDIsIDEsIDFdLFxuICAgICAgICAgICAgWzIsIDIsIDEsIDEsIDEsIDRdLFxuICAgICAgICAgICAgWzQsIDEsIDMsIDEsIDEsIDFdLFxuICAgICAgICAgICAgWzIsIDQsIDEsIDEsIDEsIDJdLFxuICAgICAgICAgICAgWzEsIDMsIDQsIDEsIDEsIDFdLFxuICAgICAgICAgICAgWzEsIDEsIDEsIDIsIDQsIDJdLFxuICAgICAgICAgICAgWzEsIDIsIDEsIDEsIDQsIDJdLFxuICAgICAgICAgICAgWzEsIDIsIDEsIDIsIDQsIDFdLFxuICAgICAgICAgICAgWzEsIDEsIDQsIDIsIDEsIDJdLFxuICAgICAgICAgICAgWzEsIDIsIDQsIDEsIDEsIDJdLFxuICAgICAgICAgICAgWzEsIDIsIDQsIDIsIDEsIDFdLFxuICAgICAgICAgICAgWzQsIDEsIDEsIDIsIDEsIDJdLFxuICAgICAgICAgICAgWzQsIDIsIDEsIDEsIDEsIDJdLFxuICAgICAgICAgICAgWzQsIDIsIDEsIDIsIDEsIDFdLFxuICAgICAgICAgICAgWzIsIDEsIDIsIDEsIDQsIDFdLFxuICAgICAgICAgICAgWzIsIDEsIDQsIDEsIDIsIDFdLFxuICAgICAgICAgICAgWzQsIDEsIDIsIDEsIDIsIDFdLFxuICAgICAgICAgICAgWzEsIDEsIDEsIDEsIDQsIDNdLFxuICAgICAgICAgICAgWzEsIDEsIDEsIDMsIDQsIDFdLFxuICAgICAgICAgICAgWzEsIDMsIDEsIDEsIDQsIDFdLFxuICAgICAgICAgICAgWzEsIDEsIDQsIDEsIDEsIDNdLFxuICAgICAgICAgICAgWzEsIDEsIDQsIDMsIDEsIDFdLFxuICAgICAgICAgICAgWzQsIDEsIDEsIDEsIDEsIDNdLFxuICAgICAgICAgICAgWzQsIDEsIDEsIDMsIDEsIDFdLFxuICAgICAgICAgICAgWzEsIDEsIDMsIDEsIDQsIDFdLFxuICAgICAgICAgICAgWzEsIDEsIDQsIDEsIDMsIDFdLFxuICAgICAgICAgICAgWzMsIDEsIDEsIDEsIDQsIDFdLFxuICAgICAgICAgICAgWzQsIDEsIDEsIDEsIDMsIDFdLFxuICAgICAgICAgICAgWzIsIDEsIDEsIDQsIDEsIDJdLFxuICAgICAgICAgICAgWzIsIDEsIDEsIDIsIDEsIDRdLFxuICAgICAgICAgICAgWzIsIDEsIDEsIDIsIDMsIDJdLFxuICAgICAgICAgICAgWzIsIDMsIDMsIDEsIDEsIDEsIDJdLFxuICAgICAgICBdO1xuICAgIFNJTkdMRV9DT0RFX0VSUk9SID0gMC42NDtcbiAgICBBVkdfQ09ERV9FUlJPUiA9IDAuMzA7XG4gICAgRk9STUFUID0gJ2NvZGVfMTI4JztcbiAgICBNT0RVTEVfSU5ESUNFUyA9IHsgYmFyOiBbMCwgMiwgNF0sIHNwYWNlOiBbMSwgMywgNV0gfTtcblxuICAgIHByb3RlY3RlZCBfZGVjb2RlQ29kZShzdGFydDogbnVtYmVyLCBjb3JyZWN0aW9uPzogQmFyY29kZUNvcnJlY3Rpb24pOiBCYXJjb2RlSW5mbyB8IG51bGwge1xuICAgICAgICBjb25zdCBiZXN0TWF0Y2ggPSB7XG4gICAgICAgICAgICBlcnJvcjogTnVtYmVyLk1BWF9WQUxVRSxcbiAgICAgICAgICAgIGNvZGU6IC0xLFxuICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0LFxuICAgICAgICAgICAgZW5kOiBzdGFydCxcbiAgICAgICAgICAgIGNvcnJlY3Rpb246IHtcbiAgICAgICAgICAgICAgICBiYXI6IDEsXG4gICAgICAgICAgICAgICAgc3BhY2U6IDEsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgICAgICBsZXQgY291bnRlciA9IFswLCAwLCAwLCAwLCAwLCAwXTtcbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gc3RhcnQ7XG4gICAgICAgIGxldCBpc1doaXRlID0gIXRoaXMuX3Jvd1tvZmZzZXRdO1xuICAgICAgICBsZXQgY291bnRlclBvcyA9IDA7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IG9mZnNldDsgaSA8IHRoaXMuX3Jvdy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3Jvd1tpXSBeIChpc1doaXRlID8gMSA6IDApKSB7XG4gICAgICAgICAgICAgICAgY291bnRlcltjb3VudGVyUG9zXSsrO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoY291bnRlclBvcyA9PT0gY291bnRlci5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb3JyZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9jb3JyZWN0KGNvdW50ZXIsIGNvcnJlY3Rpb24pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGNvZGUgPSAwOyBjb2RlIDwgdGhpcy5DT0RFX1BBVFRFUk4ubGVuZ3RoOyBjb2RlKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yID0gdGhpcy5fbWF0Y2hQYXR0ZXJuKGNvdW50ZXIsIHRoaXMuQ09ERV9QQVRURVJOW2NvZGVdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnJvciA8IGJlc3RNYXRjaC5lcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJlc3RNYXRjaC5jb2RlID0gY29kZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiZXN0TWF0Y2guZXJyb3IgPSBlcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBiZXN0TWF0Y2guZW5kID0gaTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJlc3RNYXRjaC5jb2RlID09PSAtMSB8fCBiZXN0TWF0Y2guZXJyb3IgPiB0aGlzLkFWR19DT0RFX0VSUk9SKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5DT0RFX1BBVFRFUk5bYmVzdE1hdGNoLmNvZGVdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBiZXN0TWF0Y2guY29ycmVjdGlvbi5iYXIgPSB0aGlzLmNhbGN1bGF0ZUNvcnJlY3Rpb24oXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5DT0RFX1BBVFRFUk5bYmVzdE1hdGNoLmNvZGVdLCBjb3VudGVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuTU9EVUxFX0lORElDRVMuYmFyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJlc3RNYXRjaC5jb3JyZWN0aW9uLnNwYWNlID0gdGhpcy5jYWxjdWxhdGVDb3JyZWN0aW9uKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuQ09ERV9QQVRURVJOW2Jlc3RNYXRjaC5jb2RlXSwgY291bnRlcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLk1PRFVMRV9JTkRJQ0VTLnNwYWNlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYmVzdE1hdGNoO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvdW50ZXJQb3MrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY291bnRlcltjb3VudGVyUG9zXSA9IDE7XG4gICAgICAgICAgICAgICAgaXNXaGl0ZSA9ICFpc1doaXRlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG5cbiAgICBwcm90ZWN0ZWQgX2NvcnJlY3QoY291bnRlcjogQXJyYXk8bnVtYmVyPiwgY29ycmVjdGlvbjogQmFyY29kZUNvcnJlY3Rpb24pIHtcbiAgICAgICAgdGhpcy5fY29ycmVjdEJhcnMoY291bnRlciwgY29ycmVjdGlvbi5iYXIsIHRoaXMuTU9EVUxFX0lORElDRVMuYmFyKTtcbiAgICAgICAgdGhpcy5fY29ycmVjdEJhcnMoY291bnRlciwgY29ycmVjdGlvbi5zcGFjZSwgdGhpcy5NT0RVTEVfSU5ESUNFUy5zcGFjZSk7XG4gICAgfTtcblxuICAgIC8vIFRPRE86IF9maW5kU3RhcnQgYW5kIGRlY29kZUNvZGUgc2hhcmUgc2ltaWxhciBjb2RlLCBjYW4gd2UgcmUtdXNlIHNvbWU/XG4gICAgcHJvdGVjdGVkIF9maW5kU3RhcnQoKTogQmFyY29kZUluZm8gfCBudWxsIHtcbiAgICAgICAgY29uc3QgY291bnRlciA9IFswLCAwLCAwLCAwLCAwLCAwXTtcbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gdGhpcy5fbmV4dFNldCh0aGlzLl9yb3cpO1xuICAgICAgICBjb25zdCBiZXN0TWF0Y2ggPSB7XG4gICAgICAgICAgICBlcnJvcjogTnVtYmVyLk1BWF9WQUxVRSxcbiAgICAgICAgICAgIGNvZGU6IC0xLFxuICAgICAgICAgICAgc3RhcnQ6IDAsXG4gICAgICAgICAgICBlbmQ6IDAsXG4gICAgICAgICAgICBjb3JyZWN0aW9uOiB7XG4gICAgICAgICAgICAgICAgYmFyOiAxLFxuICAgICAgICAgICAgICAgIHNwYWNlOiAxLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICAgICAgbGV0IGlzV2hpdGUgPSBmYWxzZTtcbiAgICAgICAgbGV0IGNvdW50ZXJQb3MgPSAwO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSBvZmZzZXQ7IGkgPCB0aGlzLl9yb3cubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9yb3dbaV0gXiAoaXNXaGl0ZSA/IDEgOiAwKSkge1xuICAgICAgICAgICAgICAgIGNvdW50ZXJbY291bnRlclBvc10rKztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvdW50ZXJQb3MgPT09IGNvdW50ZXIubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzdW0gPSBjb3VudGVyLnJlZHVjZSgocHJldiwgbmV4dCkgPT4gcHJldiArIG5leHQsIDApO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBjb2RlID0gdGhpcy5TVEFSVF9DT0RFX0E7IGNvZGUgPD0gdGhpcy5TVEFSVF9DT0RFX0M7IGNvZGUrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZXJyb3IgPSB0aGlzLl9tYXRjaFBhdHRlcm4oY291bnRlciwgdGhpcy5DT0RFX1BBVFRFUk5bY29kZV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yIDwgYmVzdE1hdGNoLmVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYmVzdE1hdGNoLmNvZGUgPSBjb2RlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJlc3RNYXRjaC5lcnJvciA9IGVycm9yO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChiZXN0TWF0Y2guZXJyb3IgPCB0aGlzLkFWR19DT0RFX0VSUk9SKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBiZXN0TWF0Y2guc3RhcnQgPSBpIC0gc3VtO1xuICAgICAgICAgICAgICAgICAgICAgICAgYmVzdE1hdGNoLmVuZCA9IGk7XG4gICAgICAgICAgICAgICAgICAgICAgICBiZXN0TWF0Y2guY29ycmVjdGlvbi5iYXIgPSB0aGlzLmNhbGN1bGF0ZUNvcnJlY3Rpb24oXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5DT0RFX1BBVFRFUk5bYmVzdE1hdGNoLmNvZGVdLCBjb3VudGVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuTU9EVUxFX0lORElDRVMuYmFyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJlc3RNYXRjaC5jb3JyZWN0aW9uLnNwYWNlID0gdGhpcy5jYWxjdWxhdGVDb3JyZWN0aW9uKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuQ09ERV9QQVRURVJOW2Jlc3RNYXRjaC5jb2RlXSwgY291bnRlcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLk1PRFVMRV9JTkRJQ0VTLnNwYWNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBiZXN0TWF0Y2g7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IDQ7IGorKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY291bnRlcltqXSA9IGNvdW50ZXJbaiArIDJdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvdW50ZXJbNF0gPSAwO1xuICAgICAgICAgICAgICAgICAgICBjb3VudGVyWzVdID0gMDtcbiAgICAgICAgICAgICAgICAgICAgY291bnRlclBvcy0tO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvdW50ZXJQb3MrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY291bnRlcltjb3VudGVyUG9zXSA9IDE7XG4gICAgICAgICAgICAgICAgaXNXaGl0ZSA9ICFpc1doaXRlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG5cbiAgICBwdWJsaWMgZGVjb2RlKHJvdz86IEFycmF5PG51bWJlcj4sIHN0YXJ0PzogQmFyY29kZVBvc2l0aW9uKTogQmFyY29kZSB8IG51bGwge1xuICAgICAgICBjb25zdCBzdGFydEluZm8gPSB0aGlzLl9maW5kU3RhcnQoKTtcbiAgICAgICAgaWYgKHN0YXJ0SW5mbyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgLy8gdmFyIHNlbGYgPSB0aGlzLFxuICAgICAgICAvLyAgICAgZG9uZSA9IGZhbHNlLFxuICAgICAgICAvLyAgICAgcmVzdWx0ID0gW10sXG4gICAgICAgIC8vICAgICBtdWx0aXBsaWVyID0gMCxcbiAgICAgICAgLy8gICAgIGNoZWNrc3VtID0gMCxcbiAgICAgICAgLy8gICAgIGNvZGVzZXQsXG4gICAgICAgIC8vICAgICByYXdSZXN1bHQgPSBbXSxcbiAgICAgICAgLy8gICAgIGRlY29kZWRDb2RlcyA9IFtdLFxuICAgICAgICAvLyAgICAgc2hpZnROZXh0ID0gZmFsc2UsXG4gICAgICAgIC8vICAgICB1bnNoaWZ0LFxuICAgICAgICAvLyAgICAgcmVtb3ZlTGFzdENoYXJhY3RlciA9IHRydWU7XG5cbiAgICAgICAgbGV0IGNvZGU6IEJhcmNvZGVJbmZvIHwgbnVsbCA9IHtcbiAgICAgICAgICAgIGNvZGU6IHN0YXJ0SW5mby5jb2RlLFxuICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0SW5mby5zdGFydCxcbiAgICAgICAgICAgIGVuZDogc3RhcnRJbmZvLmVuZCxcbiAgICAgICAgICAgIGNvcnJlY3Rpb246IHtcbiAgICAgICAgICAgICAgICBiYXI6IHN0YXJ0SW5mby5jb3JyZWN0aW9uIS5iYXIsXG4gICAgICAgICAgICAgICAgc3BhY2U6IHN0YXJ0SW5mby5jb3JyZWN0aW9uIS5zcGFjZSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGRlY29kZWRDb2RlcyA9IFtdO1xuICAgICAgICBkZWNvZGVkQ29kZXMucHVzaChjb2RlKTtcbiAgICAgICAgbGV0IGNoZWNrc3VtID0gY29kZS5jb2RlO1xuICAgICAgICBsZXQgY29kZXNldCA9ICgoYzogbnVtYmVyKSA9PiB7XG4gICAgICAgICAgICBzd2l0Y2ggKGMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIHRoaXMuU1RBUlRfQ09ERV9BOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5DT0RFX0E7XG4gICAgICAgICAgICAgICAgY2FzZSB0aGlzLlNUQVJUX0NPREVfQjpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuQ09ERV9CO1xuICAgICAgICAgICAgICAgIGNhc2UgdGhpcy5TVEFSVF9DT0RFX0M6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLkNPREVfQztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkoY29kZS5jb2RlKTtcbiAgICAgICAgbGV0IGRvbmUgPSBmYWxzZTtcbiAgICAgICAgbGV0IHNoaWZ0TmV4dCA9IGZhbHNlO1xuICAgICAgICBsZXQgdW5zaGlmdCA9IHNoaWZ0TmV4dDtcbiAgICAgICAgbGV0IHJlbW92ZUxhc3RDaGFyYWN0ZXIgPSB0cnVlO1xuICAgICAgICBsZXQgbXVsdGlwbGllciA9IDA7XG4gICAgICAgIGxldCByYXdSZXN1bHQ6IEFycmF5PG51bWJlcj4gPSBbXTtcbiAgICAgICAgbGV0IHJlc3VsdDogQXJyYXk8c3RyaW5nIHwgbnVtYmVyPiA9IFtdOyAvLyBUT0RPOiBpIHRoaW5rIHRoaXMgc2hvdWxkIGJlIHN0cmluZyBvbmx5LCBidXQgaXQgY3JlYXRlcyBwcm9ibGVtcyBpZiBpdCBpc1xuXG4gICAgICAgIHdoaWxlICghZG9uZSkge1xuICAgICAgICAgICAgdW5zaGlmdCA9IHNoaWZ0TmV4dDtcbiAgICAgICAgICAgIHNoaWZ0TmV4dCA9IGZhbHNlO1xuICAgICAgICAgICAgY29kZSA9IHRoaXMuX2RlY29kZUNvZGUoY29kZSEuZW5kLCBjb2RlIS5jb3JyZWN0aW9uKTtcbiAgICAgICAgICAgIGlmIChjb2RlICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvZGUuY29kZSAhPT0gdGhpcy5TVE9QX0NPREUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlTGFzdENoYXJhY3RlciA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGNvZGUuY29kZSAhPT0gdGhpcy5TVE9QX0NPREUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmF3UmVzdWx0LnB1c2goY29kZS5jb2RlKTtcbiAgICAgICAgICAgICAgICAgICAgbXVsdGlwbGllcisrO1xuICAgICAgICAgICAgICAgICAgICBjaGVja3N1bSArPSBtdWx0aXBsaWVyICogY29kZS5jb2RlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkZWNvZGVkQ29kZXMucHVzaChjb2RlKTtcblxuICAgICAgICAgICAgICAgIHN3aXRjaCAoY29kZXNldCkge1xuICAgICAgICAgICAgICAgIGNhc2UgdGhpcy5DT0RFX0E6XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb2RlLmNvZGUgPCA2NCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZSgzMiArIGNvZGUuY29kZSkpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNvZGUuY29kZSA8IDk2KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUuY29kZSAtIDY0KSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29kZS5jb2RlICE9PSB0aGlzLlNUT1BfQ09ERSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZUxhc3RDaGFyYWN0ZXIgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoY29kZS5jb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIHRoaXMuQ09ERV9TSElGVDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaGlmdE5leHQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGVzZXQgPSB0aGlzLkNPREVfQjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgdGhpcy5DT0RFX0I6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZXNldCA9IHRoaXMuQ09ERV9CO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSB0aGlzLkNPREVfQzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2Rlc2V0ID0gdGhpcy5DT0RFX0M7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIHRoaXMuU1RPUF9DT0RFOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvbmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgdGhpcy5DT0RFX0I6XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb2RlLmNvZGUgPCA5Nikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZSgzMiArIGNvZGUuY29kZSkpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvZGUuY29kZSAhPT0gdGhpcy5TVE9QX0NPREUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW1vdmVMYXN0Q2hhcmFjdGVyID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGNvZGUuY29kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgdGhpcy5DT0RFX1NISUZUOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaGlmdE5leHQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2Rlc2V0ID0gdGhpcy5DT0RFX0E7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgdGhpcy5DT0RFX0E6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGVzZXQgPSB0aGlzLkNPREVfQTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSB0aGlzLkNPREVfQzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZXNldCA9IHRoaXMuQ09ERV9DO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIHRoaXMuU1RPUF9DT0RFOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb25lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSB0aGlzLkNPREVfQzpcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvZGUuY29kZSA8IDEwMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goY29kZS5jb2RlIDwgMTAgPyAnMCcgKyBjb2RlLmNvZGUgOiBjb2RlLmNvZGUpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvZGUuY29kZSAhPT0gdGhpcy5TVE9QX0NPREUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW1vdmVMYXN0Q2hhcmFjdGVyID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGNvZGUuY29kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSB0aGlzLkNPREVfQTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2Rlc2V0ID0gdGhpcy5DT0RFX0E7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIHRoaXMuQ09ERV9COlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGVzZXQgPSB0aGlzLkNPREVfQjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgdGhpcy5TVE9QX0NPREU6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9uZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBkb25lID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh1bnNoaWZ0KSB7XG4gICAgICAgICAgICAgICAgY29kZXNldCA9IGNvZGVzZXQgPT09IHRoaXMuQ09ERV9BID8gdGhpcy5DT0RFX0IgOiB0aGlzLkNPREVfQTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjb2RlID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvZGUuZW5kID0gdGhpcy5fbmV4dFVuc2V0KHRoaXMuX3JvdywgY29kZS5lbmQpO1xuICAgICAgICBpZiAoIXRoaXMuX3ZlcmlmeVRyYWlsaW5nV2hpdGVzcGFjZShjb2RlKSl7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGNoZWNrc3VtIC09IG11bHRpcGxpZXIgKiByYXdSZXN1bHRbcmF3UmVzdWx0Lmxlbmd0aCAtIDFdO1xuICAgICAgICBpZiAoY2hlY2tzdW0gJSAxMDMgIT09IHJhd1Jlc3VsdFtyYXdSZXN1bHQubGVuZ3RoIC0gMV0pIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFyZXN1bHQubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHJlbW92ZSBsYXN0IGNvZGUgZnJvbSByZXN1bHQgKGNoZWNrc3VtKVxuICAgICAgICBpZiAocmVtb3ZlTGFzdENoYXJhY3Rlcikge1xuICAgICAgICAgICAgcmVzdWx0LnNwbGljZShyZXN1bHQubGVuZ3RoIC0gMSwgMSk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjb2RlOiByZXN1bHQuam9pbignJyksXG4gICAgICAgICAgICBzdGFydDogc3RhcnRJbmZvLnN0YXJ0LFxuICAgICAgICAgICAgZW5kOiBjb2RlLmVuZCxcbiAgICAgICAgICAgIGNvZGVzZXQ6IGNvZGVzZXQgYXMgbnVtYmVyLFxuICAgICAgICAgICAgc3RhcnRJbmZvOiBzdGFydEluZm8sXG4gICAgICAgICAgICBkZWNvZGVkQ29kZXM6IGRlY29kZWRDb2RlcyxcbiAgICAgICAgICAgIGVuZEluZm86IGNvZGUsXG4gICAgICAgICAgICBmb3JtYXQ6IHRoaXMuRk9STUFULFxuICAgICAgICB9O1xuICAgIH07XG5cbiAgICBwcm90ZWN0ZWQgX3ZlcmlmeVRyYWlsaW5nV2hpdGVzcGFjZShlbmRJbmZvOiBCYXJjb2RlSW5mbyk6IEJhcmNvZGVJbmZvIHwgbnVsbCB7XG5cbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzLFxuICAgICAgICAgICAgdHJhaWxpbmdXaGl0ZXNwYWNlRW5kO1xuXG4gICAgICAgIHRyYWlsaW5nV2hpdGVzcGFjZUVuZCA9IGVuZEluZm8uZW5kICsgKChlbmRJbmZvLmVuZCAtIGVuZEluZm8uc3RhcnQpIC8gMik7XG4gICAgICAgIGlmICh0cmFpbGluZ1doaXRlc3BhY2VFbmQgPCBzZWxmLl9yb3cubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoc2VsZi5fbWF0Y2hSYW5nZShlbmRJbmZvLmVuZCwgdHJhaWxpbmdXaGl0ZXNwYWNlRW5kLCAwKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBlbmRJbmZvO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG5cblxuICAgIHB1YmxpYyBjYWxjdWxhdGVDb3JyZWN0aW9uKGV4cGVjdGVkOiBSZWFkb25seUFycmF5PG51bWJlcj4sIG5vcm1hbGl6ZWQ6IFJlYWRvbmx5QXJyYXk8bnVtYmVyPiwgaW5kaWNlczogUmVhZG9ubHlBcnJheTxudW1iZXI+KTogbnVtYmVyIHtcbiAgICAgICAgdmFyIGxlbmd0aCA9IGluZGljZXMubGVuZ3RoLFxuICAgICAgICAgICAgc3VtTm9ybWFsaXplZCA9IDAsXG4gICAgICAgICAgICBzdW1FeHBlY3RlZCA9IDA7XG5cbiAgICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgICAgICBzdW1FeHBlY3RlZCArPSBleHBlY3RlZFtpbmRpY2VzW2xlbmd0aF1dO1xuICAgICAgICAgICAgc3VtTm9ybWFsaXplZCArPSBub3JtYWxpemVkW2luZGljZXNbbGVuZ3RoXV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN1bUV4cGVjdGVkIC8gc3VtTm9ybWFsaXplZDtcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IENvZGUxMjhSZWFkZXI7XG4iLCIvKiBlc2xpbnQtZGlzYWJsZSBjbGFzcy1tZXRob2RzLXVzZS10aGlzICovXG5pbXBvcnQgQXJyYXlIZWxwZXIgZnJvbSAnLi4vY29tbW9uL2FycmF5X2hlbHBlcic7XG5pbXBvcnQgQmFyY29kZVJlYWRlciwgeyB0eXBlIEJhcmNvZGVQb3NpdGlvbiwgdHlwZSBCYXJjb2RlIH0gZnJvbSAnLi9iYXJjb2RlX3JlYWRlcic7XG5cbmNvbnN0IEFMUEhBQkVUSF9TVFJJTkcgPSAnMDEyMzQ1Njc4OUFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaLS4gKiQvKyUnO1xuY29uc3QgQUxQSEFCRVQgPSBuZXcgVWludDE2QXJyYXkoWy4uLkFMUEhBQkVUSF9TVFJJTkddLm1hcCgoY2hhcikgPT4gY2hhci5jaGFyQ29kZUF0KDApKSk7XG5jb25zdCBDSEFSQUNURVJfRU5DT0RJTkdTID0gbmV3IFVpbnQxNkFycmF5KFtcbiAgICAweDAzNCwgMHgxMjEsIDB4MDYxLCAweDE2MCwgMHgwMzEsIDB4MTMwLCAweDA3MCwgMHgwMjUsIDB4MTI0LCAweDA2NCwgMHgxMDksIDB4MDQ5LFxuICAgIDB4MTQ4LCAweDAxOSwgMHgxMTgsIDB4MDU4LCAweDAwRCwgMHgxMEMsIDB4MDRDLCAweDAxQywgMHgxMDMsIDB4MDQzLCAweDE0MiwgMHgwMTMsIDB4MTEyLCAweDA1MiwgMHgwMDcsIDB4MTA2LFxuICAgIDB4MDQ2LCAweDAxNiwgMHgxODEsIDB4MEMxLCAweDFDMCwgMHgwOTEsIDB4MTkwLCAweDBEMCwgMHgwODUsIDB4MTg0LCAweDBDNCwgMHgwOTQsIDB4MEE4LCAweDBBMiwgMHgwOEEsIDB4MDJBLFxuXSk7XG5jb25zdCBBU1RFUklTSyA9IDB4MDk0O1xuXG5jbGFzcyBDb2RlMzlSZWFkZXIgZXh0ZW5kcyBCYXJjb2RlUmVhZGVyIHtcbiAgICBGT1JNQVQgPSAnY29kZV8zOSc7XG5cbiAgICBwcm90ZWN0ZWQgX2ZpbmRTdGFydCgpOiBCYXJjb2RlUG9zaXRpb24gfCBudWxsIHtcbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gdGhpcy5fbmV4dFNldCh0aGlzLl9yb3cpO1xuICAgICAgICBsZXQgcGF0dGVyblN0YXJ0ID0gb2Zmc2V0O1xuICAgICAgICBjb25zdCBjb3VudGVyID0gbmV3IFVpbnQxNkFycmF5KFswLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwXSk7XG4gICAgICAgIGxldCBjb3VudGVyUG9zID0gMDtcbiAgICAgICAgbGV0IGlzV2hpdGUgPSBmYWxzZTtcblxuICAgICAgICBmb3IgKGxldCBpID0gb2Zmc2V0OyBpIDwgdGhpcy5fcm93Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tYml0d2lzZVxuICAgICAgICAgICAgaWYgKHRoaXMuX3Jvd1tpXSBeIChpc1doaXRlID8gMSA6IDApKSB7XG4gICAgICAgICAgICAgICAgY291bnRlcltjb3VudGVyUG9zXSsrO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoY291bnRlclBvcyA9PT0gY291bnRlci5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGZpbmQgc3RhcnQgcGF0dGVyblxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fdG9QYXR0ZXJuKGNvdW50ZXIpID09PSBBU1RFUklTSykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgd2hpdGVTcGFjZU11c3RTdGFydCA9IE1hdGguZmxvb3IoTWF0aC5tYXgoMCwgcGF0dGVyblN0YXJ0IC0gKChpIC0gcGF0dGVyblN0YXJ0KSAvIDQpKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fbWF0Y2hSYW5nZSh3aGl0ZVNwYWNlTXVzdFN0YXJ0LCBwYXR0ZXJuU3RhcnQsIDApKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IHBhdHRlcm5TdGFydCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kOiBpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBwYXR0ZXJuU3RhcnQgKz0gY291bnRlclswXSArIGNvdW50ZXJbMV07XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgNzsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb3VudGVyW2pdID0gY291bnRlcltqICsgMl07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY291bnRlcls3XSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGNvdW50ZXJbOF0gPSAwO1xuICAgICAgICAgICAgICAgICAgICBjb3VudGVyUG9zLS07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY291bnRlclBvcysrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb3VudGVyW2NvdW50ZXJQb3NdID0gMTtcbiAgICAgICAgICAgICAgICBpc1doaXRlID0gIWlzV2hpdGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIF90b1BhdHRlcm4oY291bnRlcnM6IFVpbnQxNkFycmF5KTogbnVtYmVyIHtcbiAgICAgICAgY29uc3QgbnVtQ291bnRlcnMgPSBjb3VudGVycy5sZW5ndGg7XG4gICAgICAgIGxldCBtYXhOYXJyb3dXaWR0aCA9IDA7XG4gICAgICAgIGxldCBudW1XaWRlQmFycyA9IG51bUNvdW50ZXJzO1xuICAgICAgICBsZXQgd2lkZUJhcldpZHRoID0gMDtcblxuICAgICAgICB3aGlsZSAobnVtV2lkZUJhcnMgPiAzKSB7XG4gICAgICAgICAgICBtYXhOYXJyb3dXaWR0aCA9IHRoaXMuX2ZpbmROZXh0V2lkdGgoY291bnRlcnMsIG1heE5hcnJvd1dpZHRoKTtcbiAgICAgICAgICAgIG51bVdpZGVCYXJzID0gMDtcbiAgICAgICAgICAgIGxldCBwYXR0ZXJuID0gMDtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtQ291bnRlcnM7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChjb3VudGVyc1tpXSA+IG1heE5hcnJvd1dpZHRoKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1iaXR3aXNlXG4gICAgICAgICAgICAgICAgICAgIHBhdHRlcm4gfD0gMSA8PCAobnVtQ291bnRlcnMgLSAxIC0gaSk7XG4gICAgICAgICAgICAgICAgICAgIG51bVdpZGVCYXJzKys7XG4gICAgICAgICAgICAgICAgICAgIHdpZGVCYXJXaWR0aCArPSBjb3VudGVyc1tpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChudW1XaWRlQmFycyA9PT0gMykge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtQ291bnRlcnMgJiYgbnVtV2lkZUJhcnMgPiAwOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvdW50ZXJzW2ldID4gbWF4TmFycm93V2lkdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG51bVdpZGVCYXJzLS07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKGNvdW50ZXJzW2ldICogMikgPj0gd2lkZUJhcldpZHRoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBwYXR0ZXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAtMTtcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgX2ZpbmROZXh0V2lkdGgoY291bnRlcnM6IFVpbnQxNkFycmF5LCBjdXJyZW50OiBudW1iZXIpOiBudW1iZXIge1xuICAgICAgICBsZXQgbWluV2lkdGggPSBOdW1iZXIuTUFYX1ZBTFVFO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY291bnRlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChjb3VudGVyc1tpXSA8IG1pbldpZHRoICYmIGNvdW50ZXJzW2ldID4gY3VycmVudCkge1xuICAgICAgICAgICAgICAgIG1pbldpZHRoID0gY291bnRlcnNbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbWluV2lkdGg7XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIF9wYXR0ZXJuVG9DaGFyKHBhdHRlcm46IG51bWJlcik6IHN0cmluZyB8IG51bGwge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IENIQVJBQ1RFUl9FTkNPRElOR1MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChDSEFSQUNURVJfRU5DT0RJTkdTW2ldID09PSBwYXR0ZXJuKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoQUxQSEFCRVRbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHByb3RlY3RlZCBfdmVyaWZ5VHJhaWxpbmdXaGl0ZXNwYWNlKGxhc3RTdGFydDogbnVtYmVyLCBuZXh0U3RhcnQ6IG51bWJlciwgY291bnRlcnM6IFVpbnQxNkFycmF5KTogYm9vbGVhbiB7XG4gICAgICAgIGNvbnN0IHBhdHRlcm5TaXplID0gQXJyYXlIZWxwZXIuc3VtKGNvdW50ZXJzKTtcblxuICAgICAgICBjb25zdCB0cmFpbGluZ1doaXRlc3BhY2VFbmQgPSBuZXh0U3RhcnQgLSBsYXN0U3RhcnQgLSBwYXR0ZXJuU2l6ZTtcbiAgICAgICAgaWYgKCh0cmFpbGluZ1doaXRlc3BhY2VFbmQgKiAzKSA+PSBwYXR0ZXJuU2l6ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHB1YmxpYyBkZWNvZGUoKTogQmFyY29kZSB8IG51bGwge1xuICAgICAgICBsZXQgY291bnRlcnMgPSBuZXcgVWludDE2QXJyYXkoWzAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDBdKTtcbiAgICAgICAgY29uc3QgcmVzdWx0OiBBcnJheTxzdHJpbmc+ID0gW107XG4gICAgICAgIGNvbnN0IHN0YXJ0ID0gdGhpcy5fZmluZFN0YXJ0KCk7XG5cbiAgICAgICAgaWYgKCFzdGFydCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG5leHRTdGFydCA9IHRoaXMuX25leHRTZXQodGhpcy5fcm93LCBzdGFydC5lbmQpO1xuXG4gICAgICAgIGxldCBkZWNvZGVkQ2hhcjtcbiAgICAgICAgbGV0IGxhc3RTdGFydDogbnVtYmVyO1xuICAgICAgICBkbyB7XG4gICAgICAgICAgICBjb3VudGVycyA9IHRoaXMuX3RvQ291bnRlcnMobmV4dFN0YXJ0LCBjb3VudGVycykgYXMgVWludDE2QXJyYXk7XG4gICAgICAgICAgICBjb25zdCBwYXR0ZXJuID0gdGhpcy5fdG9QYXR0ZXJuKGNvdW50ZXJzKTtcbiAgICAgICAgICAgIGlmIChwYXR0ZXJuIDwgMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVjb2RlZENoYXIgPSB0aGlzLl9wYXR0ZXJuVG9DaGFyKHBhdHRlcm4pO1xuICAgICAgICAgICAgaWYgKGRlY29kZWRDaGFyID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQucHVzaChkZWNvZGVkQ2hhcik7XG4gICAgICAgICAgICBsYXN0U3RhcnQgPSBuZXh0U3RhcnQ7XG4gICAgICAgICAgICBuZXh0U3RhcnQgKz0gQXJyYXlIZWxwZXIuc3VtKGNvdW50ZXJzKTtcbiAgICAgICAgICAgIG5leHRTdGFydCA9IHRoaXMuX25leHRTZXQodGhpcy5fcm93LCBuZXh0U3RhcnQpO1xuICAgICAgICB9IHdoaWxlIChkZWNvZGVkQ2hhciAhPT0gJyonKTtcbiAgICAgICAgcmVzdWx0LnBvcCgpO1xuXG4gICAgICAgIGlmICghcmVzdWx0Lmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRoaXMuX3ZlcmlmeVRyYWlsaW5nV2hpdGVzcGFjZShsYXN0U3RhcnQsIG5leHRTdGFydCwgY291bnRlcnMpKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjb2RlOiByZXN1bHQuam9pbignJyksXG4gICAgICAgICAgICBzdGFydDogc3RhcnQuc3RhcnQsXG4gICAgICAgICAgICBlbmQ6IG5leHRTdGFydCxcbiAgICAgICAgICAgIHN0YXJ0SW5mbzogc3RhcnQsXG4gICAgICAgICAgICBkZWNvZGVkQ29kZXM6IHJlc3VsdCxcbiAgICAgICAgICAgIGZvcm1hdDogdGhpcy5GT1JNQVQsXG4gICAgICAgIH07XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBDb2RlMzlSZWFkZXI7XG4iLCJpbXBvcnQgQ29kZTM5UmVhZGVyIGZyb20gJy4vY29kZV8zOV9yZWFkZXInO1xuXG5jb25zdCBwYXR0ZXJucyA9IHtcbiAgICBBRUlPOiAvW0FFSU9dL2csXG4gICAgQVowOTogL1tBLVowLTldLyxcbn07XG5cbmNvbnN0IGNvZGUzMnNldCA9ICcwMTIzNDU2Nzg5QkNERkdISktMTU5QUVJTVFVWV1hZWic7XG5cbmNsYXNzIENvZGUzMlJlYWRlciBleHRlbmRzIENvZGUzOVJlYWRlciB7XG4gICAgRk9STUFUID0gJ2NvZGVfMzJfcmVhZGVyJztcblxuICAgIHByb3RlY3RlZCBfZGVjb2RlQ29kZTMyKGNvZGU6IHN0cmluZykge1xuICAgICAgICBpZiAoL1teMC05QkNERkdISktMTU5QUVJTVFVWV1hZWl0vLnRlc3QoY29kZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGxldCByZXMgPSAwO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvZGUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHJlcyA9IHJlcyAqIDMyICsgY29kZTMyc2V0LmluZGV4T2YoY29kZVtpXSk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGNvZGUzMiA9IGAke3Jlc31gO1xuICAgICAgICBpZiAoY29kZTMyLmxlbmd0aCA8IDkpIHtcbiAgICAgICAgICAgIGNvZGUzMiA9ICgnMDAwMDAwMDAwJyArIGNvZGUzMikuc2xpY2UoLTkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAnQScgKyBjb2RlMzI7XG4gICAgfVxuXG4gICAgLy8gVE9ETyAodGhpcyB3YXMgdG9kbyBpbiBvcmlnaW5hbCByZXBvLCBubyB0ZXh0IHdhcyB0aGVyZS4gc29ycnkuKVxuICAgIHByb3RlY3RlZCBfY2hlY2tDaGVja3N1bShjb2RlOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuICEhY29kZTtcbiAgICB9XG5cbiAgICBwdWJsaWMgZGVjb2RlKCkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBzdXBlci5kZWNvZGUoKTtcbiAgICAgICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGNvZGUgPSByZXN1bHQuY29kZTtcblxuICAgICAgICBpZiAoIWNvZGUpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgY29kZSA9IGNvZGUucmVwbGFjZShwYXR0ZXJucy5BRUlPLCAnJyk7XG5cbiAgICAgICAgaWYgKCF0aGlzLl9jaGVja0NoZWNrc3VtKGNvZGUpKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGNvZGUzMiA9IHRoaXMuX2RlY29kZUNvZGUzMihjb2RlKTtcblxuICAgICAgICBpZiAoIWNvZGUzMikge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICByZXN1bHQuY29kZSA9IGNvZGUzMjtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IENvZGUzMlJlYWRlcjtcbiIsIi8qIGVzbGludC1kaXNhYmxlIGNsYXNzLW1ldGhvZHMtdXNlLXRoaXMgKi9cbmltcG9ydCB7IEJhcmNvZGUgfSBmcm9tICcuL2JhcmNvZGVfcmVhZGVyJztcbmltcG9ydCBDb2RlMzlSZWFkZXIgZnJvbSAnLi9jb2RlXzM5X3JlYWRlcic7XG5cbmNvbnN0IHBhdHRlcm5zID0ge1xuICAgIElPUTogL1tJT1FdL2csXG4gICAgQVowOTogL1tBLVowLTldezE3fS8sXG59O1xuXG5jbGFzcyBDb2RlMzlWSU5SZWFkZXIgZXh0ZW5kcyBDb2RlMzlSZWFkZXIge1xuICAgIEZPUk1BVCA9ICdjb2RlXzM5X3Zpbic7XG5cbiAgICAvLyBUT0RPICh0aGlzIHdhcyB0b2RvIGluIG9yaWdpbmFsIHJlcG8sIG5vIHRleHQgd2FzIHRoZXJlLiBzb3JyeS4pXG4gICAgcHJvdGVjdGVkIF9jaGVja0NoZWNrc3VtKGNvZGU6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gISFjb2RlO1xuICAgIH1cblxuICAgIC8vIENyaWJiZWQgZnJvbTpcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20venhpbmcvenhpbmcvYmxvYi9tYXN0ZXIvY29yZS9zcmMvbWFpbi9qYXZhL2NvbS9nb29nbGUvenhpbmcvY2xpZW50L3Jlc3VsdC9WSU5SZXN1bHRQYXJzZXIuamF2YVxuICAgIHB1YmxpYyBkZWNvZGUoKTogQmFyY29kZSB8IG51bGwge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBzdXBlci5kZWNvZGUoKTtcbiAgICAgICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IHsgY29kZSB9ID0gcmVzdWx0O1xuXG4gICAgICAgIGlmICghY29kZSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBjb2RlID0gY29kZS5yZXBsYWNlKHBhdHRlcm5zLklPUSwgJycpO1xuXG4gICAgICAgIGlmICghY29kZS5tYXRjaChwYXR0ZXJucy5BWjA5KSkge1xuICAgICAgICAgICAgaWYgKEVOVi5kZXZlbG9wbWVudCkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdGYWlsZWQgQVowOSBwYXR0ZXJuIGNvZGU6JywgY29kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGhpcy5fY2hlY2tDaGVja3N1bShjb2RlKSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICByZXN1bHQuY29kZSA9IGNvZGU7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBDb2RlMzlWSU5SZWFkZXI7XG4iLCJpbXBvcnQgQmFyY29kZVJlYWRlciwgeyBCYXJjb2RlUG9zaXRpb24sIEJhcmNvZGUgfSBmcm9tICcuL2JhcmNvZGVfcmVhZGVyJztcbmltcG9ydCBBcnJheUhlbHBlciBmcm9tICcuLi9jb21tb24vYXJyYXlfaGVscGVyJztcblxuY29uc3QgQUxQSEFCRVRIX1NUUklORyA9ICcwMTIzNDU2Nzg5QUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVotLiAkLyslYWJjZConO1xuY29uc3QgQUxQSEFCRVQgPSBuZXcgVWludDE2QXJyYXkoWy4uLkFMUEhBQkVUSF9TVFJJTkddLm1hcChjaGFyID0+IGNoYXIuY2hhckNvZGVBdCgwKSkpO1xuY29uc3QgQ0hBUkFDVEVSX0VOQ09ESU5HUyA9IG5ldyBVaW50MTZBcnJheShbXG4gICAgMHgxMTQsIDB4MTQ4LCAweDE0NCwgMHgxNDIsIDB4MTI4LCAweDEyNCwgMHgxMjIsIDB4MTUwLCAweDExMiwgMHgxMEEsXG4gICAgMHgxQTgsIDB4MUE0LCAweDFBMiwgMHgxOTQsIDB4MTkyLCAweDE4QSwgMHgxNjgsIDB4MTY0LCAweDE2MiwgMHgxMzQsXG4gICAgMHgxMUEsIDB4MTU4LCAweDE0QywgMHgxNDYsIDB4MTJDLCAweDExNiwgMHgxQjQsIDB4MUIyLCAweDFBQywgMHgxQTYsXG4gICAgMHgxOTYsIDB4MTlBLCAweDE2QywgMHgxNjYsIDB4MTM2LCAweDEzQSwgMHgxMkUsIDB4MUQ0LCAweDFEMiwgMHgxQ0EsXG4gICAgMHgxNkUsIDB4MTc2LCAweDFBRSwgMHgxMjYsIDB4MURBLCAweDFENiwgMHgxMzIsIDB4MTVFLFxuXSk7XG5jb25zdCBBU1RFUklTSyA9IDB4MTVFO1xuXG5jbGFzcyBDb2RlOTNSZWFkZXIgZXh0ZW5kcyBCYXJjb2RlUmVhZGVyIHtcbiAgICBGT1JNQVQgPSAnY29kZV85Myc7XG4gICAgcHJvdGVjdGVkIF9wYXR0ZXJuVG9DaGFyKHBhdHRlcm46IG51bWJlcik6IHN0cmluZyB8IG51bGwge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IENIQVJBQ1RFUl9FTkNPRElOR1MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChDSEFSQUNURVJfRU5DT0RJTkdTW2ldID09PSBwYXR0ZXJuKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoQUxQSEFCRVRbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG5cbiAgICBwcm90ZWN0ZWQgX3RvUGF0dGVybihjb3VudGVyczogVWludDE2QXJyYXkpOiBudW1iZXIge1xuICAgICAgICBjb25zdCBudW1Db3VudGVycyA9IGNvdW50ZXJzLmxlbmd0aDtcbiAgICAgICAgY29uc3Qgc3VtID0gY291bnRlcnMucmVkdWNlKChwcmV2LCBuZXh0KSA9PiBwcmV2ICsgbmV4dCwgMCk7XG4gICAgICAgIGxldCBwYXR0ZXJuID0gMDtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bUNvdW50ZXJzOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBub3JtYWxpemVkID0gTWF0aC5yb3VuZChjb3VudGVyc1tpXSAqIDkgLyBzdW0pO1xuICAgICAgICAgICAgaWYgKG5vcm1hbGl6ZWQgPCAxIHx8IG5vcm1hbGl6ZWQgPiA0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKChpICYgMSkgPT09IDApIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IG5vcm1hbGl6ZWQ7IGorKykge1xuICAgICAgICAgICAgICAgICAgICBwYXR0ZXJuID0gKHBhdHRlcm4gPDwgMSkgfCAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcGF0dGVybiA8PD0gbm9ybWFsaXplZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGF0dGVybjtcbiAgICB9O1xuXG4gICAgcHJvdGVjdGVkIF9maW5kU3RhcnQoKTogQmFyY29kZVBvc2l0aW9uIHwgbnVsbCB7XG4gICAgICAgIGNvbnN0IG9mZnNldCA9IHRoaXMuX25leHRTZXQodGhpcy5fcm93KTtcbiAgICAgICAgbGV0IHBhdHRlcm5TdGFydCA9IG9mZnNldDtcbiAgICAgICAgY29uc3QgY291bnRlciA9IG5ldyBVaW50MTZBcnJheShbMCwgMCwgMCwgMCwgMCwgMF0pO1xuICAgICAgICBsZXQgY291bnRlclBvcyA9IDA7XG4gICAgICAgIGxldCBpc1doaXRlID0gZmFsc2U7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IG9mZnNldDsgaSA8IHRoaXMuX3Jvdy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3Jvd1tpXSBeIChpc1doaXRlID8gMSA6IDApKSB7XG4gICAgICAgICAgICAgICAgY291bnRlcltjb3VudGVyUG9zXSsrO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoY291bnRlclBvcyA9PT0gY291bnRlci5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGZpbmQgc3RhcnQgcGF0dGVyblxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fdG9QYXR0ZXJuKGNvdW50ZXIpID09PSBBU1RFUklTSykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgd2hpdGVTcGFjZU11c3RTdGFydCA9IE1hdGguZmxvb3IoTWF0aC5tYXgoMCwgcGF0dGVyblN0YXJ0IC0gKChpIC0gcGF0dGVyblN0YXJ0KSAvIDQpKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fbWF0Y2hSYW5nZSh3aGl0ZVNwYWNlTXVzdFN0YXJ0LCBwYXR0ZXJuU3RhcnQsIDApKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IHBhdHRlcm5TdGFydCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kOiBpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBwYXR0ZXJuU3RhcnQgKz0gY291bnRlclswXSArIGNvdW50ZXJbMV07XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgNDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb3VudGVyW2pdID0gY291bnRlcltqICsgMl07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY291bnRlcls0XSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGNvdW50ZXJbNV0gPSAwO1xuICAgICAgICAgICAgICAgICAgICBjb3VudGVyUG9zLS07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY291bnRlclBvcysrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb3VudGVyW2NvdW50ZXJQb3NdID0gMTtcbiAgICAgICAgICAgICAgICBpc1doaXRlID0gIWlzV2hpdGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcblxuICAgIHByb3RlY3RlZCBfdmVyaWZ5RW5kKGxhc3RTdGFydDogbnVtYmVyLCBuZXh0U3RhcnQ6IG51bWJlcik6IGJvb2xlYW4ge1xuICAgICAgICBpZiAobGFzdFN0YXJ0ID09PSBuZXh0U3RhcnQgfHwgIXRoaXMuX3Jvd1tuZXh0U3RhcnRdKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcblxuICAgIHByb3RlY3RlZCBfZGVjb2RlRXh0ZW5kZWQoY2hhckFycmF5OiBBcnJheTxzdHJpbmc+KTogc3RyaW5nW10gfCBudWxsIHtcbiAgICAgICAgY29uc3QgbGVuZ3RoID0gY2hhckFycmF5Lmxlbmd0aDtcbiAgICAgICAgY29uc3QgcmVzdWx0OiBBcnJheTxzdHJpbmc+ID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGNoYXIgPSBjaGFyQXJyYXlbaV07XG4gICAgICAgICAgICBpZiAoY2hhciA+PSAnYScgJiYgY2hhciA8PSAnZCcpIHtcbiAgICAgICAgICAgICAgICBpZiAoaSA+IChsZW5ndGggLSAyKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgbmV4dENoYXIgPSBjaGFyQXJyYXlbKytpXTtcbiAgICAgICAgICAgICAgICBjb25zdCBuZXh0Q2hhckNvZGUgPSBuZXh0Q2hhci5jaGFyQ29kZUF0KDApO1xuICAgICAgICAgICAgICAgIGxldCBkZWNvZGVkQ2hhcjtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGNoYXIpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnYSc6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobmV4dENoYXIgPj0gJ0EnICYmIG5leHRDaGFyIDw9ICdaJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlY29kZWRDaGFyID0gU3RyaW5nLmZyb21DaGFyQ29kZShuZXh0Q2hhckNvZGUgLSA2NCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2InOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5leHRDaGFyID49ICdBJyAmJiBuZXh0Q2hhciA8PSAnRScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWNvZGVkQ2hhciA9IFN0cmluZy5mcm9tQ2hhckNvZGUobmV4dENoYXJDb2RlIC0gMzgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChuZXh0Q2hhciA+PSAnRicgJiYgbmV4dENoYXIgPD0gJ0onKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVjb2RlZENoYXIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKG5leHRDaGFyQ29kZSAtIDExKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobmV4dENoYXIgPj0gJ0snICYmIG5leHRDaGFyIDw9ICdPJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlY29kZWRDaGFyID0gU3RyaW5nLmZyb21DaGFyQ29kZShuZXh0Q2hhckNvZGUgKyAxNik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG5leHRDaGFyID49ICdQJyAmJiBuZXh0Q2hhciA8PSAnUycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWNvZGVkQ2hhciA9IFN0cmluZy5mcm9tQ2hhckNvZGUobmV4dENoYXJDb2RlICsgNDMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChuZXh0Q2hhciA+PSAnVCcgJiYgbmV4dENoYXIgPD0gJ1onKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVjb2RlZENoYXIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDEyNyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2MnOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5leHRDaGFyID49ICdBJyAmJiBuZXh0Q2hhciA8PSAnTycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWNvZGVkQ2hhciA9IFN0cmluZy5mcm9tQ2hhckNvZGUobmV4dENoYXJDb2RlIC0gMzIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChuZXh0Q2hhciA9PT0gJ1onKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVjb2RlZENoYXIgPSAnOic7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2QnOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5leHRDaGFyID49ICdBJyAmJiBuZXh0Q2hhciA8PSAnWicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWNvZGVkQ2hhciA9IFN0cmluZy5mcm9tQ2hhckNvZGUobmV4dENoYXJDb2RlICsgMzIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCcqIGNvZGVfOTNfcmVhZGVyIF9kZWNvZGVFeHRlbmRlZCBoaXQgZGVmYXVsdCBjYXNlLCB0aGlzIG1heSBiZSBhbiBlcnJvcicsIGRlY29kZWRDaGFyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChkZWNvZGVkQ2hhcik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGNoYXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcblxuICAgIHByb3RlY3RlZCBfbWF0Y2hDaGVja0NoYXIoY2hhckFycmF5OiBBcnJheTxzdHJpbmc+LCBpbmRleDogbnVtYmVyLCBtYXhXZWlnaHQ6IG51bWJlcik6IGJvb2xlYW4ge1xuICAgICAgICBjb25zdCBhcnJheVRvQ2hlY2sgPSBjaGFyQXJyYXkuc2xpY2UoMCwgaW5kZXgpO1xuICAgICAgICBjb25zdCBsZW5ndGggPSBhcnJheVRvQ2hlY2subGVuZ3RoO1xuICAgICAgICBjb25zdCB3ZWlnaHRlZFN1bXMgPSBhcnJheVRvQ2hlY2sucmVkdWNlKChzdW0sIGNoYXIsIGkpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHdlaWdodCA9ICgoKGkgKiAtMSkgKyAobGVuZ3RoIC0gMSkpICUgbWF4V2VpZ2h0KSArIDE7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IEFMUEhBQkVULmluZGV4T2YoY2hhci5jaGFyQ29kZUF0KDApKTtcbiAgICAgICAgICAgIHJldHVybiBzdW0gKyAod2VpZ2h0ICogdmFsdWUpO1xuICAgICAgICB9LCAwKTtcblxuICAgICAgICBjb25zdCBjaGVja0NoYXIgPSBBTFBIQUJFVFsod2VpZ2h0ZWRTdW1zICUgNDcpXTtcbiAgICAgICAgcmV0dXJuIGNoZWNrQ2hhciA9PT0gY2hhckFycmF5W2luZGV4XS5jaGFyQ29kZUF0KDApO1xuICAgIH07XG5cbiAgICBwcm90ZWN0ZWQgX3ZlcmlmeUNoZWNrc3VtcyhjaGFyQXJyYXk6IEFycmF5PHN0cmluZz4pOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21hdGNoQ2hlY2tDaGFyKGNoYXJBcnJheSwgY2hhckFycmF5Lmxlbmd0aCAtIDIsIDIwKVxuICAgICAgICAgICAgJiYgdGhpcy5fbWF0Y2hDaGVja0NoYXIoY2hhckFycmF5LCBjaGFyQXJyYXkubGVuZ3RoIC0gMSwgMTUpO1xuICAgIH07XG5cbiAgICBwdWJsaWMgZGVjb2RlKHJvdz86IEFycmF5PG51bWJlcj4sIHN0YXJ0PzogQmFyY29kZVBvc2l0aW9uIHwgbnVtYmVyIHwgbnVsbCk6IEJhcmNvZGUgfCBudWxsIHtcbiAgICAgICAgc3RhcnQgPSB0aGlzLl9maW5kU3RhcnQoKTtcbiAgICAgICAgaWYgKCFzdGFydCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgY291bnRlcnMgPSBuZXcgVWludDE2QXJyYXkoWzAsIDAsIDAsIDAsIDAsIDBdKTtcbiAgICAgICAgbGV0IHJlc3VsdDogQXJyYXk8c3RyaW5nPiB8IG51bGwgPSBbXTtcbiAgICAgICAgbGV0IG5leHRTdGFydCA9IHRoaXMuX25leHRTZXQodGhpcy5fcm93LCBzdGFydC5lbmQpO1xuICAgICAgICBsZXQgbGFzdFN0YXJ0O1xuICAgICAgICBsZXQgZGVjb2RlZENoYXI6IHN0cmluZyB8IG51bGw7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIGNvdW50ZXJzID0gdGhpcy5fdG9Db3VudGVycyhuZXh0U3RhcnQsIGNvdW50ZXJzKSBhcyBVaW50MTZBcnJheTtcbiAgICAgICAgICAgIGNvbnN0IHBhdHRlcm4gPSB0aGlzLl90b1BhdHRlcm4oY291bnRlcnMpO1xuICAgICAgICAgICAgaWYgKHBhdHRlcm4gPCAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWNvZGVkQ2hhciA9IHRoaXMuX3BhdHRlcm5Ub0NoYXIocGF0dGVybik7XG4gICAgICAgICAgICBpZiAoZGVjb2RlZENoYXIgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGRlY29kZWRDaGFyKTtcbiAgICAgICAgICAgIGxhc3RTdGFydCA9IG5leHRTdGFydDtcbiAgICAgICAgICAgIG5leHRTdGFydCArPSBBcnJheUhlbHBlci5zdW0oY291bnRlcnMpO1xuICAgICAgICAgICAgbmV4dFN0YXJ0ID0gdGhpcy5fbmV4dFNldCh0aGlzLl9yb3csIG5leHRTdGFydCk7XG4gICAgICAgIH0gd2hpbGUgKGRlY29kZWRDaGFyICE9PSAnKicpO1xuICAgICAgICByZXN1bHQucG9wKCk7XG5cbiAgICAgICAgaWYgKCFyZXN1bHQubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGhpcy5fdmVyaWZ5RW5kKGxhc3RTdGFydCwgbmV4dFN0YXJ0KSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRoaXMuX3ZlcmlmeUNoZWNrc3VtcyhyZXN1bHQpKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlc3VsdCA9IHJlc3VsdC5zbGljZSgwLCByZXN1bHQubGVuZ3RoIC0gMik7XG4gICAgICAgIC8vIHllcywgdGhpcyBpcyBhbiBhc3NpZ24gaW5zaWRlIGFuIGlmLlxuICAgICAgICBpZiAoKHJlc3VsdCA9IHRoaXMuX2RlY29kZUV4dGVuZGVkKHJlc3VsdCkpID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjb2RlOiByZXN1bHQuam9pbignJyksXG4gICAgICAgICAgICBzdGFydDogc3RhcnQuc3RhcnQsXG4gICAgICAgICAgICBlbmQ6IG5leHRTdGFydCxcbiAgICAgICAgICAgIHN0YXJ0SW5mbzogc3RhcnQsXG4gICAgICAgICAgICBkZWNvZGVkQ29kZXM6IHJlc3VsdCxcbiAgICAgICAgICAgIGZvcm1hdDogdGhpcy5GT1JNQVQsXG4gICAgICAgIH07XG5cbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IENvZGU5M1JlYWRlcjtcbiIsImltcG9ydCBCYXJjb2RlUmVhZGVyLCB7IEJhcmNvZGVSZWFkZXJDb25maWcsIEJhcmNvZGVJbmZvLCBCYXJjb2RlUG9zaXRpb24sIEJhcmNvZGUgfSBmcm9tICcuL2JhcmNvZGVfcmVhZGVyJztcbmltcG9ydCBtZXJnZSBmcm9tICdsb2Rhc2gvbWVyZ2UnO1xuXG4vLyBjb25zdCBDT0RFX0xfU1RBUlQgPSAwO1xuY29uc3QgQ09ERV9HX1NUQVJUID0gMTA7XG5leHBvcnQgeyBDT0RFX0dfU1RBUlQgfTtcbmNvbnN0IFNUQVJUX1BBVFRFUk4gPSBbMSwgMSwgMV07XG5jb25zdCBNSURETEVfUEFUVEVSTiA9IFsxLCAxLCAxLCAxLCAxXTtcbmV4cG9ydCB7IE1JRERMRV9QQVRURVJOIH07XG5jb25zdCBFWFRFTlNJT05fU1RBUlRfUEFUVEVSTiA9IFsxLCAxLCAyXTtcbmNvbnN0IENPREVfUEFUVEVSTiA9IFtcbiAgICBbMywgMiwgMSwgMV0sXG4gICAgWzIsIDIsIDIsIDFdLFxuICAgIFsyLCAxLCAyLCAyXSxcbiAgICBbMSwgNCwgMSwgMV0sXG4gICAgWzEsIDEsIDMsIDJdLFxuICAgIFsxLCAyLCAzLCAxXSxcbiAgICBbMSwgMSwgMSwgNF0sXG4gICAgWzEsIDMsIDEsIDJdLFxuICAgIFsxLCAyLCAxLCAzXSxcbiAgICBbMywgMSwgMSwgMl0sXG4gICAgWzEsIDEsIDIsIDNdLFxuICAgIFsxLCAyLCAyLCAyXSxcbiAgICBbMiwgMiwgMSwgMl0sXG4gICAgWzEsIDEsIDQsIDFdLFxuICAgIFsyLCAzLCAxLCAxXSxcbiAgICBbMSwgMywgMiwgMV0sXG4gICAgWzQsIDEsIDEsIDFdLFxuICAgIFsyLCAxLCAzLCAxXSxcbiAgICBbMywgMSwgMiwgMV0sXG4gICAgWzIsIDEsIDEsIDNdLFxuXTtcbmNvbnN0IENPREVfRlJFUVVFTkNZID0gWzAsIDExLCAxMywgMTQsIDE5LCAyNSwgMjgsIDIxLCAyMiwgMjZdO1xuLy8gY29uc3QgU0lOR0xFX0NPREVfRVJST1IgPSAwLjcwO1xuY29uc3QgQVZHX0NPREVfRVJST1IgPSAwLjQ4O1xuXG5jbGFzcyBFQU5SZWFkZXIgZXh0ZW5kcyBCYXJjb2RlUmVhZGVyIHtcbiAgICBGT1JNQVQgPSAnZWFuXzEzJztcbiAgICBTSU5HTEVfQ09ERV9FUlJPUiA9IDAuNzA7XG4gICAgU1RPUF9QQVRURVJOID0gWzEsIDEsIDFdOyAvLyBUT0RPOiBkb2VzIHRoaXMgbmVlZCB0byBiZSBpbiB0aGUgY2xhc3M/XG5cbiAgICBjb25zdHJ1Y3Rvcihjb25maWc/OiBCYXJjb2RlUmVhZGVyQ29uZmlnLCBzdXBwbGVtZW50cz86IEFycmF5PEJhcmNvZGVSZWFkZXI+KSB7XG4gICAgICAgIHN1cGVyKG1lcmdlKHsgc3VwcGxlbWVudHM6IFtdIH0sIGNvbmZpZyksIHN1cHBsZW1lbnRzKTtcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgX2ZpbmRQYXR0ZXJuKHBhdHRlcm46IFJlYWRvbmx5QXJyYXk8bnVtYmVyPiwgb2Zmc2V0OiBudW1iZXIsIGlzV2hpdGU6IGJvb2xlYW4sIHRyeUhhcmRlcjogYm9vbGVhbik6IEJhcmNvZGVQb3NpdGlvbiB8IG51bGwge1xuICAgICAgICBjb25zdCBjb3VudGVyID0gbmV3IEFycmF5PG51bWJlcj4ocGF0dGVybi5sZW5ndGgpLmZpbGwoMCk7XG4gICAgICAgIGNvbnN0IGJlc3RNYXRjaDogQmFyY29kZVBvc2l0aW9uID0ge1xuICAgICAgICAgICAgZXJyb3I6IE51bWJlci5NQVhfVkFMVUUsXG4gICAgICAgICAgICBzdGFydDogMCxcbiAgICAgICAgICAgIGVuZDogMFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBlcHNpbG9uID0gQVZHX0NPREVfRVJST1I7XG4gICAgICAgIC8vIGNvbnNvbGUud2FybignKiBmaW5kUGF0dGVybicsIHBhdHRlcm4sIG9mZnNldCwgaXNXaGl0ZSwgdHJ5SGFyZGVyLCBlcHNpbG9uKTtcbiAgICAgICAgbGV0IGNvdW50ZXJQb3MgPSAwO1xuICAgICAgICBpZiAoIW9mZnNldCkge1xuICAgICAgICAgICAgb2Zmc2V0ID0gdGhpcy5fbmV4dFNldCh0aGlzLl9yb3cpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBmb3VuZCA9IGZhbHNlO1xuICAgICAgICBmb3IgKGxldCBpID0gb2Zmc2V0OyBpIDwgdGhpcy5fcm93Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAvLyBjb25zb2xlLndhcm4oYCogbG9vcCBpPSR7b2Zmc2V0fSBsZW49JHt0aGlzLl9yb3cubGVuZ3RofSBpc1doaXRlPSR7aXNXaGl0ZX0gY291bnRlclBvcz0ke2NvdW50ZXJQb3N9YCk7XG4gICAgICAgICAgICBpZiAodGhpcy5fcm93W2ldIF4gKGlzV2hpdGUgPyAxIDogMCkpIHtcbiAgICAgICAgICAgICAgICBjb3VudGVyW2NvdW50ZXJQb3NdICs9IDE7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChjb3VudGVyUG9zID09PSBjb3VudGVyLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZXJyb3IgPSB0aGlzLl9tYXRjaFBhdHRlcm4oY291bnRlciwgcGF0dGVybik7XG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUud2FybignKiBtYXRjaFBhdHRlcm4nLCBlcnJvciwgY291bnRlciwgcGF0dGVybik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnJvciA8IGVwc2lsb24gJiYgYmVzdE1hdGNoLmVycm9yICYmIGVycm9yIDwgYmVzdE1hdGNoLmVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3VuZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBiZXN0TWF0Y2guZXJyb3IgPSBlcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJlc3RNYXRjaC5zdGFydCA9IGkgLSBjb3VudGVyLnJlZHVjZSgoc3VtLCB2YWx1ZSkgPT4gc3VtICsgdmFsdWUsIDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgYmVzdE1hdGNoLmVuZCA9IGk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjb25zb2xlLndhcm4oJyogcmV0dXJuIGJlc3RNYXRjaCcsIEpTT04uc3RyaW5naWZ5KGJlc3RNYXRjaCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJlc3RNYXRjaDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodHJ5SGFyZGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGNvdW50ZXIubGVuZ3RoIC0gMjsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY291bnRlcltqXSA9IGNvdW50ZXJbaiArIDJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY291bnRlcltjb3VudGVyLmxlbmd0aCAtIDJdID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50ZXJbY291bnRlci5sZW5ndGggLSAxXSA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb3VudGVyUG9zLS07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb3VudGVyUG9zKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvdW50ZXJbY291bnRlclBvc10gPSAxO1xuICAgICAgICAgICAgICAgIGlzV2hpdGUgPSAhaXNXaGl0ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZm91bmQpIHtcbiAgICAgICAgICAgIC8vIGNvbnNvbGUud2FybignKiByZXR1cm4gYmVzdE1hdGNoJywgSlNPTi5zdHJpbmdpZnkoYmVzdE1hdGNoKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBjb25zb2xlLndhcm4oJyogcmV0dXJuIG51bGwnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZm91bmQgPyBiZXN0TWF0Y2ggOiBudWxsO1xuICAgIH1cblxuICAgIC8vIFRPRE86IGZpbmRQYXR0ZXJuIGFuZCBkZWNvZGVDb2RlIGFwcGVhciB0byBzaGFyZSBxdWl0ZSBzaW1pbGFyIGNvZGUsIGNhbiBpdCBiZSByZWR1Y2VkP1xuICAgIHByb3RlY3RlZCBfZGVjb2RlQ29kZShzdGFydDogbnVtYmVyLCBjb2RlcmFuZ2U/OiBudW1iZXIpOiBCYXJjb2RlSW5mbyB8IG51bGwge1xuICAgICAgICAvLyBjb25zb2xlLndhcm4oJyogZGVjb2RlQ29kZScsIHN0YXJ0LCBjb2RlcmFuZ2UpO1xuICAgICAgICBjb25zdCBjb3VudGVyID0gWzAsIDAsIDAsIDBdO1xuICAgICAgICBjb25zdCBvZmZzZXQgPSBzdGFydDtcbiAgICAgICAgY29uc3QgYmVzdE1hdGNoOiBCYXJjb2RlSW5mbyA9IHtcbiAgICAgICAgICAgIGVycm9yOiBOdW1iZXIuTUFYX1ZBTFVFLFxuICAgICAgICAgICAgY29kZTogLTEsXG4gICAgICAgICAgICBzdGFydDogc3RhcnQsXG4gICAgICAgICAgICBlbmQ6IHN0YXJ0XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGVwc2lsb24gPSBBVkdfQ09ERV9FUlJPUjtcbiAgICAgICAgbGV0IGlzV2hpdGUgPSAhdGhpcy5fcm93W29mZnNldF07XG4gICAgICAgIGxldCBjb3VudGVyUG9zID0gMDtcblxuICAgICAgICBpZiAoIWNvZGVyYW5nZSkge1xuICAgICAgICAgICAgLy8gY29uc29sZS53YXJuKCcqIGRlY29kZUNvZGUgYmVmb3JlIGxlbmd0aCcpO1xuICAgICAgICAgICAgY29kZXJhbmdlID0gQ09ERV9QQVRURVJOLmxlbmd0aDtcbiAgICAgICAgICAgIC8vIGNvbnNvbGUud2FybignKiBkZWNvZGVDb2RlIGFmdGVyIGxlbmd0aCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGZvdW5kID0gZmFsc2U7XG4gICAgICAgIGZvciAobGV0IGkgPSBvZmZzZXQ7IGkgPCB0aGlzLl9yb3cubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9yb3dbaV0gXiAoaXNXaGl0ZSA/IDEgOiAwKSkge1xuICAgICAgICAgICAgICAgIGNvdW50ZXJbY291bnRlclBvc10rKztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvdW50ZXJQb3MgPT09IGNvdW50ZXIubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBjb2RlID0gMDsgY29kZSA8IGNvZGVyYW5nZTsgY29kZSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBlcnJvciA9IHRoaXMuX21hdGNoUGF0dGVybihjb3VudGVyLCBDT0RFX1BBVFRFUk5bY29kZV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgYmVzdE1hdGNoLmVuZCA9IGk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3IgPCBiZXN0TWF0Y2guZXJyb3IhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYmVzdE1hdGNoLmNvZGUgPSBjb2RlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJlc3RNYXRjaC5lcnJvciA9IGVycm9yO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChiZXN0TWF0Y2guZXJyb3IhID4gZXBzaWxvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY29uc29sZS53YXJuKCcqIHJldHVybiBudWxsJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBjb25zb2xlLndhcm4oJyogcmV0dXJuIGJlc3RNYXRjaCcsIEpTT04uc3RyaW5naWZ5KGJlc3RNYXRjaCkpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYmVzdE1hdGNoO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvdW50ZXJQb3MrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY291bnRlcltjb3VudGVyUG9zXSA9IDE7XG4gICAgICAgICAgICAgICAgaXNXaGl0ZSA9ICFpc1doaXRlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmb3VuZCA/IGJlc3RNYXRjaCA6IG51bGw7XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIF9maW5kU3RhcnQoKTogQmFyY29kZVBvc2l0aW9uIHwgbnVsbCB7XG4gICAgICAgIC8vIGNvbnNvbGUud2FybignKiBmaW5kU3RhcnQnKTtcbiAgICAgICAgbGV0IG9mZnNldCA9IHRoaXMuX25leHRTZXQodGhpcy5fcm93KTtcbiAgICAgICAgbGV0IHN0YXJ0SW5mbzogQmFyY29kZVBvc2l0aW9uIHwgbnVsbCA9IG51bGw7XG5cbiAgICAgICAgd2hpbGUgKCFzdGFydEluZm8pIHtcbiAgICAgICAgICAgIHN0YXJ0SW5mbyA9IHRoaXMuX2ZpbmRQYXR0ZXJuKFNUQVJUX1BBVFRFUk4sIG9mZnNldCwgZmFsc2UsIHRydWUpO1xuICAgICAgICAgICAgLy8gY29uc29sZS53YXJuKCcqIHN0YXJ0SW5mbz0nLCBKU09OLnN0cmluZ2lmeShzdGFydEluZm8pKTtcbiAgICAgICAgICAgIGlmICghc3RhcnRJbmZvKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IGxlYWRpbmdXaGl0ZXNwYWNlU3RhcnQgPSBzdGFydEluZm8uc3RhcnQgLSAoc3RhcnRJbmZvLmVuZCAtIHN0YXJ0SW5mby5zdGFydCk7XG5cbiAgICAgICAgICAgIGlmIChsZWFkaW5nV2hpdGVzcGFjZVN0YXJ0ID49IDApIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fbWF0Y2hSYW5nZShsZWFkaW5nV2hpdGVzcGFjZVN0YXJ0LCBzdGFydEluZm8uc3RhcnQsIDApKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUud2FybignKiByZXR1cm5pbmcgc3RhcnRJbmZvJyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzdGFydEluZm87XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBvZmZzZXQgPSBzdGFydEluZm8uZW5kO1xuICAgICAgICAgICAgc3RhcnRJbmZvID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICAvLyBjb25zb2xlLndhcm4oJyogcmV0dXJuaW5nIG51bGwnKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBfY2FsY3VsYXRlRmlyc3REaWdpdChjb2RlRnJlcXVlbmN5OiBudW1iZXIpOiBudW1iZXIgfCBudWxsIHtcbiAgICAgICAgLy8gY29uc29sZS53YXJuKCcqIGNhbGN1bGF0ZUZpcnN0RGlnaXQnLCBjb2RlRnJlcXVlbmN5KTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBDT0RFX0ZSRVFVRU5DWS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGNvZGVGcmVxdWVuY3kgPT09IENPREVfRlJFUVVFTkNZW2ldKSB7XG4gICAgICAgICAgICAgICAgLy8gY29uc29sZS53YXJuKCcqIHJldHVybmluZycsIGkpO1xuICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGNvbnNvbGUud2FybignKiByZXR1cm4gbnVsbCcpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgX2RlY29kZVBheWxvYWQoaW5Db2RlOiBCYXJjb2RlUG9zaXRpb24sIHJlc3VsdDogQXJyYXk8bnVtYmVyPiwgZGVjb2RlZENvZGVzOiBBcnJheTxCYXJjb2RlUG9zaXRpb24+KTogQmFyY29kZUluZm8gfCBudWxsIHtcbiAgICAgICAgLy8gY29uc29sZS53YXJuKCcqIGRlY29kZVBheWxvYWQnLCBpbkNvZGUsIHJlc3VsdCwgZGVjb2RlZENvZGVzKTtcbiAgICAgICAgbGV0IG91dENvZGU6IEJhcmNvZGVJbmZvIHwgQmFyY29kZVBvc2l0aW9uIHwgbnVsbCA9IHsgLi4uaW5Db2RlIH07XG4gICAgICAgIGxldCBjb2RlRnJlcXVlbmN5ID0gMHgwO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNjsgaSsrKSB7XG4gICAgICAgICAgICBvdXRDb2RlID0gdGhpcy5fZGVjb2RlQ29kZShvdXRDb2RlLmVuZCk7XG4gICAgICAgICAgICAvLyBjb25zb2xlLndhcm4oJyogZGVjb2RlQ29kZT0nLCBvdXRDb2RlKTtcbiAgICAgICAgICAgIGlmICghb3V0Q29kZSkge1xuICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUud2FybignKiByZXR1cm4gbnVsbCcpO1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKChvdXRDb2RlIGFzIEJhcmNvZGVJbmZvKS5jb2RlID49IENPREVfR19TVEFSVCkge1xuICAgICAgICAgICAgICAgIChvdXRDb2RlIGFzIEJhcmNvZGVJbmZvKS5jb2RlIC09IENPREVfR19TVEFSVDtcbiAgICAgICAgICAgICAgICBjb2RlRnJlcXVlbmN5IHw9IDEgPDwgKDUgLSBpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29kZUZyZXF1ZW5jeSB8PSAwIDw8ICg1IC0gaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQucHVzaCgob3V0Q29kZSBhcyBCYXJjb2RlSW5mbykuY29kZSk7XG4gICAgICAgICAgICBkZWNvZGVkQ29kZXMucHVzaChvdXRDb2RlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGZpcnN0RGlnaXQgPSB0aGlzLl9jYWxjdWxhdGVGaXJzdERpZ2l0KGNvZGVGcmVxdWVuY3kpO1xuICAgICAgICAvLyBjb25zb2xlLndhcm4oJyogZmlyc3REaWdpdD0nLCBmaXJzdERpZ2l0KTtcbiAgICAgICAgaWYgKGZpcnN0RGlnaXQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIGNvbnNvbGUud2FybignKiByZXR1cm4gbnVsbCcpO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICByZXN1bHQudW5zaGlmdChmaXJzdERpZ2l0KTtcblxuICAgICAgICBsZXQgbWlkZGxlUGF0dGVybiA9IHRoaXMuX2ZpbmRQYXR0ZXJuKE1JRERMRV9QQVRURVJOLCBvdXRDb2RlLmVuZCwgdHJ1ZSwgZmFsc2UpO1xuICAgICAgICAvLyBjb25zb2xlLndhcm4oJyogZmluZFBhdHRlcm49JywgSlNPTi5zdHJpbmdpZnkobWlkZGxlUGF0dGVybikpO1xuXG4gICAgICAgIGlmIChtaWRkbGVQYXR0ZXJuID09PSBudWxsIHx8ICFtaWRkbGVQYXR0ZXJuLmVuZCkge1xuICAgICAgICAgICAgLy8gY29uc29sZS53YXJuKCcqIHJldHVybiBudWxsJyk7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGRlY29kZWRDb2Rlcy5wdXNoKG1pZGRsZVBhdHRlcm4pO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNjsgaSsrKSB7XG4gICAgICAgICAgICBtaWRkbGVQYXR0ZXJuID0gdGhpcy5fZGVjb2RlQ29kZShtaWRkbGVQYXR0ZXJuIS5lbmQsIENPREVfR19TVEFSVCk7XG4gICAgICAgICAgICAvLyBjb25zb2xlLndhcm4oJyogZGVjb2RlQ29kZT0nLCBKU09OLnN0cmluZ2lmeShtaWRkbGVQYXR0ZXJuKSk7XG5cbiAgICAgICAgICAgIGlmICghbWlkZGxlUGF0dGVybikge1xuICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUud2FybignKiByZXR1cm4gbnVsbCcpO1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBkZWNvZGVkQ29kZXMucHVzaChtaWRkbGVQYXR0ZXJuKTtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKChtaWRkbGVQYXR0ZXJuIGFzIEJhcmNvZGVJbmZvKS5jb2RlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNvbnNvbGUud2FybignKiBlbmQgY29kZT0nLCBKU09OLnN0cmluZ2lmeShtaWRkbGVQYXR0ZXJuKSk7XG4gICAgICAgIC8vIGNvbnNvbGUud2FybignKiBlbmQgcmVzdWx0PScsIEpTT04uc3RyaW5naWZ5KHJlc3VsdCkpO1xuICAgICAgICAvLyBjb25zb2xlLndhcm4oJyogZW5kIGRlY29kZWRDb2Rlcz0nLCBkZWNvZGVkQ29kZXMpO1xuICAgICAgICByZXR1cm4gbWlkZGxlUGF0dGVybiBhcyBCYXJjb2RlSW5mbztcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgX3ZlcmlmeVRyYWlsaW5nV2hpdGVzcGFjZShlbmRJbmZvOiBCYXJjb2RlUG9zaXRpb24pOiBCYXJjb2RlUG9zaXRpb24gfCBudWxsIHtcbiAgICAgICAgLy8gY29uc29sZS53YXJuKCcqIHZlcmlmeVRyYWlsaW5nV2hpdGVzcGFjZScsIEpTT04uc3RyaW5naWZ5KGVuZEluZm8pKTtcbiAgICAgICAgY29uc3QgdHJhaWxpbmdXaGl0ZXNwYWNlRW5kID0gZW5kSW5mby5lbmQgKyAoZW5kSW5mby5lbmQgLSBlbmRJbmZvLnN0YXJ0KTtcblxuICAgICAgICBpZiAodHJhaWxpbmdXaGl0ZXNwYWNlRW5kIDwgdGhpcy5fcm93Lmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX21hdGNoUmFuZ2UoZW5kSW5mby5lbmQsIHRyYWlsaW5nV2hpdGVzcGFjZUVuZCwgMCkpIHtcbiAgICAgICAgICAgICAgICAvLyBjb25zb2xlLndhcm4oJyogcmV0dXJuaW5nJywgSlNPTi5zdHJpbmdpZnkoZW5kSW5mbykpO1xuICAgICAgICAgICAgICAgIHJldHVybiBlbmRJbmZvO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGNvbnNvbGUud2FybignKiByZXR1cm4gbnVsbCcpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgX2ZpbmRFbmQob2Zmc2V0OiBudW1iZXIsIGlzV2hpdGU6IGJvb2xlYW4pOiBCYXJjb2RlUG9zaXRpb24gfCBudWxsIHtcbiAgICAgICAgLy8gY29uc29sZS53YXJuKCcqIGZpbmRFbmQnLCBvZmZzZXQsIGlzV2hpdGUpO1xuICAgICAgICBjb25zdCBlbmRJbmZvID0gdGhpcy5fZmluZFBhdHRlcm4odGhpcy5TVE9QX1BBVFRFUk4sIG9mZnNldCwgaXNXaGl0ZSwgZmFsc2UpO1xuXG4gICAgICAgIHJldHVybiBlbmRJbmZvICE9PSBudWxsID8gdGhpcy5fdmVyaWZ5VHJhaWxpbmdXaGl0ZXNwYWNlKGVuZEluZm8pIDogbnVsbDtcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgX2NoZWNrc3VtKHJlc3VsdDogQXJyYXk8bnVtYmVyPik6IGJvb2xlYW4ge1xuICAgICAgICAvLyBjb25zb2xlLndhcm4oJyogX2NoZWNrc3VtJywgcmVzdWx0KTtcbiAgICAgICAgbGV0IHN1bSA9IDA7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IHJlc3VsdC5sZW5ndGggLSAyOyBpID49IDA7IGkgLT0gMikge1xuICAgICAgICAgICAgc3VtICs9IHJlc3VsdFtpXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN1bSAqPSAzO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSByZXN1bHQubGVuZ3RoIC0gMTsgaSA+PSAwOyBpIC09IDIpIHtcbiAgICAgICAgICAgIHN1bSArPSByZXN1bHRbaV07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjb25zb2xlLndhcm4oJyogZW5kIGNoZWNrc3VtJywgc3VtICUgMTAgPT09IDApO1xuICAgICAgICByZXR1cm4gc3VtICUgMTAgPT09IDA7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBfZGVjb2RlRXh0ZW5zaW9ucyhvZmZzZXQ6IG51bWJlcik6IEJhcmNvZGUgfCBudWxsIHtcbiAgICAgICAgY29uc3Qgc3RhcnQgPSB0aGlzLl9uZXh0U2V0KHRoaXMuX3Jvdywgb2Zmc2V0KTtcbiAgICAgICAgY29uc3Qgc3RhcnRJbmZvID0gdGhpcy5fZmluZFBhdHRlcm4oRVhURU5TSU9OX1NUQVJUX1BBVFRFUk4sIHN0YXJ0LCBmYWxzZSwgZmFsc2UpO1xuXG4gICAgICAgIGlmIChzdGFydEluZm8gPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gY29uc29sZS53YXJuKCcqIGRlY29kZUV4dGVuc2lvbnMnLCB0aGlzLnN1cHBsZW1lbnRzKTtcbiAgICAgICAgLy8gY29uc29sZS53YXJuKCcqIHRoZXJlIGFyZSAnLCB0aGlzLnN1cHBsZW1lbnRzLmxlbmd0aCwgJyBzdXBwbGVtZW50cycpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuc3VwcGxlbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIC8vIGNvbnNvbGUud2FybignKiBleHRlbnNpb25zIGxvb3AnLCBpLCB0aGlzLnN1cHBsZW1lbnRzW2ldLCB0aGlzLnN1cHBsZW1lbnRzW2ldLl9kZWNvZGUpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBsZXQgcmVzdWx0ID0gdGhpcy5zdXBwbGVtZW50c1tpXS5kZWNvZGUodGhpcy5fcm93LCBzdGFydEluZm8uZW5kKTtcbiAgICAgICAgICAgICAgICAvLyBjb25zb2xlLndhcm4oJyogZGVjb2RlIHJlc3VsdD0nLCByZXN1bHQpO1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IHJlc3VsdC5jb2RlLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQsXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydEluZm8sXG4gICAgICAgICAgICAgICAgICAgICAgICBlbmQ6IHJlc3VsdC5lbmQsXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWNvZGVkQ29kZXM6IHJlc3VsdC5kZWNvZGVkQ29kZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3JtYXQ6IHRoaXMuc3VwcGxlbWVudHNbaV0uRk9STUFULFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJyogZGVjb2RlRXh0ZW5zaW9ucyBlcnJvciBpbiAnLCB0aGlzLnN1cHBsZW1lbnRzW2ldLCAnOiAnLCBlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gY29uc29sZS53YXJuKCcqIGVuZCBkZWNvZGVFeHRlbnNpb25zJyk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHB1YmxpYyBkZWNvZGUocm93PzogQXJyYXk8bnVtYmVyPiwgc3RhcnQ/OiBCYXJjb2RlUG9zaXRpb24gfCBudW1iZXIpOiBCYXJjb2RlIHwgbnVsbCB7XG4gICAgICAgIC8vIGNvbnNvbGUud2FybignKiBkZWNvZGUnLCByb3cpO1xuICAgICAgICAvLyBjb25zb2xlLndhcm4oJyogZGVjb2RlJywgc3RhcnQpO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBuZXcgQXJyYXk8bnVtYmVyPigpO1xuICAgICAgICBjb25zdCBkZWNvZGVkQ29kZXMgPSBuZXcgQXJyYXk8QmFyY29kZUluZm8gfCBCYXJjb2RlUG9zaXRpb24+KCk7XG4gICAgICAgIGxldCByZXN1bHRJbmZvOiBCYXJjb2RlIHwge30gPSB7fTtcbiAgICAgICAgbGV0IHN0YXJ0SW5mbyA9IHRoaXMuX2ZpbmRTdGFydCgpO1xuXG4gICAgICAgIGlmICghc3RhcnRJbmZvKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBjb2RlOiBCYXJjb2RlUG9zaXRpb24gfCBCYXJjb2RlSW5mbyB8IG51bGwgPSB7XG4gICAgICAgICAgICBzdGFydDogc3RhcnRJbmZvLnN0YXJ0LFxuICAgICAgICAgICAgZW5kOiBzdGFydEluZm8uZW5kXG4gICAgICAgIH07XG4gICAgICAgIGRlY29kZWRDb2Rlcy5wdXNoKGNvZGUpO1xuXG4gICAgICAgIGNvZGUgPSB0aGlzLl9kZWNvZGVQYXlsb2FkKGNvZGUsIHJlc3VsdCwgZGVjb2RlZENvZGVzKTtcblxuICAgICAgICBpZiAoIWNvZGUpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgY29kZSA9IHRoaXMuX2ZpbmRFbmQoY29kZS5lbmQsIGZhbHNlKTtcblxuICAgICAgICBpZiAoIWNvZGUpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgZGVjb2RlZENvZGVzLnB1c2goY29kZSk7XG5cbiAgICAgICAgLy8gQ2hlY2tzdW1cbiAgICAgICAgaWYgKCF0aGlzLl9jaGVja3N1bShyZXN1bHQpKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNvbnNvbGUud2FybignKiB0aGlzLnN1cHBsZW1lbnRzPScsIHRoaXMuc3VwcGxlbWVudHMpO1xuICAgICAgICBpZiAodGhpcy5zdXBwbGVtZW50cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBjb25zdCBzdXBwbGVtZW50ID0gdGhpcy5fZGVjb2RlRXh0ZW5zaW9ucyhjb2RlLmVuZCk7XG4gICAgICAgICAgICAvLyBjb25zb2xlLndhcm4oJyogZGVjb2RlRXh0ZW5zaW9ucyByZXR1cm5zJywgc3VwcGxlbWVudCk7XG4gICAgICAgICAgICBpZiAoIXN1cHBsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFzdXBwbGVtZW50LmRlY29kZWRDb2Rlcykge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCBsYXN0Q29kZSA9IHN1cHBsZW1lbnQuZGVjb2RlZENvZGVzW3N1cHBsZW1lbnQuZGVjb2RlZENvZGVzLmxlbmd0aCAtIDFdIGFzIEJhcmNvZGVJbmZvO1xuICAgICAgICAgICAgY29uc3QgZW5kSW5mbyA9IHtcbiAgICAgICAgICAgICAgICBzdGFydDogbGFzdENvZGUuc3RhcnQgKyAoKChsYXN0Q29kZS5lbmQgLSBsYXN0Q29kZS5zdGFydCkgLyAyKSB8IDApLFxuICAgICAgICAgICAgICAgIGVuZDogbGFzdENvZGUuZW5kXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBpZiAoIXRoaXMuX3ZlcmlmeVRyYWlsaW5nV2hpdGVzcGFjZShlbmRJbmZvKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXN1bHRJbmZvID0ge1xuICAgICAgICAgICAgICAgIHN1cHBsZW1lbnQsXG4gICAgICAgICAgICAgICAgY29kZTogcmVzdWx0LmpvaW4oJycpICsgc3VwcGxlbWVudC5jb2RlXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNvZGU6IHJlc3VsdC5qb2luKCcnKSxcbiAgICAgICAgICAgIHN0YXJ0OiBzdGFydEluZm8uc3RhcnQsXG4gICAgICAgICAgICBlbmQ6IGNvZGUuZW5kLFxuICAgICAgICAgICAgc3RhcnRJbmZvLFxuICAgICAgICAgICAgZGVjb2RlZENvZGVzLFxuICAgICAgICAgICAgLi4ucmVzdWx0SW5mbyxcbiAgICAgICAgICAgIGZvcm1hdDogdGhpcy5GT1JNQVQsXG4gICAgICAgIH07XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBFQU5SZWFkZXI7XG4iLCJpbXBvcnQgRUFOUmVhZGVyLCB7IENPREVfR19TVEFSVCB9IGZyb20gJy4vZWFuX3JlYWRlcic7XG5pbXBvcnQgeyBCYXJjb2RlUG9zaXRpb24sIEJhcmNvZGUsIEJhcmNvZGVJbmZvIH0gZnJvbSAnLi9iYXJjb2RlX3JlYWRlcic7XG5cblxuY2xhc3MgRUFOMlJlYWRlciBleHRlbmRzIEVBTlJlYWRlciB7XG4gICAgRk9STUFUID0gJ2Vhbl8yJztcbiAgICBwdWJsaWMgZGVjb2RlKHJvdz86IEFycmF5PG51bWJlcj4sIHN0YXJ0PzogbnVtYmVyKTogQmFyY29kZSB8IG51bGwge1xuICAgICAgICBpZiAocm93KSB7XG4gICAgICAgICAgICB0aGlzLl9yb3cgPSByb3c7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgY29kZUZyZXF1ZW5jeSA9IDA7XG4gICAgICAgIGxldCBvZmZzZXQgPSBzdGFydDtcbiAgICAgICAgY29uc3QgZW5kID0gdGhpcy5fcm93Lmxlbmd0aDtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgICAgIGNvbnN0IGRlY29kZWRDb2RlcyA9IFtdO1xuICAgICAgICBsZXQgY29kZTogQmFyY29kZUluZm8gfCBudWxsID0gbnVsbDtcblxuICAgICAgICBpZiAob2Zmc2V0ID09PSB1bmRlZmluZWQpe1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDIgJiYgb2Zmc2V0IDwgZW5kOyBpKyspIHtcbiAgICAgICAgICAgIGNvZGUgPSB0aGlzLl9kZWNvZGVDb2RlKG9mZnNldCk7XG4gICAgICAgICAgICBpZiAoIWNvZGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlY29kZWRDb2Rlcy5wdXNoKGNvZGUpO1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goY29kZS5jb2RlICUgMTApO1xuICAgICAgICAgICAgaWYgKGNvZGUuY29kZSA+PSBDT0RFX0dfU1RBUlQpIHtcbiAgICAgICAgICAgICAgICBjb2RlRnJlcXVlbmN5IHw9IDEgPDwgKDEgLSBpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpICE9PSAxKSB7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ID0gdGhpcy5fbmV4dFNldCh0aGlzLl9yb3csIGNvZGUuZW5kKTtcbiAgICAgICAgICAgICAgICBvZmZzZXQgPSB0aGlzLl9uZXh0VW5zZXQodGhpcy5fcm93LCBvZmZzZXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJlc3VsdC5sZW5ndGggIT09IDIgfHwgKHBhcnNlSW50KHJlc3VsdC5qb2luKCcnKSkgJSA0KSAhPT0gY29kZUZyZXF1ZW5jeSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBzdGFydEluZm8gPSB0aGlzLl9maW5kU3RhcnQoKTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY29kZTogcmVzdWx0LmpvaW4oJycpLFxuICAgICAgICAgICAgZGVjb2RlZENvZGVzLFxuICAgICAgICAgICAgZW5kOiAoY29kZSBhcyBCYXJjb2RlSW5mbykuZW5kLFxuICAgICAgICAgICAgZm9ybWF0OiB0aGlzLkZPUk1BVCxcbiAgICAgICAgICAgIHN0YXJ0SW5mbzogc3RhcnRJbmZvIGFzIEJhcmNvZGVQb3NpdGlvbixcbiAgICAgICAgICAgIHN0YXJ0OiAoc3RhcnRJbmZvIGFzIEJhcmNvZGVQb3NpdGlvbikuc3RhcnQsXG4gICAgICAgIH07XG4gICAgfVxufTtcblxuZXhwb3J0IGRlZmF1bHQgRUFOMlJlYWRlcjtcbiIsImltcG9ydCBFQU5SZWFkZXIsIHsgQ09ERV9HX1NUQVJUIH0gZnJvbSAnLi9lYW5fcmVhZGVyJztcbmltcG9ydCB7IEJhcmNvZGUsIEJhcmNvZGVQb3NpdGlvbiwgQmFyY29kZUluZm8gfSBmcm9tICcuL2JhcmNvZGVfcmVhZGVyJztcblxuY29uc3QgQ0hFQ0tfRElHSVRfRU5DT0RJTkdTID0gWzI0LCAyMCwgMTgsIDE3LCAxMiwgNiwgMywgMTAsIDksIDVdO1xuXG5mdW5jdGlvbiBkZXRlcm1pbmVDaGVja0RpZ2l0KGNvZGVGcmVxdWVuY3k6IG51bWJlcikge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTA7IGkrKykge1xuICAgICAgICBpZiAoY29kZUZyZXF1ZW5jeSA9PT0gQ0hFQ0tfRElHSVRfRU5DT0RJTkdTW2ldKSB7XG4gICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gZXh0ZW5zaW9uQ2hlY2tzdW0ocmVzdWx0OiBBcnJheTxudW1iZXI+KSB7XG4gICAgY29uc3QgbGVuZ3RoID0gcmVzdWx0Lmxlbmd0aDtcbiAgICBsZXQgc3VtID0gMDtcblxuICAgIGZvciAobGV0IGkgPSBsZW5ndGggLSAyOyBpID49IDA7IGkgLT0gMikge1xuICAgICAgICBzdW0gKz0gcmVzdWx0W2ldO1xuICAgIH1cbiAgICBzdW0gKj0gMztcbiAgICBmb3IgKGxldCBpID0gbGVuZ3RoIC0gMTsgaSA+PSAwOyBpIC09IDIpIHtcbiAgICAgICAgc3VtICs9IHJlc3VsdFtpXTtcbiAgICB9XG4gICAgc3VtICo9IDM7XG4gICAgcmV0dXJuIHN1bSAlIDEwO1xufVxuXG5jbGFzcyBFQU41UmVhZGVyIGV4dGVuZHMgRUFOUmVhZGVyIHtcbiAgICBGT1JNQVQgPSAnZWFuXzUnO1xuICAgIHB1YmxpYyBkZWNvZGUocm93PzogQXJyYXk8bnVtYmVyPiwgc3RhcnQ/OiBudW1iZXIpOiBCYXJjb2RlIHwgbnVsbCB7XG4gICAgICAgIGlmIChzdGFydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyb3cpIHtcbiAgICAgICAgICAgIHRoaXMuX3JvdyA9IHJvdztcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBjb2RlRnJlcXVlbmN5ID0gMDtcbiAgICAgICAgbGV0IG9mZnNldCA9IHN0YXJ0O1xuICAgICAgICBjb25zdCBlbmQgPSB0aGlzLl9yb3cubGVuZ3RoO1xuICAgICAgICBsZXQgY29kZTogQmFyY29kZUluZm8gfCBudWxsID0gbnVsbDtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgICAgIGNvbnN0IGRlY29kZWRDb2RlcyA9IFtdO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNSAmJiBvZmZzZXQgPCBlbmQ7IGkrKykge1xuICAgICAgICAgICAgY29kZSA9IHRoaXMuX2RlY29kZUNvZGUob2Zmc2V0KTtcbiAgICAgICAgICAgIGlmICghY29kZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVjb2RlZENvZGVzLnB1c2goY29kZSk7XG4gICAgICAgICAgICByZXN1bHQucHVzaChjb2RlLmNvZGUgJSAxMCk7XG4gICAgICAgICAgICBpZiAoY29kZS5jb2RlID49IENPREVfR19TVEFSVCkge1xuICAgICAgICAgICAgICAgIGNvZGVGcmVxdWVuY3kgfD0gMSA8PCAoNCAtIGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGkgIT09IDQpIHtcbiAgICAgICAgICAgICAgICBvZmZzZXQgPSB0aGlzLl9uZXh0U2V0KHRoaXMuX3JvdywgY29kZS5lbmQpO1xuICAgICAgICAgICAgICAgIG9mZnNldCA9IHRoaXMuX25leHRVbnNldCh0aGlzLl9yb3csIG9mZnNldCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocmVzdWx0Lmxlbmd0aCAhPT0gNSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXh0ZW5zaW9uQ2hlY2tzdW0ocmVzdWx0KSAhPT0gZGV0ZXJtaW5lQ2hlY2tEaWdpdChjb2RlRnJlcXVlbmN5KSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBzdGFydEluZm8gPSB0aGlzLl9maW5kU3RhcnQoKTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY29kZTogcmVzdWx0LmpvaW4oJycpLFxuICAgICAgICAgICAgZGVjb2RlZENvZGVzLFxuICAgICAgICAgICAgZW5kOiAoY29kZSBhcyBCYXJjb2RlSW5mbykuZW5kLFxuICAgICAgICAgICAgZm9ybWF0OiB0aGlzLkZPUk1BVCxcbiAgICAgICAgICAgIHN0YXJ0SW5mbzogc3RhcnRJbmZvIGFzIEJhcmNvZGVQb3NpdGlvbixcbiAgICAgICAgICAgIHN0YXJ0OiAoc3RhcnRJbmZvIGFzIEJhcmNvZGVQb3NpdGlvbikuc3RhcnQsXG4gICAgICAgIH07XG4gICAgfVxufTtcblxuZXhwb3J0IGRlZmF1bHQgRUFONVJlYWRlcjtcbiIsImltcG9ydCBFQU5SZWFkZXIsIHsgQ09ERV9HX1NUQVJULCBNSURETEVfUEFUVEVSTiB9IGZyb20gJy4vZWFuX3JlYWRlcic7XG5pbXBvcnQgeyBCYXJjb2RlUG9zaXRpb24sIEJhcmNvZGVJbmZvIH0gZnJvbSAnLi9iYXJjb2RlX3JlYWRlcic7XG5cbmNsYXNzIEVBTjhSZWFkZXIgZXh0ZW5kcyBFQU5SZWFkZXIge1xuICAgIEZPUk1BVCA9ICdlYW5fOCc7XG4gICAgcHJvdGVjdGVkIF9kZWNvZGVQYXlsb2FkKGluQ29kZTogQmFyY29kZVBvc2l0aW9uLCByZXN1bHQ6IEFycmF5PG51bWJlcj4sIGRlY29kZWRDb2RlczogQXJyYXk8QmFyY29kZVBvc2l0aW9uPik6IEJhcmNvZGVJbmZvIHwgbnVsbCB7XG4gICAgICAgIGxldCBjb2RlOiBCYXJjb2RlSW5mbyB8IEJhcmNvZGVQb3NpdGlvbiB8IG51bGwgPSBpbkNvZGU7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCA0OyBpKyspIHtcbiAgICAgICAgICAgIGNvZGUgPSB0aGlzLl9kZWNvZGVDb2RlKGNvZGUuZW5kLCBDT0RFX0dfU1RBUlQpO1xuICAgICAgICAgICAgaWYgKCFjb2RlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQucHVzaCgoY29kZSBhcyBCYXJjb2RlSW5mbykuY29kZSk7XG4gICAgICAgICAgICBkZWNvZGVkQ29kZXMucHVzaChjb2RlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvZGUgPSB0aGlzLl9maW5kUGF0dGVybihNSURETEVfUEFUVEVSTiwgY29kZS5lbmQsIHRydWUsIGZhbHNlKTtcbiAgICAgICAgaWYgKGNvZGUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGRlY29kZWRDb2Rlcy5wdXNoKGNvZGUpO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNDsgaSsrKSB7XG4gICAgICAgICAgICBjb2RlID0gdGhpcy5fZGVjb2RlQ29kZShjb2RlLmVuZCwgQ09ERV9HX1NUQVJUKTtcbiAgICAgICAgICAgIGlmICghY29kZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVjb2RlZENvZGVzLnB1c2goY29kZSk7XG4gICAgICAgICAgICByZXN1bHQucHVzaCgoY29kZSBhcyBCYXJjb2RlSW5mbykuY29kZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY29kZSBhcyBCYXJjb2RlSW5mbztcbiAgICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBFQU44UmVhZGVyO1xuIiwiLy8gVE9ETzogaTJvZjVfcmVhZGVyIGFuZCAyb2Y1X3JlYWRlciBzaGFyZSB2ZXJ5IHNpbWlsYXIgY29kZSwgbWFrZSB1c2Ugb2YgdGhhdFxuXG5pbXBvcnQgQmFyY29kZVJlYWRlciwgeyBCYXJjb2RlUmVhZGVyQ29uZmlnLCBCYXJjb2RlSW5mbywgQmFyY29kZVBvc2l0aW9uLCBCYXJjb2RlIH0gZnJvbSAnLi9iYXJjb2RlX3JlYWRlcic7XG5pbXBvcnQgbWVyZ2UgZnJvbSAnbG9kYXNoL21lcmdlJztcblxuY29uc3QgTiA9IDE7XG5jb25zdCBXID0gMztcblxuY2xhc3MgSTJvZjVSZWFkZXIgZXh0ZW5kcyBCYXJjb2RlUmVhZGVyIHtcbiAgICBwcml2YXRlIGJhclNwYWNlUmF0aW8gPSBbMSwgMV07XG4gICAgU0lOR0xFX0NPREVfRVJST1IgPSAwLjc4O1xuICAgIEFWR19DT0RFX0VSUk9SID0gMC4zODtcblxuICAgIFNUQVJUX1BBVFRFUk4gPSBbTiwgTiwgTiwgTl07XG4gICAgU1RPUF9QQVRURVJOID0gW04sIE4sIFddO1xuICAgIENPREVfUEFUVEVSTiA9IFtcbiAgICAgICAgW04sIE4sIFcsIFcsIE5dLFxuICAgICAgICBbVywgTiwgTiwgTiwgV10sXG4gICAgICAgIFtOLCBXLCBOLCBOLCBXXSxcbiAgICAgICAgW1csIFcsIE4sIE4sIE5dLFxuICAgICAgICBbTiwgTiwgVywgTiwgV10sXG4gICAgICAgIFtXLCBOLCBXLCBOLCBOXSxcbiAgICAgICAgW04sIFcsIFcsIE4sIE5dLFxuICAgICAgICBbTiwgTiwgTiwgVywgV10sXG4gICAgICAgIFtXLCBOLCBOLCBXLCBOXSxcbiAgICAgICAgW04sIFcsIE4sIFcsIE5dLFxuICAgIF07XG4gICAgTUFYX0NPUlJFQ1RJT05fRkFDVE9SID0gNTtcbiAgICBGT1JNQVQgPSAnaTJvZjUnO1xuXG4gICAgY29uc3RydWN0b3Iob3B0czogQmFyY29kZVJlYWRlckNvbmZpZykge1xuICAgICAgICBzdXBlcihtZXJnZSh7IG5vcm1hbGl6ZUJhclNwYWNlV2lkdGg6IGZhbHNlIH0sIG9wdHMpKTtcbiAgICAgICAgaWYgKG9wdHMubm9ybWFsaXplQmFyU3BhY2VXaWR0aCkge1xuICAgICAgICAgICAgdGhpcy5TSU5HTEVfQ09ERV9FUlJPUiA9IDAuMzg7XG4gICAgICAgICAgICB0aGlzLkFWR19DT0RFX0VSUk9SID0gMC4wOTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNvbmZpZyA9IG9wdHM7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHByb3RlY3RlZCBfbWF0Y2hQYXR0ZXJuKGNvdW50ZXI6IEFycmF5PG51bWJlcj4sIGNvZGU6IFJlYWRvbmx5QXJyYXk8bnVtYmVyPik6IG51bWJlciB7XG4gICAgICAgIGlmICh0aGlzLmNvbmZpZy5ub3JtYWxpemVCYXJTcGFjZVdpZHRoKSB7XG4gICAgICAgICAgICBjb25zdCBjb3VudGVyU3VtID0gWzAsIDBdO1xuICAgICAgICAgICAgY29uc3QgY29kZVN1bSA9IFswLCAwXTtcbiAgICAgICAgICAgIGNvbnN0IGNvcnJlY3Rpb24gPSBbMCwgMF07XG4gICAgICAgICAgICBjb25zdCBjb3JyZWN0aW9uUmF0aW8gPSB0aGlzLk1BWF9DT1JSRUNUSU9OX0ZBQ1RPUjtcbiAgICAgICAgICAgIGNvbnN0IGNvcnJlY3Rpb25SYXRpb0ludmVyc2UgPSAxIC8gY29ycmVjdGlvblJhdGlvO1xuXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvdW50ZXIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb3VudGVyU3VtW2kgJSAyXSArPSBjb3VudGVyW2ldO1xuICAgICAgICAgICAgICAgIGNvZGVTdW1baSAlIDJdICs9IGNvZGVbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb3JyZWN0aW9uWzBdID0gY29kZVN1bVswXSAvIGNvdW50ZXJTdW1bMF07XG4gICAgICAgICAgICBjb3JyZWN0aW9uWzFdID0gY29kZVN1bVsxXSAvIGNvdW50ZXJTdW1bMV07XG5cbiAgICAgICAgICAgIGNvcnJlY3Rpb25bMF0gPSBNYXRoLm1heChNYXRoLm1pbihjb3JyZWN0aW9uWzBdLCBjb3JyZWN0aW9uUmF0aW8pLCBjb3JyZWN0aW9uUmF0aW9JbnZlcnNlKTtcbiAgICAgICAgICAgIGNvcnJlY3Rpb25bMV0gPSBNYXRoLm1heChNYXRoLm1pbihjb3JyZWN0aW9uWzFdLCBjb3JyZWN0aW9uUmF0aW8pLCBjb3JyZWN0aW9uUmF0aW9JbnZlcnNlKTtcbiAgICAgICAgICAgIHRoaXMuYmFyU3BhY2VSYXRpbyA9IGNvcnJlY3Rpb247XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvdW50ZXIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb3VudGVyW2ldICo9IHRoaXMuYmFyU3BhY2VSYXRpb1tpICUgMl07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN1cGVyLl9tYXRjaFBhdHRlcm4oY291bnRlciwgY29kZSk7XG4gICAgfTtcblxuICAgIHByb3RlY3RlZCBfZmluZFBhdHRlcm4ocGF0dGVybjogUmVhZG9ubHlBcnJheTxudW1iZXI+LCBvZmZzZXQ/OiBudW1iZXIsIGlzV2hpdGU6IGJvb2xlYW4gPSBmYWxzZSwgdHJ5SGFyZGVyOiBib29sZWFuID0gZmFsc2UpOiBCYXJjb2RlUG9zaXRpb24gfCBudWxsIHtcbiAgICAgICAgY29uc3QgY291bnRlciA9IG5ldyBBcnJheTxudW1iZXI+KHBhdHRlcm4ubGVuZ3RoKS5maWxsKDApO1xuICAgICAgICBsZXQgY291bnRlclBvcyA9IDA7XG4gICAgICAgIGNvbnN0IGJlc3RNYXRjaDogQmFyY29kZVBvc2l0aW9uID0ge1xuICAgICAgICAgICAgZXJyb3I6IE51bWJlci5NQVhfVkFMVUUsXG4gICAgICAgICAgICBzdGFydDogMCxcbiAgICAgICAgICAgIGVuZDogMCxcbiAgICAgICAgfTtcblxuICAgICAgICBjb25zdCBlcHNpbG9uID0gdGhpcy5BVkdfQ09ERV9FUlJPUjtcblxuICAgICAgICBpc1doaXRlID0gaXNXaGl0ZSB8fCBmYWxzZTtcbiAgICAgICAgdHJ5SGFyZGVyID0gdHJ5SGFyZGVyIHx8IGZhbHNlO1xuXG4gICAgICAgIGlmICghb2Zmc2V0KSB7XG4gICAgICAgICAgICBvZmZzZXQgPSB0aGlzLl9uZXh0U2V0KHRoaXMuX3Jvdyk7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGxldCBpID0gb2Zmc2V0OyBpIDwgdGhpcy5fcm93Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fcm93W2ldIF4gKGlzV2hpdGUgPyAxIDogMCkpIHtcbiAgICAgICAgICAgICAgICBjb3VudGVyW2NvdW50ZXJQb3NdKys7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChjb3VudGVyUG9zID09PSBjb3VudGVyLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3VtID0gY291bnRlci5yZWR1Y2UoKHByZXYsIG5leHQpID0+IHByZXYgKyBuZXh0LCAwKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZXJyb3IgPSB0aGlzLl9tYXRjaFBhdHRlcm4oY291bnRlciwgcGF0dGVybik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnJvciA8IGVwc2lsb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJlc3RNYXRjaC5lcnJvciA9IGVycm9yO1xuICAgICAgICAgICAgICAgICAgICAgICAgYmVzdE1hdGNoLnN0YXJ0ID0gaSAtIHN1bTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJlc3RNYXRjaC5lbmQgPSBpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJlc3RNYXRjaDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodHJ5SGFyZGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGNvdW50ZXIubGVuZ3RoIC0gMjsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY291bnRlcltqXSA9IGNvdW50ZXJbaiArIDJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY291bnRlcltjb3VudGVyLmxlbmd0aCAtIDJdID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50ZXJbY291bnRlci5sZW5ndGggLSAxXSA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb3VudGVyUG9zLS07XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvdW50ZXJQb3MrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY291bnRlcltjb3VudGVyUG9zXSA9IDE7XG4gICAgICAgICAgICAgICAgaXNXaGl0ZSA9ICFpc1doaXRlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG5cbiAgICBwcm90ZWN0ZWQgX2ZpbmRTdGFydCgpOiBCYXJjb2RlUG9zaXRpb24gfCBudWxsIHtcbiAgICAgICAgbGV0IGxlYWRpbmdXaGl0ZXNwYWNlU3RhcnQgPSAwO1xuICAgICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5fbmV4dFNldCh0aGlzLl9yb3cpO1xuICAgICAgICBsZXQgc3RhcnRJbmZvOiBCYXJjb2RlUG9zaXRpb24gfCBudWxsID0gbnVsbDtcbiAgICAgICAgbGV0IG5hcnJvd0JhcldpZHRoID0gMTtcblxuICAgICAgICB3aGlsZSAoIXN0YXJ0SW5mbykge1xuICAgICAgICAgICAgc3RhcnRJbmZvID0gdGhpcy5fZmluZFBhdHRlcm4odGhpcy5TVEFSVF9QQVRURVJOLCBvZmZzZXQsIGZhbHNlLCB0cnVlKTtcbiAgICAgICAgICAgIGlmICghc3RhcnRJbmZvKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuYXJyb3dCYXJXaWR0aCA9IE1hdGguZmxvb3IoKHN0YXJ0SW5mby5lbmQgLSBzdGFydEluZm8uc3RhcnQpIC8gNCk7XG4gICAgICAgICAgICBsZWFkaW5nV2hpdGVzcGFjZVN0YXJ0ID0gc3RhcnRJbmZvLnN0YXJ0IC0gbmFycm93QmFyV2lkdGggKiAxMDtcbiAgICAgICAgICAgIGlmIChsZWFkaW5nV2hpdGVzcGFjZVN0YXJ0ID49IDApIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fbWF0Y2hSYW5nZShsZWFkaW5nV2hpdGVzcGFjZVN0YXJ0LCBzdGFydEluZm8uc3RhcnQsIDApKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzdGFydEluZm87XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb2Zmc2V0ID0gc3RhcnRJbmZvLmVuZDtcbiAgICAgICAgICAgIHN0YXJ0SW5mbyA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcblxuICAgIHByb3RlY3RlZCBfdmVyaWZ5VHJhaWxpbmdXaGl0ZXNwYWNlKGVuZEluZm86IEJhcmNvZGVQb3NpdGlvbik6IEJhcmNvZGVQb3NpdGlvbiB8IG51bGwge1xuICAgICAgICBjb25zdCB0cmFpbGluZ1doaXRlc3BhY2VFbmQgPSBlbmRJbmZvLmVuZCArICgoZW5kSW5mby5lbmQgLSBlbmRJbmZvLnN0YXJ0KSAvIDIpO1xuICAgICAgICBpZiAodHJhaWxpbmdXaGl0ZXNwYWNlRW5kIDwgdGhpcy5fcm93Lmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX21hdGNoUmFuZ2UoZW5kSW5mby5lbmQsIHRyYWlsaW5nV2hpdGVzcGFjZUVuZCwgMCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZW5kSW5mbztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuXG4gICAgcHJvdGVjdGVkIF9maW5kRW5kKCk6IEJhcmNvZGVQb3NpdGlvbiB8IG51bGwge1xuICAgICAgICB0aGlzLl9yb3cucmV2ZXJzZSgpO1xuICAgICAgICBjb25zdCBlbmRJbmZvID0gdGhpcy5fZmluZFBhdHRlcm4odGhpcy5TVE9QX1BBVFRFUk4pO1xuICAgICAgICB0aGlzLl9yb3cucmV2ZXJzZSgpO1xuXG4gICAgICAgIGlmIChlbmRJbmZvID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHJldmVyc2UgbnVtYmVyc1xuICAgICAgICBjb25zdCB0bXAgPSBlbmRJbmZvLnN0YXJ0O1xuICAgICAgICBlbmRJbmZvLnN0YXJ0ID0gdGhpcy5fcm93Lmxlbmd0aCAtIGVuZEluZm8uZW5kO1xuICAgICAgICBlbmRJbmZvLmVuZCA9IHRoaXMuX3Jvdy5sZW5ndGggLSB0bXA7XG5cbiAgICAgICAgcmV0dXJuIGVuZEluZm8gIT09IG51bGwgPyB0aGlzLl92ZXJpZnlUcmFpbGluZ1doaXRlc3BhY2UoZW5kSW5mbykgOiBudWxsO1xuICAgIH07XG5cbiAgICBwcm90ZWN0ZWQgX2RlY29kZVBhaXIoY291bnRlclBhaXI6IEFycmF5PEFycmF5PG51bWJlcj4+KTogQXJyYXk8QmFyY29kZUluZm8+IHwgbnVsbCB7XG4gICAgICAgIGNvbnN0IGNvZGVzOiBBcnJheTxCYXJjb2RlSW5mbz4gPSBbXTtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvdW50ZXJQYWlyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBjb2RlID0gdGhpcy5fZGVjb2RlQ29kZShjb3VudGVyUGFpcltpXSk7XG4gICAgICAgICAgICBpZiAoIWNvZGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvZGVzLnB1c2goY29kZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvZGVzO1xuICAgIH07XG5cbiAgICBwcm90ZWN0ZWQgX2RlY29kZUNvZGUoY291bnRlcjogQXJyYXk8bnVtYmVyPik6IEJhcmNvZGVJbmZvIHwgbnVsbCB7XG4gICAgICAgIGNvbnN0IGVwc2lsb24gPSB0aGlzLkFWR19DT0RFX0VSUk9SO1xuXG4gICAgICAgIGNvbnN0IGJlc3RNYXRjaDogQmFyY29kZUluZm8gPSB7XG4gICAgICAgICAgICBlcnJvcjogTnVtYmVyLk1BWF9WQUxVRSxcbiAgICAgICAgICAgIGNvZGU6IC0xLFxuICAgICAgICAgICAgc3RhcnQ6IDAsXG4gICAgICAgICAgICBlbmQ6IDAsXG4gICAgICAgIH07XG5cbiAgICAgICAgZm9yIChsZXQgY29kZSA9IDA7IGNvZGUgPCB0aGlzLkNPREVfUEFUVEVSTi5sZW5ndGg7IGNvZGUrKykge1xuICAgICAgICAgICAgY29uc3QgZXJyb3IgPSB0aGlzLl9tYXRjaFBhdHRlcm4oY291bnRlciwgdGhpcy5DT0RFX1BBVFRFUk5bY29kZV0pO1xuICAgICAgICAgICAgaWYgKGVycm9yIDwgYmVzdE1hdGNoLmVycm9yISkge1xuICAgICAgICAgICAgICAgIGJlc3RNYXRjaC5jb2RlID0gY29kZTtcbiAgICAgICAgICAgICAgICBiZXN0TWF0Y2guZXJyb3IgPSBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoYmVzdE1hdGNoLmVycm9yISA8IGVwc2lsb24pIHtcbiAgICAgICAgICAgIHJldHVybiBiZXN0TWF0Y2g7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcblxuICAgIHByb3RlY3RlZCBfZGVjb2RlUGF5bG9hZChjb3VudGVyczogUmVhZG9ubHlBcnJheTxudW1iZXI+LCByZXN1bHQ6IEFycmF5PHN0cmluZz4sIGRlY29kZWRDb2RlczogQXJyYXk8QmFyY29kZUluZm8gfCBCYXJjb2RlUG9zaXRpb24+KTogQXJyYXk8QmFyY29kZUluZm8+IHwgbnVsbCB7XG4gICAgICAgIGxldCBwb3MgPSAwO1xuICAgICAgICBjb25zdCBjb3VudGVyTGVuZ3RoID0gY291bnRlcnMubGVuZ3RoO1xuICAgICAgICBjb25zdCBjb3VudGVyUGFpciA9IFtbMCwgMCwgMCwgMCwgMF0sIFswLCAwLCAwLCAwLCAwXV07XG4gICAgICAgIGxldCBjb2RlczogQmFyY29kZUluZm9bXSB8IG51bGwgPSBudWxsO1xuXG4gICAgICAgIHdoaWxlIChwb3MgPCBjb3VudGVyTGVuZ3RoKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDU7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvdW50ZXJQYWlyWzBdW2ldID0gY291bnRlcnNbcG9zXSAqIHRoaXMuYmFyU3BhY2VSYXRpb1swXTtcbiAgICAgICAgICAgICAgICBjb3VudGVyUGFpclsxXVtpXSA9IGNvdW50ZXJzW3BvcyArIDFdICogdGhpcy5iYXJTcGFjZVJhdGlvWzFdO1xuICAgICAgICAgICAgICAgIHBvcyArPSAyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29kZXMgPSB0aGlzLl9kZWNvZGVQYWlyKGNvdW50ZXJQYWlyKTtcbiAgICAgICAgICAgIGlmICghY29kZXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY29kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChjb2Rlc1tpXS5jb2RlICsgJycpO1xuICAgICAgICAgICAgICAgIGRlY29kZWRDb2Rlcy5wdXNoKGNvZGVzW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29kZXM7XG4gICAgfTtcblxuICAgIHByb3RlY3RlZCBfdmVyaWZ5Q291bnRlckxlbmd0aChjb3VudGVyczogQXJyYXk8bnVtYmVyPikge1xuICAgICAgICByZXR1cm4gKGNvdW50ZXJzLmxlbmd0aCAlIDEwID09PSAwKTtcbiAgICB9O1xuXG4gICAgcHVibGljIGRlY29kZShyb3c/OiBBcnJheTxudW1iZXI+LCBzdGFydD86IEJhcmNvZGVQb3NpdGlvbiB8IG51bWJlcik6IEJhcmNvZGUgfCBudWxsIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IG5ldyBBcnJheTxzdHJpbmc+KCk7XG4gICAgICAgIHZhciBkZWNvZGVkQ29kZXMgPSBuZXcgQXJyYXk8QmFyY29kZVBvc2l0aW9uPigpO1xuXG4gICAgICAgIGNvbnN0IHN0YXJ0SW5mbyA9IHRoaXMuX2ZpbmRTdGFydCgpO1xuICAgICAgICBpZiAoIXN0YXJ0SW5mbykge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZGVjb2RlZENvZGVzLnB1c2goc3RhcnRJbmZvKTtcblxuICAgICAgICBjb25zdCBlbmRJbmZvID0gdGhpcy5fZmluZEVuZCgpO1xuICAgICAgICBpZiAoIWVuZEluZm8pIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgY291bnRlcnMgPSB0aGlzLl9maWxsQ291bnRlcnMoc3RhcnRJbmZvLmVuZCwgZW5kSW5mby5zdGFydCwgZmFsc2UpO1xuICAgICAgICBpZiAoIXRoaXMuX3ZlcmlmeUNvdW50ZXJMZW5ndGgoY291bnRlcnMpKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjb2RlID0gdGhpcy5fZGVjb2RlUGF5bG9hZChjb3VudGVycywgcmVzdWx0LCBkZWNvZGVkQ29kZXMpO1xuICAgICAgICBpZiAoIWNvZGUpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQubGVuZ3RoICUgMiAhPT0gMCB8fFxuICAgICAgICAgICAgICAgIHJlc3VsdC5sZW5ndGggPCA2KSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGRlY29kZWRDb2Rlcy5wdXNoKGVuZEluZm8pO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY29kZTogcmVzdWx0LmpvaW4oJycpLFxuICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0SW5mby5zdGFydCxcbiAgICAgICAgICAgIGVuZDogZW5kSW5mby5lbmQsXG4gICAgICAgICAgICBzdGFydEluZm86IHN0YXJ0SW5mbyxcbiAgICAgICAgICAgIGRlY29kZWRDb2RlczogZGVjb2RlZENvZGVzLFxuICAgICAgICAgICAgZm9ybWF0OiB0aGlzLkZPUk1BVCxcbiAgICAgICAgfTtcbiAgICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBJMm9mNVJlYWRlcjtcbiIsImltcG9ydCBFQU5SZWFkZXIsIHsgQ09ERV9HX1NUQVJUIH0gZnJvbSAnLi9lYW5fcmVhZGVyJztcbmltcG9ydCB7IEJhcmNvZGVQb3NpdGlvbiwgQmFyY29kZUluZm8gfSBmcm9tICcuL2JhcmNvZGVfcmVhZGVyJztcblxuY2xhc3MgVVBDRVJlYWRlciBleHRlbmRzIEVBTlJlYWRlciB7XG4gICAgQ09ERV9GUkVRVUVOQ1kgPSBbXG4gICAgICAgIFsgNTYsIDUyLCA1MCwgNDksIDQ0LCAzOCwgMzUsIDQyLCA0MSwgMzcgXSxcbiAgICAgICAgWzcsIDExLCAxMywgMTQsIDE5LCAyNSwgMjgsIDIxLCAyMiwgMjZdXTtcbiAgICBTVE9QX1BBVFRFUk4gPSBbMSAvIDYgKiA3LCAxIC8gNiAqIDcsIDEgLyA2ICogNywgMSAvIDYgKiA3LCAxIC8gNiAqIDcsIDEgLyA2ICogN107XG4gICAgRk9STUFUID0gJ3VwY19lJztcbiAgICBwcm90ZWN0ZWQgX2RlY29kZVBheWxvYWQoaW5Db2RlOiBCYXJjb2RlUG9zaXRpb24sIHJlc3VsdDogQXJyYXk8bnVtYmVyPiwgZGVjb2RlZENvZGVzOiBBcnJheTxCYXJjb2RlUG9zaXRpb24+KTogQmFyY29kZUluZm8gfCBudWxsIHtcbiAgICAgICAgbGV0IG91dENvZGU6IEJhcmNvZGVJbmZvIHwgQmFyY29kZVBvc2l0aW9uIHwgbnVsbCA9IHsgLi4uaW5Db2RlIH07XG4gICAgICAgIGxldCBjb2RlRnJlcXVlbmN5ID0gMHgwO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNjsgaSsrKSB7XG4gICAgICAgICAgICBvdXRDb2RlID0gdGhpcy5fZGVjb2RlQ29kZShvdXRDb2RlLmVuZCk7XG4gICAgICAgICAgICBpZiAoIW91dENvZGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgob3V0Q29kZSBhcyBCYXJjb2RlSW5mbykuY29kZSA+PSBDT0RFX0dfU1RBUlQpIHtcbiAgICAgICAgICAgICAgICAob3V0Q29kZSBhcyBCYXJjb2RlSW5mbykuY29kZSA9IChvdXRDb2RlIGFzIEJhcmNvZGVJbmZvKS5jb2RlIC0gQ09ERV9HX1NUQVJUO1xuICAgICAgICAgICAgICAgIGNvZGVGcmVxdWVuY3kgfD0gKDEgPDwgKDUgLSBpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQucHVzaCgob3V0Q29kZSBhcyBCYXJjb2RlSW5mbykuY29kZSk7XG4gICAgICAgICAgICBkZWNvZGVkQ29kZXMucHVzaChvdXRDb2RlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuX2RldGVybWluZVBhcml0eShjb2RlRnJlcXVlbmN5LCByZXN1bHQpKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3V0Q29kZSBhcyBCYXJjb2RlSW5mbztcbiAgICB9O1xuXG4gICAgcHJvdGVjdGVkIF9kZXRlcm1pbmVQYXJpdHkoY29kZUZyZXF1ZW5jeTogbnVtYmVyLCByZXN1bHQ6IEFycmF5PG51bWJlcj4pIHtcbiAgICAgICAgZm9yIChsZXQgbnJTeXN0ZW0gPSAwOyBuclN5c3RlbSA8IHRoaXMuQ09ERV9GUkVRVUVOQ1kubGVuZ3RoOyBuclN5c3RlbSsrKXtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5DT0RFX0ZSRVFVRU5DWVtuclN5c3RlbV0ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoY29kZUZyZXF1ZW5jeSA9PT0gdGhpcy5DT0RFX0ZSRVFVRU5DWVtuclN5c3RlbV1baV0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnVuc2hpZnQobnJTeXN0ZW0pO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChpKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuXG4gICAgcHJvdGVjdGVkIF9jb252ZXJ0VG9VUENBKHJlc3VsdDogQXJyYXk8bnVtYmVyPikge1xuICAgICAgICBsZXQgdXBjYSA9IFtyZXN1bHRbMF1dO1xuICAgICAgICBjb25zdCBsYXN0RGlnaXQgPSByZXN1bHRbcmVzdWx0Lmxlbmd0aCAtIDJdO1xuXG4gICAgICAgIGlmIChsYXN0RGlnaXQgPD0gMikge1xuICAgICAgICAgICAgdXBjYSA9IHVwY2EuY29uY2F0KHJlc3VsdC5zbGljZSgxLCAzKSlcbiAgICAgICAgICAgICAgICAuY29uY2F0KFtsYXN0RGlnaXQsIDAsIDAsIDAsIDBdKVxuICAgICAgICAgICAgICAgIC5jb25jYXQocmVzdWx0LnNsaWNlKDMsIDYpKTtcbiAgICAgICAgfSBlbHNlIGlmIChsYXN0RGlnaXQgPT09IDMpIHtcbiAgICAgICAgICAgIHVwY2EgPSB1cGNhLmNvbmNhdChyZXN1bHQuc2xpY2UoMSwgNCkpXG4gICAgICAgICAgICAgICAgLmNvbmNhdChbMCwgMCwgMCwgMCwgMF0pXG4gICAgICAgICAgICAgICAgLmNvbmNhdChyZXN1bHQuc2xpY2UoNCwgNikpO1xuICAgICAgICB9IGVsc2UgaWYgKGxhc3REaWdpdCA9PT0gNCkge1xuICAgICAgICAgICAgdXBjYSA9IHVwY2EuY29uY2F0KHJlc3VsdC5zbGljZSgxLCA1KSlcbiAgICAgICAgICAgICAgICAuY29uY2F0KFswLCAwLCAwLCAwLCAwLCByZXN1bHRbNV1dKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHVwY2EgPSB1cGNhLmNvbmNhdChyZXN1bHQuc2xpY2UoMSwgNikpXG4gICAgICAgICAgICAgICAgLmNvbmNhdChbMCwgMCwgMCwgMCwgbGFzdERpZ2l0XSk7XG4gICAgICAgIH1cblxuICAgICAgICB1cGNhLnB1c2gocmVzdWx0W3Jlc3VsdC5sZW5ndGggLSAxXSk7XG4gICAgICAgIHJldHVybiB1cGNhO1xuICAgIH07XG5cbiAgICBwcm90ZWN0ZWQgX2NoZWNrc3VtKHJlc3VsdDogQXJyYXk8bnVtYmVyPik6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gc3VwZXIuX2NoZWNrc3VtKHRoaXMuX2NvbnZlcnRUb1VQQ0EocmVzdWx0KSk7XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIF9maW5kRW5kKG9mZnNldDogbnVtYmVyLCBpc1doaXRlOiBib29sZWFuKTogQmFyY29kZVBvc2l0aW9uIHwgbnVsbCB7XG4gICAgICAgIHJldHVybiBzdXBlci5fZmluZEVuZChvZmZzZXQsIHRydWUpO1xuICAgIH1cblxuICAgIHByb3RlY3RlZCBfdmVyaWZ5VHJhaWxpbmdXaGl0ZXNwYWNlKGVuZEluZm86IEJhcmNvZGVQb3NpdGlvbik6IEJhcmNvZGVQb3NpdGlvbiB8IG51bGwge1xuICAgICAgICBjb25zdCB0cmFpbGluZ1doaXRlc3BhY2VFbmQgPSBlbmRJbmZvLmVuZCArICgoZW5kSW5mby5lbmQgLSBlbmRJbmZvLnN0YXJ0KSAvIDIpO1xuICAgICAgICBpZiAodHJhaWxpbmdXaGl0ZXNwYWNlRW5kIDwgdGhpcy5fcm93Lmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX21hdGNoUmFuZ2UoZW5kSW5mby5lbmQsIHRyYWlsaW5nV2hpdGVzcGFjZUVuZCwgMCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZW5kSW5mbztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBVUENFUmVhZGVyO1xuIiwiaW1wb3J0IEVBTlJlYWRlciBmcm9tICcuL2Vhbl9yZWFkZXInO1xuaW1wb3J0IHsgQmFyY29kZVBvc2l0aW9uLCBCYXJjb2RlIH0gZnJvbSAnLi9iYXJjb2RlX3JlYWRlcic7XG5cbmNsYXNzIFVQQ1JlYWRlciBleHRlbmRzIEVBTlJlYWRlciB7XG4gICAgRk9STUFUID0gJ3VwY19hJztcbiAgICBkZWNvZGUocm93PzogQXJyYXk8bnVtYmVyPiwgc3RhcnQ/OiBCYXJjb2RlUG9zaXRpb24gfCBudW1iZXIpOiBCYXJjb2RlIHwgbnVsbCB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IEVBTlJlYWRlci5wcm90b3R5cGUuZGVjb2RlLmNhbGwodGhpcyk7XG5cbiAgICAgICAgaWYgKHJlc3VsdCAmJiByZXN1bHQuY29kZSAmJiByZXN1bHQuY29kZS5sZW5ndGggPT09IDEzICYmIHJlc3VsdC5jb2RlLmNoYXJBdCgwKSA9PT0gJzAnKSB7XG4gICAgICAgICAgICByZXN1bHQuY29kZSA9IHJlc3VsdC5jb2RlLnN1YnN0cmluZygxKTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBVUENSZWFkZXI7XG4iLCJjb25zdCBCcmVzZW5oYW0gPSB7fTtcblxuY29uc3QgU2xvcGUgPSB7XG4gICAgRElSOiB7XG4gICAgICAgIFVQOiAxLFxuICAgICAgICBET1dOOiAtMSxcbiAgICB9LFxufTtcbi8qKlxuICogU2NhbnMgYSBsaW5lIG9mIHRoZSBnaXZlbiBpbWFnZSBmcm9tIHBvaW50IHAxIHRvIHAyIGFuZCByZXR1cm5zIGEgcmVzdWx0IG9iamVjdCBjb250YWluaW5nXG4gKiBncmF5LXNjYWxlIHZhbHVlcyAoMC0yNTUpIG9mIHRoZSB1bmRlcmx5aW5nIHBpeGVscyBpbiBhZGRpdGlvbiB0byB0aGUgbWluXG4gKiBhbmQgbWF4IHZhbHVlcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBpbWFnZVdyYXBwZXJcbiAqIEBwYXJhbSB7T2JqZWN0fSBwMSBUaGUgc3RhcnQgcG9pbnQge3gseX1cbiAqIEBwYXJhbSB7T2JqZWN0fSBwMiBUaGUgZW5kIHBvaW50IHt4LHl9XG4gKiBAcmV0dXJucyB7bGluZSwgbWluLCBtYXh9XG4gKi9cbkJyZXNlbmhhbS5nZXRCYXJjb2RlTGluZSA9IGZ1bmN0aW9uIChpbWFnZVdyYXBwZXIsIHAxLCBwMikge1xuICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLWJpdHdpc2UgKi9cbiAgICBsZXQgeDAgPSBwMS54IHwgMDtcbiAgICBsZXQgeTAgPSBwMS55IHwgMDtcbiAgICBsZXQgeDEgPSBwMi54IHwgMDtcbiAgICBsZXQgeTEgPSBwMi55IHwgMDtcbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1iaXR3aXNlICovXG4gICAgY29uc3Qgc3RlZXAgPSBNYXRoLmFicyh5MSAtIHkwKSA+IE1hdGguYWJzKHgxIC0geDApO1xuICAgIGxldCBlcnJvcjtcbiAgICBsZXQgeTtcbiAgICBsZXQgdG1wO1xuICAgIGxldCB4O1xuICAgIGNvbnN0IGxpbmUgPSBbXTtcbiAgICBjb25zdCBpbWFnZURhdGEgPSBpbWFnZVdyYXBwZXIuZGF0YTtcbiAgICBjb25zdCB3aWR0aCA9IGltYWdlV3JhcHBlci5zaXplLng7XG4gICAgbGV0IHZhbDtcbiAgICBsZXQgbWluID0gMjU1O1xuICAgIGxldCBtYXggPSAwO1xuXG4gICAgZnVuY3Rpb24gcmVhZChhLCBiKSB7XG4gICAgICAgIHZhbCA9IGltYWdlRGF0YVtiICogd2lkdGggKyBhXTtcbiAgICAgICAgbWluID0gdmFsIDwgbWluID8gdmFsIDogbWluO1xuICAgICAgICBtYXggPSB2YWwgPiBtYXggPyB2YWwgOiBtYXg7XG4gICAgICAgIGxpbmUucHVzaCh2YWwpO1xuICAgIH1cblxuICAgIGlmIChzdGVlcCkge1xuICAgICAgICB0bXAgPSB4MDtcbiAgICAgICAgeDAgPSB5MDtcbiAgICAgICAgeTAgPSB0bXA7XG5cbiAgICAgICAgdG1wID0geDE7XG4gICAgICAgIHgxID0geTE7XG4gICAgICAgIHkxID0gdG1wO1xuICAgIH1cbiAgICBpZiAoeDAgPiB4MSkge1xuICAgICAgICB0bXAgPSB4MDtcbiAgICAgICAgeDAgPSB4MTtcbiAgICAgICAgeDEgPSB0bXA7XG5cbiAgICAgICAgdG1wID0geTA7XG4gICAgICAgIHkwID0geTE7XG4gICAgICAgIHkxID0gdG1wO1xuICAgIH1cbiAgICBjb25zdCBkZWx0YVggPSB4MSAtIHgwO1xuICAgIGNvbnN0IGRlbHRhWSA9IE1hdGguYWJzKHkxIC0geTApO1xuICAgIGVycm9yID0gKGRlbHRhWCAvIDIpIHwgMDtcbiAgICB5ID0geTA7XG4gICAgY29uc3QgeVN0ZXAgPSB5MCA8IHkxID8gMSA6IC0xO1xuICAgIGZvciAoeCA9IHgwOyB4IDwgeDE7IHgrKykge1xuICAgICAgICBpZiAoc3RlZXApIHtcbiAgICAgICAgICAgIHJlYWQoeSwgeCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZWFkKHgsIHkpO1xuICAgICAgICB9XG4gICAgICAgIGVycm9yIC09IGRlbHRhWTtcbiAgICAgICAgaWYgKGVycm9yIDwgMCkge1xuICAgICAgICAgICAgeSArPSB5U3RlcDtcbiAgICAgICAgICAgIGVycm9yICs9IGRlbHRhWDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICAgIGxpbmUsXG4gICAgICAgIG1pbixcbiAgICAgICAgbWF4LFxuICAgIH07XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIHRoZSByZXN1bHQgZnJvbSBnZXRCYXJjb2RlTGluZSBpbnRvIGEgYmluYXJ5IHJlcHJlc2VudGF0aW9uXG4gKiBhbHNvIGNvbnNpZGVyaW5nIHRoZSBmcmVxdWVuY3kgYW5kIHNsb3BlIG9mIHRoZSBzaWduYWwgZm9yIG1vcmUgcm9idXN0IHJlc3VsdHNcbiAqIEBwYXJhbSB7T2JqZWN0fSByZXN1bHQge2xpbmUsIG1pbiwgbWF4fVxuICovXG5CcmVzZW5oYW0udG9CaW5hcnlMaW5lID0gZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgIGNvbnN0IHsgbWluIH0gPSByZXN1bHQ7XG4gICAgY29uc3QgeyBtYXggfSA9IHJlc3VsdDtcbiAgICBjb25zdCB7IGxpbmUgfSA9IHJlc3VsdDtcbiAgICBsZXQgc2xvcGU7XG4gICAgbGV0IHNsb3BlMjtcbiAgICBjb25zdCBjZW50ZXIgPSBtaW4gKyAobWF4IC0gbWluKSAvIDI7XG4gICAgY29uc3QgZXh0cmVtYSA9IFtdO1xuICAgIGxldCBjdXJyZW50RGlyO1xuICAgIGxldCBkaXI7XG4gICAgbGV0IHRocmVzaG9sZCA9IChtYXggLSBtaW4pIC8gMTI7XG4gICAgY29uc3QgclRocmVzaG9sZCA9IC10aHJlc2hvbGQ7XG4gICAgbGV0IGk7XG4gICAgbGV0IGo7XG5cbiAgICAvLyAxLiBmaW5kIGV4dHJlbWFcbiAgICBjdXJyZW50RGlyID0gbGluZVswXSA+IGNlbnRlciA/IFNsb3BlLkRJUi5VUCA6IFNsb3BlLkRJUi5ET1dOO1xuICAgIGV4dHJlbWEucHVzaCh7XG4gICAgICAgIHBvczogMCxcbiAgICAgICAgdmFsOiBsaW5lWzBdLFxuICAgIH0pO1xuICAgIGZvciAoaSA9IDA7IGkgPCBsaW5lLmxlbmd0aCAtIDI7IGkrKykge1xuICAgICAgICBzbG9wZSA9IChsaW5lW2kgKyAxXSAtIGxpbmVbaV0pO1xuICAgICAgICBzbG9wZTIgPSAobGluZVtpICsgMl0gLSBsaW5lW2kgKyAxXSk7XG4gICAgICAgIGlmICgoc2xvcGUgKyBzbG9wZTIpIDwgclRocmVzaG9sZCAmJiBsaW5lW2kgKyAxXSA8IChjZW50ZXIgKiAxLjUpKSB7XG4gICAgICAgICAgICBkaXIgPSBTbG9wZS5ESVIuRE9XTjtcbiAgICAgICAgfSBlbHNlIGlmICgoc2xvcGUgKyBzbG9wZTIpID4gdGhyZXNob2xkICYmIGxpbmVbaSArIDFdID4gKGNlbnRlciAqIDAuNSkpIHtcbiAgICAgICAgICAgIGRpciA9IFNsb3BlLkRJUi5VUDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRpciA9IGN1cnJlbnREaXI7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY3VycmVudERpciAhPT0gZGlyKSB7XG4gICAgICAgICAgICBleHRyZW1hLnB1c2goe1xuICAgICAgICAgICAgICAgIHBvczogaSxcbiAgICAgICAgICAgICAgICB2YWw6IGxpbmVbaV0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGN1cnJlbnREaXIgPSBkaXI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZXh0cmVtYS5wdXNoKHtcbiAgICAgICAgcG9zOiBsaW5lLmxlbmd0aCxcbiAgICAgICAgdmFsOiBsaW5lW2xpbmUubGVuZ3RoIC0gMV0sXG4gICAgfSk7XG5cbiAgICBmb3IgKGogPSBleHRyZW1hWzBdLnBvczsgaiA8IGV4dHJlbWFbMV0ucG9zOyBqKyspIHtcbiAgICAgICAgbGluZVtqXSA9IGxpbmVbal0gPiBjZW50ZXIgPyAwIDogMTtcbiAgICB9XG5cbiAgICAvLyBpdGVyYXRlIG92ZXIgZXh0cmVtYSBhbmQgY29udmVydCB0byBiaW5hcnkgYmFzZWQgb24gYXZnIGJldHdlZW4gbWlubWF4XG4gICAgZm9yIChpID0gMTsgaSA8IGV4dHJlbWEubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgIGlmIChleHRyZW1hW2kgKyAxXS52YWwgPiBleHRyZW1hW2ldLnZhbCkge1xuICAgICAgICAgICAgdGhyZXNob2xkID0gKGV4dHJlbWFbaV0udmFsICsgKChleHRyZW1hW2kgKyAxXS52YWwgLSBleHRyZW1hW2ldLnZhbCkgLyAzKSAqIDIpIHwgMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocmVzaG9sZCA9IChleHRyZW1hW2kgKyAxXS52YWwgKyAoKGV4dHJlbWFbaV0udmFsIC0gZXh0cmVtYVtpICsgMV0udmFsKSAvIDMpKSB8IDA7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGogPSBleHRyZW1hW2ldLnBvczsgaiA8IGV4dHJlbWFbaSArIDFdLnBvczsgaisrKSB7XG4gICAgICAgICAgICBsaW5lW2pdID0gbGluZVtqXSA+IHRocmVzaG9sZCA/IDAgOiAxO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgbGluZSxcbiAgICAgICAgdGhyZXNob2xkLFxuICAgIH07XG59O1xuXG4vKipcbiAqIFVzZWQgZm9yIGRldmVsb3BtZW50IG9ubHlcbiAqL1xuQnJlc2VuaGFtLmRlYnVnID0ge1xuICAgIHByaW50RnJlcXVlbmN5KGxpbmUsIGNhbnZhcykge1xuICAgICAgICBsZXQgaTtcbiAgICAgICAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgICBjYW52YXMud2lkdGggPSBsaW5lLmxlbmd0aDtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICAgIGNhbnZhcy5oZWlnaHQgPSAyNTY7XG5cbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSAnYmx1ZSc7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsaW5lLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjdHgubW92ZVRvKGksIDI1NSk7XG4gICAgICAgICAgICBjdHgubGluZVRvKGksIDI1NSAtIGxpbmVbaV0pO1xuICAgICAgICB9XG4gICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgIH0sXG5cbiAgICBwcmludFBhdHRlcm4obGluZSwgY2FudmFzKSB7XG4gICAgICAgIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpOyBsZXRcbiAgICAgICAgICAgIGk7XG5cbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICAgIGNhbnZhcy53aWR0aCA9IGxpbmUubGVuZ3RoO1xuICAgICAgICBjdHguZmlsbENvbG9yID0gJ2JsYWNrJztcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxpbmUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChsaW5lW2ldID09PSAxKSB7XG4gICAgICAgICAgICAgICAgY3R4LmZpbGxSZWN0KGksIDAsIDEsIDEwMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxufTtcblxuZXhwb3J0IGRlZmF1bHQgQnJlc2VuaGFtO1xuIiwiLyogZXNsaW50LWRpc2FibGUgaW1wb3J0L25vLWN5Y2xlICovXG5cbmltcG9ydCBJbWFnZURlYnVnIGZyb20gJy4uL2NvbW1vbi9pbWFnZV9kZWJ1Zyc7XG5pbXBvcnQgVHdvT2ZGaXZlUmVhZGVyIGZyb20gJy4uL3JlYWRlci8yb2Y1X3JlYWRlcic7XG5pbXBvcnQgQ29kYWJhclJlYWRlciBmcm9tICcuLi9yZWFkZXIvY29kYWJhcl9yZWFkZXInO1xuaW1wb3J0IENvZGUxMjhSZWFkZXIgZnJvbSAnLi4vcmVhZGVyL2NvZGVfMTI4X3JlYWRlcic7XG5pbXBvcnQgQ29kZTMyUmVhZGVyIGZyb20gJy4uL3JlYWRlci9jb2RlXzMyX3JlYWRlcic7XG5pbXBvcnQgQ29kZTM5UmVhZGVyIGZyb20gJy4uL3JlYWRlci9jb2RlXzM5X3JlYWRlcic7XG5pbXBvcnQgQ29kZTM5VklOUmVhZGVyIGZyb20gJy4uL3JlYWRlci9jb2RlXzM5X3Zpbl9yZWFkZXInO1xuaW1wb3J0IENvZGU5M1JlYWRlciBmcm9tICcuLi9yZWFkZXIvY29kZV85M19yZWFkZXInO1xuaW1wb3J0IEVBTjJSZWFkZXIgZnJvbSAnLi4vcmVhZGVyL2Vhbl8yX3JlYWRlcic7XG5pbXBvcnQgRUFONVJlYWRlciBmcm9tICcuLi9yZWFkZXIvZWFuXzVfcmVhZGVyJztcbmltcG9ydCBFQU44UmVhZGVyIGZyb20gJy4uL3JlYWRlci9lYW5fOF9yZWFkZXInO1xuaW1wb3J0IEVBTlJlYWRlciBmcm9tICcuLi9yZWFkZXIvZWFuX3JlYWRlcic7XG5pbXBvcnQgSTJvZjVSZWFkZXIgZnJvbSAnLi4vcmVhZGVyL2kyb2Y1X3JlYWRlcic7XG5pbXBvcnQgVVBDRVJlYWRlciBmcm9tICcuLi9yZWFkZXIvdXBjX2VfcmVhZGVyJztcbmltcG9ydCBVUENSZWFkZXIgZnJvbSAnLi4vcmVhZGVyL3VwY19yZWFkZXInO1xuaW1wb3J0IEJyZXNlbmhhbSBmcm9tICcuL2JyZXNlbmhhbSc7XG5cbmNvbnN0IFJFQURFUlMgPSB7XG4gICAgY29kZV8xMjhfcmVhZGVyOiBDb2RlMTI4UmVhZGVyLFxuICAgIGVhbl9yZWFkZXI6IEVBTlJlYWRlcixcbiAgICBlYW5fNV9yZWFkZXI6IEVBTjVSZWFkZXIsXG4gICAgZWFuXzJfcmVhZGVyOiBFQU4yUmVhZGVyLFxuICAgIGVhbl84X3JlYWRlcjogRUFOOFJlYWRlcixcbiAgICBjb2RlXzM5X3JlYWRlcjogQ29kZTM5UmVhZGVyLFxuICAgIGNvZGVfMzlfdmluX3JlYWRlcjogQ29kZTM5VklOUmVhZGVyLFxuICAgIGNvZGFiYXJfcmVhZGVyOiBDb2RhYmFyUmVhZGVyLFxuICAgIHVwY19yZWFkZXI6IFVQQ1JlYWRlcixcbiAgICB1cGNfZV9yZWFkZXI6IFVQQ0VSZWFkZXIsXG4gICAgaTJvZjVfcmVhZGVyOiBJMm9mNVJlYWRlcixcbiAgICAnMm9mNV9yZWFkZXInOiBUd29PZkZpdmVSZWFkZXIsXG4gICAgY29kZV85M19yZWFkZXI6IENvZGU5M1JlYWRlcixcbiAgICBjb2RlXzMyX3JlYWRlcjogQ29kZTMyUmVhZGVyLFxufTtcblxuZXhwb3J0IGRlZmF1bHQge1xuICAgIHJlZ2lzdGVyUmVhZGVyOiAobmFtZSwgcmVhZGVyKSA9PiB7XG4gICAgICAgIFJFQURFUlNbbmFtZV0gPSByZWFkZXI7XG4gICAgfSxcbiAgICBjcmVhdGUoY29uZmlnLCBpbnB1dEltYWdlV3JhcHBlcikge1xuICAgICAgICBjb25zdCBfY2FudmFzID0ge1xuICAgICAgICAgICAgY3R4OiB7XG4gICAgICAgICAgICAgICAgZnJlcXVlbmN5OiBudWxsLFxuICAgICAgICAgICAgICAgIHBhdHRlcm46IG51bGwsXG4gICAgICAgICAgICAgICAgb3ZlcmxheTogbnVsbCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkb206IHtcbiAgICAgICAgICAgICAgICBmcmVxdWVuY3k6IG51bGwsXG4gICAgICAgICAgICAgICAgcGF0dGVybjogbnVsbCxcbiAgICAgICAgICAgICAgICBvdmVybGF5OiBudWxsLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgX2JhcmNvZGVSZWFkZXJzID0gW107XG5cbiAgICAgICAgaW5pdENhbnZhcygpO1xuICAgICAgICBpbml0UmVhZGVycygpO1xuICAgICAgICBpbml0Q29uZmlnKCk7XG5cbiAgICAgICAgZnVuY3Rpb24gaW5pdENhbnZhcygpIHtcbiAgICAgICAgICAgIGlmIChFTlYuZGV2ZWxvcG1lbnQgJiYgdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIGNvbnN0ICRkZWJ1ZyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyNkZWJ1Zy5kZXRlY3Rpb24nKTtcbiAgICAgICAgICAgICAgICBfY2FudmFzLmRvbS5mcmVxdWVuY3kgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdjYW52YXMuZnJlcXVlbmN5Jyk7XG4gICAgICAgICAgICAgICAgaWYgKCFfY2FudmFzLmRvbS5mcmVxdWVuY3kpIHtcbiAgICAgICAgICAgICAgICAgICAgX2NhbnZhcy5kb20uZnJlcXVlbmN5ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgICAgICAgICAgICAgICAgIF9jYW52YXMuZG9tLmZyZXF1ZW5jeS5jbGFzc05hbWUgPSAnZnJlcXVlbmN5JztcbiAgICAgICAgICAgICAgICAgICAgaWYgKCRkZWJ1Zykge1xuICAgICAgICAgICAgICAgICAgICAgICAgJGRlYnVnLmFwcGVuZENoaWxkKF9jYW52YXMuZG9tLmZyZXF1ZW5jeSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgX2NhbnZhcy5jdHguZnJlcXVlbmN5ID0gX2NhbnZhcy5kb20uZnJlcXVlbmN5LmdldENvbnRleHQoJzJkJyk7XG5cbiAgICAgICAgICAgICAgICBfY2FudmFzLmRvbS5wYXR0ZXJuID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignY2FudmFzLnBhdHRlcm5CdWZmZXInKTtcbiAgICAgICAgICAgICAgICBpZiAoIV9jYW52YXMuZG9tLnBhdHRlcm4pIHtcbiAgICAgICAgICAgICAgICAgICAgX2NhbnZhcy5kb20ucGF0dGVybiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgICAgICAgICAgICAgICAgICBfY2FudmFzLmRvbS5wYXR0ZXJuLmNsYXNzTmFtZSA9ICdwYXR0ZXJuQnVmZmVyJztcbiAgICAgICAgICAgICAgICAgICAgaWYgKCRkZWJ1Zykge1xuICAgICAgICAgICAgICAgICAgICAgICAgJGRlYnVnLmFwcGVuZENoaWxkKF9jYW52YXMuZG9tLnBhdHRlcm4pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF9jYW52YXMuY3R4LnBhdHRlcm4gPSBfY2FudmFzLmRvbS5wYXR0ZXJuLmdldENvbnRleHQoJzJkJyk7XG5cbiAgICAgICAgICAgICAgICBfY2FudmFzLmRvbS5vdmVybGF5ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignY2FudmFzLmRyYXdpbmdCdWZmZXInKTtcbiAgICAgICAgICAgICAgICBpZiAoX2NhbnZhcy5kb20ub3ZlcmxheSkge1xuICAgICAgICAgICAgICAgICAgICBfY2FudmFzLmN0eC5vdmVybGF5ID0gX2NhbnZhcy5kb20ub3ZlcmxheS5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGluaXRSZWFkZXJzKCkge1xuICAgICAgICAgICAgY29uZmlnLnJlYWRlcnMuZm9yRWFjaCgocmVhZGVyQ29uZmlnKSA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IHJlYWRlcjtcbiAgICAgICAgICAgICAgICBsZXQgY29uZmlndXJhdGlvbiA9IHt9O1xuICAgICAgICAgICAgICAgIGxldCBzdXBwbGVtZW50cyA9IFtdO1xuXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiByZWFkZXJDb25maWcgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlciA9IHJlYWRlckNvbmZpZy5mb3JtYXQ7XG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZ3VyYXRpb24gPSByZWFkZXJDb25maWcuY29uZmlnO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHJlYWRlckNvbmZpZyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyID0gcmVhZGVyQ29uZmlnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoRU5WLmRldmVsb3BtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdCZWZvcmUgcmVnaXN0ZXJpbmcgcmVhZGVyOiAnLCByZWFkZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoY29uZmlndXJhdGlvbi5zdXBwbGVtZW50cykge1xuICAgICAgICAgICAgICAgICAgICBzdXBwbGVtZW50cyA9IGNvbmZpZ3VyYXRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgIC5zdXBwbGVtZW50cy5tYXAoKHN1cHBsZW1lbnQpID0+IG5ldyBSRUFERVJTW3N1cHBsZW1lbnRdKCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZWFkZXJPYmogPSBuZXcgUkVBREVSU1tyZWFkZXJdKGNvbmZpZ3VyYXRpb24sIHN1cHBsZW1lbnRzKTtcbiAgICAgICAgICAgICAgICAgICAgX2JhcmNvZGVSZWFkZXJzLnB1c2gocmVhZGVyT2JqKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignKiBFcnJvciBjb25zdHJ1Y3RpbmcgcmVhZGVyICcsIHJlYWRlciwgZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKEVOVi5kZXZlbG9wbWVudCkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBSZWdpc3RlcmVkIFJlYWRlcnM6ICR7X2JhcmNvZGVSZWFkZXJzXG4gICAgICAgICAgICAgICAgICAgIC5tYXAoKHJlYWRlcikgPT4gSlNPTi5zdHJpbmdpZnkoeyBmb3JtYXQ6IHJlYWRlci5GT1JNQVQsIGNvbmZpZzogcmVhZGVyLmNvbmZpZyB9KSlcbiAgICAgICAgICAgICAgICAgICAgLmpvaW4oJywgJyl9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBpbml0Q29uZmlnKCkge1xuICAgICAgICAgICAgaWYgKEVOVi5kZXZlbG9wbWVudCAmJiB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgbGV0IGk7XG4gICAgICAgICAgICAgICAgY29uc3QgdmlzID0gW3tcbiAgICAgICAgICAgICAgICAgICAgbm9kZTogX2NhbnZhcy5kb20uZnJlcXVlbmN5LFxuICAgICAgICAgICAgICAgICAgICBwcm9wOiBjb25maWcuZGVidWcuc2hvd0ZyZXF1ZW5jeSxcbiAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGU6IF9jYW52YXMuZG9tLnBhdHRlcm4sXG4gICAgICAgICAgICAgICAgICAgIHByb3A6IGNvbmZpZy5kZWJ1Zy5zaG93UGF0dGVybixcbiAgICAgICAgICAgICAgICB9XTtcblxuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCB2aXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZpc1tpXS5wcm9wID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2aXNbaV0ubm9kZS5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZpc1tpXS5ub2RlLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogZXh0ZW5kIHRoZSBsaW5lIG9uIGJvdGggZW5kc1xuICAgICAgICAgKiBAcGFyYW0ge0FycmF5fSBsaW5lXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhbmdsZVxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gZ2V0RXh0ZW5kZWRMaW5lKGxpbmUsIGFuZ2xlLCBleHQpIHtcbiAgICAgICAgICAgIGZ1bmN0aW9uIGV4dGVuZExpbmUoYW1vdW50KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZXh0ZW5zaW9uID0ge1xuICAgICAgICAgICAgICAgICAgICB5OiBhbW91bnQgKiBNYXRoLnNpbihhbmdsZSksXG4gICAgICAgICAgICAgICAgICAgIHg6IGFtb3VudCAqIE1hdGguY29zKGFuZ2xlKSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLXBhcmFtLXJlYXNzaWduICovXG4gICAgICAgICAgICAgICAgbGluZVswXS55IC09IGV4dGVuc2lvbi55O1xuICAgICAgICAgICAgICAgIGxpbmVbMF0ueCAtPSBleHRlbnNpb24ueDtcbiAgICAgICAgICAgICAgICBsaW5lWzFdLnkgKz0gZXh0ZW5zaW9uLnk7XG4gICAgICAgICAgICAgICAgbGluZVsxXS54ICs9IGV4dGVuc2lvbi54O1xuICAgICAgICAgICAgICAgIC8qIGVzbGludC1lbmFibGUgbm8tcGFyYW0tcmVhc3NpZ24gKi9cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gY2hlY2sgaWYgaW5zaWRlIGltYWdlXG4gICAgICAgICAgICBleHRlbmRMaW5lKGV4dCk7XG4gICAgICAgICAgICB3aGlsZSAoZXh0ID4gMSAmJiAoIWlucHV0SW1hZ2VXcmFwcGVyLmluSW1hZ2VXaXRoQm9yZGVyKGxpbmVbMF0pXG4gICAgICAgICAgICAgICAgICAgIHx8ICFpbnB1dEltYWdlV3JhcHBlci5pbkltYWdlV2l0aEJvcmRlcihsaW5lWzFdKSkpIHtcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgICAgICAgICAgICBleHQgLT0gTWF0aC5jZWlsKGV4dCAvIDIpO1xuICAgICAgICAgICAgICAgIGV4dGVuZExpbmUoLWV4dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbGluZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGdldExpbmUoYm94KSB7XG4gICAgICAgICAgICByZXR1cm4gW3tcbiAgICAgICAgICAgICAgICB4OiAoYm94WzFdWzBdIC0gYm94WzBdWzBdKSAvIDIgKyBib3hbMF1bMF0sXG4gICAgICAgICAgICAgICAgeTogKGJveFsxXVsxXSAtIGJveFswXVsxXSkgLyAyICsgYm94WzBdWzFdLFxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIHg6IChib3hbM11bMF0gLSBib3hbMl1bMF0pIC8gMiArIGJveFsyXVswXSxcbiAgICAgICAgICAgICAgICB5OiAoYm94WzNdWzFdIC0gYm94WzJdWzFdKSAvIDIgKyBib3hbMl1bMV0sXG4gICAgICAgICAgICB9XTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHRyeURlY29kZShsaW5lKSB7XG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gbnVsbDtcbiAgICAgICAgICAgIGxldCBpO1xuICAgICAgICAgICAgY29uc3QgYmFyY29kZUxpbmUgPSBCcmVzZW5oYW0uZ2V0QmFyY29kZUxpbmUoaW5wdXRJbWFnZVdyYXBwZXIsIGxpbmVbMF0sIGxpbmVbMV0pO1xuXG4gICAgICAgICAgICBpZiAoRU5WLmRldmVsb3BtZW50ICYmIGNvbmZpZy5kZWJ1Zy5zaG93RnJlcXVlbmN5KSB7XG4gICAgICAgICAgICAgICAgSW1hZ2VEZWJ1Zy5kcmF3UGF0aChsaW5lLCB7IHg6ICd4JywgeTogJ3knIH0sIF9jYW52YXMuY3R4Lm92ZXJsYXksIHsgY29sb3I6ICdyZWQnLCBsaW5lV2lkdGg6IDMgfSk7XG4gICAgICAgICAgICAgICAgQnJlc2VuaGFtLmRlYnVnLnByaW50RnJlcXVlbmN5KGJhcmNvZGVMaW5lLmxpbmUsIF9jYW52YXMuZG9tLmZyZXF1ZW5jeSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIEJyZXNlbmhhbS50b0JpbmFyeUxpbmUoYmFyY29kZUxpbmUpO1xuXG4gICAgICAgICAgICBpZiAoRU5WLmRldmVsb3BtZW50ICYmIGNvbmZpZy5kZWJ1Zy5zaG93UGF0dGVybikge1xuICAgICAgICAgICAgICAgIEJyZXNlbmhhbS5kZWJ1Zy5wcmludFBhdHRlcm4oYmFyY29kZUxpbmUubGluZSwgX2NhbnZhcy5kb20ucGF0dGVybik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBfYmFyY29kZVJlYWRlcnMubGVuZ3RoICYmIHJlc3VsdCA9PT0gbnVsbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gX2JhcmNvZGVSZWFkZXJzW2ldLmRlY29kZVBhdHRlcm4oYmFyY29kZUxpbmUubGluZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVzdWx0ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGNvZGVSZXN1bHQ6IHJlc3VsdCxcbiAgICAgICAgICAgICAgICBiYXJjb2RlTGluZSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhpcyBtZXRob2Qgc2xpY2VzIHRoZSBnaXZlbiBhcmVhIGFwYXJ0IGFuZCB0cmllcyB0byBkZXRlY3QgYSBiYXJjb2RlLXBhdHRlcm5cbiAgICAgICAgICogZm9yIGVhY2ggc2xpY2UuIEl0IHJldHVybnMgdGhlIGRlY29kZWQgYmFyY29kZSwgb3IgbnVsbCBpZiBub3RoaW5nIHdhcyBmb3VuZFxuICAgICAgICAgKiBAcGFyYW0ge0FycmF5fSBib3hcbiAgICAgICAgICogQHBhcmFtIHtBcnJheX0gbGluZVxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gbGluZUFuZ2xlXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiB0cnlEZWNvZGVCcnV0ZUZvcmNlKGJveCwgbGluZSwgbGluZUFuZ2xlKSB7XG4gICAgICAgICAgICBjb25zdCBzaWRlTGVuZ3RoID0gTWF0aC5zcXJ0KE1hdGgucG93KGJveFsxXVswXSAtIGJveFswXVswXSwgMikgKyBNYXRoLnBvdygoYm94WzFdWzFdIC0gYm94WzBdWzFdKSwgMikpO1xuICAgICAgICAgICAgbGV0IGk7XG4gICAgICAgICAgICBjb25zdCBzbGljZXMgPSAxNjtcbiAgICAgICAgICAgIGxldCByZXN1bHQgPSBudWxsO1xuICAgICAgICAgICAgbGV0IGRpcjtcbiAgICAgICAgICAgIGxldCBleHRlbnNpb247XG4gICAgICAgICAgICBjb25zdCB4ZGlyID0gTWF0aC5zaW4obGluZUFuZ2xlKTtcbiAgICAgICAgICAgIGNvbnN0IHlkaXIgPSBNYXRoLmNvcyhsaW5lQW5nbGUpO1xuXG4gICAgICAgICAgICBmb3IgKGkgPSAxOyBpIDwgc2xpY2VzICYmIHJlc3VsdCA9PT0gbnVsbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgLy8gbW92ZSBsaW5lIHBlcnBlbmRpY3VsYXIgdG8gYW5nbGVcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbWl4ZWQtb3BlcmF0b3JzXG4gICAgICAgICAgICAgICAgZGlyID0gc2lkZUxlbmd0aCAvIHNsaWNlcyAqIGkgKiAoaSAlIDIgPT09IDAgPyAtMSA6IDEpO1xuICAgICAgICAgICAgICAgIGV4dGVuc2lvbiA9IHtcbiAgICAgICAgICAgICAgICAgICAgeTogZGlyICogeGRpcixcbiAgICAgICAgICAgICAgICAgICAgeDogZGlyICogeWRpcixcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLXBhcmFtLXJlYXNzaWduICovXG4gICAgICAgICAgICAgICAgbGluZVswXS55ICs9IGV4dGVuc2lvbi54O1xuICAgICAgICAgICAgICAgIGxpbmVbMF0ueCAtPSBleHRlbnNpb24ueTtcbiAgICAgICAgICAgICAgICBsaW5lWzFdLnkgKz0gZXh0ZW5zaW9uLng7XG4gICAgICAgICAgICAgICAgbGluZVsxXS54IC09IGV4dGVuc2lvbi55O1xuICAgICAgICAgICAgICAgIC8qIGVzbGludC1lbmFibGUgbm8tcGFyYW0tcmVhc3NpZ24gKi9cblxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHRyeURlY29kZShsaW5lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBnZXRMaW5lTGVuZ3RoKGxpbmUpIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLnNxcnQoXG4gICAgICAgICAgICAgICAgTWF0aC5wb3coTWF0aC5hYnMobGluZVsxXS55IC0gbGluZVswXS55KSwgMilcbiAgICAgICAgICAgICAgICArIE1hdGgucG93KE1hdGguYWJzKGxpbmVbMV0ueCAtIGxpbmVbMF0ueCksIDIpLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGFzeW5jIGZ1bmN0aW9uIGRlY29kZUZyb21JbWFnZShpbWFnZVdyYXBwZXIpIHtcbiAgICAgICAgICAgIGxldCByZXN1bHQgPSBudWxsO1xuICAgICAgICAgICAgZm9yIChjb25zdCByZWFkZXIgb2YgX2JhcmNvZGVSZWFkZXJzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlYWRlci5kZWNvZGVJbWFnZSkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBhd2FpdCByZWFkZXIuZGVjb2RlSW1hZ2UoaW1hZ2VXcmFwcGVyKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaXRoIHRoZSBoZWxwIG9mIHRoZSBjb25maWd1cmVkIHJlYWRlcnMgKENvZGUxMjggb3IgRUFOKSB0aGlzIGZ1bmN0aW9uIHRyaWVzIHRvIGRldGVjdCBhXG4gICAgICAgICAqIHZhbGlkIGJhcmNvZGUgcGF0dGVybiB3aXRoaW4gdGhlIGdpdmVuIGFyZWEuXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBib3ggVGhlIGFyZWEgdG8gc2VhcmNoIGluXG4gICAgICAgICAqIEByZXR1cm5zIHtPYmplY3R9IHRoZSByZXN1bHQge2NvZGVSZXN1bHQsIGxpbmUsIGFuZ2xlLCBwYXR0ZXJuLCB0aHJlc2hvbGR9XG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBkZWNvZGVGcm9tQm91bmRpbmdCb3goYm94KSB7XG4gICAgICAgICAgICBsZXQgbGluZTtcbiAgICAgICAgICAgIGNvbnN0IGN0eCA9IF9jYW52YXMuY3R4Lm92ZXJsYXk7XG4gICAgICAgICAgICBsZXQgcmVzdWx0O1xuXG4gICAgICAgICAgICBpZiAoRU5WLmRldmVsb3BtZW50KSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvbmZpZy5kZWJ1Zy5kcmF3Qm91bmRpbmdCb3ggJiYgY3R4KSB7XG4gICAgICAgICAgICAgICAgICAgIEltYWdlRGVidWcuZHJhd1BhdGgoYm94LCB7IHg6IDAsIHk6IDEgfSwgY3R4LCB7IGNvbG9yOiAnYmx1ZScsIGxpbmVXaWR0aDogMiB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxpbmUgPSBnZXRMaW5lKGJveCk7XG4gICAgICAgICAgICBjb25zdCBsaW5lTGVuZ3RoID0gZ2V0TGluZUxlbmd0aChsaW5lKTtcbiAgICAgICAgICAgIGNvbnN0IGxpbmVBbmdsZSA9IE1hdGguYXRhbjIobGluZVsxXS55IC0gbGluZVswXS55LCBsaW5lWzFdLnggLSBsaW5lWzBdLngpO1xuICAgICAgICAgICAgbGluZSA9IGdldEV4dGVuZGVkTGluZShsaW5lLCBsaW5lQW5nbGUsIE1hdGguZmxvb3IobGluZUxlbmd0aCAqIDAuMSkpO1xuICAgICAgICAgICAgaWYgKGxpbmUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmVzdWx0ID0gdHJ5RGVjb2RlKGxpbmUpO1xuICAgICAgICAgICAgaWYgKHJlc3VsdCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHRyeURlY29kZUJydXRlRm9yY2UoYm94LCBsaW5lLCBsaW5lQW5nbGUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAocmVzdWx0ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChFTlYuZGV2ZWxvcG1lbnQgJiYgcmVzdWx0ICYmIGNvbmZpZy5kZWJ1Zy5kcmF3U2NhbmxpbmUgJiYgY3R4KSB7XG4gICAgICAgICAgICAgICAgSW1hZ2VEZWJ1Zy5kcmF3UGF0aChsaW5lLCB7IHg6ICd4JywgeTogJ3knIH0sIGN0eCwgeyBjb2xvcjogJ3JlZCcsIGxpbmVXaWR0aDogMyB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBjb2RlUmVzdWx0OiByZXN1bHQuY29kZVJlc3VsdCxcbiAgICAgICAgICAgICAgICBsaW5lLFxuICAgICAgICAgICAgICAgIGFuZ2xlOiBsaW5lQW5nbGUsXG4gICAgICAgICAgICAgICAgcGF0dGVybjogcmVzdWx0LmJhcmNvZGVMaW5lLmxpbmUsXG4gICAgICAgICAgICAgICAgdGhyZXNob2xkOiByZXN1bHQuYmFyY29kZUxpbmUudGhyZXNob2xkLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkZWNvZGVGcm9tQm91bmRpbmdCb3goYm94KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlY29kZUZyb21Cb3VuZGluZ0JveChib3gpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGRlY29kZUZyb21Cb3VuZGluZ0JveGVzKGJveGVzKSB7XG4gICAgICAgICAgICAgICAgbGV0IGk7IGxldCByZXN1bHQ7XG4gICAgICAgICAgICAgICAgY29uc3QgYmFyY29kZXMgPSBbXTtcbiAgICAgICAgICAgICAgICBjb25zdCB7IG11bHRpcGxlIH0gPSBjb25maWc7XG5cbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgYm94ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYm94ID0gYm94ZXNbaV07XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGRlY29kZUZyb21Cb3VuZGluZ0JveChib3gpIHx8IHt9O1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQuYm94ID0gYm94O1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChtdWx0aXBsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYmFyY29kZXMucHVzaChyZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHJlc3VsdC5jb2RlUmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgYmFyY29kZXMsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBhc3luYyBkZWNvZGVGcm9tSW1hZ2UoaW1hZ2VXcmFwcGVySW4pIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBkZWNvZGVGcm9tSW1hZ2UoaW1hZ2VXcmFwcGVySW4pO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcmVnaXN0ZXJSZWFkZXIobmFtZSwgcmVhZGVyKSB7XG4gICAgICAgICAgICAgICAgaWYgKFJFQURFUlNbbmFtZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjYW5ub3QgcmVnaXN0ZXIgZXhpc3RpbmcgcmVhZGVyJywgbmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFJFQURFUlNbbmFtZV0gPSByZWFkZXI7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2V0UmVhZGVycyhyZWFkZXJzKSB7XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICAgICAgICAgICAgY29uZmlnLnJlYWRlcnMgPSByZWFkZXJzO1xuICAgICAgICAgICAgICAgIF9iYXJjb2RlUmVhZGVycy5sZW5ndGggPSAwO1xuICAgICAgICAgICAgICAgIGluaXRSZWFkZXJzKCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgIH0sXG59O1xuIiwiaW1wb3J0IEJhcmNvZGVSZWFkZXIgZnJvbSAnLi9iYXJjb2RlX3JlYWRlcic7XG5pbXBvcnQgVHdvT2ZGaXZlUmVhZGVyIGZyb20gJy4vMm9mNV9yZWFkZXInO1xuaW1wb3J0IE5ld0NvZGFiYXJSZWFkZXIgZnJvbSAnLi9jb2RhYmFyX3JlYWRlcic7XG5pbXBvcnQgQ29kZTEyOFJlYWRlciBmcm9tICcuL2NvZGVfMTI4X3JlYWRlcic7XG5pbXBvcnQgQ29kZTMyUmVhZGVyIGZyb20gJy4vY29kZV8zMl9yZWFkZXInO1xuaW1wb3J0IENvZGUzOVJlYWRlciBmcm9tICcuL2NvZGVfMzlfcmVhZGVyJztcbmltcG9ydCBDb2RlMzlWSU5SZWFkZXIgZnJvbSAnLi9jb2RlXzM5X3Zpbl9yZWFkZXInO1xuaW1wb3J0IENvZGU5M1JlYWRlciBmcm9tICcuL2NvZGVfOTNfcmVhZGVyJztcbmltcG9ydCBFQU4yUmVhZGVyIGZyb20gJy4vZWFuXzJfcmVhZGVyJztcbmltcG9ydCBFQU41UmVhZGVyIGZyb20gJy4vZWFuXzVfcmVhZGVyJztcbmltcG9ydCBFQU44UmVhZGVyIGZyb20gJy4vZWFuXzhfcmVhZGVyJztcbmltcG9ydCBFQU5SZWFkZXIgZnJvbSAnLi9lYW5fcmVhZGVyJztcbmltcG9ydCBJMm9mNVJlYWRlciBmcm9tICcuL2kyb2Y1X3JlYWRlcic7XG5pbXBvcnQgVVBDRVJlYWRlciBmcm9tICcuL3VwY19lX3JlYWRlcic7XG5pbXBvcnQgVVBDUmVhZGVyIGZyb20gJy4vdXBjX3JlYWRlcic7XG5cbmV4cG9ydCB7XG4gICAgQmFyY29kZVJlYWRlcixcbiAgICBUd29PZkZpdmVSZWFkZXIsXG4gICAgTmV3Q29kYWJhclJlYWRlcixcbiAgICBDb2RlMTI4UmVhZGVyLFxuICAgIENvZGUzMlJlYWRlcixcbiAgICBDb2RlMzlSZWFkZXIsXG4gICAgQ29kZTM5VklOUmVhZGVyLFxuICAgIENvZGU5M1JlYWRlcixcbiAgICBFQU4yUmVhZGVyLFxuICAgIEVBTjVSZWFkZXIsXG4gICAgRUFOOFJlYWRlcixcbiAgICBFQU5SZWFkZXIsXG4gICAgSTJvZjVSZWFkZXIsXG4gICAgVVBDRVJlYWRlcixcbiAgICBVUENSZWFkZXIsICAgIFxufVxuIiwidHlwZSBFdmVudE5hbWUgPSBzdHJpbmc7XG5cbmludGVyZmFjZSBTdWJzY3JpcHRpb24ge1xuICAgIGFzeW5jPzogYm9vbGVhbjtcbiAgICBjYWxsYmFjazogRnVuY3Rpb247XG4gICAgb25jZT86IGJvb2xlYW47XG59XG5cbmludGVyZmFjZSBFdmVudERhdGEge1xuICAgIHN1YnNjcmliZXJzOiBBcnJheTxTdWJzY3JpcHRpb24+O1xufVxuXG5pbnRlcmZhY2UgRXZlbnRzIHtcbiAgICBba2V5OiBzdHJpbmddOiBFdmVudERhdGE7XG59XG5cbmludGVyZmFjZSBFdmVudEludGVyZmFjZSB7XG4gICAgc3Vic2NyaWJlKGV2ZW50OiBFdmVudE5hbWUsIGNhbGxiYWNrOiBGdW5jdGlvbiB8IFN1YnNjcmlwdGlvbiwgYXN5bmM/OiBib29sZWFuKTogdm9pZDtcbiAgICBwdWJsaXNoKGV2ZW50TmFtZTogRXZlbnROYW1lLCBkYXRhPzogbmV2ZXIpOiB2b2lkO1xuICAgIG9uY2UoZXZlbnQ6IEV2ZW50TmFtZSwgY2FsbGJhY2s6IEZ1bmN0aW9uLCBhc3luYz86IGJvb2xlYW4pOiB2b2lkO1xuICAgIHVuc3Vic2NyaWJlKGV2ZW50TmFtZT86IEV2ZW50TmFtZSwgY2FsbGJhY2s/OiBGdW5jdGlvbiB8IFN1YnNjcmlwdGlvbik6IHZvaWQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IChmdW5jdGlvbiBFdmVudEludGVyZmFjZSgpOiBFdmVudEludGVyZmFjZSB7XG4gICAgbGV0IGV2ZW50czogRXZlbnRzID0ge307XG5cbiAgICBmdW5jdGlvbiBnZXRFdmVudChldmVudE5hbWU6IEV2ZW50TmFtZSk6IEV2ZW50RGF0YSB7XG4gICAgICAgIGlmICghZXZlbnRzW2V2ZW50TmFtZV0pIHtcbiAgICAgICAgICAgIGV2ZW50c1tldmVudE5hbWVdID0ge1xuICAgICAgICAgICAgICAgIHN1YnNjcmliZXJzOiBbXSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGV2ZW50c1tldmVudE5hbWVdO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNsZWFyRXZlbnRzKCk6IHZvaWQge1xuICAgICAgICBldmVudHMgPSB7fTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwdWJsaXNoU3Vic2NyaXB0aW9uKHN1YnNjcmlwdGlvbjogU3Vic2NyaXB0aW9uLCBkYXRhOiBuZXZlcik6IHZvaWQge1xuICAgICAgICBpZiAoc3Vic2NyaXB0aW9uLmFzeW5jKSB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICBzdWJzY3JpcHRpb24uY2FsbGJhY2soZGF0YSk7XG4gICAgICAgICAgICB9LCA0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN1YnNjcmlwdGlvbi5jYWxsYmFjayhkYXRhKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9zdWJzY3JpYmUoZXZlbnQ6IEV2ZW50TmFtZSwgY2FsbGJhY2s6IEZ1bmN0aW9uIHwgU3Vic2NyaXB0aW9uLCBhc3luYz86IGJvb2xlYW4pOiB2b2lkIHtcbiAgICAgICAgbGV0IHN1YnNjcmlwdGlvbjtcblxuICAgICAgICBpZiAodHlwZW9mIGNhbGxiYWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBzdWJzY3JpcHRpb24gPSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2ssXG4gICAgICAgICAgICAgICAgYXN5bmMsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3Vic2NyaXB0aW9uID0gY2FsbGJhY2s7XG4gICAgICAgICAgICBpZiAoIXN1YnNjcmlwdGlvbi5jYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2FsbGJhY2sgd2FzIG5vdCBzcGVjaWZpZWQgb24gb3B0aW9ucycpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZ2V0RXZlbnQoZXZlbnQpLnN1YnNjcmliZXJzLnB1c2goc3Vic2NyaXB0aW9uKTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBzdWJzY3JpYmUoZXZlbnQ6IEV2ZW50TmFtZSwgY2FsbGJhY2s6IEZ1bmN0aW9uIHwgU3Vic2NyaXB0aW9uLCBhc3luYz86IGJvb2xlYW4pOiB2b2lkIHtcbiAgICAgICAgICAgIHJldHVybiBfc3Vic2NyaWJlKGV2ZW50LCBjYWxsYmFjaywgYXN5bmMpO1xuICAgICAgICB9LFxuICAgICAgICBwdWJsaXNoKGV2ZW50TmFtZTogRXZlbnROYW1lLCBkYXRhPzogbmV2ZXIpOiB2b2lkIHtcbiAgICAgICAgICAgIGNvbnN0IGV2ZW50ID0gZ2V0RXZlbnQoZXZlbnROYW1lKTtcbiAgICAgICAgICAgIGNvbnN0IHsgc3Vic2NyaWJlcnMgfSA9IGV2ZW50O1xuXG4gICAgICAgICAgICAvLyBQdWJsaXNoIG9uZS10aW1lIHN1YnNjcmlwdGlvbnNcbiAgICAgICAgICAgIHN1YnNjcmliZXJzLmZpbHRlcigoc3Vic2NyaWJlcikgPT4gISFzdWJzY3JpYmVyLm9uY2UpLmZvckVhY2goKHN1YnNjcmliZXIpID0+IHtcbiAgICAgICAgICAgICAgICBwdWJsaXNoU3Vic2NyaXB0aW9uKHN1YnNjcmliZXIsIGRhdGEgYXMgbmV2ZXIpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIHJlbW92ZSB0aGVtIGZyb20gdGhlIHN1YnNjcmliZXJcbiAgICAgICAgICAgIGV2ZW50LnN1YnNjcmliZXJzID0gc3Vic2NyaWJlcnMuZmlsdGVyKChzdWJzY3JpYmVyKSA9PiAhc3Vic2NyaWJlci5vbmNlKTtcblxuICAgICAgICAgICAgLy8gcHVibGlzaCB0aGUgcmVzdFxuICAgICAgICAgICAgZXZlbnQuc3Vic2NyaWJlcnMuZm9yRWFjaCgoc3Vic2NyaWJlcikgPT4ge1xuICAgICAgICAgICAgICAgIHB1Ymxpc2hTdWJzY3JpcHRpb24oc3Vic2NyaWJlciwgZGF0YSBhcyBuZXZlcik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgb25jZShldmVudDogRXZlbnROYW1lLCBjYWxsYmFjazogRnVuY3Rpb24sIGFzeW5jID0gZmFsc2UpOiB2b2lkIHtcbiAgICAgICAgICAgIF9zdWJzY3JpYmUoZXZlbnQsIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayxcbiAgICAgICAgICAgICAgICBhc3luYyxcbiAgICAgICAgICAgICAgICBvbmNlOiB0cnVlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIHVuc3Vic2NyaWJlKGV2ZW50TmFtZT86IEV2ZW50TmFtZSwgY2FsbGJhY2s/OiBGdW5jdGlvbiB8IFN1YnNjcmlwdGlvbik6IHZvaWQge1xuICAgICAgICAgICAgaWYgKGV2ZW50TmFtZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGV2ZW50ID0gZ2V0RXZlbnQoZXZlbnROYW1lKTtcbiAgICAgICAgICAgICAgICBpZiAoZXZlbnQgJiYgY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQuc3Vic2NyaWJlcnMgPSBldmVudC5zdWJzY3JpYmVycy5maWx0ZXIoKHN1YnNjcmliZXIpID0+IHN1YnNjcmliZXIuY2FsbGJhY2sgIT09IGNhbGxiYWNrKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBldmVudC5zdWJzY3JpYmVycyA9IFtdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY2xlYXJFdmVudHMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICB9O1xufSgpKTtcbiIsImV4cG9ydCBkZWZhdWx0IGNsYXNzIEV4Y2VwdGlvbiBleHRlbmRzIEVycm9yIHtcbiAgICBjb2RlPzogbnVtYmVyO1xuXG4gICAgY29uc3RydWN0b3IobTogc3RyaW5nLCBjb2RlPzogbnVtYmVyKSB7XG4gICAgICAgIHN1cGVyKG0pO1xuICAgICAgICB0aGlzLmNvZGUgPSBjb2RlO1xuICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YodGhpcywgRXhjZXB0aW9uLnByb3RvdHlwZSk7XG4gICAgfVxufVxuIiwiaW1wb3J0IEV4Y2VwdGlvbiBmcm9tICcuLi9xdWFnZ2EvRXhjZXB0aW9uJztcblxuY29uc3QgRVJST1JfREVTQyA9ICdUaGlzIG1heSBtZWFuIHRoYXQgdGhlIHVzZXIgaGFzIGRlY2xpbmVkIGNhbWVyYSBhY2Nlc3MsIG9yIHRoZSBicm93c2VyIGRvZXMgbm90IHN1cHBvcnQgbWVkaWEgQVBJcy4gSWYgeW91IGFyZSBydW5uaW5nIGluIGlPUywgeW91IG11c3QgdXNlIFNhZmFyaS4nO1xuXG5leHBvcnQgZnVuY3Rpb24gZW51bWVyYXRlRGV2aWNlcygpOiBQcm9taXNlPEFycmF5PE1lZGlhRGV2aWNlSW5mbz4+IHtcbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5lbnVtZXJhdGVEZXZpY2VzKCk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGNvbnN0IGVycm9yOiBFcnJvciA9IG5ldyBFeGNlcHRpb24oYGVudW1lcmF0ZURldmljZXMgaXMgbm90IGRlZmluZWQuICR7RVJST1JfREVTQ31gLCAtMSk7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnJvcik7XG4gICAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0VXNlck1lZGlhKGNvbnN0cmFpbnRzOiBNZWRpYVN0cmVhbUNvbnN0cmFpbnRzKTogUHJvbWlzZTxNZWRpYVN0cmVhbT4ge1xuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFVzZXJNZWRpYShjb25zdHJhaW50cyk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGNvbnN0IGVycm9yOiBFcnJvciA9IG5ldyBFeGNlcHRpb24oYGdldFVzZXJNZWRpYSBpcyBub3QgZGVmaW5lZC4gJHtFUlJPUl9ERVNDfWAsIC0xKTtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycm9yKTtcbiAgICB9XG59XG4iLCIvLyBUT0RPOiB3aGVuIHRoaXMgZmlsZSB3YXMgd3JpdHRlbiB5ZWFycyBhZ28sIEhUTUxNZWRpYUVsZW1lbnQucGxheSgpIGRpZCBub3QgcmV0dXJuIGEgdXNlZnVsIHZhbHVlXG4vLyB0byBsZXQgdXMga25vdyB3aGVuIHRoZSB2aWRlbyBzdGFydGVkIHBsYXlpbmcuICBOb3csIGl0IGRvZXMuICBTbywgd2Ugc2hvdWxkbid0IG5lZWQgdG8gcnVuIHRoaXNcbi8vIG9kZCB3YWl0Rm9yVmlkZW8oKSBmdW5jdGlvbiB0aGF0IHBvbGxzIHRvIHNlZSBpZiB0aGUgdmlkZW8gaGFzIHN0YXJ0ZWQuXG5pbXBvcnQgcGljayBmcm9tICdsb2Rhc2gvcGljayc7XG5pbXBvcnQgeyBnZXRVc2VyTWVkaWEsIGVudW1lcmF0ZURldmljZXMgfSBmcm9tICcuLi9jb21tb24vbWVkaWFEZXZpY2VzJztcbmltcG9ydCBFeGNlcHRpb24gZnJvbSAnLi4vcXVhZ2dhL0V4Y2VwdGlvbic7XG5pbXBvcnQgdHlwZSB7XG4gICAgTWVkaWFUcmFja0NvbnN0cmFpbnRzV2l0aERlcHJlY2F0ZWQsXG4gICAgUXVhZ2dhSlNDYW1lcmFBY2Nlc3MgYXMgQ2FtZXJhQWNjZXNzVHlwZSxcbn0gZnJvbSAnLi4vLi4vdHlwZS1kZWZpbml0aW9ucy9xdWFnZ2EuZCc7XG5cbmxldCBzdHJlYW1SZWY6IE1lZGlhU3RyZWFtIHwgbnVsbDtcblxuZnVuY3Rpb24gd2FpdEZvclZpZGVvKHZpZGVvOiBIVE1MVmlkZW9FbGVtZW50KTogUHJvbWlzZTx2b2lkPiB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgbGV0IGF0dGVtcHRzID0gMTA7XG5cbiAgICAgICAgZnVuY3Rpb24gY2hlY2tWaWRlbygpOiB2b2lkIHtcbiAgICAgICAgICAgIGlmIChhdHRlbXB0cyA+IDApIHtcbiAgICAgICAgICAgICAgICBpZiAodmlkZW8udmlkZW9XaWR0aCA+IDEwICYmIHZpZGVvLnZpZGVvSGVpZ2h0ID4gMTApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKEVOVi5kZXZlbG9wbWVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coYCogZGV2OiBjaGVja1ZpZGVvIGZvdW5kICR7dmlkZW8udmlkZW9XaWR0aH1weCB4ICR7dmlkZW8udmlkZW9IZWlnaHR9cHhgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgd2luZG93LnNldFRpbWVvdXQoY2hlY2tWaWRlbywgNTAwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlamVjdChuZXcgRXhjZXB0aW9uKCdVbmFibGUgdG8gcGxheSB2aWRlbyBzdHJlYW0uIElzIHdlYmNhbSB3b3JraW5nPycsIC0xKSk7IC8vIFRPRE86IGFkZCBlcnJvciBjb2RlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhdHRlbXB0cy0tO1xuICAgICAgICB9XG4gICAgICAgIGNoZWNrVmlkZW8oKTtcbiAgICB9KTtcbn1cblxuLyoqXG4gKiBUcmllcyB0byBhdHRhY2ggdGhlIGNhbWVyYS1zdHJlYW0gdG8gYSBnaXZlbiB2aWRlby1lbGVtZW50XG4gKiBhbmQgY2FsbHMgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uIHdoZW4gdGhlIGNvbnRlbnQgaXMgcmVhZHlcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb25zdHJhaW50c1xuICogQHBhcmFtIHtPYmplY3R9IHZpZGVvXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGluaXRDYW1lcmEodmlkZW86IEhUTUxWaWRlb0VsZW1lbnQgfCBudWxsLCBjb25zdHJhaW50czogTWVkaWFTdHJlYW1Db25zdHJhaW50cyk6IFByb21pc2U8dm9pZD4ge1xuICAgIGNvbnN0IHN0cmVhbSA9IGF3YWl0IGdldFVzZXJNZWRpYShjb25zdHJhaW50cyk7XG4gICAgc3RyZWFtUmVmID0gc3RyZWFtO1xuICAgIGlmICh2aWRlbykge1xuICAgICAgICB2aWRlby5zZXRBdHRyaWJ1dGUoJ2F1dG9wbGF5JywgJ3RydWUnKTtcbiAgICAgICAgdmlkZW8uc2V0QXR0cmlidXRlKCdtdXRlZCcsICd0cnVlJyk7XG4gICAgICAgIHZpZGVvLnNldEF0dHJpYnV0ZSgncGxheXNpbmxpbmUnLCAndHJ1ZScpOyAvLyBub3QgbGlzdGVkIG9uIE1ETi4uLlxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgICAgdmlkZW8uc3JjT2JqZWN0ID0gc3RyZWFtO1xuICAgICAgICB2aWRlby5hZGRFdmVudExpc3RlbmVyKCdsb2FkZWRtZXRhZGF0YScsICgpID0+IHtcbiAgICAgICAgICAgIHZpZGVvLnBsYXkoKS5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCcqIEVycm9yIHdoaWxlIHRyeWluZyB0byBwbGF5IHZpZGVvIHN0cmVhbTonLCBlcnIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gd2FpdEZvclZpZGVvKHZpZGVvKTtcbiAgICB9XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xufVxuXG5mdW5jdGlvbiBkZXByZWNhdGVkQ29uc3RyYWludHModmlkZW9Db25zdHJhaW50czogTWVkaWFUcmFja0NvbnN0cmFpbnRzV2l0aERlcHJlY2F0ZWQpOiBNZWRpYVRyYWNrQ29uc3RyYWludHMge1xuICAgIGNvbnN0IG5vcm1hbGl6ZWQgPSBwaWNrKHZpZGVvQ29uc3RyYWludHMsIFsnd2lkdGgnLCAnaGVpZ2h0JywgJ2ZhY2luZ01vZGUnLFxuICAgICAgICAnYXNwZWN0UmF0aW8nLCAnZGV2aWNlSWQnXSk7XG5cbiAgICBpZiAodHlwZW9mIHZpZGVvQ29uc3RyYWludHMubWluQXNwZWN0UmF0aW8gIT09ICd1bmRlZmluZWQnXG4gICAgICAgICAgICAmJiB2aWRlb0NvbnN0cmFpbnRzLm1pbkFzcGVjdFJhdGlvID4gMCkge1xuICAgICAgICBub3JtYWxpemVkLmFzcGVjdFJhdGlvID0gdmlkZW9Db25zdHJhaW50cy5taW5Bc3BlY3RSYXRpbztcbiAgICAgICAgY29uc29sZS5sb2coJ1dBUk5JTkc6IENvbnN0cmFpbnQgXFwnbWluQXNwZWN0UmF0aW9cXCcgaXMgZGVwcmVjYXRlZDsgVXNlIFxcJ2FzcGVjdFJhdGlvXFwnIGluc3RlYWQnKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB2aWRlb0NvbnN0cmFpbnRzLmZhY2luZyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgbm9ybWFsaXplZC5mYWNpbmdNb2RlID0gdmlkZW9Db25zdHJhaW50cy5mYWNpbmc7XG4gICAgICAgIGNvbnNvbGUubG9nKCdXQVJOSU5HOiBDb25zdHJhaW50IFxcJ2ZhY2luZ1xcJyBpcyBkZXByZWNhdGVkLiBVc2UgXFwnZmFjaW5nTW9kZVxcJyBpbnN0ZWFkXFwnJyk7XG4gICAgfVxuICAgIHJldHVybiBub3JtYWxpemVkO1xufVxuXG4vLyBUT0RPOiAjMTkyIEkgZG9uJ3QgdGhpbmsgdGhlcmUncyBhbnkgZ29vZCByZWFzb24gcGlja0NvbnN0cmFpbnRzIHNob3VsZCByZXR1cm4gYSBQcm9taXNlLFxuLy8gSSB0aGluayBpdCB3YXMganVzdCB0aGF0IHdheSBzbyBpdCBjb3VsZCBiZSBjaGFpbmVkIHRvIG90aGVyIGZ1bmN0aW9ucyB0aGF0IGRpZCByZXR1cm4gYSBQcm9taXNlLlxuLy8gVGhhdCdzIG5vdCBuZWNlc3Nhcnkgd2l0aCBhc3luYyBmdW5jdGlvbnMgYmVpbmcgYSB0aGluZywgc28gdGhhdCBzaG91bGQgYmUgZml4ZWQuXG5leHBvcnQgZnVuY3Rpb24gcGlja0NvbnN0cmFpbnRzKHZpZGVvQ29uc3RyYWludHM6IE1lZGlhVHJhY2tDb25zdHJhaW50c1dpdGhEZXByZWNhdGVkID0ge30pOiBQcm9taXNlPE1lZGlhU3RyZWFtQ29uc3RyYWludHM+IHtcbiAgICBjb25zdCB2aWRlbyA9IGRlcHJlY2F0ZWRDb25zdHJhaW50cyh2aWRlb0NvbnN0cmFpbnRzKTtcblxuICAgIGlmICh2aWRlbyAmJiB2aWRlby5kZXZpY2VJZCAmJiB2aWRlby5mYWNpbmdNb2RlKSB7XG4gICAgICAgIGRlbGV0ZSB2aWRlby5mYWNpbmdNb2RlO1xuICAgIH1cbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHsgYXVkaW86IGZhbHNlLCB2aWRlbyB9KTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gZW51bWVyYXRlVmlkZW9EZXZpY2VzKCk6IFByb21pc2U8QXJyYXk8TWVkaWFEZXZpY2VJbmZvPj4ge1xuICAgIGNvbnN0IGRldmljZXMgPSBhd2FpdCBlbnVtZXJhdGVEZXZpY2VzKCk7XG4gICAgcmV0dXJuIGRldmljZXMuZmlsdGVyKChkZXZpY2U6IE1lZGlhRGV2aWNlSW5mbykgPT4gZGV2aWNlLmtpbmQgPT09ICd2aWRlb2lucHV0Jyk7XG59XG5cbmZ1bmN0aW9uIGdldEFjdGl2ZVRyYWNrKCk6IE1lZGlhU3RyZWFtVHJhY2sgfCBudWxsIHtcbiAgICBpZiAoIXN0cmVhbVJlZikge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgdHJhY2tzID0gc3RyZWFtUmVmLmdldFZpZGVvVHJhY2tzKCk7XG4gICAgcmV0dXJuIHRyYWNrcyAmJiB0cmFja3M/Lmxlbmd0aCA/IHRyYWNrc1swXSA6IG51bGw7XG59XG5cbi8qKlxuICogVXNlZCBmb3IgYWNjZXNzaW5nIGluZm9ybWF0aW9uIGFib3V0IHRoZSBhY3RpdmUgc3RyZWFtIHRyYWNrIGFuZCBhdmFpbGFibGUgdmlkZW8gZGV2aWNlcy5cbiAqL1xuY29uc3QgUXVhZ2dhSlNDYW1lcmFBY2Nlc3M6IENhbWVyYUFjY2Vzc1R5cGUgPSB7XG4gICAgcmVxdWVzdGVkVmlkZW9FbGVtZW50OiBudWxsLFxuICAgIGFzeW5jIHJlcXVlc3QodmlkZW86IEhUTUxWaWRlb0VsZW1lbnQgfCBudWxsLCB2aWRlb0NvbnN0cmFpbnRzPzogTWVkaWFUcmFja0NvbnN0cmFpbnRzV2l0aERlcHJlY2F0ZWQpOiBQcm9taXNlPGFueT4ge1xuICAgICAgICBRdWFnZ2FKU0NhbWVyYUFjY2Vzcy5yZXF1ZXN0ZWRWaWRlb0VsZW1lbnQgPSB2aWRlbztcbiAgICAgICAgY29uc3QgbmV3Q29uc3RyYWludHMgPSBhd2FpdCBwaWNrQ29uc3RyYWludHModmlkZW9Db25zdHJhaW50cyk7XG4gICAgICAgIHJldHVybiBpbml0Q2FtZXJhKHZpZGVvLCBuZXdDb25zdHJhaW50cyk7XG4gICAgfSxcbiAgICByZWxlYXNlKCk6IFByb21pc2U8dm9pZD4ge1xuICAgICAgICBjb25zdCB0cmFja3MgPSBzdHJlYW1SZWYgJiYgc3RyZWFtUmVmLmdldFZpZGVvVHJhY2tzKCk7XG4gICAgICAgIGlmIChRdWFnZ2FKU0NhbWVyYUFjY2Vzcy5yZXF1ZXN0ZWRWaWRlb0VsZW1lbnQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIFF1YWdnYUpTQ2FtZXJhQWNjZXNzLnJlcXVlc3RlZFZpZGVvRWxlbWVudC5wYXVzZSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZTx2b2lkPigocmVzb2x2ZSkgPT4ge1xuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHRyYWNrcyAmJiB0cmFja3MubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyYWNrcy5mb3JFYWNoKCh0cmFjaykgPT4gdHJhY2suc3RvcCgpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3RyZWFtUmVmID0gbnVsbDtcbiAgICAgICAgICAgICAgICBRdWFnZ2FKU0NhbWVyYUFjY2Vzcy5yZXF1ZXN0ZWRWaWRlb0VsZW1lbnQgPSBudWxsO1xuICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgIH0sIDApO1xuICAgICAgICB9KTtcbiAgICB9LFxuICAgIGVudW1lcmF0ZVZpZGVvRGV2aWNlcyxcbiAgICBnZXRBY3RpdmVTdHJlYW1MYWJlbCgpOiBzdHJpbmcge1xuICAgICAgICBjb25zdCB0cmFjayA9IGdldEFjdGl2ZVRyYWNrKCk7XG4gICAgICAgIHJldHVybiB0cmFjayA/IHRyYWNrLmxhYmVsIDogJyc7XG4gICAgfSxcbiAgICBnZXRBY3RpdmVUcmFjayxcbiAgICBhc3luYyBkaXNhYmxlVG9yY2goKSB7XG4gICAgICAgIGNvbnN0IHRyYWNrID0gZ2V0QWN0aXZlVHJhY2soKTtcbiAgICAgICAgLy8gVE9ETzogc2hvdWxkIHdlIGFjcXVpcmUgY2FtZXJhIGFjY2VzcyBldmVuIGlmIHRoZXJlJ3Mgbm8gY3VycmVudCBjYW1lcmEgb3Blbj9cbiAgICAgICAgLy8gVE9ETzogd2hhdCBoYXBwZW5zIG9uIGlPUyBvciBhbm90aGVyIGRldmljZSB3aGVyZSB0b3JjaCBpc24ndCBzdXBwb3J0ZWQgYXQgYWxsPyBTaG91bGQgd2UgdGhyb3cgYW4gZXJyb3I/XG4gICAgICAgIGlmICh0cmFjaykge1xuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZSAvLyB0eXBlc2NyaXB0IGRvZXNuJ3Qga25vdyB0aGUgdG9yY2ggcHJvcGVydHlcbiAgICAgICAgICAgIGF3YWl0IHRyYWNrLmFwcGx5Q29uc3RyYWludHMoeyB0b3JjaDogZmFsc2UgfSk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIGFzeW5jIGVuYWJsZVRvcmNoKCkge1xuICAgICAgICBjb25zdCB0cmFjayA9IGdldEFjdGl2ZVRyYWNrKCk7XG4gICAgICAgIC8vIFRPRE86IHNob3VsZCB3ZSBhY3F1aXJlIGNhbWVyYSBhY2Nlc3MgZXZlbiBpZiB0aGVyZSdzIG5vIGN1cnJlbnQgY2FtZXJhIG9wZW4/XG4gICAgICAgIC8vIFRPRE86IHdoYXQgaGFwcGVucyBvbiBpT1Mgb3IgYW5vdGhlciBkZXZpY2Ugd2hlcmUgdG9yY2ggaXNuJ3Qgc3VwcG9ydGVkIGF0IGFsbD8gU2hvdWxkIHdlIHRocm93IGFuIGVycm9yP1xuICAgICAgICBpZiAodHJhY2spIHtcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmUgLy8gdHlwZXNjcmlwdCBkb2Vzbid0IGtub3cgdGhlIHRvcmNoIHByb3BlcnR5XG4gICAgICAgICAgICBhd2FpdCB0cmFjay5hcHBseUNvbnN0cmFpbnRzKHsgdG9yY2g6IHRydWUgfSk7XG4gICAgICAgIH1cbiAgICB9LFxufTtcblxuZXhwb3J0IGRlZmF1bHQgUXVhZ2dhSlNDYW1lcmFBY2Nlc3M7XG4iLCJpbXBvcnQgSW1hZ2VEZWJ1ZyBmcm9tICcuLi9jb21tb24vaW1hZ2VfZGVidWcnO1xuaW1wb3J0IHtcbiAgICBRdWFnZ2FKU0NvZGVSZXN1bHQsXG4gICAgUXVhZ2dhSlNSZXN1bHRDb2xsZWN0b3IsXG4gICAgUXVhZ2dhSlNSZXN1bHRDb2xsZWN0b3JGaWx0ZXJGdW5jdGlvbixcbiAgICBYWVNpemUsXG4gICAgUXVhZ2dhSW1hZ2VEYXRhLFxufSBmcm9tICcuLi8uLi90eXBlLWRlZmluaXRpb25zL3F1YWdnYS5kJztcblxuZnVuY3Rpb24gY29udGFpbnMoY29kZVJlc3VsdDogUXVhZ2dhSlNDb2RlUmVzdWx0LCBsaXN0OiBBcnJheTxRdWFnZ2FKU0NvZGVSZXN1bHQ+KTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIGxpc3QgJiYgbGlzdC5zb21lKChpdGVtKSA9PiB7XG4gICAgICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhpdGVtKSBhcyBBcnJheTxrZXlvZiBRdWFnZ2FKU0NvZGVSZXN1bHQ+O1xuICAgICAgICByZXR1cm4ga2V5cy5ldmVyeSgoa2V5KSA9PiBpdGVtW2tleV0gPT09IGNvZGVSZXN1bHRba2V5XSk7XG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIHBhc3Nlc0ZpbHRlcihcbiAgICBjb2RlUmVzdWx0OiBRdWFnZ2FKU0NvZGVSZXN1bHQsXG4gICAgZmlsdGVyOiBRdWFnZ2FKU1Jlc3VsdENvbGxlY3RvckZpbHRlckZ1bmN0aW9uIHwgdW5kZWZpbmVkLFxuKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHR5cGVvZiBmaWx0ZXIgPT09ICdmdW5jdGlvbicgPyBmaWx0ZXIoY29kZVJlc3VsdCkgOiB0cnVlO1xufVxuXG5pbnRlcmZhY2UgUmVzdWx0Q29sbGVjdG9yIHtcbiAgICBhZGRSZXN1bHQ6IChkYXRhOiBRdWFnZ2FJbWFnZURhdGEsIGltYWdlU2l6ZTogWFlTaXplLCBjb2RlUmVzdWx0OiBRdWFnZ2FKU0NvZGVSZXN1bHQpID0+IHZvaWQ7XG4gICAgZ2V0UmVzdWx0czogKCkgPT4gQXJyYXk8UXVhZ2dhSlNDb2RlUmVzdWx0Pjtcbn1cblxuZXhwb3J0IGRlZmF1bHQge1xuICAgIGNyZWF0ZShjb25maWc6IFF1YWdnYUpTUmVzdWx0Q29sbGVjdG9yKTogUmVzdWx0Q29sbGVjdG9yIHtcbiAgICAgICAgY29uc3QgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgICAgIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpIGFzIENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRDtcbiAgICAgICAgY29uc3QgcmVzdWx0czogQXJyYXk8UXVhZ2dhSlNDb2RlUmVzdWx0PiA9IFtdO1xuICAgICAgICBsZXQgY2FwYWNpdHkgPSBjb25maWcuY2FwYWNpdHkgPz8gMjA7XG4gICAgICAgIGNvbnN0IGNhcHR1cmUgPSBjb25maWcuY2FwdHVyZSA9PT0gdHJ1ZTtcblxuICAgICAgICBmdW5jdGlvbiBtYXRjaGVzQ29uc3RyYWludHMoY29kZVJlc3VsdDogUXVhZ2dhSlNDb2RlUmVzdWx0KTogYm9vbGVhbiB7XG4gICAgICAgICAgICByZXR1cm4gISFjYXBhY2l0eVxuICAgICAgICAgICAgICAgICYmIGNvZGVSZXN1bHRcbiAgICAgICAgICAgICAgICAmJiAhY29udGFpbnMoY29kZVJlc3VsdCwgY29uZmlnLmJsYWNrbGlzdCBhcyBBcnJheTxRdWFnZ2FKU0NvZGVSZXN1bHQ+KVxuICAgICAgICAgICAgICAgICYmIHBhc3Nlc0ZpbHRlcihjb2RlUmVzdWx0LCBjb25maWcuZmlsdGVyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBhZGRSZXN1bHQoZGF0YTogUXVhZ2dhSW1hZ2VEYXRhLCBpbWFnZVNpemU6IFhZU2l6ZSwgY29kZVJlc3VsdDogUXVhZ2dhSlNDb2RlUmVzdWx0KTogdm9pZCB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0OiBhbnkgPSB7IH07IC8vIHRoaXMgaXMgJ2FueScgdG8gYXZvaWQgaGF2aW5nIHRvIGNvbnN0cnVjdCBhIHdob2xlIFF1YWdnYUpTQ29kZVJlc3VsdCA6fFxuICAgICAgICAgICAgICAgIGlmIChtYXRjaGVzQ29uc3RyYWludHMoY29kZVJlc3VsdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FwYWNpdHktLTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmNvZGVSZXN1bHQgPSBjb2RlUmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2FwdHVyZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FudmFzLndpZHRoID0gaW1hZ2VTaXplLng7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYW52YXMuaGVpZ2h0ID0gaW1hZ2VTaXplLnk7XG4gICAgICAgICAgICAgICAgICAgICAgICBJbWFnZURlYnVnLmRyYXdJbWFnZShkYXRhLCBpbWFnZVNpemUsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuZnJhbWUgPSBjYW52YXMudG9EYXRhVVJMKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldFJlc3VsdHMoKTogQXJyYXk8UXVhZ2dhSlNDb2RlUmVzdWx0PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgIH0sXG59O1xuIiwiaW1wb3J0IHsgUXVhZ2dhSlNDb25maWdPYmplY3QgfSBmcm9tICcuLi8uLi90eXBlLWRlZmluaXRpb25zL3F1YWdnYS5kJztcblxuY29uc3QgRGV2Q29uZmlnOiBRdWFnZ2FKU0NvbmZpZ09iamVjdCA9IHtcbiAgICBpbnB1dFN0cmVhbToge1xuICAgICAgICBuYW1lOiAnTGl2ZScsXG4gICAgICAgIHR5cGU6ICdMaXZlU3RyZWFtJyxcbiAgICAgICAgY29uc3RyYWludHM6IHtcbiAgICAgICAgICAgIHdpZHRoOiA2NDAsXG4gICAgICAgICAgICBoZWlnaHQ6IDQ4MCxcbiAgICAgICAgICAgIC8vIGFzcGVjdFJhdGlvOiA2NDAvNDgwLCAvLyBvcHRpb25hbFxuICAgICAgICAgICAgZmFjaW5nTW9kZTogJ2Vudmlyb25tZW50JywgLy8gb3IgdXNlclxuICAgICAgICAgICAgLy8gZGV2aWNlSWQ6IFwiMzg3NDU5ODM0NTczODc1OTgzNzU5ODM3NTk4MzRcIlxuICAgICAgICB9LFxuICAgICAgICBhcmVhOiB7XG4gICAgICAgICAgICB0b3A6ICcwJScsXG4gICAgICAgICAgICByaWdodDogJzAlJyxcbiAgICAgICAgICAgIGxlZnQ6ICcwJScsXG4gICAgICAgICAgICBib3R0b206ICcwJScsXG4gICAgICAgIH0sXG4gICAgICAgIHNpbmdsZUNoYW5uZWw6IGZhbHNlLCAvLyB0cnVlOiBvbmx5IHRoZSByZWQgY29sb3ItY2hhbm5lbCBpcyByZWFkXG4gICAgfSxcbiAgICBsb2NhdGU6IHRydWUsXG4gICAgbnVtT2ZXb3JrZXJzOiAwLFxuICAgIGRlY29kZXI6IHtcbiAgICAgICAgcmVhZGVyczogW1xuICAgICAgICAgICAgJ2NvZGVfMTI4X3JlYWRlcicsXG4gICAgICAgIF0sXG4gICAgICAgIGRlYnVnOiB7XG4gICAgICAgICAgICBkcmF3Qm91bmRpbmdCb3g6IGZhbHNlLFxuICAgICAgICAgICAgc2hvd0ZyZXF1ZW5jeTogZmFsc2UsXG4gICAgICAgICAgICBkcmF3U2NhbmxpbmU6IGZhbHNlLFxuICAgICAgICAgICAgc2hvd1BhdHRlcm46IGZhbHNlLFxuICAgICAgICB9LFxuICAgIH0sXG4gICAgbG9jYXRvcjoge1xuICAgICAgICBoYWxmU2FtcGxlOiB0cnVlLFxuICAgICAgICBwYXRjaFNpemU6ICdtZWRpdW0nLCAvLyB4LXNtYWxsLCBzbWFsbCwgbWVkaXVtLCBsYXJnZSwgeC1sYXJnZVxuICAgICAgICBkZWJ1Zzoge1xuICAgICAgICAgICAgc2hvd0NhbnZhczogZmFsc2UsXG4gICAgICAgICAgICBzaG93UGF0Y2hlczogZmFsc2UsXG4gICAgICAgICAgICBzaG93Rm91bmRQYXRjaGVzOiBmYWxzZSxcbiAgICAgICAgICAgIHNob3dTa2VsZXRvbjogZmFsc2UsXG4gICAgICAgICAgICBzaG93TGFiZWxzOiBmYWxzZSxcbiAgICAgICAgICAgIHNob3dQYXRjaExhYmVsczogZmFsc2UsXG4gICAgICAgICAgICBzaG93UmVtYWluaW5nUGF0Y2hMYWJlbHM6IGZhbHNlLFxuICAgICAgICAgICAgYm94RnJvbVBhdGNoZXM6IHtcbiAgICAgICAgICAgICAgICBzaG93VHJhbnNmb3JtZWQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHNob3dUcmFuc2Zvcm1lZEJveDogZmFsc2UsXG4gICAgICAgICAgICAgICAgc2hvd0JCOiBmYWxzZSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgfSxcbn07XG5cbmV4cG9ydCBkZWZhdWx0IERldkNvbmZpZztcbiIsImltcG9ydCB7IFF1YWdnYUpTQ29uZmlnT2JqZWN0IH0gZnJvbSAnLi4vLi4vdHlwZS1kZWZpbml0aW9ucy9xdWFnZ2EuZCc7XG5cbmNvbnN0IE5vZGVDb25maWc6IFF1YWdnYUpTQ29uZmlnT2JqZWN0ID0ge1xuICAgIGlucHV0U3RyZWFtOiB7XG4gICAgICAgIHR5cGU6ICdJbWFnZVN0cmVhbScsXG4gICAgICAgIHNlcXVlbmNlOiBmYWxzZSxcbiAgICAgICAgc2l6ZTogODAwLFxuICAgICAgICBhcmVhOiB7XG4gICAgICAgICAgICB0b3A6ICcwJScsXG4gICAgICAgICAgICByaWdodDogJzAlJyxcbiAgICAgICAgICAgIGxlZnQ6ICcwJScsXG4gICAgICAgICAgICBib3R0b206ICcwJScsXG4gICAgICAgIH0sXG4gICAgICAgIHNpbmdsZUNoYW5uZWw6IGZhbHNlLCAvLyB0cnVlOiBvbmx5IHRoZSByZWQgY29sb3ItY2hhbm5lbCBpcyByZWFkXG4gICAgfSxcbiAgICBsb2NhdGU6IHRydWUsXG4gICAgbnVtT2ZXb3JrZXJzOiAwLFxuICAgIGRlY29kZXI6IHtcbiAgICAgICAgcmVhZGVyczogW1xuICAgICAgICAgICAgJ2NvZGVfMTI4X3JlYWRlcicsXG4gICAgICAgIF0sXG4gICAgfSxcbiAgICBsb2NhdG9yOiB7XG4gICAgICAgIGhhbGZTYW1wbGU6IHRydWUsXG4gICAgICAgIHBhdGNoU2l6ZTogJ21lZGl1bScsIC8vIHgtc21hbGwsIHNtYWxsLCBtZWRpdW0sIGxhcmdlLCB4LWxhcmdlXG4gICAgfSxcbn07XG5cbmV4cG9ydCBkZWZhdWx0IE5vZGVDb25maWc7XG4iLCJpbXBvcnQgeyBRdWFnZ2FKU0NvbmZpZ09iamVjdCB9IGZyb20gJy4uLy4uL3R5cGUtZGVmaW5pdGlvbnMvcXVhZ2dhLmQnO1xuXG5jb25zdCBQcm9kQ29uZmlnOiBRdWFnZ2FKU0NvbmZpZ09iamVjdCA9IHtcbiAgICBpbnB1dFN0cmVhbToge1xuICAgICAgICBuYW1lOiAnTGl2ZScsXG4gICAgICAgIHR5cGU6ICdMaXZlU3RyZWFtJyxcbiAgICAgICAgY29uc3RyYWludHM6IHtcbiAgICAgICAgICAgIHdpZHRoOiA2NDAsXG4gICAgICAgICAgICBoZWlnaHQ6IDQ4MCxcbiAgICAgICAgICAgIC8vIGFzcGVjdFJhdGlvOiA2NDAvNDgwLCAvLyBvcHRpb25hbFxuICAgICAgICAgICAgZmFjaW5nTW9kZTogJ2Vudmlyb25tZW50JywgLy8gb3IgdXNlclxuICAgICAgICAgICAgLy8gZGV2aWNlSWQ6IFwiMzg3NDU5ODM0NTczODc1OTgzNzU5ODM3NTk4MzRcIlxuICAgICAgICB9LFxuICAgICAgICBhcmVhOiB7XG4gICAgICAgICAgICB0b3A6ICcwJScsXG4gICAgICAgICAgICByaWdodDogJzAlJyxcbiAgICAgICAgICAgIGxlZnQ6ICcwJScsXG4gICAgICAgICAgICBib3R0b206ICcwJScsXG4gICAgICAgIH0sXG4gICAgICAgIHNpbmdsZUNoYW5uZWw6IGZhbHNlLCAvLyB0cnVlOiBvbmx5IHRoZSByZWQgY29sb3ItY2hhbm5lbCBpcyByZWFkXG4gICAgfSxcbiAgICBsb2NhdGU6IHRydWUsXG4gICAgbnVtT2ZXb3JrZXJzOiA0LFxuICAgIGRlY29kZXI6IHtcbiAgICAgICAgcmVhZGVyczogW1xuICAgICAgICAgICAgJ2NvZGVfMTI4X3JlYWRlcicsXG4gICAgICAgIF0sXG4gICAgfSxcbiAgICBsb2NhdG9yOiB7XG4gICAgICAgIGhhbGZTYW1wbGU6IHRydWUsXG4gICAgICAgIHBhdGNoU2l6ZTogJ21lZGl1bScsIC8vIHgtc21hbGwsIHNtYWxsLCBtZWRpdW0sIGxhcmdlLCB4LWxhcmdlXG4gICAgfSxcbn07XG5cbmV4cG9ydCBkZWZhdWx0IFByb2RDb25maWc7XG4iLCJpbXBvcnQgeyBRdWFnZ2FKU0NvbmZpZ09iamVjdCB9IGZyb20gJy4uLy4uL3R5cGUtZGVmaW5pdGlvbnMvcXVhZ2dhLmQnO1xuaW1wb3J0IERldkNvbmZpZyBmcm9tICcuL2NvbmZpZy5kZXYnO1xuaW1wb3J0IE5vZGVDb25maWcgZnJvbSAnLi9jb25maWcubm9kZSc7XG5pbXBvcnQgUHJvZENvbmZpZyBmcm9tICcuL2NvbmZpZy5wcm9kJztcblxuY29uc3QgRXhwb3J0Q29uZmlnOiBRdWFnZ2FKU0NvbmZpZ09iamVjdCA9ICgoKSA9PiB7XG4gICAgbGV0IFF1YWdnYUNvbmZpZzogUXVhZ2dhSlNDb25maWdPYmplY3Q7XG4gICAgaWYgKHR5cGVvZiBFTlYgPT09ICd1bmRlZmluZWQnIHx8IEVOVi5kZXZlbG9wbWVudCkge1xuICAgICAgICBRdWFnZ2FDb25maWcgPSBEZXZDb25maWc7XG4gICAgfSBlbHNlIGlmIChFTlYubm9kZSkge1xuICAgICAgICBRdWFnZ2FDb25maWcgPSBOb2RlQ29uZmlnO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIFF1YWdnYUNvbmZpZyA9IFByb2RDb25maWc7XG4gICAgfVxuICAgIHJldHVybiBRdWFnZ2FDb25maWc7XG59KSgpO1xuXG5leHBvcnQgZGVmYXVsdCBFeHBvcnRDb25maWc7XG4iLCIvLyBOT1RFIEZPUiBBTllPTkUgSU4gSEVSRSBJTiBUSEUgRlVUVVJFOlxuLy8gd2VicGFjay5jb25maWcuanMgcmVwbGFjZXMgdGhlIGZyYW1lX2dyYWJiZXIgbW9kdWxlIHdpdGggVEhJUyBtb2R1bGUgd2hlbiBpdCBpcyBidWlsZGluZyBmb3IgYSBCcm93c2VyIGVudmlyb25tZW50LlxuXG5pbXBvcnQge1xuICAgIGltYWdlUmVmLFxuICAgIGdyYXlBbmRIYWxmU2FtcGxlRnJvbUNhbnZhc0RhdGEsXG4gICAgY29tcHV0ZUdyYXksXG59IGZyb20gJy4uL2NvbW1vbi9jdl91dGlscyc7XG5cbmNvbnN0IFRPX1JBRElBTlMgPSBNYXRoLlBJIC8gMTgwO1xuXG5mdW5jdGlvbiBhZGp1c3RDYW52YXNTaXplKGNhbnZhcywgdGFyZ2V0U2l6ZSkge1xuICAgIGlmIChjYW52YXMud2lkdGggIT09IHRhcmdldFNpemUueCkge1xuICAgICAgICBpZiAoRU5WLmRldmVsb3BtZW50KSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnV0FSTklORzogY2FudmFzLXNpemUgbmVlZHMgdG8gYmUgYWRqdXN0ZWQnKTtcbiAgICAgICAgfVxuICAgICAgICBjYW52YXMud2lkdGggPSB0YXJnZXRTaXplLng7XG4gICAgfVxuICAgIGlmIChjYW52YXMuaGVpZ2h0ICE9PSB0YXJnZXRTaXplLnkpIHtcbiAgICAgICAgaWYgKEVOVi5kZXZlbG9wbWVudCkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ1dBUk5JTkc6IGNhbnZhcy1zaXplIG5lZWRzIHRvIGJlIGFkanVzdGVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgY2FudmFzLmhlaWdodCA9IHRhcmdldFNpemUueTtcbiAgICB9XG59XG5cbmNvbnN0IEZyYW1lR3JhYmJlciA9IHt9O1xuXG5GcmFtZUdyYWJiZXIuY3JlYXRlID0gZnVuY3Rpb24gKGlucHV0U3RyZWFtLCBjYW52YXMpIHtcbiAgICAvLyBjb25zb2xlLndhcm4oJyoqKiBGcmFtZUdyYWJiZXJCcm93c2VyIGNyZWF0ZScpO1xuICAgIGNvbnN0IF90aGF0ID0ge307XG4gICAgY29uc3QgX3N0cmVhbUNvbmZpZyA9IGlucHV0U3RyZWFtLmdldENvbmZpZygpO1xuICAgIGNvbnN0IF92aWRlb1NpemUgPSBpbWFnZVJlZihpbnB1dFN0cmVhbS5nZXRSZWFsV2lkdGgoKSwgaW5wdXRTdHJlYW0uZ2V0UmVhbEhlaWdodCgpKTtcbiAgICBjb25zdCBfY2FudmFzU2l6ZSA9IGlucHV0U3RyZWFtLmdldENhbnZhc1NpemUoKTtcbiAgICBjb25zdCBfc2l6ZSA9IGltYWdlUmVmKGlucHV0U3RyZWFtLmdldFdpZHRoKCksIGlucHV0U3RyZWFtLmdldEhlaWdodCgpKTtcbiAgICBjb25zdCB0b3BSaWdodCA9IGlucHV0U3RyZWFtLmdldFRvcFJpZ2h0KCk7XG4gICAgY29uc3QgX3N4ID0gdG9wUmlnaHQueDtcbiAgICBjb25zdCBfc3kgPSB0b3BSaWdodC55O1xuICAgIGxldCBfY2FudmFzO1xuICAgIGxldCBfY3R4ID0gbnVsbDtcbiAgICBsZXQgX2RhdGEgPSBudWxsO1xuXG4gICAgX2NhbnZhcyA9IGNhbnZhcyB8fCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICBfY2FudmFzLndpZHRoID0gX2NhbnZhc1NpemUueDtcbiAgICBfY2FudmFzLmhlaWdodCA9IF9jYW52YXNTaXplLnk7XG4gICAgX2N0eCA9IF9jYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICBfZGF0YSA9IG5ldyBVaW50OEFycmF5KF9zaXplLnggKiBfc2l6ZS55KTtcbiAgICBpZiAoRU5WLmRldmVsb3BtZW50KSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdGcmFtZUdyYWJiZXInLCBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICBzaXplOiBfc2l6ZSxcbiAgICAgICAgICAgIHRvcFJpZ2h0LFxuICAgICAgICAgICAgdmlkZW9TaXplOiBfdmlkZW9TaXplLFxuICAgICAgICAgICAgY2FudmFzU2l6ZTogX2NhbnZhc1NpemUsXG4gICAgICAgIH0pKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVc2VzIHRoZSBnaXZlbiBhcnJheSBhcyBmcmFtZS1idWZmZXJcbiAgICAgKi9cbiAgICBfdGhhdC5hdHRhY2hEYXRhID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgX2RhdGEgPSBkYXRhO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSB1c2VkIGZyYW1lLWJ1ZmZlclxuICAgICAqL1xuICAgIF90aGF0LmdldERhdGEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfZGF0YTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRmV0Y2hlcyBhIGZyYW1lIGZyb20gdGhlIGlucHV0LXN0cmVhbSBhbmQgcHV0cyBpbnRvIHRoZSBmcmFtZS1idWZmZXIuXG4gICAgICogVGhlIGltYWdlLWRhdGEgaXMgY29udmVydGVkIHRvIGdyYXktc2NhbGUgYW5kIHRoZW4gaGFsZi1zYW1wbGVkIGlmIGNvbmZpZ3VyZWQuXG4gICAgICovXG4gICAgX3RoYXQuZ3JhYiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY29uc3QgZG9IYWxmU2FtcGxlID0gX3N0cmVhbUNvbmZpZy5oYWxmU2FtcGxlO1xuICAgICAgICBjb25zdCBmcmFtZSA9IGlucHV0U3RyZWFtLmdldEZyYW1lKCk7XG4gICAgICAgIGxldCBkcmF3YWJsZSA9IGZyYW1lO1xuICAgICAgICBsZXQgZHJhd0FuZ2xlID0gMDtcbiAgICAgICAgbGV0IGN0eERhdGE7XG4gICAgICAgIGlmIChkcmF3YWJsZSkge1xuICAgICAgICAgICAgYWRqdXN0Q2FudmFzU2l6ZShfY2FudmFzLCBfY2FudmFzU2l6ZSk7XG4gICAgICAgICAgICBpZiAoX3N0cmVhbUNvbmZpZy50eXBlID09PSAnSW1hZ2VTdHJlYW0nKSB7XG4gICAgICAgICAgICAgICAgZHJhd2FibGUgPSBmcmFtZS5pbWc7XG4gICAgICAgICAgICAgICAgaWYgKGZyYW1lLnRhZ3MgJiYgZnJhbWUudGFncy5vcmllbnRhdGlvbikge1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGZyYW1lLnRhZ3Mub3JpZW50YXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkcmF3QW5nbGUgPSA5MCAqIFRPX1JBRElBTlM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZHJhd0FuZ2xlID0gLTkwICogVE9fUkFESUFOUztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGRyYXdBbmdsZSAhPT0gMCkge1xuICAgICAgICAgICAgICAgIF9jdHgudHJhbnNsYXRlKF9jYW52YXNTaXplLnggLyAyLCBfY2FudmFzU2l6ZS55IC8gMik7XG4gICAgICAgICAgICAgICAgX2N0eC5yb3RhdGUoZHJhd0FuZ2xlKTtcbiAgICAgICAgICAgICAgICBfY3R4LmRyYXdJbWFnZShkcmF3YWJsZSwgLV9jYW52YXNTaXplLnkgLyAyLCAtX2NhbnZhc1NpemUueCAvIDIsIF9jYW52YXNTaXplLnksIF9jYW52YXNTaXplLngpO1xuICAgICAgICAgICAgICAgIF9jdHgucm90YXRlKC1kcmF3QW5nbGUpO1xuICAgICAgICAgICAgICAgIF9jdHgudHJhbnNsYXRlKC1fY2FudmFzU2l6ZS54IC8gMiwgLV9jYW52YXNTaXplLnkgLyAyKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgX2N0eC5kcmF3SW1hZ2UoZHJhd2FibGUsIDAsIDAsIF9jYW52YXNTaXplLngsIF9jYW52YXNTaXplLnkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjdHhEYXRhID0gX2N0eC5nZXRJbWFnZURhdGEoX3N4LCBfc3ksIF9zaXplLngsIF9zaXplLnkpLmRhdGE7XG4gICAgICAgICAgICBpZiAoZG9IYWxmU2FtcGxlKSB7XG4gICAgICAgICAgICAgICAgZ3JheUFuZEhhbGZTYW1wbGVGcm9tQ2FudmFzRGF0YShjdHhEYXRhLCBfc2l6ZSwgX2RhdGEpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb21wdXRlR3JheShjdHhEYXRhLCBfZGF0YSwgX3N0cmVhbUNvbmZpZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcblxuICAgIF90aGF0LmdldFNpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfc2l6ZTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIF90aGF0O1xufTtcblxuZXhwb3J0IGRlZmF1bHQgRnJhbWVHcmFiYmVyO1xuIiwiLy8gTk9URTogKFNPTUUgT0YpIFRISVMgSVMgQlJPV1NFUiBPTkxZIENPREUuICBOb2RlIGRvZXMgbm90IGhhdmUgJ2F0b2InIGJ1aWx0IGluLCBub3IgWE1MSHR0cFJlcXVlc3QuXG4vLyBIb3cgZXhhY3RseSBpcyB0aGlzIHNldCBvZiBmdW5jdGlvbnMgdXNlZCBpbiBRdWFnZ2E/IERvIHdlIG5lZWQgdGhlIGJyb3dzZXIgc3BlY2lmaWMgY29kZT8gRG8gd2Vcbi8vIG5lZWQgdG8gcG9ydCBhbnkgcGFydCBvZiB0aGlzIHRoYXQgZG9lc24ndCB3b3JrIGluIE5vZGUgdG8gbm9kZT9cblxuLy8gVGFncyBzY3JhcGVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2V4aWYtanMvZXhpZi1qc1xuY29uc3QgRXhpZlRhZ3MgPSB7IDB4MDExMjogJ29yaWVudGF0aW9uJyB9O1xuZXhwb3J0IGNvbnN0IEF2YWlsYWJsZVRhZ3MgPSBPYmplY3Qua2V5cyhFeGlmVGFncykubWFwKChrZXkpID0+IEV4aWZUYWdzW2tleV0pO1xuXG5leHBvcnQgZnVuY3Rpb24gZmluZFRhZ3NJbk9iamVjdFVSTChzcmMsIHRhZ3MgPSBBdmFpbGFibGVUYWdzKSB7XG4gICAgaWYgKC9eYmxvYjovaS50ZXN0KHNyYykpIHtcbiAgICAgICAgcmV0dXJuIG9iamVjdFVSTFRvQmxvYihzcmMpXG4gICAgICAgICAgICAudGhlbihyZWFkVG9CdWZmZXIpXG4gICAgICAgICAgICAudGhlbigoYnVmZmVyKSA9PiBmaW5kVGFnc0luQnVmZmVyKGJ1ZmZlciwgdGFncykpO1xuICAgIH1cbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG51bGwpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYmFzZTY0VG9BcnJheUJ1ZmZlcihkYXRhVXJsKSB7XG4gICAgY29uc3QgYmFzZTY0ID0gZGF0YVVybC5yZXBsYWNlKC9eZGF0YTooW147XSspO2Jhc2U2NCwvZ21pLCAnJyk7XG4gICAgY29uc3QgYmluYXJ5ID0gYXRvYihiYXNlNjQpO1xuICAgIGNvbnN0IGxlbiA9IGJpbmFyeS5sZW5ndGg7XG4gICAgY29uc3QgYnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKGxlbik7XG4gICAgY29uc3QgdmlldyA9IG5ldyBVaW50OEFycmF5KGJ1ZmZlcik7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHZpZXdbaV0gPSBiaW5hcnkuY2hhckNvZGVBdChpKTtcbiAgICB9XG4gICAgcmV0dXJuIGJ1ZmZlcjtcbn1cblxuZnVuY3Rpb24gcmVhZFRvQnVmZmVyKGJsb2IpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgY29uc3QgZmlsZVJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XG4gICAgICAgIGZpbGVSZWFkZXIub25sb2FkID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHJldHVybiByZXNvbHZlKGUudGFyZ2V0LnJlc3VsdCk7XG4gICAgICAgIH07XG4gICAgICAgIGZpbGVSZWFkZXIucmVhZEFzQXJyYXlCdWZmZXIoYmxvYik7XG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIG9iamVjdFVSTFRvQmxvYih1cmwpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBjb25zdCBodHRwID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgICAgIGh0dHAub3BlbignR0VUJywgdXJsLCB0cnVlKTtcbiAgICAgICAgaHR0cC5yZXNwb25zZVR5cGUgPSAnYmxvYic7XG4gICAgICAgIGh0dHAub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKGh0dHAucmVhZHlTdGF0ZSA9PT0gWE1MSHR0cFJlcXVlc3QuRE9ORSAmJiAoaHR0cC5zdGF0dXMgPT09IDIwMCB8fCBodHRwLnN0YXR1cyA9PT0gMCkpIHtcbiAgICAgICAgICAgICAgICByZXNvbHZlKHRoaXMucmVzcG9uc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBodHRwLm9uZXJyb3IgPSByZWplY3Q7XG4gICAgICAgIGh0dHAuc2VuZCgpO1xuICAgIH0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZmluZFRhZ3NJbkJ1ZmZlcihmaWxlLCBzZWxlY3RlZFRhZ3MgPSBBdmFpbGFibGVUYWdzKSB7XG4gICAgY29uc3QgZGF0YVZpZXcgPSBuZXcgRGF0YVZpZXcoZmlsZSk7XG4gICAgY29uc3QgbGVuZ3RoID0gZmlsZS5ieXRlTGVuZ3RoO1xuICAgIGNvbnN0IGV4aWZUYWdzID0gc2VsZWN0ZWRUYWdzLnJlZHVjZSgocmVzdWx0LCBzZWxlY3RlZFRhZykgPT4ge1xuICAgICAgICBjb25zdCBleGlmVGFnID0gT2JqZWN0LmtleXMoRXhpZlRhZ3MpLmZpbHRlcigodGFnKSA9PiBFeGlmVGFnc1t0YWddID09PSBzZWxlY3RlZFRhZylbMF07XG4gICAgICAgIGlmIChleGlmVGFnKSB7XG4gICAgICAgICAgICByZXN1bHRbZXhpZlRhZ10gPSBzZWxlY3RlZFRhZztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sIHt9KTtcbiAgICBsZXQgb2Zmc2V0ID0gMjtcbiAgICBsZXQgbWFya2VyO1xuXG4gICAgaWYgKChkYXRhVmlldy5nZXRVaW50OCgwKSAhPT0gMHhGRikgfHwgKGRhdGFWaWV3LmdldFVpbnQ4KDEpICE9PSAweEQ4KSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgd2hpbGUgKG9mZnNldCA8IGxlbmd0aCkge1xuICAgICAgICBpZiAoZGF0YVZpZXcuZ2V0VWludDgob2Zmc2V0KSAhPT0gMHhGRikge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgbWFya2VyID0gZGF0YVZpZXcuZ2V0VWludDgob2Zmc2V0ICsgMSk7XG4gICAgICAgIGlmIChtYXJrZXIgPT09IDB4RTEpIHtcbiAgICAgICAgICAgIHJldHVybiByZWFkRVhJRkRhdGEoZGF0YVZpZXcsIG9mZnNldCArIDQsIGV4aWZUYWdzKTtcbiAgICAgICAgfVxuICAgICAgICBvZmZzZXQgKz0gMiArIGRhdGFWaWV3LmdldFVpbnQxNihvZmZzZXQgKyAyKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIHJlYWRFWElGRGF0YShmaWxlLCBzdGFydCwgZXhpZlRhZ3MpIHtcbiAgICBpZiAoZ2V0U3RyaW5nRnJvbUJ1ZmZlcihmaWxlLCBzdGFydCwgNCkgIT09ICdFeGlmJykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgY29uc3QgdGlmZk9mZnNldCA9IHN0YXJ0ICsgNjtcbiAgICBsZXQgYmlnRW5kO1xuXG4gICAgaWYgKGZpbGUuZ2V0VWludDE2KHRpZmZPZmZzZXQpID09PSAweDQ5NDkpIHtcbiAgICAgICAgYmlnRW5kID0gZmFsc2U7XG4gICAgfSBlbHNlIGlmIChmaWxlLmdldFVpbnQxNih0aWZmT2Zmc2V0KSA9PT0gMHg0RDREKSB7XG4gICAgICAgIGJpZ0VuZCA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChmaWxlLmdldFVpbnQxNih0aWZmT2Zmc2V0ICsgMiwgIWJpZ0VuZCkgIT09IDB4MDAyQSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgY29uc3QgZmlyc3RJRkRPZmZzZXQgPSBmaWxlLmdldFVpbnQzMih0aWZmT2Zmc2V0ICsgNCwgIWJpZ0VuZCk7XG4gICAgaWYgKGZpcnN0SUZET2Zmc2V0IDwgMHgwMDAwMDAwOCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgY29uc3QgdGFncyA9IHJlYWRUYWdzKGZpbGUsIHRpZmZPZmZzZXQsIHRpZmZPZmZzZXQgKyBmaXJzdElGRE9mZnNldCwgZXhpZlRhZ3MsIGJpZ0VuZCk7XG4gICAgcmV0dXJuIHRhZ3M7XG59XG5cbmZ1bmN0aW9uIHJlYWRUYWdzKGZpbGUsIHRpZmZTdGFydCwgZGlyU3RhcnQsIHN0cmluZ3MsIGJpZ0VuZCkge1xuICAgIGNvbnN0IGVudHJpZXMgPSBmaWxlLmdldFVpbnQxNihkaXJTdGFydCwgIWJpZ0VuZCk7XG4gICAgY29uc3QgdGFncyA9IHt9O1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBlbnRyaWVzOyBpKyspIHtcbiAgICAgICAgY29uc3QgZW50cnlPZmZzZXQgPSBkaXJTdGFydCArIGkgKiAxMiArIDI7XG4gICAgICAgIGNvbnN0IHRhZyA9IHN0cmluZ3NbZmlsZS5nZXRVaW50MTYoZW50cnlPZmZzZXQsICFiaWdFbmQpXTtcbiAgICAgICAgaWYgKHRhZykge1xuICAgICAgICAgICAgdGFnc1t0YWddID0gcmVhZFRhZ1ZhbHVlKGZpbGUsIGVudHJ5T2Zmc2V0LCB0aWZmU3RhcnQsIGRpclN0YXJ0LCBiaWdFbmQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0YWdzO1xufVxuXG5mdW5jdGlvbiByZWFkVGFnVmFsdWUoZmlsZSwgZW50cnlPZmZzZXQsIHRpZmZTdGFydCwgZGlyU3RhcnQsIGJpZ0VuZCkge1xuICAgIGNvbnN0IHR5cGUgPSBmaWxlLmdldFVpbnQxNihlbnRyeU9mZnNldCArIDIsICFiaWdFbmQpO1xuICAgIGNvbnN0IG51bVZhbHVlcyA9IGZpbGUuZ2V0VWludDMyKGVudHJ5T2Zmc2V0ICsgNCwgIWJpZ0VuZCk7XG5cbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgaWYgKG51bVZhbHVlcyA9PT0gMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmaWxlLmdldFVpbnQxNihlbnRyeU9mZnNldCArIDgsICFiaWdFbmQpO1xuICAgICAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiBnZXRTdHJpbmdGcm9tQnVmZmVyKGJ1ZmZlciwgc3RhcnQsIGxlbmd0aCkge1xuICAgIGxldCBvdXRzdHIgPSAnJztcbiAgICBmb3IgKGxldCBuID0gc3RhcnQ7IG4gPCBzdGFydCArIGxlbmd0aDsgbisrKSB7XG4gICAgICAgIG91dHN0ciArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZmZlci5nZXRVaW50OChuKSk7XG4gICAgfVxuICAgIHJldHVybiBvdXRzdHI7XG59XG4iLCJpbXBvcnQgeyBmaW5kVGFnc0luT2JqZWN0VVJMIH0gZnJvbSAnLi9leGlmX2hlbHBlcic7XG5cbmNvbnN0IEltYWdlTG9hZGVyID0ge307XG5JbWFnZUxvYWRlci5sb2FkID0gZnVuY3Rpb24gKGRpcmVjdG9yeSwgY2FsbGJhY2ssIG9mZnNldCwgc2l6ZSwgc2VxdWVuY2UpIHtcbiAgICBjb25zdCBodG1sSW1hZ2VzU3JjQXJyYXkgPSBuZXcgQXJyYXkoc2l6ZSk7XG4gICAgY29uc3QgaHRtbEltYWdlc0FycmF5ID0gbmV3IEFycmF5KGh0bWxJbWFnZXNTcmNBcnJheS5sZW5ndGgpO1xuICAgIGxldCBpO1xuICAgIGxldCBpbWc7XG4gICAgbGV0IG51bTtcblxuICAgIGlmIChzZXF1ZW5jZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgaHRtbEltYWdlc1NyY0FycmF5WzBdID0gZGlyZWN0b3J5O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBodG1sSW1hZ2VzU3JjQXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIG51bSA9IChvZmZzZXQgKyBpKTtcbiAgICAgICAgICAgIGh0bWxJbWFnZXNTcmNBcnJheVtpXSA9IGAke2RpcmVjdG9yeX1pbWFnZS0keyhgMDAke251bX1gKS5zbGljZSgtMyl9LmpwZ2A7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaHRtbEltYWdlc0FycmF5Lm5vdExvYWRlZCA9IFtdO1xuICAgIGh0bWxJbWFnZXNBcnJheS5hZGRJbWFnZSA9IGZ1bmN0aW9uIChpbWFnZSkge1xuICAgICAgICBodG1sSW1hZ2VzQXJyYXkubm90TG9hZGVkLnB1c2goaW1hZ2UpO1xuICAgIH07XG4gICAgaHRtbEltYWdlc0FycmF5LmxvYWRlZCA9IGZ1bmN0aW9uIChsb2FkZWRJbWcpIHtcbiAgICAgICAgY29uc3Qgbm90bG9hZGVkSW1ncyA9IGh0bWxJbWFnZXNBcnJheS5ub3RMb2FkZWQ7XG4gICAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgbm90bG9hZGVkSW1ncy5sZW5ndGg7IHgrKykge1xuICAgICAgICAgICAgaWYgKG5vdGxvYWRlZEltZ3NbeF0gPT09IGxvYWRlZEltZykge1xuICAgICAgICAgICAgICAgIG5vdGxvYWRlZEltZ3Muc3BsaWNlKHgsIDEpO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IHkgPSAwOyB5IDwgaHRtbEltYWdlc1NyY0FycmF5Lmxlbmd0aDsgeSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGltZ05hbWUgPSBodG1sSW1hZ2VzU3JjQXJyYXlbeV0uc3Vic3RyKGh0bWxJbWFnZXNTcmNBcnJheVt5XS5sYXN0SW5kZXhPZignLycpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxvYWRlZEltZy5zcmMubGFzdEluZGV4T2YoaW1nTmFtZSkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBodG1sSW1hZ2VzQXJyYXlbeV0gPSB7IGltZzogbG9hZGVkSW1nIH07XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobm90bG9hZGVkSW1ncy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGlmIChFTlYuZGV2ZWxvcG1lbnQpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnSW1hZ2VzIGxvYWRlZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNlcXVlbmNlID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIGZpbmRUYWdzSW5PYmplY3RVUkwoZGlyZWN0b3J5LCBbJ29yaWVudGF0aW9uJ10pXG4gICAgICAgICAgICAgICAgICAgIC50aGVuKCh0YWdzKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBodG1sSW1hZ2VzQXJyYXlbMF0udGFncyA9IHRhZ3M7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhodG1sSW1hZ2VzQXJyYXkpO1xuICAgICAgICAgICAgICAgICAgICB9KS5jYXRjaCgoZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhodG1sSW1hZ2VzQXJyYXkpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soaHRtbEltYWdlc0FycmF5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgaHRtbEltYWdlc1NyY0FycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGltZyA9IG5ldyBJbWFnZSgpO1xuICAgICAgICBodG1sSW1hZ2VzQXJyYXkuYWRkSW1hZ2UoaW1nKTtcbiAgICAgICAgYWRkT25sb2FkSGFuZGxlcihpbWcsIGh0bWxJbWFnZXNBcnJheSk7XG4gICAgICAgIGltZy5zcmMgPSBodG1sSW1hZ2VzU3JjQXJyYXlbaV07XG4gICAgfVxufTtcblxuZnVuY3Rpb24gYWRkT25sb2FkSGFuZGxlcihpbWcsIGh0bWxJbWFnZXNBcnJheSkge1xuICAgIGltZy5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGh0bWxJbWFnZXNBcnJheS5sb2FkZWQodGhpcyk7XG4gICAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgKEltYWdlTG9hZGVyKTtcbiIsIi8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnkgKi9cblxuaW1wb3J0IEltYWdlTG9hZGVyIGZyb20gJy4uL2ltYWdlX2xvYWRlcic7XG5pbXBvcnQgeyBYWVNpemUsIFBvaW50IH0gZnJvbSAnLi4vLi4vLi4vdHlwZS1kZWZpbml0aW9ucy9xdWFnZ2EuZCc7XG5pbXBvcnQgeyBJbnB1dFN0cmVhbUZhY3RvcnksIElucHV0U3RyZWFtLCBFdmVudEhhbmRsZXJMaXN0IH0gZnJvbSAnLi9pbnB1dF9zdHJlYW0uZCc7XG5cbmNvbnN0IGlucHV0U3RyZWFtRmFjdG9yeTogSW5wdXRTdHJlYW1GYWN0b3J5ID0ge1xuICAgIGNyZWF0ZVZpZGVvU3RyZWFtKHZpZGVvKTogSW5wdXRTdHJlYW0ge1xuICAgICAgICBjb25zb2xlLndhcm4oJyoqKiogSW5wdXRTdHJlYW1Ccm93c2VyIGNyZWF0ZVZpZGVvU3RyZWFtJyk7XG4gICAgICAgIGxldCBfY29uZmlnOiB7IHNpemU6IG51bWJlcjsgdHlwZTogc3RyaW5nIH0gfCBudWxsID0gbnVsbDtcbiAgICAgICAgY29uc3QgX2V2ZW50TmFtZXMgPSBbJ2NhbnJlY29yZCcsICdlbmRlZCddO1xuICAgICAgICBjb25zdCBfZXZlbnRIYW5kbGVyczogRXZlbnRIYW5kbGVyTGlzdCA9IHt9O1xuICAgICAgICBsZXQgX2NhbGN1bGF0ZWRXaWR0aDogbnVtYmVyO1xuICAgICAgICBsZXQgX2NhbGN1bGF0ZWRIZWlnaHQ6IG51bWJlcjtcbiAgICAgICAgY29uc3QgX3RvcFJpZ2h0OiBQb2ludCA9IHsgeDogMCwgeTogMCwgdHlwZTogJ1BvaW50JyB9O1xuICAgICAgICBjb25zdCBfY2FudmFzU2l6ZTogWFlTaXplID0geyB4OiAwLCB5OiAwLCB0eXBlOiAnWFlTaXplJyB9O1xuXG4gICAgICAgIGZ1bmN0aW9uIGluaXRTaXplKCk6IHZvaWQge1xuICAgICAgICAgICAgY29uc3Qgd2lkdGggPSB2aWRlby52aWRlb1dpZHRoO1xuICAgICAgICAgICAgY29uc3QgaGVpZ2h0ID0gdmlkZW8udmlkZW9IZWlnaHQ7XG5cbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1uZXN0ZWQtdGVybmFyeVxuICAgICAgICAgICAgX2NhbGN1bGF0ZWRXaWR0aCA9IF9jb25maWc/LnNpemUgPyB3aWR0aCAvIGhlaWdodCA+IDEgPyBfY29uZmlnLnNpemUgOiBNYXRoLmZsb29yKCh3aWR0aCAvIGhlaWdodCkgKiBfY29uZmlnLnNpemUpIDogd2lkdGg7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbmVzdGVkLXRlcm5hcnlcbiAgICAgICAgICAgIF9jYWxjdWxhdGVkSGVpZ2h0ID0gX2NvbmZpZz8uc2l6ZSA/IHdpZHRoIC8gaGVpZ2h0ID4gMSA/IE1hdGguZmxvb3IoKGhlaWdodCAvIHdpZHRoKSAqIF9jb25maWcuc2l6ZSkgOiBfY29uZmlnLnNpemUgOiBoZWlnaHQ7XG5cbiAgICAgICAgICAgIF9jYW52YXNTaXplLnggPSBfY2FsY3VsYXRlZFdpZHRoO1xuICAgICAgICAgICAgX2NhbnZhc1NpemUueSA9IF9jYWxjdWxhdGVkSGVpZ2h0O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGlucHV0U3RyZWFtOiBJbnB1dFN0cmVhbSA9IHtcbiAgICAgICAgICAgIGdldFJlYWxXaWR0aCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmlkZW8udmlkZW9XaWR0aDtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGdldFJlYWxIZWlnaHQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZpZGVvLnZpZGVvSGVpZ2h0O1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgZ2V0V2lkdGgoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jYWxjdWxhdGVkV2lkdGg7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBnZXRIZWlnaHQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jYWxjdWxhdGVkSGVpZ2h0O1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgc2V0V2lkdGgod2lkdGgpIHtcbiAgICAgICAgICAgICAgICBfY2FsY3VsYXRlZFdpZHRoID0gd2lkdGg7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBzZXRIZWlnaHQoaGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgX2NhbGN1bGF0ZWRIZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBzZXRJbnB1dFN0cmVhbShjb25maWcpIHtcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1hc3NpZ25tZW50XG4gICAgICAgICAgICAgICAgX2NvbmZpZyA9IGNvbmZpZztcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1tZW1iZXItYWNjZXNzXG4gICAgICAgICAgICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ3NyYycsICh0eXBlb2YgY29uZmlnLnNyYyAhPT0gJ3VuZGVmaW5lZCcpID8gY29uZmlnLnNyYyA6ICcnKTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGVuZGVkKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB2aWRlby5lbmRlZDtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGdldENvbmZpZygpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbmZpZztcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIHNldEF0dHJpYnV0ZShuYW1lLCB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGlmICh2aWRlbykge1xuICAgICAgICAgICAgICAgICAgICB2aWRlby5zZXRBdHRyaWJ1dGUobmFtZSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIHBhdXNlKCkge1xuICAgICAgICAgICAgICAgIHZpZGVvLnBhdXNlKCk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBwbGF5KCkge1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZmxvYXRpbmctcHJvbWlzZXNcbiAgICAgICAgICAgICAgICB2aWRlby5wbGF5KCk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBzZXRDdXJyZW50VGltZSh0aW1lKSB7XG4gICAgICAgICAgICAgICAgaWYgKF9jb25maWc/LnR5cGUgIT09ICdMaXZlU3RyZWFtJykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldEF0dHJpYnV0ZSgnY3VycmVudFRpbWUnLCB0aW1lLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIGYsIGJvb2wpIHtcbiAgICAgICAgICAgICAgICBpZiAoX2V2ZW50TmFtZXMuaW5kZXhPZihldmVudCkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghX2V2ZW50SGFuZGxlcnNbZXZlbnRdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfZXZlbnRIYW5kbGVyc1tldmVudF0gPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBfZXZlbnRIYW5kbGVyc1tldmVudF0ucHVzaChmKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2aWRlby5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBmLCBib29sKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBjbGVhckV2ZW50SGFuZGxlcnMoKSB7XG4gICAgICAgICAgICAgICAgX2V2ZW50TmFtZXMuZm9yRWFjaCgoZXZlbnROYW1lKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGhhbmRsZXJzID0gX2V2ZW50SGFuZGxlcnNbZXZlbnROYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGhhbmRsZXJzICYmIGhhbmRsZXJzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZXJzLmZvckVhY2goKGhhbmRsZXIpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2aWRlby5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgaGFuZGxlcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgdHJpZ2dlcihldmVudE5hbWUsIGFyZ3MpIHtcbiAgICAgICAgICAgICAgICBsZXQgajtcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1tZW1iZXItYWNjZXNzXG4gICAgICAgICAgICAgICAgY29uc3QgaGFuZGxlcnMgPSBfZXZlbnRIYW5kbGVyc1tldmVudE5hbWVdO1xuXG4gICAgICAgICAgICAgICAgaWYgKGV2ZW50TmFtZSA9PT0gJ2NhbnJlY29yZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5pdFNpemUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGhhbmRsZXJzICYmIGhhbmRsZXJzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IGhhbmRsZXJzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGVyc1tqXS5hcHBseShpbnB1dFN0cmVhbSwgYXJncyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBzZXRUb3BSaWdodCh0b3BSaWdodCkge1xuICAgICAgICAgICAgICAgIF90b3BSaWdodC54ID0gdG9wUmlnaHQueDtcbiAgICAgICAgICAgICAgICBfdG9wUmlnaHQueSA9IHRvcFJpZ2h0Lnk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBnZXRUb3BSaWdodCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3RvcFJpZ2h0O1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgc2V0Q2FudmFzU2l6ZShzaXplKSB7XG4gICAgICAgICAgICAgICAgX2NhbnZhc1NpemUueCA9IHNpemUueDtcbiAgICAgICAgICAgICAgICBfY2FudmFzU2l6ZS55ID0gc2l6ZS55O1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgZ2V0Q2FudmFzU2l6ZSgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NhbnZhc1NpemU7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBnZXRGcmFtZSgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmlkZW87XG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gaW5wdXRTdHJlYW07XG4gICAgfSxcbiAgICBjcmVhdGVMaXZlU3RyZWFtKHZpZGVvKTogSW5wdXRTdHJlYW0ge1xuICAgICAgICBjb25zb2xlLndhcm4oJyoqKiogSW5wdXRTdHJlYW1Ccm93c2VyIGNyZWF0ZUxpdmVTdHJlYW0nKTtcbiAgICAgICAgaWYgKHZpZGVvKSB7XG4gICAgICAgICAgICB2aWRlby5zZXRBdHRyaWJ1dGUoJ2F1dG9wbGF5JywgJ3RydWUnKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0aGF0ID0gaW5wdXRTdHJlYW1GYWN0b3J5LmNyZWF0ZVZpZGVvU3RyZWFtKHZpZGVvKTtcbiAgICAgICAgdGhhdC5lbmRlZCA9IGZ1bmN0aW9uIGVuZGVkKCk6IGZhbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHRoYXQ7XG4gICAgfSxcbiAgICBjcmVhdGVJbWFnZVN0cmVhbSgpOiBJbnB1dFN0cmVhbSB7XG4gICAgICAgIC8vIGNvbnNvbGUud2FybignKioqKiBJbnB1dFN0cmVhbUJyb3dzZXIgY3JlYXRlSW1hZ2VTdHJlYW0nKTtcbiAgICAgICAgbGV0IF9jb25maWc6IHsgc2l6ZTogbnVtYmVyOyBzZXF1ZW5jZTogYW55IH0gfCBudWxsID0gbnVsbDtcblxuICAgICAgICBsZXQgd2lkdGggPSAwO1xuICAgICAgICBsZXQgaGVpZ2h0ID0gMDtcbiAgICAgICAgbGV0IGZyYW1lSWR4ID0gMDtcbiAgICAgICAgbGV0IHBhdXNlZCA9IHRydWU7XG4gICAgICAgIGxldCBsb2FkZWQgPSBmYWxzZTtcbiAgICAgICAgbGV0IGltZ0FycmF5OiBhbnlbXSB8IG51bGwgPSBudWxsO1xuICAgICAgICBsZXQgc2l6ZSA9IDA7XG4gICAgICAgIGNvbnN0IG9mZnNldCA9IDE7XG4gICAgICAgIGxldCBiYXNlVXJsOiBzdHJpbmcgfCBudWxsID0gbnVsbDtcbiAgICAgICAgbGV0IGVuZGVkID0gZmFsc2U7XG4gICAgICAgIGxldCBjYWxjdWxhdGVkV2lkdGg6IG51bWJlcjtcbiAgICAgICAgbGV0IGNhbGN1bGF0ZWRIZWlnaHQ6IG51bWJlcjtcbiAgICAgICAgY29uc3QgX2V2ZW50TmFtZXMgPSBbJ2NhbnJlY29yZCcsICdlbmRlZCddO1xuICAgICAgICBjb25zdCBfZXZlbnRIYW5kbGVyczogRXZlbnRIYW5kbGVyTGlzdCA9IHt9O1xuICAgICAgICBjb25zdCBfdG9wUmlnaHQ6IFBvaW50ID0geyB4OiAwLCB5OiAwLCB0eXBlOiAnUG9pbnQnIH07XG4gICAgICAgIGNvbnN0IF9jYW52YXNTaXplOiBYWVNpemUgPSB7IHg6IDAsIHk6IDAsIHR5cGU6ICdYWVNpemUnIH07XG5cbiAgICAgICAgZnVuY3Rpb24gbG9hZEltYWdlcygpOiB2b2lkIHtcbiAgICAgICAgICAgIGxvYWRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgSW1hZ2VMb2FkZXIubG9hZChiYXNlVXJsLCAoaW1nczogQXJyYXk8eyB0YWdzOiBhbnk7IGltZzogSFRNTEltYWdlRWxlbWVudH0+KSA9PiB7XG4gICAgICAgICAgICAgICAgaW1nQXJyYXkgPSBpbWdzO1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLW1lbWJlci1hY2Nlc3NcbiAgICAgICAgICAgICAgICBpZiAoaW1nc1swXS50YWdzICYmIGltZ3NbMF0udGFncy5vcmllbnRhdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1tZW1iZXItYWNjZXNzXG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoaW1nc1swXS50YWdzLm9yaWVudGF0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGggPSBpbWdzWzBdLmltZy5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0ID0gaW1nc1swXS5pbWcud2lkdGg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoID0gaW1nc1swXS5pbWcud2lkdGg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0ID0gaW1nc1swXS5pbWcuaGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgd2lkdGggPSBpbWdzWzBdLmltZy53aWR0aDtcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0ID0gaW1nc1swXS5pbWcuaGVpZ2h0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbmVzdGVkLXRlcm5hcnlcbiAgICAgICAgICAgICAgICBjYWxjdWxhdGVkV2lkdGggPSBfY29uZmlnPy5zaXplID8gd2lkdGggLyBoZWlnaHQgPiAxID8gX2NvbmZpZy5zaXplIDogTWF0aC5mbG9vcigod2lkdGggLyBoZWlnaHQpICogX2NvbmZpZy5zaXplKSA6IHdpZHRoO1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1uZXN0ZWQtdGVybmFyeVxuICAgICAgICAgICAgICAgIGNhbGN1bGF0ZWRIZWlnaHQgPSBfY29uZmlnPy5zaXplID8gd2lkdGggLyBoZWlnaHQgPiAxID8gTWF0aC5mbG9vcigoaGVpZ2h0IC8gd2lkdGgpICogX2NvbmZpZy5zaXplKSA6IF9jb25maWcuc2l6ZSA6IGhlaWdodDtcbiAgICAgICAgICAgICAgICBfY2FudmFzU2l6ZS54ID0gY2FsY3VsYXRlZFdpZHRoO1xuICAgICAgICAgICAgICAgIF9jYW52YXNTaXplLnkgPSBjYWxjdWxhdGVkSGVpZ2h0O1xuICAgICAgICAgICAgICAgIGxvYWRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgZnJhbWVJZHggPSAwO1xuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVzZS1iZWZvcmUtZGVmaW5lXG4gICAgICAgICAgICAgICAgICAgIHB1Ymxpc2hFdmVudCgnY2FucmVjb3JkJywgW10pO1xuICAgICAgICAgICAgICAgIH0sIDApO1xuICAgICAgICAgICAgfSwgb2Zmc2V0LCBzaXplLCBfY29uZmlnPy5zZXF1ZW5jZSk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBwdWJsaXNoRXZlbnQoZXZlbnROYW1lOiBzdHJpbmcsIGFyZ3M6IEFycmF5PGFueT4pOiB2b2lkIHtcbiAgICAgICAgICAgIGxldCBqO1xuICAgICAgICAgICAgY29uc3QgaGFuZGxlcnMgPSBfZXZlbnRIYW5kbGVyc1tldmVudE5hbWVdO1xuXG4gICAgICAgICAgICBpZiAoaGFuZGxlcnMgJiYgaGFuZGxlcnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBoYW5kbGVycy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVzZS1iZWZvcmUtZGVmaW5lXG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZXJzW2pdLmFwcGx5KGlucHV0U3RyZWFtLCBhcmdzIGFzIGFueSk7IC8vIFRPRE86IHR5cGVzY3JpcHQgY29tcGxhaW5zIHRoYXQgYW55W10gaXMgbm90IHZhbGlkIGZvciBhIHNlY29uZCBhcmcgZm9yIGFwcGx5PyFcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUT0RPOiBhbnkgY29kZSBzaGFyZWQgd2l0aCB0aGUgZmlyc3QgSW5wdXRTdHJlYW0gYWJvdmUgc2hvdWxkIGJlIHNoYXJlZCBub3QgY29waWVkXG4gICAgICAgIC8vIFRPRE86IHB1Ymxpc2hFdmVudCBuZWVkcyBhY2Nlc3MgdG8gaW5wdXRTdHJlYW0sIGJ1dCBpbnB1dFN0cmVhbSBuZWVkcyBhY2Nlc3MgdG8gcHVibGlzaEV2ZW50XG4gICAgICAgIC8vIFRPRE86IFRoaXMgaXMgd2h5IGl0J3MgYSAndmFyJywgc28gaXQgaG9pc3RzIGJhY2suICBUaGlzIGlzIHVnbHksIGFuZCBzaG91bGQgYmUgY2hhbmdlZC5cbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXZhcix2YXJzLW9uLXRvcFxuICAgICAgICB2YXIgaW5wdXRTdHJlYW06IElucHV0U3RyZWFtID0ge1xuXG4gICAgICAgICAgICB0cmlnZ2VyOiBwdWJsaXNoRXZlbnQsXG5cbiAgICAgICAgICAgIGdldFdpZHRoKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjYWxjdWxhdGVkV2lkdGg7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBnZXRIZWlnaHQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbGN1bGF0ZWRIZWlnaHQ7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBzZXRXaWR0aChuZXdXaWR0aCkge1xuICAgICAgICAgICAgICAgIGNhbGN1bGF0ZWRXaWR0aCA9IG5ld1dpZHRoO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgc2V0SGVpZ2h0KG5ld0hlaWdodCkge1xuICAgICAgICAgICAgICAgIGNhbGN1bGF0ZWRIZWlnaHQgPSBuZXdIZWlnaHQ7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBnZXRSZWFsV2lkdGgoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHdpZHRoO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgZ2V0UmVhbEhlaWdodCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaGVpZ2h0O1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgc2V0SW5wdXRTdHJlYW0oc3RyZWFtKSB7XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtYXNzaWdubWVudFxuICAgICAgICAgICAgICAgIF9jb25maWcgPSBzdHJlYW07XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtbWVtYmVyLWFjY2Vzc1xuICAgICAgICAgICAgICAgIGlmIChzdHJlYW0uc2VxdWVuY2UgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWFzc2lnbm1lbnQsQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1tZW1iZXItYWNjZXNzXG4gICAgICAgICAgICAgICAgICAgIGJhc2VVcmwgPSBzdHJlYW0uc3JjO1xuICAgICAgICAgICAgICAgICAgICBzaXplID0gMTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1hc3NpZ25tZW50LEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtbWVtYmVyLWFjY2Vzc1xuICAgICAgICAgICAgICAgICAgICBiYXNlVXJsID0gc3RyZWFtLnNyYztcbiAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtYXNzaWdubWVudCxAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLW1lbWJlci1hY2Nlc3NcbiAgICAgICAgICAgICAgICAgICAgc2l6ZSA9IHN0cmVhbS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxvYWRJbWFnZXMoKTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGVuZGVkKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBlbmRlZDtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIHNldEF0dHJpYnV0ZSgpIHt9LFxuXG4gICAgICAgICAgICBnZXRDb25maWcoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb25maWc7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBwYXVzZSgpIHtcbiAgICAgICAgICAgICAgICBwYXVzZWQgPSB0cnVlO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgcGxheSgpIHtcbiAgICAgICAgICAgICAgICBwYXVzZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIHNldEN1cnJlbnRUaW1lKHRpbWUpIHtcbiAgICAgICAgICAgICAgICBmcmFtZUlkeCA9IHRpbWU7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBhZGRFdmVudExpc3RlbmVyKGV2ZW50LCBmKSB7XG4gICAgICAgICAgICAgICAgaWYgKF9ldmVudE5hbWVzLmluZGV4T2YoZXZlbnQpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIV9ldmVudEhhbmRsZXJzW2V2ZW50XSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX2V2ZW50SGFuZGxlcnNbZXZlbnRdID0gW107XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgX2V2ZW50SGFuZGxlcnNbZXZlbnRdLnB1c2goZik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgY2xlYXJFdmVudEhhbmRsZXJzKCkge1xuICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKF9ldmVudEhhbmRsZXJzKS5mb3JFYWNoKChpbmQpID0+IGRlbGV0ZSBfZXZlbnRIYW5kbGVyc1tpbmRdKTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIHNldFRvcFJpZ2h0KHRvcFJpZ2h0KSB7XG4gICAgICAgICAgICAgICAgX3RvcFJpZ2h0LnggPSB0b3BSaWdodC54O1xuICAgICAgICAgICAgICAgIF90b3BSaWdodC55ID0gdG9wUmlnaHQueTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGdldFRvcFJpZ2h0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfdG9wUmlnaHQ7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBzZXRDYW52YXNTaXplKGNhbnZhc1NpemUpIHtcbiAgICAgICAgICAgICAgICBfY2FudmFzU2l6ZS54ID0gY2FudmFzU2l6ZS54O1xuICAgICAgICAgICAgICAgIF9jYW52YXNTaXplLnkgPSBjYW52YXNTaXplLnk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBnZXRDYW52YXNTaXplKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfY2FudmFzU2l6ZTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGdldEZyYW1lKCkge1xuICAgICAgICAgICAgICAgIGxldCBmcmFtZTtcblxuICAgICAgICAgICAgICAgIGlmICghbG9hZGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIXBhdXNlZCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1hc3NpZ25tZW50XG4gICAgICAgICAgICAgICAgICAgIGZyYW1lID0gaW1nQXJyYXk/LltmcmFtZUlkeF07XG4gICAgICAgICAgICAgICAgICAgIGlmIChmcmFtZUlkeCA8IChzaXplIC0gMSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZyYW1lSWR4Kys7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHVibGlzaEV2ZW50KCdlbmRlZCcsIFtdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIDApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLXJldHVyblxuICAgICAgICAgICAgICAgIHJldHVybiBmcmFtZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBpbnB1dFN0cmVhbTtcbiAgICB9LFxufTtcblxuZXhwb3J0IGRlZmF1bHQgaW5wdXRTdHJlYW1GYWN0b3J5O1xuIiwiaW1wb3J0IHsgUXVhZ2dhSlNDb25maWdPYmplY3QgfSBmcm9tIFwiLi4vdHlwZS1kZWZpbml0aW9ucy9xdWFnZ2FcIjtcbmltcG9ydCBJbWFnZVdyYXBwZXIgZnJvbSBcImNvbW1vbi9pbWFnZV93cmFwcGVyXCI7XG5cbmV4cG9ydCBjbGFzcyBRdWFnZ2FDb250ZXh0IHtcbiAgICBwdWJsaWMgY29uZmlnPzogUXVhZ2dhSlNDb25maWdPYmplY3Q7XG5cbiAgICBwdWJsaWMgaW5wdXRTdHJlYW06IGFueTtcblxuICAgIHB1YmxpYyBmcmFtZWdyYWJiZXI6IGFueTtcblxuICAgIHB1YmxpYyBpbnB1dEltYWdlV3JhcHBlcj86IEltYWdlV3JhcHBlcjtcblxuICAgIHB1YmxpYyBzdG9wcGVkOiBib29sZWFuID0gZmFsc2U7XG5cbiAgICBwdWJsaWMgYm94U2l6ZTogYW55O1xuXG4gICAgcHVibGljIHJlc3VsdENvbGxlY3RvcjogYW55O1xuXG4gICAgcHVibGljIGRlY29kZXI6IGFueTtcblxuICAgIHB1YmxpYyB3b3JrZXJQb29sOiBhbnlbXSA9IFtdO1xuXG4gICAgcHVibGljIG9uVUlUaHJlYWQgPSB0cnVlO1xuXG4gICAgcHVibGljIHJlYWRvbmx5IGNhbnZhc0NvbnRhaW5lciA9IG5ldyBDYW52YXNDb250YWluZXIoKTtcbn1cblxuZXhwb3J0IGNsYXNzIENhbnZhc0luZm8ge1xuICAgIGltYWdlOiBhbnk7XG4gICAgb3ZlcmxheTogYW55O1xufVxuXG5leHBvcnQgY2xhc3MgQ2FudmFzQ29udGFpbmVyIHtcbiAgICBwdWJsaWMgcmVhZG9ubHkgY3R4OiBDYW52YXNJbmZvO1xuICAgIHB1YmxpYyByZWFkb25seSBkb206IENhbnZhc0luZm87XG5cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5jdHggPSBuZXcgQ2FudmFzSW5mbygpO1xuICAgICAgICB0aGlzLmRvbSA9IG5ldyBDYW52YXNJbmZvKCk7XG4gICAgfVxufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0Vmlld1BvcnQodGFyZ2V0PzogRWxlbWVudCB8IHN0cmluZyk6IEVsZW1lbnQgfCBudWxsIHtcbiAgICBpZiAodHlwZW9mIGRvY3VtZW50ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICAvLyBDaGVjayBpZiB0YXJnZXQgaXMgYWxyZWFkeSBhIERPTSBlbGVtZW50XG4gICAgaWYgKHRhcmdldCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50ICYmIHRhcmdldC5ub2RlTmFtZSAmJiB0YXJnZXQubm9kZVR5cGUgPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9XG4gICAgLy8gVXNlICcjaW50ZXJhY3RpdmUudmlld3BvcnQnIGFzIGEgZmFsbGJhY2sgc2VsZWN0b3IgKGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5KVxuICAgIGNvbnN0IHNlbGVjdG9yID0gdHlwZW9mIHRhcmdldCA9PT0gJ3N0cmluZycgPyB0YXJnZXQgOiAnI2ludGVyYWN0aXZlLnZpZXdwb3J0JztcbiAgICByZXR1cm4gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihzZWxlY3Rvcik7XG59XG4iLCJpbXBvcnQgeyBnbE1hdHJpeCwgdmVjMiB9IGZyb20gJ2dsLW1hdHJpeCc7XG5pbXBvcnQgSW1hZ2VXcmFwcGVyIGZyb20gJy4uL2NvbW1vbi9pbWFnZV93cmFwcGVyJztcbmltcG9ydCB0eXBlIHsgSW5wdXRTdHJlYW0gfSBmcm9tICcuLi9pbnB1dC9pbnB1dF9zdHJlYW0vaW5wdXRfc3RyZWFtLmQnO1xuaW1wb3J0IEJhcmNvZGVMb2NhdG9yIGZyb20gJy4uL2xvY2F0b3IvYmFyY29kZV9sb2NhdG9yJztcblxuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEFycmF5KTtcblxuLy8gVE9ETzogbmVlZCB0eXBlc2NyaXB0IGRlZiBmb3IgQmFyY29kZUxvY2F0b3JcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGluaXRCdWZmZXJzKFxuICAgIGlucHV0U3RyZWFtOiBJbnB1dFN0cmVhbSxcbiAgICBpbWFnZVdyYXBwZXI6IEltYWdlV3JhcHBlciB8IHVuZGVmaW5lZCxcbiAgICBsb2NhdG9yOiBhbnksXG4pIHtcbiAgICBjb25zdCBpbnB1dEltYWdlV3JhcHBlciA9IGltYWdlV3JhcHBlciB8fCBuZXcgSW1hZ2VXcmFwcGVyKHtcbiAgICAgICAgeDogaW5wdXRTdHJlYW0uZ2V0V2lkdGgoKSxcbiAgICAgICAgeTogaW5wdXRTdHJlYW0uZ2V0SGVpZ2h0KCksXG4gICAgICAgIHR5cGU6ICdYWVNpemUnLFxuICAgIH0pO1xuXG4gICAgaWYgKEVOVi5kZXZlbG9wbWVudCkge1xuICAgICAgICBjb25zb2xlLmxvZyhgaW1hZ2Ugd3JhcHBlciBzaXplICR7aW5wdXRJbWFnZVdyYXBwZXIuc2l6ZX1gKTtcbiAgICB9XG4gICAgY29uc3QgYm94U2l6ZSA9IFtcbiAgICAgICAgdmVjMi5jbG9uZShbMCwgMF0pLFxuICAgICAgICB2ZWMyLmNsb25lKFswLCBpbnB1dEltYWdlV3JhcHBlci5zaXplLnldKSxcbiAgICAgICAgdmVjMi5jbG9uZShbaW5wdXRJbWFnZVdyYXBwZXIuc2l6ZS54LCBpbnB1dEltYWdlV3JhcHBlci5zaXplLnldKSxcbiAgICAgICAgdmVjMi5jbG9uZShbaW5wdXRJbWFnZVdyYXBwZXIuc2l6ZS54LCAwXSksXG4gICAgXTtcbiAgICBCYXJjb2RlTG9jYXRvci5pbml0KGlucHV0SW1hZ2VXcmFwcGVyLCBsb2NhdG9yKTtcbiAgICByZXR1cm4geyBpbnB1dEltYWdlV3JhcHBlciwgYm94U2l6ZSB9O1xufVxuIiwiaW1wb3J0IHsgUXVhZ2dhQ29udGV4dCwgQ2FudmFzQ29udGFpbmVyIH0gZnJvbSAnUXVhZ2dhQ29udGV4dCc7XG5pbXBvcnQgdHlwZSB7IFhZU2l6ZSB9IGZyb20gJy4uLy4uL3R5cGUtZGVmaW5pdGlvbnMvcXVhZ2dhLmQnO1xuaW1wb3J0IGdldFZpZXdQb3J0IGZyb20gJy4vZ2V0Vmlld1BvcnQnO1xuXG5mdW5jdGlvbiBmaW5kT3JDcmVhdGVDYW52YXMoc2VsZWN0b3I6IHN0cmluZywgY2xhc3NOYW1lOiBzdHJpbmcpIHtcbiAgICBsZXQgY2FudmFzOiBIVE1MQ2FudmFzRWxlbWVudCB8IG51bGwgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHNlbGVjdG9yKTtcbiAgICBpZiAoIWNhbnZhcykge1xuICAgICAgICBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICAgICAgY2FudmFzLmNsYXNzTmFtZSA9IGNsYXNzTmFtZTtcbiAgICB9XG4gICAgcmV0dXJuIGNhbnZhcztcbn1cblxuZnVuY3Rpb24gZ2V0Q2FudmFzQW5kQ29udGV4dChzZWxlY3Rvcjogc3RyaW5nLCBjbGFzc05hbWU6IHN0cmluZykge1xuICAgIGNvbnN0IGNhbnZhcyA9IGZpbmRPckNyZWF0ZUNhbnZhcyhzZWxlY3RvciwgY2xhc3NOYW1lKTtcbiAgICBjb25zdCBjb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgcmV0dXJuIHsgY2FudmFzLCBjb250ZXh0IH07XG59XG5cbmZ1bmN0aW9uIGluaXRDYW52YXNlcyhjYW52YXNTaXplOiBYWVNpemUpOiBDYW52YXNDb250YWluZXIgfCBudWxsIHtcbiAgICBpZiAodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBjb25zdCBpbWFnZSA9IGdldENhbnZhc0FuZENvbnRleHQoJ2NhbnZhcy5pbWdCdWZmZXInLCAnaW1nQnVmZmVyJyk7XG4gICAgICAgIGNvbnN0IG92ZXJsYXkgPSBnZXRDYW52YXNBbmRDb250ZXh0KCdjYW52YXMuZHJhd2luZ0J1ZmZlcicsICdkcmF3aW5nQnVmZmVyJyk7XG5cbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLW11bHRpLWFzc2lnblxuICAgICAgICBpbWFnZS5jYW52YXMud2lkdGggPSBvdmVybGF5LmNhbnZhcy53aWR0aCA9IGNhbnZhc1NpemUueDtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLW11bHRpLWFzc2lnblxuICAgICAgICBpbWFnZS5jYW52YXMuaGVpZ2h0ID0gb3ZlcmxheS5jYW52YXMuaGVpZ2h0ID0gY2FudmFzU2l6ZS55O1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkb206IHtcbiAgICAgICAgICAgICAgICBpbWFnZTogaW1hZ2UuY2FudmFzLFxuICAgICAgICAgICAgICAgIG92ZXJsYXk6IG92ZXJsYXkuY2FudmFzLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGN0eDoge1xuICAgICAgICAgICAgICAgIGltYWdlOiBpbWFnZS5jb250ZXh0LFxuICAgICAgICAgICAgICAgIG92ZXJsYXk6IG92ZXJsYXkuY29udGV4dCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBpbml0Q2FudmFzKGNvbnRleHQ6IFF1YWdnYUNvbnRleHQpOiBDYW52YXNDb250YWluZXIgfCBudWxsIHtcbiAgICBjb25zdCB2aWV3cG9ydCA9IGdldFZpZXdQb3J0KGNvbnRleHQ/LmNvbmZpZz8uaW5wdXRTdHJlYW0/LnRhcmdldCk7XG4gICAgY29uc3QgdHlwZSA9IGNvbnRleHQ/LmNvbmZpZz8uaW5wdXRTdHJlYW0/LnR5cGU7XG4gICAgaWYgKCF0eXBlKSByZXR1cm4gbnVsbDtcbiAgICBjb25zdCBjb250YWluZXIgPSBpbml0Q2FudmFzZXMoY29udGV4dC5pbnB1dFN0cmVhbS5nZXRDYW52YXNTaXplKCkpO1xuICAgIGlmICghY29udGFpbmVyKSByZXR1cm4geyBkb206IHsgaW1hZ2U6IG51bGwsIG92ZXJsYXk6IG51bGwgfSwgY3R4OiB7IGltYWdlOiBudWxsLCBvdmVybGF5OiBudWxsIH0gfTtcblxuICAgIGNvbnN0IHsgZG9tIH0gPSBjb250YWluZXI7XG4gICAgaWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgaWYgKHZpZXdwb3J0KSB7XG4gICAgICAgICAgICBpZiAodHlwZSA9PT0gJ0ltYWdlU3RyZWFtJyAmJiAhdmlld3BvcnQuY29udGFpbnMoZG9tLmltYWdlKSkge1xuICAgICAgICAgICAgICAgIHZpZXdwb3J0LmFwcGVuZENoaWxkKGRvbS5pbWFnZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXZpZXdwb3J0LmNvbnRhaW5zKGRvbS5vdmVybGF5KSkge1xuICAgICAgICAgICAgICAgIHZpZXdwb3J0LmFwcGVuZENoaWxkKGRvbS5vdmVybGF5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY29udGFpbmVyO1xufVxuIiwiLyogV29ya2VyIGZ1bmN0aW9ucy4gVGhlc2UgYXJlIHN0cmFpZ2h0IGZyb20gdGhlIG9yaWdpbmFsIHF1YWdnYS5qcyBmaWxlLlxuICogTm90IHByZXNlbnRseSB1c2VkLCBhcyB3b3JrZXIgc3VwcG9ydCBpcyBub24tZnVuY3Rpb25hbC4gIEtlZXBpbmcgdGhlbSBhcm91bmQgdGVtcG9yYXJpbHlcbiAqIHRvIHJlZmVyIHRvIHVudGlsIGl0IGlzIHJlLWltcGxlbWVudGVkLiBXZSBtYXkgYmUgYWJsZSB0byBmaXgvdXNlIHNvbWUgb2YgdGhpcy5cbiAqL1xuXG5pbXBvcnQgeyBRdWFnZ2FKU0NvbmZpZ09iamVjdCwgUXVhZ2dhSlNSZWFkZXJDb25maWcgfSBmcm9tIFwiLi4vLi4vdHlwZS1kZWZpbml0aW9ucy9xdWFnZ2FcIjtcblxuLy8gVE9ETzogbmVlZCBhIHR5cGVzY3JpcHQgaW50ZXJmYWNlIGZvciBGcmFtZUdyYWJiZXJcblxuaW50ZXJmYWNlIFFXb3JrZXJUaHJlYWQge1xuICAgIGltYWdlRGF0YTogVWludDhBcnJheTtcbiAgICBidXN5OiBib29sZWFuO1xuICAgIHdvcmtlcjogV29ya2VyO1xufVxuXG5sZXQgd29ya2VyUG9vbDogQXJyYXk8UVdvcmtlclRocmVhZD4gPSBbXTtcblxuZXhwb3J0IGZ1bmN0aW9uIHVwZGF0ZVdvcmtlcnMoZnJhbWVHcmFiYmVyOiBhbnkpIHtcbiAgICBsZXQgYXZhaWxhYmxlV29ya2VyOiBRV29ya2VyVGhyZWFkO1xuICAgIGlmICh3b3JrZXJQb29sLmxlbmd0aCkge1xuICAgICAgICBhdmFpbGFibGVXb3JrZXIgPSB3b3JrZXJQb29sLmZpbHRlcigod29ya2VyVGhyZWFkKSA9PiAhd29ya2VyVGhyZWFkLmJ1c3kpWzBdO1xuICAgICAgICBpZiAoYXZhaWxhYmxlV29ya2VyKSB7XG4gICAgICAgICAgICBmcmFtZUdyYWJiZXIuYXR0YWNoRGF0YShhdmFpbGFibGVXb3JrZXIuaW1hZ2VEYXRhKTtcbiAgICAgICAgICAgIGlmIChmcmFtZUdyYWJiZXIuZ3JhYigpKSB7XG4gICAgICAgICAgICAgICAgYXZhaWxhYmxlV29ya2VyLmJ1c3kgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGF2YWlsYWJsZVdvcmtlci53b3JrZXIucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgICAgICAgICAgICBjbWQ6ICdwcm9jZXNzJyxcbiAgICAgICAgICAgICAgICAgICAgaW1hZ2VEYXRhOiBhdmFpbGFibGVXb3JrZXIuaW1hZ2VEYXRhLFxuICAgICAgICAgICAgICAgIH0sIFthdmFpbGFibGVXb3JrZXIuaW1hZ2VEYXRhLmJ1ZmZlcl0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIGNvbmZpZ0Zvcldvcmtlcihjb25maWc6IFF1YWdnYUpTQ29uZmlnT2JqZWN0KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLi4uY29uZmlnLFxuICAgICAgICBpbnB1dFN0cmVhbToge1xuICAgICAgICAgICAgLi4uY29uZmlnLmlucHV0U3RyZWFtLFxuICAgICAgICAgICAgdGFyZ2V0OiBudWxsLFxuICAgICAgICB9LFxuICAgIH07XG59XG5cbi8vIEB0cy1pZ25vcmVcbmZ1bmN0aW9uIHdvcmtlckludGVyZmFjZShmYWN0b3J5KSB7XG4gICAgaWYgKGZhY3RvcnkpIHtcbiAgICAgICAgdmFyIFF1YWdnYSA9IGZhY3RvcnkoKS5kZWZhdWx0O1xuICAgICAgICBpZiAoIVF1YWdnYSkge1xuLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgc2VsZi5wb3N0TWVzc2FnZSh7ICdldmVudCc6ICdlcnJvcicsIG1lc3NhZ2U6ICdRdWFnZ2EgY291bGQgbm90IGJlIGNyZWF0ZWQnIH0pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgfVxuLy8gQHRzLWlnbm9yZVxuICAgIHZhciBpbWFnZVdyYXBwZXI7XG5cbi8vIEB0cy1pZ25vcmVcbiAgICBmdW5jdGlvbiBvblByb2Nlc3NlZChyZXN1bHQpIHtcbiAgICAgICAgc2VsZi5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgICAnZXZlbnQnOiAncHJvY2Vzc2VkJyxcbi8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIGltYWdlRGF0YTogaW1hZ2VXcmFwcGVyLmRhdGEsXG4gICAgICAgICAgICByZXN1bHQ6IHJlc3VsdCxcbi8vIEB0cy1pZ25vcmVcbiAgICAgICAgfSwgW2ltYWdlV3JhcHBlci5kYXRhLmJ1ZmZlcl0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHdvcmtlckludGVyZmFjZVJlYWR5KCkge1xuICAgICAgICBzZWxmLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICAgICdldmVudCc6ICdpbml0aWFsaXplZCcsXG4vLyBAdHMtaWdub3JlXG4gICAgICAgICAgICBpbWFnZURhdGE6IGltYWdlV3JhcHBlci5kYXRhLFxuLy8gQHRzLWlnbm9yZVxuICAgICAgICB9LCBbaW1hZ2VXcmFwcGVyLmRhdGEuYnVmZmVyXSk7XG4gICAgfVxuXG4vLyBAdHMtaWdub3JlXG4gICAgc2VsZi5vbm1lc3NhZ2UgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICBpZiAoZS5kYXRhLmNtZCA9PT0gJ2luaXQnKSB7XG4gICAgICAgICAgICB2YXIgY29uZmlnID0gZS5kYXRhLmNvbmZpZztcbiAgICAgICAgICAgIGNvbmZpZy5udW1PZldvcmtlcnMgPSAwO1xuICAgICAgICAgICAgaW1hZ2VXcmFwcGVyID0gbmV3IFF1YWdnYS5JbWFnZVdyYXBwZXIoe1xuICAgICAgICAgICAgICAgIHg6IGUuZGF0YS5zaXplLngsXG4gICAgICAgICAgICAgICAgeTogZS5kYXRhLnNpemUueSxcbiAgICAgICAgICAgIH0sIG5ldyBVaW50OEFycmF5KGUuZGF0YS5pbWFnZURhdGEpKTtcbiAgICAgICAgICAgIFF1YWdnYS5pbml0KGNvbmZpZywgd29ya2VySW50ZXJmYWNlUmVhZHksIGltYWdlV3JhcHBlcik7XG4gICAgICAgICAgICBRdWFnZ2Eub25Qcm9jZXNzZWQob25Qcm9jZXNzZWQpO1xuICAgICAgICB9IGVsc2UgaWYgKGUuZGF0YS5jbWQgPT09ICdwcm9jZXNzJykge1xuLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgaW1hZ2VXcmFwcGVyLmRhdGEgPSBuZXcgVWludDhBcnJheShlLmRhdGEuaW1hZ2VEYXRhKTtcbiAgICAgICAgICAgIFF1YWdnYS5zdGFydCgpO1xuICAgICAgICB9IGVsc2UgaWYgKGUuZGF0YS5jbWQgPT09ICdzZXRSZWFkZXJzJykge1xuICAgICAgICAgICAgUXVhZ2dhLnNldFJlYWRlcnMoZS5kYXRhLnJlYWRlcnMpO1xuICAgICAgICB9IGVsc2UgaWYgKGUuZGF0YS5jbWQgPT09ICdyZWdpc3RlclJlYWRlcicpIHtcbiAgICAgICAgICAgIFF1YWdnYS5yZWdpc3RlclJlYWRlcihlLmRhdGEubmFtZSwgZS5kYXRhLnJlYWRlcik7XG4gICAgICAgIH1cbiAgICB9O1xufVxuXG5mdW5jdGlvbiBnZW5lcmF0ZVdvcmtlckJsb2IoKSB7XG4gICAgdmFyIGJsb2IsXG4gICAgICAgIGZhY3RvcnlTb3VyY2U7XG5cbiAgICAvKiBqc2hpbnQgaWdub3JlOnN0YXJ0ICovXG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIGlmICh0eXBlb2YgX19mYWN0b3J5U291cmNlX18gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgZmFjdG9yeVNvdXJjZSA9IF9fZmFjdG9yeVNvdXJjZV9fOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG4gICAgfVxuICAgIC8qIGpzaGludCBpZ25vcmU6ZW5kICovXG5cbiAgICBibG9iID0gbmV3IEJsb2IoWycoJyArIHdvcmtlckludGVyZmFjZS50b1N0cmluZygpICsgJykoJyArIGZhY3RvcnlTb3VyY2UgKyAnKTsnXSxcbiAgICAgICAgeyB0eXBlOiAndGV4dC9qYXZhc2NyaXB0JyB9KTtcblxuICAgIHJldHVybiB3aW5kb3cuVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGluaXRXb3JrZXIoY29uZmlnOiBRdWFnZ2FKU0NvbmZpZ09iamVjdCwgaW5wdXRTdHJlYW06IGFueSwgY2I6IEZ1bmN0aW9uKSB7XG4gICAgY29uc3QgYmxvYlVSTCA9IGdlbmVyYXRlV29ya2VyQmxvYigpO1xuICAgIGNvbnN0IHdvcmtlciA9IG5ldyBXb3JrZXIoYmxvYlVSTCk7XG5cbiAgICBjb25zdCB3b3JrZXJUaHJlYWQ6IFFXb3JrZXJUaHJlYWQgPSB7XG4gICAgICAgIHdvcmtlcixcbiAgICAgICAgaW1hZ2VEYXRhOiBuZXcgVWludDhBcnJheShpbnB1dFN0cmVhbS5nZXRXaWR0aCgpICogaW5wdXRTdHJlYW0uZ2V0SGVpZ2h0KCkpLFxuICAgICAgICBidXN5OiB0cnVlLFxuICAgIH07XG5cbiAgICB3b3JrZXJUaHJlYWQud29ya2VyLm9ubWVzc2FnZSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGlmIChlLmRhdGEuZXZlbnQgPT09ICdpbml0aWFsaXplZCcpIHtcbiAgICAgICAgICAgIFVSTC5yZXZva2VPYmplY3RVUkwoYmxvYlVSTCk7XG4gICAgICAgICAgICB3b3JrZXJUaHJlYWQuYnVzeSA9IGZhbHNlO1xuICAgICAgICAgICAgd29ya2VyVGhyZWFkLmltYWdlRGF0YSA9IG5ldyBVaW50OEFycmF5KGUuZGF0YS5pbWFnZURhdGEpO1xuICAgICAgICAgICAgaWYgKEVOVi5kZXZlbG9wbWVudCkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdXb3JrZXIgaW5pdGlhbGl6ZWQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNiKHdvcmtlclRocmVhZCk7XG4gICAgICAgIH0gZWxzZSBpZiAoZS5kYXRhLmV2ZW50ID09PSAncHJvY2Vzc2VkJykge1xuICAgICAgICAgICAgd29ya2VyVGhyZWFkLmltYWdlRGF0YSA9IG5ldyBVaW50OEFycmF5KGUuZGF0YS5pbWFnZURhdGEpO1xuICAgICAgICAgICAgd29ya2VyVGhyZWFkLmJ1c3kgPSBmYWxzZTtcbiAgICAgICAgICAgIC8vIFRPRE86IGhvdyB0byB0aHJlYWQgcHVibGlzaFJlc3VsdCBpbnRvIGhlcmU/XG4gICAgICAgICAgICAvLyBwdWJsaXNoUmVzdWx0KGUuZGF0YS5yZXN1bHQsIHdvcmtlclRocmVhZC5pbWFnZURhdGEpO1xuICAgICAgICB9IGVsc2UgaWYgKGUuZGF0YS5ldmVudCA9PT0gJ2Vycm9yJykge1xuICAgICAgICAgICAgaWYgKEVOVi5kZXZlbG9wbWVudCkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdXb3JrZXIgZXJyb3I6ICcgKyBlLmRhdGEubWVzc2FnZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgd29ya2VyVGhyZWFkLndvcmtlci5wb3N0TWVzc2FnZSh7XG4gICAgICAgIGNtZDogJ2luaXQnLFxuICAgICAgICBzaXplOiB7IHg6IGlucHV0U3RyZWFtLmdldFdpZHRoKCksIHk6IGlucHV0U3RyZWFtLmdldEhlaWdodCgpIH0sXG4gICAgICAgIGltYWdlRGF0YTogd29ya2VyVGhyZWFkLmltYWdlRGF0YSxcbiAgICAgICAgY29uZmlnOiBjb25maWdGb3JXb3JrZXIoY29uZmlnKSxcbiAgICB9LCBbd29ya2VyVGhyZWFkLmltYWdlRGF0YS5idWZmZXJdKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFkanVzdFdvcmtlclBvb2woY2FwYWNpdHk6IG51bWJlciwgY29uZmlnPzogUXVhZ2dhSlNDb25maWdPYmplY3QsIGlucHV0U3RyZWFtPzogYW55LCBjYj86IEZ1bmN0aW9uKSB7XG4gICAgY29uc3QgaW5jcmVhc2VCeSA9IGNhcGFjaXR5IC0gd29ya2VyUG9vbC5sZW5ndGg7XG4gICAgaWYgKGluY3JlYXNlQnkgPT09IDAgJiYgY2IpIHtcbiAgICAgICAgY2IoKTtcbiAgICB9IGVsc2UgaWYgKGluY3JlYXNlQnkgPCAwKSB7XG4gICAgICAgIGNvbnN0IHdvcmtlcnNUb1Rlcm1pbmF0ZSA9IHdvcmtlclBvb2wuc2xpY2UoaW5jcmVhc2VCeSk7XG4gICAgICAgIHdvcmtlcnNUb1Rlcm1pbmF0ZS5mb3JFYWNoKGZ1bmN0aW9uICh3b3JrZXJUaHJlYWQpIHtcbiAgICAgICAgICAgIHdvcmtlclRocmVhZC53b3JrZXIudGVybWluYXRlKCk7XG4gICAgICAgICAgICBpZiAoRU5WLmRldmVsb3BtZW50KSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ1dvcmtlciB0ZXJtaW5hdGVkIScpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgd29ya2VyUG9vbCA9IHdvcmtlclBvb2wuc2xpY2UoMCwgaW5jcmVhc2VCeSk7XG4gICAgICAgIGlmIChjYikge1xuICAgICAgICAgICAgY2IoKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHdvcmtlckluaXRpYWxpemVkID0gKHdvcmtlclRocmVhZDogUVdvcmtlclRocmVhZCkgPT4ge1xuICAgICAgICAgICAgd29ya2VyUG9vbC5wdXNoKHdvcmtlclRocmVhZCk7XG4gICAgICAgICAgICBpZiAod29ya2VyUG9vbC5sZW5ndGggPj0gY2FwYWNpdHkgJiYgY2IpIHtcbiAgICAgICAgICAgICAgICBjYigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChjb25maWcpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5jcmVhc2VCeTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaW5pdFdvcmtlcihjb25maWcsIGlucHV0U3RyZWFtLCB3b3JrZXJJbml0aWFsaXplZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzZXRSZWFkZXJzKHJlYWRlcnM6IEFycmF5PFF1YWdnYUpTUmVhZGVyQ29uZmlnPikge1xuICAgIHdvcmtlclBvb2wuZm9yRWFjaCgod29ya2VyVGhyZWFkKSA9PiB3b3JrZXJUaHJlYWQud29ya2VyLnBvc3RNZXNzYWdlKHsgY21kOiAnc2V0UmVhZGVycycsIHJlYWRlcnMgfSkpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVnaXN0ZXJSZWFkZXIobmFtZTogc3RyaW5nLCByZWFkZXI6IGFueSkge1xuICAgIHdvcmtlclBvb2wuZm9yRWFjaCgod29ya2VyVGhyZWFkKSA9PiB3b3JrZXJUaHJlYWQud29ya2VyLnBvc3RNZXNzYWdlKHsgY21kOiAncmVnaXN0ZXJSZWFkZXInLCBuYW1lLCByZWFkZXIgfSkpO1xufVxuIiwiaW1wb3J0IHsgSW5wdXRTdHJlYW1GYWN0b3J5IH0gZnJvbSAnaW5wdXQvaW5wdXRfc3RyZWFtL2lucHV0X3N0cmVhbS5kJztcbmltcG9ydCB0eXBlIHsgSW5wdXRTdHJlYW1UeXBlIH0gZnJvbSAnLi4vLi4vdHlwZS1kZWZpbml0aW9ucy9xdWFnZ2EuZCc7XG5cbi8vIFRPRE86IG5lZWQgdG8gY3JlYXRlIGFuIElucHV0U3RyZWFtIHR5cGVzY3JpcHQgaW50ZXJmYWNlLCBzbyB3ZSBkb24ndCBoYXZlIGFuIFwiYW55XCIgaW4gdGhlIG5leHQgbGluZVxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gc2V0dXBJbnB1dFN0cmVhbSh0eXBlOiBJbnB1dFN0cmVhbVR5cGUgPSAnTGl2ZVN0cmVhbScsIHZpZXdwb3J0OiBFbGVtZW50IHwgbnVsbCwgaW5wdXRTdHJlYW1GYWN0b3J5OiBJbnB1dFN0cmVhbUZhY3RvcnkpIHtcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSAnVmlkZW9TdHJlYW0nOiB7XG4gICAgICAgICAgICBjb25zdCB2aWRlbyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3ZpZGVvJyk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHZpZGVvLFxuICAgICAgICAgICAgICAgIGlucHV0U3RyZWFtOiBpbnB1dFN0cmVhbUZhY3RvcnkuY3JlYXRlVmlkZW9TdHJlYW0odmlkZW8pLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdJbWFnZVN0cmVhbSc6XG4gICAgICAgICAgICByZXR1cm4geyBpbnB1dFN0cmVhbTogaW5wdXRTdHJlYW1GYWN0b3J5LmNyZWF0ZUltYWdlU3RyZWFtKCkgfTtcbiAgICAgICAgY2FzZSAnTGl2ZVN0cmVhbSc6IHtcbiAgICAgICAgICAgIGxldCB2aWRlbzogSFRNTFZpZGVvRWxlbWVudCB8IG51bGwgPSBudWxsO1xuICAgICAgICAgICAgaWYgKHZpZXdwb3J0KSB7XG4gICAgICAgICAgICAgICAgdmlkZW8gPSB2aWV3cG9ydC5xdWVyeVNlbGVjdG9yKCd2aWRlbycpO1xuICAgICAgICAgICAgICAgIGlmICghdmlkZW8pIHtcbiAgICAgICAgICAgICAgICAgICAgdmlkZW8gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd2aWRlbycpO1xuICAgICAgICAgICAgICAgICAgICB2aWV3cG9ydC5hcHBlbmRDaGlsZCh2aWRlbyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB2aWRlbyxcbiAgICAgICAgICAgICAgICBpbnB1dFN0cmVhbTogaW5wdXRTdHJlYW1GYWN0b3J5LmNyZWF0ZUxpdmVTdHJlYW0odmlkZW8gYXMgSFRNTFZpZGVvRWxlbWVudCksXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGAqIHNldHVwSW5wdXRTdHJlYW0gaW52YWxpZCB0eXBlICR7dHlwZX1gKTtcbiAgICAgICAgICAgIHJldHVybiB7IHZpZGVvOiBudWxsLCBpbnB1dFN0cmVhbTogbnVsbCB9O1xuICAgIH1cbn1cbiIsIi8qIGVzbGludC1kaXNhYmxlIG5vLXBhcmFtLXJlYXNzaWduICovXG5pbXBvcnQgdHlwZSB7IFBvaW50IH0gZnJvbSAnLi4vLi4vdHlwZS1kZWZpbml0aW9ucy9xdWFnZ2EuZCc7XG5cbmV4cG9ydCB0eXBlIEJveCA9IEFycmF5PFsgbnVtYmVyLCBudW1iZXIgXT47XG5cbmV4cG9ydCB0eXBlIExpbmUgPSBbIFBvaW50LCBQb2ludCBdO1xuXG5leHBvcnQgZnVuY3Rpb24gbW92ZUJveChib3g6IEJveCwgeE9mZnNldDogbnVtYmVyLCB5T2Zmc2V0OiBudW1iZXIpOiB2b2lkIHtcbiAgICBsZXQgY29ybmVyID0gYm94Lmxlbmd0aDtcbiAgICB3aGlsZSAoY29ybmVyLS0pIHtcbiAgICAgICAgYm94W2Nvcm5lcl1bMF0gKz0geE9mZnNldDtcbiAgICAgICAgYm94W2Nvcm5lcl1bMV0gKz0geU9mZnNldDtcbiAgICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBtb3ZlTGluZShsaW5lOiBMaW5lLCB4T2Zmc2V0OiBudW1iZXIsIHlPZmZzZXQ6IG51bWJlcik6IHZvaWQge1xuICAgIGxpbmVbMF0ueCArPSB4T2Zmc2V0O1xuICAgIGxpbmVbMF0ueSArPSB5T2Zmc2V0O1xuICAgIGxpbmVbMV0ueCArPSB4T2Zmc2V0O1xuICAgIGxpbmVbMV0ueSArPSB5T2Zmc2V0O1xufVxuIiwiaW1wb3J0IHsgZ2xNYXRyaXgsIHZlYzIgfSBmcm9tICdnbC1tYXRyaXgnO1xuaW1wb3J0IHsgUXVhZ2dhSlNSZXN1bHRPYmplY3QsIFF1YWdnYUpTUmVhZGVyQ29uZmlnIH0gZnJvbSAnLi4vLi4vdHlwZS1kZWZpbml0aW9ucy9xdWFnZ2EuZCc7XG5pbXBvcnQgRXZlbnRzIGZyb20gJy4uL2NvbW1vbi9ldmVudHMnO1xuaW1wb3J0IEltYWdlV3JhcHBlciBmcm9tICcuLi9jb21tb24vaW1hZ2Vfd3JhcHBlcic7XG5pbXBvcnQgQmFyY29kZURlY29kZXIgZnJvbSAnLi4vZGVjb2Rlci9iYXJjb2RlX2RlY29kZXInO1xuaW1wb3J0IENhbWVyYUFjY2VzcyBmcm9tICcuLi9pbnB1dC9jYW1lcmFfYWNjZXNzJztcbmltcG9ydCBGcmFtZUdyYWJiZXIgZnJvbSAnLi4vaW5wdXQvZnJhbWVfZ3JhYmJlci5qcyc7XG5pbXBvcnQgSW5wdXRTdHJlYW0gZnJvbSAnLi4vaW5wdXQvaW5wdXRfc3RyZWFtL2lucHV0X3N0cmVhbSc7XG5pbXBvcnQgQmFyY29kZUxvY2F0b3IgZnJvbSAnLi4vbG9jYXRvci9iYXJjb2RlX2xvY2F0b3InO1xuaW1wb3J0IHsgUXVhZ2dhQ29udGV4dCB9IGZyb20gJy4uL1F1YWdnYUNvbnRleHQnO1xuaW1wb3J0IHsgQmFyY29kZUluZm8gfSBmcm9tICcuLi9yZWFkZXIvYmFyY29kZV9yZWFkZXInO1xuaW1wb3J0IF9nZXRWaWV3UG9ydCBmcm9tICcuL2dldFZpZXdQb3J0JztcbmltcG9ydCBfaW5pdEJ1ZmZlcnMgZnJvbSAnLi9pbml0QnVmZmVycyc7XG5pbXBvcnQgX2luaXRDYW52YXMgZnJvbSAnLi9pbml0Q2FudmFzJztcbmltcG9ydCAqIGFzIFFXb3JrZXJzIGZyb20gJy4vcXdvcmtlcic7XG5pbXBvcnQgc2V0dXBJbnB1dFN0cmVhbSBmcm9tICcuL3NldHVwSW5wdXRTdHJlYW0nO1xuaW1wb3J0IHsgbW92ZUxpbmUsIG1vdmVCb3ggfSBmcm9tICcuL3RyYW5zZm9ybSc7XG5cbmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShBcnJheSk7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFF1YWdnYSB7XG4gICAgY29udGV4dDogUXVhZ2dhQ29udGV4dCA9IG5ldyBRdWFnZ2FDb250ZXh0KCk7XG5cbiAgICBpbml0QnVmZmVycyhpbWFnZVdyYXBwZXI/OiBJbWFnZVdyYXBwZXIpOiB2b2lkIHtcbiAgICAgICAgaWYgKCF0aGlzLmNvbnRleHQuY29uZmlnKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBpbnB1dEltYWdlV3JhcHBlciwgYm94U2l6ZSB9ID0gX2luaXRCdWZmZXJzKFxuICAgICAgICAgICAgdGhpcy5jb250ZXh0LmlucHV0U3RyZWFtLFxuICAgICAgICAgICAgaW1hZ2VXcmFwcGVyLFxuICAgICAgICAgICAgdGhpcy5jb250ZXh0LmNvbmZpZy5sb2NhdG9yLFxuICAgICAgICApO1xuICAgICAgICB0aGlzLmNvbnRleHQuaW5wdXRJbWFnZVdyYXBwZXIgPSBpbnB1dEltYWdlV3JhcHBlcjtcbiAgICAgICAgdGhpcy5jb250ZXh0LmJveFNpemUgPSBib3hTaXplO1xuICAgIH1cblxuICAgIGluaXRpYWxpemVEYXRhKGltYWdlV3JhcHBlcj86IEltYWdlV3JhcHBlcik6IHZvaWQge1xuICAgICAgICBpZiAoIXRoaXMuY29udGV4dC5jb25maWcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmluaXRCdWZmZXJzKGltYWdlV3JhcHBlcik7XG4gICAgICAgIHRoaXMuY29udGV4dC5kZWNvZGVyID0gQmFyY29kZURlY29kZXIuY3JlYXRlKHRoaXMuY29udGV4dC5jb25maWcuZGVjb2RlciwgdGhpcy5jb250ZXh0LmlucHV0SW1hZ2VXcmFwcGVyKTtcbiAgICB9XG5cbiAgICBnZXRWaWV3UG9ydCgpOiBFbGVtZW50IHwgbnVsbCB7XG4gICAgICAgIGlmICghdGhpcy5jb250ZXh0LmNvbmZpZyB8fCAhdGhpcy5jb250ZXh0LmNvbmZpZy5pbnB1dFN0cmVhbSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyB0YXJnZXQgfSA9IHRoaXMuY29udGV4dC5jb25maWcuaW5wdXRTdHJlYW07XG4gICAgICAgIHJldHVybiBfZ2V0Vmlld1BvcnQodGFyZ2V0KTtcbiAgICB9XG5cbiAgICByZWFkeShjYWxsYmFjazogKCkgPT4gdm9pZCk6IHZvaWQge1xuICAgICAgICB0aGlzLmNvbnRleHQuaW5wdXRTdHJlYW0ucGxheSgpO1xuICAgICAgICBjYWxsYmFjaygpO1xuICAgIH1cblxuICAgIGluaXRDYW52YXMoKTogdm9pZCB7XG4gICAgICAgIGNvbnN0IGNvbnRhaW5lciA9IF9pbml0Q2FudmFzKHRoaXMuY29udGV4dCk7XG4gICAgICAgIGlmICghY29udGFpbmVyKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBjdHgsIGRvbSB9ID0gY29udGFpbmVyO1xuICAgICAgICB0aGlzLmNvbnRleHQuY2FudmFzQ29udGFpbmVyLmRvbS5pbWFnZSA9IGRvbS5pbWFnZTtcbiAgICAgICAgdGhpcy5jb250ZXh0LmNhbnZhc0NvbnRhaW5lci5kb20ub3ZlcmxheSA9IGRvbS5vdmVybGF5O1xuICAgICAgICB0aGlzLmNvbnRleHQuY2FudmFzQ29udGFpbmVyLmN0eC5pbWFnZSA9IGN0eC5pbWFnZTtcbiAgICAgICAgdGhpcy5jb250ZXh0LmNhbnZhc0NvbnRhaW5lci5jdHgub3ZlcmxheSA9IGN0eC5vdmVybGF5O1xuICAgIH1cblxuICAgIGNhblJlY29yZCA9IChjYWxsYmFjazogKCkgPT4gdm9pZCk6IHZvaWQgPT4ge1xuICAgICAgICBpZiAoIXRoaXMuY29udGV4dC5jb25maWcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBCYXJjb2RlTG9jYXRvci5jaGVja0ltYWdlQ29uc3RyYWludHModGhpcy5jb250ZXh0LmlucHV0U3RyZWFtLCB0aGlzLmNvbnRleHQuY29uZmlnPy5sb2NhdG9yKTtcbiAgICAgICAgdGhpcy5pbml0Q2FudmFzKCk7XG4gICAgICAgIHRoaXMuY29udGV4dC5mcmFtZWdyYWJiZXIgPSBGcmFtZUdyYWJiZXIuY3JlYXRlKFxuICAgICAgICAgICAgdGhpcy5jb250ZXh0LmlucHV0U3RyZWFtLFxuICAgICAgICAgICAgdGhpcy5jb250ZXh0LmNhbnZhc0NvbnRhaW5lci5kb20uaW1hZ2UsXG4gICAgICAgICk7XG5cbiAgICAgICAgaWYgKHRoaXMuY29udGV4dC5jb25maWcubnVtT2ZXb3JrZXJzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuY29udGV4dC5jb25maWcubnVtT2ZXb3JrZXJzID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIFFXb3JrZXJzLmFkanVzdFdvcmtlclBvb2woXG4gICAgICAgICAgICB0aGlzLmNvbnRleHQuY29uZmlnLm51bU9mV29ya2VycyxcbiAgICAgICAgICAgIHRoaXMuY29udGV4dC5jb25maWcsXG4gICAgICAgICAgICB0aGlzLmNvbnRleHQuaW5wdXRTdHJlYW0sXG4gICAgICAgICAgICAoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY29udGV4dC5jb25maWc/Lm51bU9mV29ya2VycyA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmluaXRpYWxpemVEYXRhKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMucmVhZHkoY2FsbGJhY2spO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgKTtcbiAgICB9O1xuXG4gICAgaW5pdElucHV0U3RyZWFtKGNhbGxiYWNrOiAoZXJyPzogRXJyb3IpID0+IHZvaWQpOiB2b2lkIHtcbiAgICAgICAgaWYgKCF0aGlzLmNvbnRleHQuY29uZmlnIHx8ICF0aGlzLmNvbnRleHQuY29uZmlnLmlucHV0U3RyZWFtKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyB0eXBlOiBpbnB1dFR5cGUsIGNvbnN0cmFpbnRzIH0gPSB0aGlzLmNvbnRleHQuY29uZmlnLmlucHV0U3RyZWFtO1xuICAgICAgICBjb25zdCB7IHZpZGVvLCBpbnB1dFN0cmVhbSB9ID0gc2V0dXBJbnB1dFN0cmVhbShpbnB1dFR5cGUsIHRoaXMuZ2V0Vmlld1BvcnQoKSwgSW5wdXRTdHJlYW0pO1xuXG4gICAgICAgIGlmIChpbnB1dFR5cGUgPT09ICdMaXZlU3RyZWFtJyAmJiB2aWRlbykge1xuICAgICAgICAgICAgQ2FtZXJhQWNjZXNzLnJlcXVlc3QodmlkZW8sIGNvbnN0cmFpbnRzKVxuICAgICAgICAgICAgICAgIC50aGVuKCgpID0+IGlucHV0U3RyZWFtLnRyaWdnZXIoJ2NhbnJlY29yZCcpKVxuICAgICAgICAgICAgICAgIC5jYXRjaCgoZXJyKSA9PiBjYWxsYmFjayhlcnIpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpbnB1dFN0cmVhbSkge1xuICAgICAgICAgICAgaW5wdXRTdHJlYW0uc2V0QXR0cmlidXRlKCdwcmVsb2FkJywgJ2F1dG8nKTtcbiAgICAgICAgICAgIGlucHV0U3RyZWFtLnNldElucHV0U3RyZWFtKHRoaXMuY29udGV4dC5jb25maWcuaW5wdXRTdHJlYW0pO1xuICAgICAgICAgICAgaW5wdXRTdHJlYW0uYWRkRXZlbnRMaXN0ZW5lcignY2FucmVjb3JkJywgdGhpcy5jYW5SZWNvcmQuYmluZCh1bmRlZmluZWQsIGNhbGxiYWNrKSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmNvbnRleHQuaW5wdXRTdHJlYW0gPSBpbnB1dFN0cmVhbTtcbiAgICB9XG5cbiAgICBnZXRCb3VuZGluZ0JveGVzKCk6IEFycmF5PEFycmF5PG51bWJlcj4+IHwgbnVsbCB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnRleHQuY29uZmlnPy5sb2NhdGUgPyBCYXJjb2RlTG9jYXRvci5sb2NhdGUoKVxuICAgICAgICAgICAgOiBbW1xuICAgICAgICAgICAgICAgIHZlYzIuY2xvbmUodGhpcy5jb250ZXh0LmJveFNpemVbMF0pLFxuICAgICAgICAgICAgICAgIHZlYzIuY2xvbmUodGhpcy5jb250ZXh0LmJveFNpemVbMV0pLFxuICAgICAgICAgICAgICAgIHZlYzIuY2xvbmUodGhpcy5jb250ZXh0LmJveFNpemVbMl0pLFxuICAgICAgICAgICAgICAgIHZlYzIuY2xvbmUodGhpcy5jb250ZXh0LmJveFNpemVbM10pLFxuICAgICAgICAgICAgXV07XG4gICAgfVxuXG4gICAgLy8gVE9ETzogbmVlZCBhIHR5cGVzY3JpcHQgdHlwZSBmb3IgcmVzdWx0IGhlcmUuXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9leHBsaWNpdC1tb2R1bGUtYm91bmRhcnktdHlwZXNcbiAgICB0cmFuc2Zvcm1SZXN1bHQocmVzdWx0OiBhbnkpOiB2b2lkIHtcbiAgICAgICAgY29uc3QgdG9wUmlnaHQgPSB0aGlzLmNvbnRleHQuaW5wdXRTdHJlYW0uZ2V0VG9wUmlnaHQoKTtcbiAgICAgICAgY29uc3QgeE9mZnNldCA9IHRvcFJpZ2h0Lng7XG4gICAgICAgIGNvbnN0IHlPZmZzZXQgPSB0b3BSaWdodC55O1xuXG4gICAgICAgIGlmICh4T2Zmc2V0ID09PSAwICYmIHlPZmZzZXQgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyZXN1bHQuYmFyY29kZXMpIHtcbiAgICAgICAgICAgIC8vIFRPRE86IEJhcmNvZGVJbmZvIG1heSBub3QgYmUgdGhlIHJpZ2h0IHR5cGUgaGVyZS5cbiAgICAgICAgICAgIHJlc3VsdC5iYXJjb2Rlcy5mb3JFYWNoKChiYXJjb2RlOiBCYXJjb2RlSW5mbykgPT4gdGhpcy50cmFuc2Zvcm1SZXN1bHQoYmFyY29kZSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJlc3VsdC5saW5lICYmIHJlc3VsdC5saW5lLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgICAgbW92ZUxpbmUocmVzdWx0LmxpbmUsIHhPZmZzZXQsIHlPZmZzZXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJlc3VsdC5ib3gpIHtcbiAgICAgICAgICAgIG1vdmVCb3gocmVzdWx0LmJveCwgeE9mZnNldCwgeU9mZnNldCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocmVzdWx0LmJveGVzICYmIHJlc3VsdC5ib3hlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlc3VsdC5ib3hlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIG1vdmVCb3gocmVzdWx0LmJveGVzW2ldLCB4T2Zmc2V0LCB5T2Zmc2V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGFkZFJlc3VsdChyZXN1bHQ6IFF1YWdnYUpTUmVzdWx0T2JqZWN0LCBpbWFnZURhdGE6IEFycmF5PG51bWJlcj4pOiB2b2lkIHtcbiAgICAgICAgaWYgKCFpbWFnZURhdGEgfHwgIXRoaXMuY29udGV4dC5yZXN1bHRDb2xsZWN0b3IpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRPRE86IEZpZ3VyZSBvdXQgd2hhdCBkYXRhIHN0cnVjdHVyZSBob2xkcyBhIFwiYmFyY29kZXNcIiByZXN1bHQsIGlmIGFueS4uLlxuICAgICAgICBpZiAocmVzdWx0LmJhcmNvZGVzKSB7XG4gICAgICAgICAgICByZXN1bHQuYmFyY29kZXMuZmlsdGVyKChiYXJjb2RlOiBRdWFnZ2FKU1Jlc3VsdE9iamVjdCkgPT4gYmFyY29kZS5jb2RlUmVzdWx0KVxuICAgICAgICAgICAgICAgIC5mb3JFYWNoKChiYXJjb2RlOiBRdWFnZ2FKU1Jlc3VsdE9iamVjdCkgPT4gdGhpcy5hZGRSZXN1bHQoYmFyY29kZSwgaW1hZ2VEYXRhKSk7XG4gICAgICAgIH0gZWxzZSBpZiAocmVzdWx0LmNvZGVSZXN1bHQpIHtcbiAgICAgICAgICAgIHRoaXMuY29udGV4dC5yZXN1bHRDb2xsZWN0b3IuYWRkUmVzdWx0KFxuICAgICAgICAgICAgICAgIGltYWdlRGF0YSxcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQuaW5wdXRTdHJlYW0uZ2V0Q2FudmFzU2l6ZSgpLFxuICAgICAgICAgICAgICAgIHJlc3VsdC5jb2RlUmVzdWx0LFxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjbGFzcy1tZXRob2RzLXVzZS10aGlzXG4gICAgaGFzQ29kZVJlc3VsdChyZXN1bHQ6IFF1YWdnYUpTUmVzdWx0T2JqZWN0KTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiAhIShyZXN1bHQgJiYgKHJlc3VsdC5iYXJjb2Rlc1xuICAgICAgICAgICAgPyByZXN1bHQuYmFyY29kZXMuc29tZSgoYmFyY29kZSkgPT4gYmFyY29kZS5jb2RlUmVzdWx0KVxuICAgICAgICAgICAgOiByZXN1bHQuY29kZVJlc3VsdCkpO1xuICAgIH1cblxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvZXhwbGljaXQtbW9kdWxlLWJvdW5kYXJ5LXR5cGVzXG4gICAgcHVibGlzaFJlc3VsdChyZXN1bHQ6IFF1YWdnYUpTUmVzdWx0T2JqZWN0IHwgbnVsbCA9IG51bGwsIGltYWdlRGF0YT86IGFueSk6IHZvaWQge1xuICAgICAgICBsZXQgcmVzdWx0VG9QdWJsaXNoOiBBcnJheTxRdWFnZ2FKU1Jlc3VsdE9iamVjdD4gfCBRdWFnZ2FKU1Jlc3VsdE9iamVjdCB8IG51bGwgPSByZXN1bHQ7XG5cbiAgICAgICAgaWYgKHJlc3VsdCAmJiB0aGlzLmNvbnRleHQub25VSVRocmVhZCkge1xuICAgICAgICAgICAgdGhpcy50cmFuc2Zvcm1SZXN1bHQocmVzdWx0KTtcbiAgICAgICAgICAgIHRoaXMuYWRkUmVzdWx0KHJlc3VsdCwgaW1hZ2VEYXRhKTtcbiAgICAgICAgICAgIHJlc3VsdFRvUHVibGlzaCA9IHJlc3VsdC5iYXJjb2RlcyB8fCByZXN1bHQ7XG4gICAgICAgIH1cblxuICAgICAgICBFdmVudHMucHVibGlzaCgncHJvY2Vzc2VkJywgcmVzdWx0VG9QdWJsaXNoIGFzIG5ldmVyKTtcbiAgICAgICAgaWYgKHRoaXMuaGFzQ29kZVJlc3VsdChyZXN1bHQgYXMgUXVhZ2dhSlNSZXN1bHRPYmplY3QpKSB7XG4gICAgICAgICAgICBFdmVudHMucHVibGlzaCgnZGV0ZWN0ZWQnLCByZXN1bHRUb1B1Ymxpc2ggYXMgbmV2ZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgYXN5bmMgbG9jYXRlQW5kRGVjb2RlKCk6IFByb21pc2U8dm9pZD4ge1xuICAgICAgICBjb25zdCBib3hlcyA9IHRoaXMuZ2V0Qm91bmRpbmdCb3hlcygpO1xuICAgICAgICBpZiAoYm94ZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IGRlY29kZVJlc3VsdCA9IChhd2FpdCB0aGlzLmNvbnRleHQuZGVjb2Rlci5kZWNvZGVGcm9tQm91bmRpbmdCb3hlcyhib3hlcykpIHx8IHt9O1xuICAgICAgICAgICAgZGVjb2RlUmVzdWx0LmJveGVzID0gYm94ZXM7XG4gICAgICAgICAgICB0aGlzLnB1Ymxpc2hSZXN1bHQoZGVjb2RlUmVzdWx0LCB0aGlzLmNvbnRleHQuaW5wdXRJbWFnZVdyYXBwZXI/LmRhdGEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgaW1hZ2VSZXN1bHQgPSBhd2FpdCB0aGlzLmNvbnRleHQuZGVjb2Rlci5kZWNvZGVGcm9tSW1hZ2UodGhpcy5jb250ZXh0LmlucHV0SW1hZ2VXcmFwcGVyKTtcbiAgICAgICAgICAgIGlmIChpbWFnZVJlc3VsdCkge1xuICAgICAgICAgICAgICAgIHRoaXMucHVibGlzaFJlc3VsdChpbWFnZVJlc3VsdCwgdGhpcy5jb250ZXh0LmlucHV0SW1hZ2VXcmFwcGVyPy5kYXRhKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wdWJsaXNoUmVzdWx0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB1cGRhdGUgPSAoKTogdm9pZCA9PiB7XG4gICAgICAgIGlmICh0aGlzLmNvbnRleHQub25VSVRocmVhZCkge1xuICAgICAgICAgICAgY29uc3Qgd29ya2Vyc1VwZGF0ZWQgPSBRV29ya2Vycy51cGRhdGVXb3JrZXJzKHRoaXMuY29udGV4dC5mcmFtZWdyYWJiZXIpO1xuICAgICAgICAgICAgaWYgKCF3b3JrZXJzVXBkYXRlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5mcmFtZWdyYWJiZXIuYXR0YWNoRGF0YSh0aGlzLmNvbnRleHQuaW5wdXRJbWFnZVdyYXBwZXI/LmRhdGEpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNvbnRleHQuZnJhbWVncmFiYmVyLmdyYWIoKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXdvcmtlcnNVcGRhdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxvY2F0ZUFuZERlY29kZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jb250ZXh0LmZyYW1lZ3JhYmJlci5hdHRhY2hEYXRhKHRoaXMuY29udGV4dC5pbnB1dEltYWdlV3JhcHBlcj8uZGF0YSk7XG4gICAgICAgICAgICB0aGlzLmNvbnRleHQuZnJhbWVncmFiYmVyLmdyYWIoKTtcbiAgICAgICAgICAgIHRoaXMubG9jYXRlQW5kRGVjb2RlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgc3RhcnRDb250aW51b3VzVXBkYXRlKCk6IHZvaWQge1xuICAgICAgICBsZXQgbmV4dDogbnVtYmVyIHwgbnVsbCA9IG51bGw7XG4gICAgICAgIGNvbnN0IGRlbGF5ID0gMTAwMCAvICh0aGlzLmNvbnRleHQuY29uZmlnPy5mcmVxdWVuY3kgfHwgNjApO1xuXG4gICAgICAgIHRoaXMuY29udGV4dC5zdG9wcGVkID0gZmFsc2U7XG4gICAgICAgIGNvbnN0IHsgY29udGV4dCB9ID0gdGhpcztcblxuICAgICAgICBjb25zdCBuZXdGcmFtZSA9ICh0aW1lc3RhbXA6IG51bWJlcikgPT4ge1xuICAgICAgICAgICAgbmV4dCA9IG5leHQgfHwgdGltZXN0YW1wO1xuICAgICAgICAgICAgaWYgKCFjb250ZXh0LnN0b3BwZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAodGltZXN0YW1wID49IG5leHQpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV4dCArPSBkZWxheTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZShuZXdGcmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgbmV3RnJhbWUocGVyZm9ybWFuY2Uubm93KCkpO1xuICAgIH1cblxuICAgIHN0YXJ0KCk6IHZvaWQge1xuICAgICAgICBpZiAodGhpcy5jb250ZXh0Lm9uVUlUaHJlYWQgJiYgdGhpcy5jb250ZXh0LmNvbmZpZz8uaW5wdXRTdHJlYW0/LnR5cGUgPT09ICdMaXZlU3RyZWFtJykge1xuICAgICAgICAgICAgdGhpcy5zdGFydENvbnRpbnVvdXNVcGRhdGUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBhc3luYyBzdG9wKCk6IFByb21pc2U8dm9pZD4ge1xuICAgICAgICB0aGlzLmNvbnRleHQuc3RvcHBlZCA9IHRydWU7XG4gICAgICAgIFFXb3JrZXJzLmFkanVzdFdvcmtlclBvb2woMCk7XG4gICAgICAgIGlmICh0aGlzLmNvbnRleHQuY29uZmlnPy5pbnB1dFN0cmVhbSAmJiB0aGlzLmNvbnRleHQuY29uZmlnLmlucHV0U3RyZWFtLnR5cGUgPT09ICdMaXZlU3RyZWFtJykge1xuICAgICAgICAgICAgYXdhaXQgQ2FtZXJhQWNjZXNzLnJlbGVhc2UoKTtcbiAgICAgICAgICAgIHRoaXMuY29udGV4dC5pbnB1dFN0cmVhbS5jbGVhckV2ZW50SGFuZGxlcnMoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHNldFJlYWRlcnMocmVhZGVyczogQXJyYXk8UXVhZ2dhSlNSZWFkZXJDb25maWc+KTogdm9pZCB7XG4gICAgICAgIGlmICh0aGlzLmNvbnRleHQuZGVjb2Rlcikge1xuICAgICAgICAgICAgdGhpcy5jb250ZXh0LmRlY29kZXIuc2V0UmVhZGVycyhyZWFkZXJzKTtcbiAgICAgICAgfVxuICAgICAgICBRV29ya2Vycy5zZXRSZWFkZXJzKHJlYWRlcnMpO1xuICAgIH1cblxuICAgIHJlZ2lzdGVyUmVhZGVyKG5hbWU6IHN0cmluZywgcmVhZGVyOiBRdWFnZ2FKU1JlYWRlckNvbmZpZyk6IHZvaWQge1xuICAgICAgICBCYXJjb2RlRGVjb2Rlci5yZWdpc3RlclJlYWRlcihuYW1lLCByZWFkZXIpO1xuICAgICAgICBpZiAodGhpcy5jb250ZXh0LmRlY29kZXIpIHtcbiAgICAgICAgICAgIHRoaXMuY29udGV4dC5kZWNvZGVyLnJlZ2lzdGVyUmVhZGVyKG5hbWUsIHJlYWRlcik7XG4gICAgICAgIH1cbiAgICAgICAgUVdvcmtlcnMucmVnaXN0ZXJSZWFkZXIobmFtZSwgcmVhZGVyKTtcbiAgICB9XG59XG4iLCJpbXBvcnQgbWVyZ2UgZnJvbSAnbG9kYXNoL21lcmdlJztcbmltcG9ydCBUeXBlRGVmcyBmcm9tICcuL2NvbW1vbi90eXBlZGVmcyc7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbmltcG9ydCBJbWFnZVdyYXBwZXIgZnJvbSAnLi9jb21tb24vaW1hZ2Vfd3JhcHBlcic7XG5pbXBvcnQgQmFyY29kZURlY29kZXIgZnJvbSAnLi9kZWNvZGVyL2JhcmNvZGVfZGVjb2Rlcic7XG5pbXBvcnQgKiBhcyBSZWFkZXJzIGZyb20gJy4vcmVhZGVyL2luZGV4JztcbmltcG9ydCBFdmVudHMgZnJvbSAnLi9jb21tb24vZXZlbnRzJztcbmltcG9ydCBDYW1lcmFBY2Nlc3MgZnJvbSAnLi9pbnB1dC9jYW1lcmFfYWNjZXNzJztcbmltcG9ydCBJbWFnZURlYnVnIGZyb20gJy4vY29tbW9uL2ltYWdlX2RlYnVnJztcbmltcG9ydCBSZXN1bHRDb2xsZWN0b3IgZnJvbSAnLi9hbmFseXRpY3MvcmVzdWx0X2NvbGxlY3Rvcic7XG5pbXBvcnQgQ29uZmlnIGZyb20gJy4vY29uZmlnL2NvbmZpZyc7XG5cbmltcG9ydCBRdWFnZ2EgZnJvbSAnLi9xdWFnZ2EvcXVhZ2dhJztcblxuY29uc3QgaW5zdGFuY2UgPSBuZXcgUXVhZ2dhKCk7XG5jb25zdCBfY29udGV4dCA9IGluc3RhbmNlLmNvbnRleHQ7XG5cbmNvbnN0IFF1YWdnYUpTU3RhdGljSW50ZXJmYWNlID0ge1xuICAgIGluaXQ6IGZ1bmN0aW9uIChjb25maWcsIGNiLCBpbWFnZVdyYXBwZXIsIHF1YWdnYUluc3RhbmNlID0gaW5zdGFuY2UpIHtcbiAgICAgICAgbGV0IHByb21pc2U7XG4gICAgICAgIGlmICghY2IpIHtcbiAgICAgICAgICAgIHByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAgICAgY2IgPSAoZXJyKSA9PiB7IGVyciA/IHJlamVjdChlcnIpIDogcmVzb2x2ZSgpOyB9O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcXVhZ2dhSW5zdGFuY2UuY29udGV4dC5jb25maWcgPSBtZXJnZSh7fSwgQ29uZmlnLCBjb25maWcpO1xuICAgICAgICAvLyBUT0RPICMxNzk6IHBlbmRpbmcgcmVzdHJ1Y3R1cmUgaW4gSXNzdWUgIzE3OSwgd2UgYXJlIHRlbXAgZGlzYWJsaW5nIHdvcmtlcnNcbiAgICAgICAgaWYgKHF1YWdnYUluc3RhbmNlLmNvbnRleHQuY29uZmlnLm51bU9mV29ya2VycyA+IDApIHtcbiAgICAgICAgICAgIHF1YWdnYUluc3RhbmNlLmNvbnRleHQuY29uZmlnLm51bU9mV29ya2VycyA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGltYWdlV3JhcHBlcikge1xuICAgICAgICAgICAgcXVhZ2dhSW5zdGFuY2UuY29udGV4dC5vblVJVGhyZWFkID0gZmFsc2U7XG4gICAgICAgICAgICBxdWFnZ2FJbnN0YW5jZS5pbml0aWFsaXplRGF0YShpbWFnZVdyYXBwZXIpO1xuICAgICAgICAgICAgaWYgKGNiKSB7XG4gICAgICAgICAgICAgICAgY2IoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHF1YWdnYUluc3RhbmNlLmluaXRJbnB1dFN0cmVhbShjYik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgfSxcbiAgICBzdGFydDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gaW5zdGFuY2Uuc3RhcnQoKTtcbiAgICB9LFxuICAgIHN0b3A6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGluc3RhbmNlLnN0b3AoKTtcbiAgICB9LFxuICAgIHBhdXNlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF9jb250ZXh0LnN0b3BwZWQgPSB0cnVlO1xuICAgIH0sXG4gICAgb25EZXRlY3RlZDogZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgIGlmICghY2FsbGJhY2sgfHwgKHR5cGVvZiBjYWxsYmFjayAhPT0gJ2Z1bmN0aW9uJyAmJiAodHlwZW9mIGNhbGxiYWNrICE9PSAnb2JqZWN0JyB8fCAhY2FsbGJhY2suY2FsbGJhY2spKSkge1xuICAgICAgICAgICAgY29uc29sZS50cmFjZSgnKiB3YXJuaW5nOiBRdWFnZ2Eub25EZXRlY3RlZCBjYWxsZWQgd2l0aCBpbnZhbGlkIGNhbGxiYWNrLCBpZ25vcmluZycpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIEV2ZW50cy5zdWJzY3JpYmUoJ2RldGVjdGVkJywgY2FsbGJhY2spO1xuICAgIH0sXG4gICAgb2ZmRGV0ZWN0ZWQ6IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICBFdmVudHMudW5zdWJzY3JpYmUoJ2RldGVjdGVkJywgY2FsbGJhY2spO1xuICAgIH0sXG4gICAgb25Qcm9jZXNzZWQ6IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICBpZiAoIWNhbGxiYWNrIHx8ICh0eXBlb2YgY2FsbGJhY2sgIT09ICdmdW5jdGlvbicgJiYgKHR5cGVvZiBjYWxsYmFjayAhPT0gJ29iamVjdCcgfHwgIWNhbGxiYWNrLmNhbGxiYWNrKSkpIHtcbiAgICAgICAgICAgIGNvbnNvbGUudHJhY2UoJyogd2FybmluZzogUXVhZ2dhLm9uUHJvY2Vzc2VkIGNhbGxlZCB3aXRoIGludmFsaWQgY2FsbGJhY2ssIGlnbm9yaW5nJyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgRXZlbnRzLnN1YnNjcmliZSgncHJvY2Vzc2VkJywgY2FsbGJhY2spO1xuICAgIH0sXG4gICAgb2ZmUHJvY2Vzc2VkOiBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgRXZlbnRzLnVuc3Vic2NyaWJlKCdwcm9jZXNzZWQnLCBjYWxsYmFjayk7XG4gICAgfSxcbiAgICBzZXRSZWFkZXJzOiBmdW5jdGlvbiAocmVhZGVycykge1xuICAgICAgICBpZiAoIXJlYWRlcnMpIHtcbiAgICAgICAgICAgIGNvbnNvbGUudHJhY2UoJyogd2FybmluZzogUXVhZ2dhLnNldFJlYWRlcnMgY2FsbGVkIHdpdGggbm8gcmVhZGVycywgaWdub3JpbmcnKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpbnN0YW5jZS5zZXRSZWFkZXJzKHJlYWRlcnMpO1xuICAgIH0sXG4gICAgcmVnaXN0ZXJSZWFkZXI6IGZ1bmN0aW9uIChuYW1lLCByZWFkZXIpIHtcbiAgICAgICAgaWYgKCFuYW1lKSB7XG4gICAgICAgICAgICBjb25zb2xlLnRyYWNlKCcqIHdhcm5pbmc6IFF1YWdnYS5yZWdpc3RlclJlYWRlciBjYWxsZWQgd2l0aCBubyBuYW1lLCBpZ25vcmluZycpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICghcmVhZGVyKSB7XG4gICAgICAgICAgICBjb25zb2xlLnRyYWNlKCcqIHdhcm5pbmc6IFF1YWdnYS5yZWdpc3RlclJlYWRlciBjYWxsZWQgd2l0aCBubyByZWFkZXIsIGlnbm9yaW5nJyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaW5zdGFuY2UucmVnaXN0ZXJSZWFkZXIobmFtZSwgcmVhZGVyKTtcbiAgICB9LFxuICAgIHJlZ2lzdGVyUmVzdWx0Q29sbGVjdG9yOiBmdW5jdGlvbiAocmVzdWx0Q29sbGVjdG9yKSB7XG4gICAgICAgIGlmIChyZXN1bHRDb2xsZWN0b3IgJiYgdHlwZW9mIHJlc3VsdENvbGxlY3Rvci5hZGRSZXN1bHQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIF9jb250ZXh0LnJlc3VsdENvbGxlY3RvciA9IHJlc3VsdENvbGxlY3RvcjtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgZ2V0IGNhbnZhcygpIHtcbiAgICAgICAgcmV0dXJuIF9jb250ZXh0LmNhbnZhc0NvbnRhaW5lcjtcbiAgICB9LFxuICAgIGRlY29kZVNpbmdsZTogZnVuY3Rpb24gKGNvbmZpZywgcmVzdWx0Q2FsbGJhY2spIHtcbiAgICAgICAgY29uc3QgcXVhZ2dhSW5zdGFuY2UgPSBuZXcgUXVhZ2dhKCk7XG4gICAgICAgIGNvbmZpZyA9IG1lcmdlKHtcbiAgICAgICAgICAgIGlucHV0U3RyZWFtOiB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ0ltYWdlU3RyZWFtJyxcbiAgICAgICAgICAgICAgICBzZXF1ZW5jZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgc2l6ZTogODAwLFxuICAgICAgICAgICAgICAgIHNyYzogY29uZmlnLnNyYyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBudW1PZldvcmtlcnM6IChFTlYuZGV2ZWxvcG1lbnQgJiYgY29uZmlnLmRlYnVnKSA/IDAgOiAxLFxuICAgICAgICAgICAgbG9jYXRvcjoge1xuICAgICAgICAgICAgICAgIGhhbGZTYW1wbGU6IGZhbHNlLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSwgY29uZmlnKTtcbiAgICAgICAgLy8gVE9ETyAjMTc1OiByZXN0cnVjdHVyZSB3b3JrZXIgc3VwcG9ydCBzbyB0aGF0IGl0IHdpbGwgd29yayB3aXRoIHR5cGVzY3JpcHQgdXNpbmcgd29ya2VyLWxvYWRlclxuICAgICAgICAvLyBodHRwczovL3dlYnBhY2suanMub3JnL2xvYWRlcnMvd29ya2VyLWxvYWRlci9cbiAgICAgICAgaWYgKGNvbmZpZy5udW1PZldvcmtlcnMgPiAwKSB7XG4gICAgICAgICAgICBjb25maWcubnVtT2ZXb3JrZXJzID0gMDtcbiAgICAgICAgfVxuICAgICAgICAvLyB3b3JrZXJzIHJlcXVpcmUgV29ya2VyIGFuZCBCbG9iIHN1cHBvcnQgcHJlc2VudGx5LCBzbyBpZiBubyBCbG9iIG9yIFdvcmtlciB0aGVuIHNldFxuICAgICAgICAvLyB3b3JrZXJzIHRvIDAuXG4gICAgICAgIGlmIChjb25maWcubnVtT2ZXb3JrZXJzID4gMCAmJiAodHlwZW9mIEJsb2IgPT09ICd1bmRlZmluZWQnIHx8IHR5cGVvZiBXb3JrZXIgPT09ICd1bmRlZmluZWQnKSkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCcqIG5vIFdvcmtlciBhbmQvb3IgQmxvYiBzdXBwb3J0IC0gZm9yY2luZyBudW1PZldvcmtlcnMgdG8gMCcpO1xuICAgICAgICAgICAgY29uZmlnLm51bU9mV29ya2VycyA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pbml0KGNvbmZpZywgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBFdmVudHMub25jZSgncHJvY2Vzc2VkJywgKHJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcXVhZ2dhSW5zdGFuY2Uuc3RvcCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdENhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0Q2FsbGJhY2suY2FsbChudWxsLCByZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICB9LCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgcXVhZ2dhSW5zdGFuY2Uuc3RhcnQoKTtcbiAgICAgICAgICAgICAgICB9LCBudWxsLCBxdWFnZ2FJbnN0YW5jZSk7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSxcbiAgICAvLyBhZGQgdGhlIHVzdWFsbHkgZXhwZWN0ZWQgXCJkZWZhdWx0XCIgZm9yIHVzZSB3aXRoIHJlcXVpcmUsIGJ1aWxkIHN0ZXAgd29uJ3QgYWxsb3cgdXMgdG9cbiAgICAvLyB3cml0ZSB0byBtb2R1bGUuZXhwb3J0cyBzbyBkbyBpdCBoZXJlLlxuICAgIGdldCBkZWZhdWx0KCkge1xuICAgICAgICByZXR1cm4gUXVhZ2dhSlNTdGF0aWNJbnRlcmZhY2U7XG4gICAgfSxcbiAgICBSZWFkZXJzLFxuICAgIENhbWVyYUFjY2VzcyxcbiAgICBJbWFnZURlYnVnLFxuICAgIEltYWdlV3JhcHBlcixcbiAgICBSZXN1bHRDb2xsZWN0b3IsXG59O1xuXG5leHBvcnQgZGVmYXVsdCBRdWFnZ2FKU1N0YXRpY0ludGVyZmFjZTtcbi8vIGV4cG9ydCBCYXJjb2RlUmVhZGVyIGFuZCBvdGhlciB1dGlsaXRpZXMgZm9yIGV4dGVybmFsIHBsdWdpbnNcbmV4cG9ydCB7XG4gICAgQmFyY29kZURlY29kZXIsXG4gICAgUmVhZGVycyxcbiAgICBDYW1lcmFBY2Nlc3MsXG4gICAgSW1hZ2VEZWJ1ZyxcbiAgICBJbWFnZVdyYXBwZXIsXG4gICAgUmVzdWx0Q29sbGVjdG9yLFxufTtcbiJdLCJzb3VyY2VSb290IjoiIn0=
