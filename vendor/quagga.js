(function webpackUniversalModuleDefinition(root, factory) {
  if (typeof exports === "object" && typeof module === "object")
    module.exports = factory();
  else if (typeof define === "function" && define.amd) define([], factory);
  else if (typeof exports === "object") exports["Quagga"] = factory();
  else root["Quagga"] = factory();
})(window, function () {
  return /******/ (function (modules) {
    // webpackBootstrap
    /******/ // The module cache
    /******/ var installedModules = {};
    /******/
    /******/ // The require function
    /******/ function __webpack_require__(moduleId) {
      /******/
      /******/ // Check if module is in cache
      /******/ if (installedModules[moduleId]) {
        /******/ return installedModules[moduleId].exports;
        /******/
      }
      /******/ // Create a new module (and put it into the cache)
      /******/ var module = (installedModules[moduleId] = {
        /******/ i: moduleId,
        /******/ l: false,
        /******/ exports: {},
        /******/
      });
      /******/
      /******/ // Execute the module function
      /******/ modules[moduleId].call(
        module.exports,
        module,
        module.exports,
        __webpack_require__
      );
      /******/
      /******/ // Flag the module as loaded
      /******/ module.l = true;
      /******/
      /******/ // Return the exports of the module
      /******/ return module.exports;
      /******/
    }
    /******/
    /******/
    /******/ // expose the modules object (__webpack_modules__)
    /******/ __webpack_require__.m = modules;
    /******/
    /******/ // expose the module cache
    /******/ __webpack_require__.c = installedModules;
    /******/
    /******/ // define getter function for harmony exports
    /******/ __webpack_require__.d = function (exports, name, getter) {
      /******/ if (!__webpack_require__.o(exports, name)) {
        /******/ Object.defineProperty(exports, name, {
          enumerable: true,
          get: getter,
        });
        /******/
      }
      /******/
    };
    /******/
    /******/ // define __esModule on exports
    /******/ __webpack_require__.r = function (exports) {
      /******/ if (typeof Symbol !== "undefined" && Symbol.toStringTag) {
        /******/ Object.defineProperty(exports, Symbol.toStringTag, {
          value: "Module",
        });
        /******/
      }
      /******/ Object.defineProperty(exports, "__esModule", { value: true });
      /******/
    };
    /******/
    /******/ // create a fake namespace object
    /******/ // mode & 1: value is a module id, require it
    /******/ // mode & 2: merge all properties of value into the ns
    /******/ // mode & 4: return value when already ns object
    /******/ // mode & 8|1: behave like require
    /******/ __webpack_require__.t = function (value, mode) {
      /******/ if (mode & 1) value = __webpack_require__(value);
      /******/ if (mode & 8) return value;
      /******/ if (
        mode & 4 &&
        typeof value === "object" &&
        value &&
        value.__esModule
      )
        return value;
      /******/ var ns = Object.create(null);
      /******/ __webpack_require__.r(ns);
      /******/ Object.defineProperty(ns, "default", {
        enumerable: true,
        value: value,
      });
      /******/ if (mode & 2 && typeof value != "string")
        for (var key in value)
          __webpack_require__.d(
            ns,
            key,
            function (key) {
              return value[key];
            }.bind(null, key)
          );
      /******/ return ns;
      /******/
    };
    /******/
    /******/ // getDefaultExport function for compatibility with non-harmony modules
    /******/ __webpack_require__.n = function (module) {
      /******/ var getter =
        module && module.__esModule
          ? /******/ function getDefault() {
              return module["default"];
            }
          : /******/ function getModuleExports() {
              return module;
            };
      /******/ __webpack_require__.d(getter, "a", getter);
      /******/ return getter;
      /******/
    };
    /******/
    /******/ // Object.prototype.hasOwnProperty.call
    /******/ __webpack_require__.o = function (object, property) {
      return Object.prototype.hasOwnProperty.call(object, property);
    };
    /******/
    /******/ // __webpack_public_path__
    /******/ __webpack_require__.p = "/";
    /******/
    /******/
    /******/ // Load entry module and return exports
    /******/ return __webpack_require__((__webpack_require__.s = 89));
    /******/
  })(
    /************************************************************************/
    /******/ [
      /* 0 */
      /***/ function (module, exports) {
        function _defineProperty(obj, key, value) {
          if (key in obj) {
            Object.defineProperty(obj, key, {
              value: value,
              enumerable: true,
              configurable: true,
              writable: true,
            });
          } else {
            obj[key] = value;
          }

          return obj;
        }

        (module.exports = _defineProperty),
          (module.exports.__esModule = true),
          (module.exports["default"] = module.exports);

        /***/
      },
      /* 1 */
      /***/ function (module, exports) {
        function _assertThisInitialized(self) {
          if (self === void 0) {
            throw new ReferenceError(
              "this hasn't been initialised - super() hasn't been called"
            );
          }

          return self;
        }

        (module.exports = _assertThisInitialized),
          (module.exports.__esModule = true),
          (module.exports["default"] = module.exports);

        /***/
      },
      /* 2 */
      /***/ function (module, exports) {
        function _getPrototypeOf(o) {
          (module.exports = _getPrototypeOf =
            Object.setPrototypeOf
              ? Object.getPrototypeOf.bind()
              : function _getPrototypeOf(o) {
                  return o.__proto__ || Object.getPrototypeOf(o);
                }),
            (module.exports.__esModule = true),
            (module.exports["default"] = module.exports);
          return _getPrototypeOf(o);
        }

        (module.exports = _getPrototypeOf),
          (module.exports.__esModule = true),
          (module.exports["default"] = module.exports);

        /***/
      },
      /* 3 */
      /***/ function (module, exports) {
        function _classCallCheck(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
          }
        }

        (module.exports = _classCallCheck),
          (module.exports.__esModule = true),
          (module.exports["default"] = module.exports);

        /***/
      },
      /* 4 */
      /***/ function (module, exports) {
        function _defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor) descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor);
          }
        }

        function _createClass(Constructor, protoProps, staticProps) {
          if (protoProps) _defineProperties(Constructor.prototype, protoProps);
          if (staticProps) _defineProperties(Constructor, staticProps);
          Object.defineProperty(Constructor, "prototype", {
            writable: false,
          });
          return Constructor;
        }

        (module.exports = _createClass),
          (module.exports.__esModule = true),
          (module.exports["default"] = module.exports);

        /***/
      },
      /* 5 */
      /***/ function (module, exports, __webpack_require__) {
        var _typeof = __webpack_require__(17)["default"];

        var assertThisInitialized = __webpack_require__(1);

        function _possibleConstructorReturn(self, call) {
          if (
            call &&
            (_typeof(call) === "object" || typeof call === "function")
          ) {
            return call;
          } else if (call !== void 0) {
            throw new TypeError(
              "Derived constructors may only return object or undefined"
            );
          }

          return assertThisInitialized(self);
        }

        (module.exports = _possibleConstructorReturn),
          (module.exports.__esModule = true),
          (module.exports["default"] = module.exports);

        /***/
      },
      /* 6 */
      /***/ function (module, exports, __webpack_require__) {
        var setPrototypeOf = __webpack_require__(41);

        function _inherits(subClass, superClass) {
          if (typeof superClass !== "function" && superClass !== null) {
            throw new TypeError(
              "Super expression must either be null or a function"
            );
          }

          subClass.prototype = Object.create(
            superClass && superClass.prototype,
            {
              constructor: {
                value: subClass,
                writable: true,
                configurable: true,
              },
            }
          );
          Object.defineProperty(subClass, "prototype", {
            writable: false,
          });
          if (superClass) setPrototypeOf(subClass, superClass);
        }

        (module.exports = _inherits),
          (module.exports.__esModule = true),
          (module.exports["default"] = module.exports);

        /***/
      },
      /* 7 */
      /***/ function (module, exports, __webpack_require__) {
        module.exports = {
          EPSILON: __webpack_require__(62),
          create: __webpack_require__(63),
          clone: __webpack_require__(156),
          fromValues: __webpack_require__(157),
          copy: __webpack_require__(158),
          set: __webpack_require__(159),
          equals: __webpack_require__(160),
          exactEquals: __webpack_require__(161),
          add: __webpack_require__(162),
          subtract: __webpack_require__(64),
          sub: __webpack_require__(163),
          multiply: __webpack_require__(65),
          mul: __webpack_require__(164),
          divide: __webpack_require__(66),
          div: __webpack_require__(165),
          inverse: __webpack_require__(166),
          min: __webpack_require__(167),
          max: __webpack_require__(168),
          rotate: __webpack_require__(169),
          floor: __webpack_require__(170),
          ceil: __webpack_require__(171),
          round: __webpack_require__(172),
          scale: __webpack_require__(173),
          scaleAndAdd: __webpack_require__(174),
          distance: __webpack_require__(67),
          dist: __webpack_require__(175),
          squaredDistance: __webpack_require__(68),
          sqrDist: __webpack_require__(176),
          length: __webpack_require__(69),
          len: __webpack_require__(177),
          squaredLength: __webpack_require__(70),
          sqrLen: __webpack_require__(178),
          negate: __webpack_require__(179),
          normalize: __webpack_require__(180),
          dot: __webpack_require__(181),
          cross: __webpack_require__(182),
          lerp: __webpack_require__(183),
          random: __webpack_require__(184),
          transformMat2: __webpack_require__(185),
          transformMat2d: __webpack_require__(186),
          transformMat3: __webpack_require__(187),
          transformMat4: __webpack_require__(188),
          forEach: __webpack_require__(189),
          limit: __webpack_require__(190),
        };

        /***/
      },
      /* 8 */
      /***/ function (module, exports, __webpack_require__) {
        // TODO(Babel 8): Remove this file.
        var runtime = __webpack_require__(224)();

        module.exports = runtime; // Copied from https://github.com/facebook/regenerator/blob/main/packages/runtime/runtime.js#L736=

        try {
          regeneratorRuntime = runtime;
        } catch (accidentalStrictMode) {
          if (typeof globalThis === "object") {
            globalThis.regeneratorRuntime = runtime;
          } else {
            Function("r", "regeneratorRuntime = r")(runtime);
          }
        }

        /***/
      },
      /* 9 */
      /***/ function (module, __webpack_exports__, __webpack_require__) {
        "use strict";

        // EXPORTS
        __webpack_require__.d(__webpack_exports__, "h", function () {
          return /* binding */ imageRef;
        });
        __webpack_require__.d(__webpack_exports__, "i", function () {
          return /* binding */ otsuThreshold;
        });
        __webpack_require__.d(__webpack_exports__, "b", function () {
          return /* binding */ cv_utils_cluster;
        });
        __webpack_require__.d(__webpack_exports__, "j", function () {
          return /* binding */ topGeneric;
        });
        __webpack_require__.d(__webpack_exports__, "e", function () {
          return /* binding */ grayAndHalfSampleFromCanvasData;
        });
        __webpack_require__.d(__webpack_exports__, "c", function () {
          return /* binding */ computeGray;
        });
        __webpack_require__.d(__webpack_exports__, "f", function () {
          return /* binding */ halfSample;
        });
        __webpack_require__.d(__webpack_exports__, "g", function () {
          return /* binding */ hsv2rgb;
        });
        __webpack_require__.d(__webpack_exports__, "a", function () {
          return /* binding */ calculatePatchSize;
        });
        __webpack_require__.d(__webpack_exports__, "d", function () {
          return /* binding */ computeImageArea;
        });

        // UNUSED EXPORTS: computeIntegralImage2, computeIntegralImage, thresholdImage, computeHistogram, sharpenLine, determineOtsuThreshold, computeBinaryImage, Tracer, DILATE, ERODE, dilate, erode, subtract, bitwiseOr, countNonZero, grayArrayFromImage, grayArrayFromContext, loadImageArray, _computeDivisors, _parseCSSDimensionValues, _dimensionsConverters

        // EXTERNAL MODULE: ./node_modules/gl-vec2/index.js
        var gl_vec2 = __webpack_require__(7);

        // EXTERNAL MODULE: ./node_modules/gl-vec3/index.js
        var gl_vec3 = __webpack_require__(84);

        // CONCATENATED MODULE: ./src/common/cluster.js
        // TODO: cluster.js and cv_utils.js are pretty tightly intertwined, making for a complex conversion
        // into typescript. be warned. :-)

        var vec2 = {
          clone: gl_vec2["clone"],
          dot: gl_vec2["dot"],
        };
        /**
         * Creates a cluster for grouping similar orientations of datapoints
         */

        /* harmony default export */ var cluster = {
          create: function create(point, threshold) {
            var points = [];
            var center = {
              rad: 0,
              vec: vec2.clone([0, 0]),
            };
            var pointMap = {};

            function _add(pointToAdd) {
              pointMap[pointToAdd.id] = pointToAdd;
              points.push(pointToAdd);
            }

            function updateCenter() {
              var i;
              var sum = 0;

              for (i = 0; i < points.length; i++) {
                sum += points[i].rad;
              }

              center.rad = sum / points.length;
              center.vec = vec2.clone([
                Math.cos(center.rad),
                Math.sin(center.rad),
              ]);
            }

            function init() {
              _add(point);

              updateCenter();
            }

            init();
            return {
              add: function add(pointToAdd) {
                if (!pointMap[pointToAdd.id]) {
                  _add(pointToAdd);

                  updateCenter();
                }
              },
              fits: function fits(otherPoint) {
                // check cosine similarity to center-angle
                var similarity = Math.abs(
                  vec2.dot(otherPoint.point.vec, center.vec)
                );

                if (similarity > threshold) {
                  return true;
                }

                return false;
              },
              getPoints: function getPoints() {
                return points;
              },
              getCenter: function getCenter() {
                return center;
              },
            };
          },
          createPoint: function createPoint(newPoint, id, property) {
            return {
              rad: newPoint[property],
              point: newPoint,
              id: id,
            };
          },
        };
        // EXTERNAL MODULE: ./src/common/array_helper.ts
        var array_helper = __webpack_require__(11);

        // CONCATENATED MODULE: ./src/common/cv_utils.js
        /* eslint-disable no-mixed-operators */

        /* eslint-disable no-bitwise */

        var cv_utils_vec2 = {
          clone: gl_vec2["clone"],
        };
        var vec3 = {
          clone: gl_vec3["clone"],
        };
        /**
         * @param x x-coordinate
         * @param y y-coordinate
         * @return ImageReference {x,y} Coordinate
         */

        function imageRef(x, y) {
          var that = {
            x: x,
            y: y,
            toVec2: function toVec2() {
              return cv_utils_vec2.clone([this.x, this.y]);
            },
            toVec3: function toVec3() {
              return vec3.clone([this.x, this.y, 1]);
            },
            round: function round() {
              this.x =
                this.x > 0.0
                  ? Math.floor(this.x + 0.5)
                  : Math.floor(this.x - 0.5);
              this.y =
                this.y > 0.0
                  ? Math.floor(this.y + 0.5)
                  : Math.floor(this.y - 0.5);
              return this;
            },
          };
          return that;
        }
        /**
         * Computes an integral image of a given grayscale image.
         * @param imageDataContainer {ImageDataContainer} the image to be integrated
         */

        function computeIntegralImage2(imageWrapper, integralWrapper) {
          var imageData = imageWrapper.data;
          var width = imageWrapper.size.x;
          var height = imageWrapper.size.y;
          var integralImageData = integralWrapper.data;
          var sum = 0;
          var posA = 0;
          var posB = 0;
          var posC = 0;
          var posD = 0;
          var x;
          var y; // sum up first column

          posB = width;
          sum = 0;

          for (y = 1; y < height; y++) {
            sum += imageData[posA];
            integralImageData[posB] += sum;
            posA += width;
            posB += width;
          }

          posA = 0;
          posB = 1;
          sum = 0;

          for (x = 1; x < width; x++) {
            sum += imageData[posA];
            integralImageData[posB] += sum;
            posA++;
            posB++;
          }

          for (y = 1; y < height; y++) {
            posA = y * width + 1;
            posB = (y - 1) * width + 1;
            posC = y * width;
            posD = (y - 1) * width;

            for (x = 1; x < width; x++) {
              integralImageData[posA] +=
                imageData[posA] +
                integralImageData[posB] +
                integralImageData[posC] -
                integralImageData[posD];
              posA++;
              posB++;
              posC++;
              posD++;
            }
          }
        }
        function computeIntegralImage(imageWrapper, integralWrapper) {
          var imageData = imageWrapper.data;
          var width = imageWrapper.size.x;
          var height = imageWrapper.size.y;
          var integralImageData = integralWrapper.data;
          var sum = 0; // sum up first row

          for (var i = 0; i < width; i++) {
            sum += imageData[i];
            integralImageData[i] = sum;
          }

          for (var v = 1; v < height; v++) {
            sum = 0;

            for (var u = 0; u < width; u++) {
              sum += imageData[v * width + u];
              integralImageData[v * width + u] =
                sum + integralImageData[(v - 1) * width + u];
            }
          }
        }
        function thresholdImage(imageWrapper, threshold, targetWrapper) {
          if (!targetWrapper) {
            // eslint-disable-next-line no-param-reassign
            targetWrapper = imageWrapper;
          }

          var imageData = imageWrapper.data;
          var length = imageData.length;
          var targetData = targetWrapper.data;

          while (length--) {
            targetData[length] = imageData[length] < threshold ? 1 : 0;
          }
        }
        function computeHistogram(imageWrapper, bitsPerPixel) {
          if (!bitsPerPixel) {
            // eslint-disable-next-line no-param-reassign
            bitsPerPixel = 8;
          }

          var imageData = imageWrapper.data;
          var length = imageData.length;
          var bitShift = 8 - bitsPerPixel;
          var bucketCnt = 1 << bitsPerPixel;
          var hist = new Int32Array(bucketCnt);

          while (length--) {
            hist[imageData[length] >> bitShift]++;
          }

          return hist;
        }
        function sharpenLine(line) {
          var i;
          var length = line.length;
          var left = line[0];
          var center = line[1];
          var right;

          for (i = 1; i < length - 1; i++) {
            right = line[i + 1]; //  -1 4 -1 kernel
            // eslint-disable-next-line no-param-reassign

            line[i - 1] = (center * 2 - left - right) & 255;
            left = center;
            center = right;
          }

          return line;
        }
        function determineOtsuThreshold(imageWrapper) {
          var bitsPerPixel =
            arguments.length > 1 && arguments[1] !== undefined
              ? arguments[1]
              : 8;
          var hist;
          var bitShift = 8 - bitsPerPixel;

          function px(init, end) {
            var sum = 0;

            for (var i = init; i <= end; i++) {
              sum += hist[i];
            }

            return sum;
          }

          function mx(init, end) {
            var sum = 0;

            for (var i = init; i <= end; i++) {
              sum += i * hist[i];
            }

            return sum;
          }

          function determineThreshold() {
            var vet = [0];
            var p1;
            var p2;
            var p12;
            var m1;
            var m2;
            var m12;
            var max = (1 << bitsPerPixel) - 1;
            hist = computeHistogram(imageWrapper, bitsPerPixel);

            for (var k = 1; k < max; k++) {
              p1 = px(0, k);
              p2 = px(k + 1, max);
              p12 = p1 * p2;

              if (p12 === 0) {
                p12 = 1;
              }

              m1 = mx(0, k) * p2;
              m2 = mx(k + 1, max) * p1;
              m12 = m1 - m2;
              vet[k] = (m12 * m12) / p12;
            }

            return array_helper["a" /* default */].maxIndex(vet);
          }

          var threshold = determineThreshold();
          return threshold << bitShift;
        }
        function otsuThreshold(imageWrapper, targetWrapper) {
          var threshold = determineOtsuThreshold(imageWrapper);
          thresholdImage(imageWrapper, threshold, targetWrapper);
          return threshold;
        } // local thresholding

        function computeBinaryImage(
          imageWrapper,
          integralWrapper,
          targetWrapper
        ) {
          computeIntegralImage(imageWrapper, integralWrapper);

          if (!targetWrapper) {
            // eslint-disable-next-line no-param-reassign
            targetWrapper = imageWrapper;
          }

          var imageData = imageWrapper.data;
          var targetData = targetWrapper.data;
          var width = imageWrapper.size.x;
          var height = imageWrapper.size.y;
          var integralImageData = integralWrapper.data;
          var sum = 0;
          var v;
          var u;
          var kernel = 3;
          var A;
          var B;
          var C;
          var D;
          var avg;
          var size = (kernel * 2 + 1) * (kernel * 2 + 1); // clear out top & bottom-border

          for (v = 0; v <= kernel; v++) {
            for (u = 0; u < width; u++) {
              targetData[v * width + u] = 0;
              targetData[(height - 1 - v) * width + u] = 0;
            }
          } // clear out left & right border

          for (v = kernel; v < height - kernel; v++) {
            for (u = 0; u <= kernel; u++) {
              targetData[v * width + u] = 0;
              targetData[v * width + (width - 1 - u)] = 0;
            }
          }

          for (v = kernel + 1; v < height - kernel - 1; v++) {
            for (u = kernel + 1; u < width - kernel; u++) {
              A =
                integralImageData[(v - kernel - 1) * width + (u - kernel - 1)];
              B = integralImageData[(v - kernel - 1) * width + (u + kernel)];
              C = integralImageData[(v + kernel) * width + (u - kernel - 1)];
              D = integralImageData[(v + kernel) * width + (u + kernel)];
              sum = D - C - B + A;
              avg = sum / size;
              targetData[v * width + u] =
                imageData[v * width + u] > avg + 5 ? 0 : 1;
            }
          }
        }
        function cv_utils_cluster(points, threshold, property) {
          var i;
          var k;
          var thisCluster;
          var point;
          var clusters = [];

          if (!property) {
            // eslint-disable-next-line no-param-reassign
            property = "rad";
          }

          function addToCluster(newPoint) {
            var found = false;

            for (k = 0; k < clusters.length; k++) {
              thisCluster = clusters[k];

              if (thisCluster.fits(newPoint)) {
                thisCluster.add(newPoint);
                found = true;
              }
            }

            return found;
          } // iterate over each cloud

          for (i = 0; i < points.length; i++) {
            point = cluster.createPoint(points[i], i, property);

            if (!addToCluster(point)) {
              clusters.push(cluster.create(point, threshold));
            }
          }

          return clusters;
        }
        var Tracer = {
          trace: function trace(points, vec) {
            var iteration;
            var maxIterations = 10;
            var top = [];
            var result = [];
            var centerPos = 0;
            var currentPos = 0;

            function trace(idx, forward) {
              var to;
              var toIdx;
              var predictedPos;
              var thresholdX = 1;
              var thresholdY = Math.abs(vec[1] / 10);
              var found = false;

              function match(pos, predicted) {
                if (
                  pos.x > predicted.x - thresholdX &&
                  pos.x < predicted.x + thresholdX &&
                  pos.y > predicted.y - thresholdY &&
                  pos.y < predicted.y + thresholdY
                ) {
                  return true;
                }

                return false;
              } // check if the next index is within the vec specifications
              // if not, check as long as the threshold is met

              var from = points[idx];

              if (forward) {
                predictedPos = {
                  x: from.x + vec[0],
                  y: from.y + vec[1],
                };
              } else {
                predictedPos = {
                  x: from.x - vec[0],
                  y: from.y - vec[1],
                };
              }

              toIdx = forward ? idx + 1 : idx - 1;
              to = points[toIdx]; // eslint-disable-next-line no-cond-assign

              while (
                to &&
                (found = match(to, predictedPos)) !== true &&
                Math.abs(to.y - from.y) < vec[1]
              ) {
                toIdx = forward ? toIdx + 1 : toIdx - 1;
                to = points[toIdx];
              }

              return found ? toIdx : null;
            }

            for (iteration = 0; iteration < maxIterations; iteration++) {
              // randomly select point to start with
              centerPos = Math.floor(Math.random() * points.length); // trace forward

              top = [];
              currentPos = centerPos;
              top.push(points[currentPos]); // eslint-disable-next-line no-cond-assign

              while ((currentPos = trace(currentPos, true)) !== null) {
                top.push(points[currentPos]);
              }

              if (centerPos > 0) {
                currentPos = centerPos; // eslint-disable-next-line no-cond-assign

                while ((currentPos = trace(currentPos, false)) !== null) {
                  top.push(points[currentPos]);
                }
              }

              if (top.length > result.length) {
                result = top;
              }
            }

            return result;
          },
        };
        var DILATE = 1;
        var ERODE = 2;
        function dilate(inImageWrapper, outImageWrapper) {
          var v;
          var u;
          var inImageData = inImageWrapper.data;
          var outImageData = outImageWrapper.data;
          var height = inImageWrapper.size.y;
          var width = inImageWrapper.size.x;
          var sum;
          var yStart1;
          var yStart2;
          var xStart1;
          var xStart2;

          for (v = 1; v < height - 1; v++) {
            for (u = 1; u < width - 1; u++) {
              yStart1 = v - 1;
              yStart2 = v + 1;
              xStart1 = u - 1;
              xStart2 = u + 1;
              sum =
                inImageData[yStart1 * width + xStart1] +
                inImageData[yStart1 * width + xStart2] +
                inImageData[v * width + u] +
                inImageData[yStart2 * width + xStart1] +
                inImageData[yStart2 * width + xStart2];
              outImageData[v * width + u] = sum > 0 ? 1 : 0;
            }
          }
        }
        function erode(inImageWrapper, outImageWrapper) {
          var v;
          var u;
          var inImageData = inImageWrapper.data;
          var outImageData = outImageWrapper.data;
          var height = inImageWrapper.size.y;
          var width = inImageWrapper.size.x;
          var sum;
          var yStart1;
          var yStart2;
          var xStart1;
          var xStart2;

          for (v = 1; v < height - 1; v++) {
            for (u = 1; u < width - 1; u++) {
              yStart1 = v - 1;
              yStart2 = v + 1;
              xStart1 = u - 1;
              xStart2 = u + 1;
              sum =
                inImageData[yStart1 * width + xStart1] +
                inImageData[yStart1 * width + xStart2] +
                inImageData[v * width + u] +
                inImageData[yStart2 * width + xStart1] +
                inImageData[yStart2 * width + xStart2];
              outImageData[v * width + u] = sum === 5 ? 1 : 0;
            }
          }
        }
        function subtract(aImageWrapper, bImageWrapper, resultImageWrapper) {
          if (!resultImageWrapper) {
            // eslint-disable-next-line no-param-reassign
            resultImageWrapper = aImageWrapper;
          }

          var length = aImageWrapper.data.length;
          var aImageData = aImageWrapper.data;
          var bImageData = bImageWrapper.data;
          var cImageData = resultImageWrapper.data;

          while (length--) {
            cImageData[length] = aImageData[length] - bImageData[length];
          }
        }
        function bitwiseOr(aImageWrapper, bImageWrapper, resultImageWrapper) {
          if (!resultImageWrapper) {
            // eslint-disable-next-line no-param-reassign
            resultImageWrapper = aImageWrapper;
          }

          var length = aImageWrapper.data.length;
          var aImageData = aImageWrapper.data;
          var bImageData = bImageWrapper.data;
          var cImageData = resultImageWrapper.data;

          while (length--) {
            cImageData[length] = aImageData[length] || bImageData[length];
          }
        }
        function countNonZero(imageWrapper) {
          var length = imageWrapper.data.length;
          var data = imageWrapper.data;
          var sum = 0;

          while (length--) {
            sum += data[length];
          }

          return sum;
        }
        function topGeneric(list, top, scoreFunc) {
          var i;
          var minIdx = 0;
          var min = 0;
          var queue = [];
          var score;
          var hit;
          var pos;

          for (i = 0; i < top; i++) {
            queue[i] = {
              score: 0,
              item: null,
            };
          }

          for (i = 0; i < list.length; i++) {
            score = scoreFunc.apply(this, [list[i]]);

            if (score > min) {
              hit = queue[minIdx];
              hit.score = score;
              hit.item = list[i];
              min = Number.MAX_VALUE;

              for (pos = 0; pos < top; pos++) {
                if (queue[pos].score < min) {
                  min = queue[pos].score;
                  minIdx = pos;
                }
              }
            }
          }

          return queue;
        }
        function grayArrayFromImage(htmlImage, offsetX, ctx, array) {
          ctx.drawImage(
            htmlImage,
            offsetX,
            0,
            htmlImage.width,
            htmlImage.height
          );
          var ctxData = ctx.getImageData(
            offsetX,
            0,
            htmlImage.width,
            htmlImage.height
          ).data;
          computeGray(ctxData, array);
        }
        function grayArrayFromContext(ctx, size, offset, array) {
          var ctxData = ctx.getImageData(
            offset.x,
            offset.y,
            size.x,
            size.y
          ).data;
          computeGray(ctxData, array);
        }
        function grayAndHalfSampleFromCanvasData(canvasData, size, outArray) {
          var topRowIdx = 0;
          var bottomRowIdx = size.x;
          var endIdx = Math.floor(canvasData.length / 4);
          var outWidth = size.x / 2;
          var outImgIdx = 0;
          var inWidth = size.x;
          var i;

          while (bottomRowIdx < endIdx) {
            for (i = 0; i < outWidth; i++) {
              // eslint-disable-next-line no-param-reassign
              outArray[outImgIdx] =
                (0.299 * canvasData[topRowIdx * 4 + 0] +
                  0.587 * canvasData[topRowIdx * 4 + 1] +
                  0.114 * canvasData[topRowIdx * 4 + 2] +
                  (0.299 * canvasData[(topRowIdx + 1) * 4 + 0] +
                    0.587 * canvasData[(topRowIdx + 1) * 4 + 1] +
                    0.114 * canvasData[(topRowIdx + 1) * 4 + 2]) +
                  (0.299 * canvasData[bottomRowIdx * 4 + 0] +
                    0.587 * canvasData[bottomRowIdx * 4 + 1] +
                    0.114 * canvasData[bottomRowIdx * 4 + 2]) +
                  (0.299 * canvasData[(bottomRowIdx + 1) * 4 + 0] +
                    0.587 * canvasData[(bottomRowIdx + 1) * 4 + 1] +
                    0.114 * canvasData[(bottomRowIdx + 1) * 4 + 2])) /
                4;
              outImgIdx++;
              topRowIdx += 2;
              bottomRowIdx += 2;
            }

            topRowIdx += inWidth;
            bottomRowIdx += inWidth;
          }
        }
        function computeGray(imageData, outArray, config) {
          var l = (imageData.length / 4) | 0;
          var singleChannel = config && config.singleChannel === true;

          if (singleChannel) {
            for (var i = 0; i < l; i++) {
              // eslint-disable-next-line no-param-reassign
              outArray[i] = imageData[i * 4 + 0];
            }
          } else {
            for (var _i = 0; _i < l; _i++) {
              // eslint-disable-next-line no-param-reassign
              outArray[_i] =
                0.299 * imageData[_i * 4 + 0] +
                0.587 * imageData[_i * 4 + 1] +
                0.114 * imageData[_i * 4 + 2];
            }
          }
        }
        function loadImageArray(src, callback) {
          var canvas =
            arguments.length > 2 && arguments[2] !== undefined
              ? arguments[2]
              : document && document.createElement("canvas");
          var img = new Image();
          img.callback = callback;

          img.onload = function () {
            // eslint-disable-next-line no-param-reassign
            canvas.width = this.width; // eslint-disable-next-line no-param-reassign

            canvas.height = this.height;
            var ctx = canvas.getContext("2d");
            ctx.drawImage(this, 0, 0);
            var array = new Uint8Array(this.width * this.height);
            ctx.drawImage(this, 0, 0);

            var _ctx$getImageData = ctx.getImageData(
                0,
                0,
                this.width,
                this.height
              ),
              data = _ctx$getImageData.data;

            computeGray(data, array);
            this.callback(
              array,
              {
                x: this.width,
                y: this.height,
              },
              this
            );
          };

          img.src = src;
        }
        /**
         * @param inImg {ImageWrapper} input image to be sampled
         * @param outImg {ImageWrapper} to be stored in
         */

        function halfSample(inImgWrapper, outImgWrapper) {
          var inImg = inImgWrapper.data;
          var inWidth = inImgWrapper.size.x;
          var outImg = outImgWrapper.data;
          var topRowIdx = 0;
          var bottomRowIdx = inWidth;
          var endIdx = inImg.length;
          var outWidth = inWidth / 2;
          var outImgIdx = 0;

          while (bottomRowIdx < endIdx) {
            for (var i = 0; i < outWidth; i++) {
              outImg[outImgIdx] = Math.floor(
                (inImg[topRowIdx] +
                  inImg[topRowIdx + 1] +
                  inImg[bottomRowIdx] +
                  inImg[bottomRowIdx + 1]) /
                  4
              );
              outImgIdx++;
              topRowIdx += 2;
              bottomRowIdx += 2;
            }

            topRowIdx += inWidth;
            bottomRowIdx += inWidth;
          }
        }
        function hsv2rgb(hsv) {
          var rgb =
            arguments.length > 1 && arguments[1] !== undefined
              ? arguments[1]
              : [0, 0, 0];
          var h = hsv[0];
          var s = hsv[1];
          var v = hsv[2];
          var c = v * s;
          var x = c * (1 - Math.abs(((h / 60) % 2) - 1));
          var m = v - c;
          var r = 0;
          var g = 0;
          var b = 0;

          if (h < 60) {
            r = c;
            g = x;
          } else if (h < 120) {
            r = x;
            g = c;
          } else if (h < 180) {
            g = c;
            b = x;
          } else if (h < 240) {
            g = x;
            b = c;
          } else if (h < 300) {
            r = x;
            b = c;
          } else if (h < 360) {
            r = c;
            b = x;
          } // eslint-disable-next-line no-param-reassign

          rgb[0] = ((r + m) * 255) | 0; // eslint-disable-next-line no-param-reassign

          rgb[1] = ((g + m) * 255) | 0; // eslint-disable-next-line no-param-reassign

          rgb[2] = ((b + m) * 255) | 0;
          return rgb;
        }
        function _computeDivisors(n) {
          var largeDivisors = [];
          var divisors = [];

          for (var i = 1; i < Math.sqrt(n) + 1; i++) {
            if (n % i === 0) {
              divisors.push(i);

              if (i !== n / i) {
                largeDivisors.unshift(Math.floor(n / i));
              }
            }
          }

          return divisors.concat(largeDivisors);
        }

        function _computeIntersection(arr1, arr2) {
          var i = 0;
          var j = 0;
          var result = [];

          while (i < arr1.length && j < arr2.length) {
            if (arr1[i] === arr2[j]) {
              result.push(arr1[i]);
              i++;
              j++;
            } else if (arr1[i] > arr2[j]) {
              j++;
            } else {
              i++;
            }
          }

          return result;
        }

        function calculatePatchSize(patchSize, imgSize) {
          var divisorsX = _computeDivisors(imgSize.x);

          var divisorsY = _computeDivisors(imgSize.y);

          var wideSide = Math.max(imgSize.x, imgSize.y);

          var common = _computeIntersection(divisorsX, divisorsY);

          var nrOfPatchesList = [8, 10, 15, 20, 32, 60, 80];
          var nrOfPatchesMap = {
            "x-small": 5,
            small: 4,
            medium: 3,
            large: 2,
            "x-large": 1,
          };
          var nrOfPatchesIdx =
            nrOfPatchesMap[patchSize] || nrOfPatchesMap.medium;
          var nrOfPatches = nrOfPatchesList[nrOfPatchesIdx];
          var desiredPatchSize = Math.floor(wideSide / nrOfPatches);
          var optimalPatchSize;

          function findPatchSizeForDivisors(divisors) {
            var i = 0;
            var found = divisors[Math.floor(divisors.length / 2)];

            while (i < divisors.length - 1 && divisors[i] < desiredPatchSize) {
              i++;
            }

            if (i > 0) {
              if (
                Math.abs(divisors[i] - desiredPatchSize) >
                Math.abs(divisors[i - 1] - desiredPatchSize)
              ) {
                found = divisors[i - 1];
              } else {
                found = divisors[i];
              }
            }

            if (
              desiredPatchSize / found <
                nrOfPatchesList[nrOfPatchesIdx + 1] /
                  nrOfPatchesList[nrOfPatchesIdx] &&
              desiredPatchSize / found >
                nrOfPatchesList[nrOfPatchesIdx - 1] /
                  nrOfPatchesList[nrOfPatchesIdx]
            ) {
              return {
                x: found,
                y: found,
              };
            }

            return null;
          }

          optimalPatchSize = findPatchSizeForDivisors(common);

          if (!optimalPatchSize) {
            optimalPatchSize = findPatchSizeForDivisors(
              _computeDivisors(wideSide)
            );

            if (!optimalPatchSize) {
              optimalPatchSize = findPatchSizeForDivisors(
                _computeDivisors(desiredPatchSize * nrOfPatches)
              );
            }
          }

          return optimalPatchSize;
        }
        function _parseCSSDimensionValues(value) {
          var dimension = {
            value: parseFloat(value),
            unit: value.indexOf("%") === value.length - 1 ? "%" : "%",
          };
          return dimension;
        }
        var _dimensionsConverters = {
          top: function top(dimension, context) {
            return dimension.unit === "%"
              ? Math.floor(context.height * (dimension.value / 100))
              : null;
          },
          right: function right(dimension, context) {
            return dimension.unit === "%"
              ? Math.floor(
                  context.width - context.width * (dimension.value / 100)
                )
              : null;
          },
          bottom: function bottom(dimension, context) {
            return dimension.unit === "%"
              ? Math.floor(
                  context.height - context.height * (dimension.value / 100)
                )
              : null;
          },
          left: function left(dimension, context) {
            return dimension.unit === "%"
              ? Math.floor(context.width * (dimension.value / 100))
              : null;
          },
        };
        function computeImageArea(inputWidth, inputHeight, area) {
          var context = {
            width: inputWidth,
            height: inputHeight,
          };
          var parsedArea = Object.keys(area).reduce(function (result, key) {
            var value = area[key];

            var parsed = _parseCSSDimensionValues(value);

            var calculated = _dimensionsConverters[key](parsed, context); // eslint-disable-next-line no-param-reassign

            result[key] = calculated;
            return result;
          }, {});
          return {
            sx: parsedArea.left,
            sy: parsedArea.top,
            sw: parsedArea.right - parsedArea.left,
            sh: parsedArea.bottom - parsedArea.top,
          };
        }

        /***/
      },
      /* 10 */
      /***/ function (module, __webpack_exports__, __webpack_require__) {
        "use strict";
        // TODO: XYPosition should be an XYObject, but that breaks XYDefinition, which breaks drawPath() below.
        // XYDefinition tells us which component of a given array or object is the "X" and which is the "Y".
        // Usually this is 0 for X and 1 for Y, but might be used as 'x' for x and 'y' for Y.
        /* harmony default export */ __webpack_exports__["a"] = {
          drawRect: function drawRect(pos, size, ctx, style) {
            ctx.strokeStyle = style.color;
            ctx.fillStyle = style.color;
            ctx.lineWidth = style.lineWidth || 1;
            ctx.beginPath();
            ctx.strokeRect(pos.x, pos.y, size.x, size.y);
          },
          drawPath: function drawPath(path, def, ctx, style) {
            ctx.strokeStyle = style.color;
            ctx.fillStyle = style.color;
            ctx.lineWidth = style.lineWidth;
            ctx.beginPath();
            ctx.moveTo(path[0][def.x], path[0][def.y]);

            for (var j = 1; j < path.length; j++) {
              ctx.lineTo(path[j][def.x], path[j][def.y]);
            }

            ctx.closePath();
            ctx.stroke();
          },
          drawImage: function drawImage(imageData, size, ctx) {
            var canvasData = ctx.getImageData(0, 0, size.x, size.y);
            var data = canvasData.data;
            var canvasDataPos = data.length;
            var imageDataPos = imageData.length;

            if (canvasDataPos / imageDataPos !== 4) {
              return false;
            }

            while (imageDataPos--) {
              var value = imageData[imageDataPos];
              data[--canvasDataPos] = 255;
              data[--canvasDataPos] = value;
              data[--canvasDataPos] = value;
              data[--canvasDataPos] = value;
            }

            ctx.putImageData(canvasData, 0, 0);
            return true;
          },
        };

        /***/
      },
      /* 11 */
      /***/ function (module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* eslint-disable no-param-reassign */
        /* harmony default export */ __webpack_exports__["a"] = {
          init: function init(arr, val) {
            arr.fill(val);
          },

          /**
           * IN-PLACE Shuffles the content of an array
           */
          shuffle: function shuffle(arr) {
            // Durstenfeld shuffle algorithm
            // https://stackoverflow.com/questions/2450954/how-to-randomize-shuffle-a-javascript-array
            for (var i = arr.length - 1; i > 0; i--) {
              var j = Math.floor(Math.random() * (i + 1));
              var _ref = [arr[j], arr[i]];
              arr[i] = _ref[0];
              arr[j] = _ref[1];
            }

            return arr;
          },
          toPointList: function toPointList(arr) {
            var rows = arr.reduce(function (p, n) {
              var row = "[".concat(n.join(","), "]");
              p.push(row);
              return p;
            }, []);
            return "[".concat(rows.join(",\r\n"), "]");
          },

          /**
           * returns the elements which's score is bigger than the threshold
           */
          // eslint-disable-next-line no-unused-vars
          threshold: function threshold(arr, _threshold, scoreFunc) {
            var queue = arr.reduce(function (prev, next) {
              if (scoreFunc.apply(arr, [next]) >= _threshold) {
                prev.push(next);
              }

              return prev;
            }, []);
            return queue;
          },
          maxIndex: function maxIndex(arr) {
            var max = 0;

            for (var i = 0; i < arr.length; i++) {
              if (arr[i] > arr[max]) {
                max = i;
              }
            }

            return max;
          },
          max: function max(arr) {
            var max = 0;

            for (var i = 0; i < arr.length; i++) {
              if (arr[i] > max) {
                max = arr[i];
              }
            }

            return max;
          },
          sum: function sum(arr) {
            var length = arr.length;
            var sum = 0;

            while (length--) {
              sum += arr[length];
            }

            return sum;
          },
        };

        /***/
      },
      /* 12 */
      /***/ function (module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony import */ var _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_0__ =
          __webpack_require__(83);
        /* harmony import */ var _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_0___default =
          /*#__PURE__*/ __webpack_require__.n(
            _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_0__
          );
        /* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1__ =
          __webpack_require__(3);
        /* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1___default =
          /*#__PURE__*/ __webpack_require__.n(
            _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1__
          );
        /* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2__ =
          __webpack_require__(4);
        /* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2___default =
          /*#__PURE__*/ __webpack_require__.n(
            _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2__
          );
        /* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_3__ =
          __webpack_require__(0);
        /* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_3___default =
          /*#__PURE__*/ __webpack_require__.n(
            _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_3__
          );
        /* harmony import */ var gl_vec2__WEBPACK_IMPORTED_MODULE_4__ =
          __webpack_require__(7);
        /* harmony import */ var gl_vec2__WEBPACK_IMPORTED_MODULE_4___default =
          /*#__PURE__*/ __webpack_require__.n(
            gl_vec2__WEBPACK_IMPORTED_MODULE_4__
          );
        /* harmony import */ var _array_helper__WEBPACK_IMPORTED_MODULE_5__ =
          __webpack_require__(11);
        /* harmony import */ var _cv_utils__WEBPACK_IMPORTED_MODULE_6__ =
          __webpack_require__(9);

        var vec2 = {
          clone: gl_vec2__WEBPACK_IMPORTED_MODULE_4__["clone"],
        };

        function assertNumberPositive(val) {
          if (val < 0) {
            throw new Error("expected positive number, received ".concat(val));
          }
        }

        var ImageWrapper = /*#__PURE__*/ (function () {
          // Represents a basic image combining the data and size. In addition, some methods for
          // manipulation are contained within.
          function ImageWrapper(size, data) {
            var ArrayType =
              arguments.length > 2 && arguments[2] !== undefined
                ? arguments[2]
                : Uint8Array;
            var initialize = arguments.length > 3 ? arguments[3] : undefined;

            _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1___default()(
              this,
              ImageWrapper
            );

            _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_3___default()(
              this,
              "data",
              void 0
            );

            _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_3___default()(
              this,
              "size",
              void 0
            );

            _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_3___default()(
              this,
              "indexMapping",
              void 0
            );

            if (!data) {
              this.data = new ArrayType(size.x * size.y);

              if (initialize) {
                _array_helper__WEBPACK_IMPORTED_MODULE_5__[
                  /* default */ "a"
                ].init(this.data, 0);
              }
            } else {
              this.data = data;
            }

            this.size = size;
          } // tests if a position is within the image, extended out by a border on each side

          _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2___default()(
            ImageWrapper,
            [
              {
                key: "inImageWithBorder",
                value: function inImageWithBorder(imgRef) {
                  var border =
                    arguments.length > 1 && arguments[1] !== undefined
                      ? arguments[1]
                      : 0;
                  assertNumberPositive(border);
                  return (
                    imgRef.x >= 0 &&
                    imgRef.y >= 0 &&
                    imgRef.x < this.size.x + border * 2 &&
                    imgRef.y < this.size.y + border * 2
                  );
                }, // Copy from THIS ImageWrapper to the new imageWrapper parameter, starting at from, stopping at
                // end of new imageWrapper size.
              },
              {
                key: "subImageAsCopy",
                value: function subImageAsCopy(imageWrapper, from) {
                  assertNumberPositive(from.x);
                  assertNumberPositive(from.y);
                  var _imageWrapper$size = imageWrapper.size,
                    sizeX = _imageWrapper$size.x,
                    sizeY = _imageWrapper$size.y;

                  for (var x = 0; x < sizeX; x++) {
                    for (var y = 0; y < sizeY; y++) {
                      // eslint-disable-next-line no-param-reassign
                      imageWrapper.data[y * sizeX + x] =
                        this.data[(from.y + y) * this.size.x + from.x + x];
                    }
                  }

                  return imageWrapper; // TODO: this function really probably should call into ImageWrapper somewhere to make
                  // sure that all of it's parameters are set properly, something like
                  // ImageWrapper.UpdateFrom()
                  // that might take a provided data and size, and make sure there's no invalid indexMapping
                  // hanging around, and such.
                }, // Retrieve a grayscale value at the given pixel position of the image
              },
              {
                key: "get",
                value: function get(x, y) {
                  return this.data[y * this.size.x + x];
                }, // Retrieve a grayscale value at the given pixel position of the image (safe, whatever that
                // means)
              },
              {
                key: "getSafe",
                value: function getSafe(x, y) {
                  // cache indexMapping because if we're using it once, we'll probably need it a bunch more
                  // too
                  if (!this.indexMapping) {
                    this.indexMapping = {
                      x: [],
                      y: [],
                    };

                    for (var i = 0; i < this.size.x; i++) {
                      this.indexMapping.x[i] = i;
                      this.indexMapping.x[i + this.size.x] = i;
                    }

                    for (var _i = 0; _i < this.size.y; _i++) {
                      this.indexMapping.y[_i] = _i;
                      this.indexMapping.y[_i + this.size.y] = _i;
                    }
                  }

                  return this.data[
                    this.indexMapping.y[y + this.size.y] * this.size.x +
                      this.indexMapping.x[x + this.size.x]
                  ];
                }, // Sets a given pixel position in the image to the given grayscale value
              },
              {
                key: "set",
                value: function set(x, y, value) {
                  this.data[y * this.size.x + x] = value;
                  delete this.indexMapping;
                  return this;
                }, // Sets the border of the image (1 pixel) to zero
              },
              {
                key: "zeroBorder",
                value: function zeroBorder() {
                  var _this$size = this.size,
                    width = _this$size.x,
                    height = _this$size.y;

                  for (var i = 0; i < width; i++) {
                    // eslint-disable-next-line no-multi-assign
                    this.data[i] = this.data[(height - 1) * width + i] = 0;
                  }

                  for (var _i2 = 1; _i2 < height - 1; _i2++) {
                    // eslint-disable-next-line no-multi-assign
                    this.data[_i2 * width] = this.data[
                      _i2 * width + (width - 1)
                    ] = 0;
                  }

                  delete this.indexMapping;
                  return this;
                }, // TODO: this function is entirely too large for me to reason out right at this moment that i'm handling
                // all the rest of it, so this is a verbatim copy of the javascript source, with only tweaks
                // necessary to get it to run, no thought put into it yet.
              },
              {
                key: "moments",
                value: function moments(labelCount) {
                  var data = this.data;
                  var x;
                  var y;
                  var height = this.size.y;
                  var width = this.size.x;
                  var val;
                  var ysq;
                  var labelSum = [];
                  var i;
                  var label;
                  var mu11;
                  var mu02;
                  var mu20;
                  var x_;
                  var y_;
                  var tmp;
                  var result = [];
                  var PI = Math.PI;
                  var PI_4 = PI / 4;

                  if (labelCount <= 0) {
                    return result;
                  }

                  for (i = 0; i < labelCount; i++) {
                    labelSum[i] = {
                      m00: 0,
                      m01: 0,
                      m10: 0,
                      m11: 0,
                      m02: 0,
                      m20: 0,
                      theta: 0,
                      rad: 0,
                    };
                  }

                  for (y = 0; y < height; y++) {
                    ysq = y * y;

                    for (x = 0; x < width; x++) {
                      val = data[y * width + x];

                      if (val > 0) {
                        label = labelSum[val - 1];
                        label.m00 += 1;
                        label.m01 += y;
                        label.m10 += x;
                        label.m11 += x * y;
                        label.m02 += ysq;
                        label.m20 += x * x;
                      }
                    }
                  }

                  for (i = 0; i < labelCount; i++) {
                    label = labelSum[i]; // eslint-disable-next-line no-restricted-globals

                    if (!isNaN(label.m00) && label.m00 !== 0) {
                      x_ = label.m10 / label.m00;
                      y_ = label.m01 / label.m00;
                      mu11 = label.m11 / label.m00 - x_ * y_;
                      mu02 = label.m02 / label.m00 - y_ * y_;
                      mu20 = label.m20 / label.m00 - x_ * x_;
                      tmp = (mu02 - mu20) / (2 * mu11);
                      tmp =
                        0.5 * Math.atan(tmp) + (mu11 >= 0 ? PI_4 : -PI_4) + PI; // eslint-disable-next-line no-mixed-operators

                      label.theta = (((tmp * 180) / PI + 90) % 180) - 90;

                      if (label.theta < 0) {
                        label.theta += 180;
                      }

                      label.rad = tmp > PI ? tmp - PI : tmp;
                      label.vec = vec2.clone([Math.cos(tmp), Math.sin(tmp)]);
                      result.push(label);
                    }
                  }

                  return result;
                }, // return a Uint8ClampedArray containing this grayscale image converted to RGBA form
              },
              {
                key: "getAsRGBA",
                value: function getAsRGBA() {
                  var scale =
                    arguments.length > 0 && arguments[0] !== undefined
                      ? arguments[0]
                      : 1.0;
                  var ret = new Uint8ClampedArray(
                    4 * this.size.x * this.size.y
                  );

                  for (var y = 0; y < this.size.y; y++) {
                    for (var x = 0; x < this.size.x; x++) {
                      var pixel = y * this.size.x + x;
                      var current = this.get(x, y) * scale;
                      ret[pixel * 4 + 0] = current;
                      ret[pixel * 4 + 1] = current;
                      ret[pixel * 4 + 2] = current;
                      ret[pixel * 4 + 3] = 255;
                    }
                  }

                  return ret;
                }, // Display this ImageWrapper in a given Canvas element at the specified scale
              },
              {
                key: "show",
                value: function show(canvas) {
                  var scale =
                    arguments.length > 1 && arguments[1] !== undefined
                      ? arguments[1]
                      : 1.0;
                  var ctx = canvas.getContext("2d");

                  if (!ctx) {
                    throw new Error("Unable to get canvas context");
                  }

                  var frame = ctx.getImageData(
                    0,
                    0,
                    canvas.width,
                    canvas.height
                  );
                  var data = this.getAsRGBA(scale); // eslint-disable-next-line no-param-reassign

                  canvas.width = this.size.x; // eslint-disable-next-line no-param-reassign

                  canvas.height = this.size.y;
                  var newFrame = new ImageData(data, frame.width, frame.height);
                  ctx.putImageData(newFrame, 0, 0);
                }, // Displays a specified SubImage area in a given canvas. This differs drastically from
                // creating a new SubImage and using it's show() method. Why? I don't have the answer to that
                // yet.  I suspect the HSV/RGB operations involved here are making it significantly different,
                // but until I can visualize these functions side by side, I'm just going to copy the existing
                // implementation.
              },
              {
                key: "overlay",
                value: function overlay(canvas, inScale, from) {
                  var adjustedScale =
                    inScale < 0 || inScale > 360 ? 360 : inScale;
                  var hsv = [0, 1, 1];
                  var rgb = [0, 0, 0];
                  var whiteRgb = [255, 255, 255];
                  var blackRgb = [0, 0, 0];
                  var result = [];
                  var ctx = canvas.getContext("2d");

                  if (!ctx) {
                    throw new Error("Unable to get canvas context");
                  }

                  var frame = ctx.getImageData(
                    from.x,
                    from.y,
                    this.size.x,
                    this.size.y
                  );
                  var data = frame.data;
                  var length = this.data.length;

                  while (length--) {
                    hsv[0] = this.data[length] * adjustedScale; // eslint-disable-next-line no-nested-ternary

                    result =
                      hsv[0] <= 0
                        ? whiteRgb
                        : hsv[0] >= 360
                        ? blackRgb
                        : Object(
                            _cv_utils__WEBPACK_IMPORTED_MODULE_6__[
                              /* hsv2rgb */ "g"
                            ]
                          )(hsv, rgb);
                    var pos = length * 4;
                    var _result = result;

                    var _result2 =
                      _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_0___default()(
                        _result,
                        3
                      );

                    data[pos] = _result2[0];
                    data[pos + 1] = _result2[1];
                    data[pos + 2] = _result2[2];
                    data[pos + 3] = 255;
                  }

                  ctx.putImageData(frame, from.x, from.y);
                },
              },
            ]
          );

          return ImageWrapper;
        })();

        /* harmony default export */ __webpack_exports__["a"] = ImageWrapper;

        /***/
      },
      /* 13 */
      /***/ function (module, exports) {
        function asyncGeneratorStep(
          gen,
          resolve,
          reject,
          _next,
          _throw,
          key,
          arg
        ) {
          try {
            var info = gen[key](arg);
            var value = info.value;
          } catch (error) {
            reject(error);
            return;
          }

          if (info.done) {
            resolve(value);
          } else {
            Promise.resolve(value).then(_next, _throw);
          }
        }

        function _asyncToGenerator(fn) {
          return function () {
            var self = this,
              args = arguments;
            return new Promise(function (resolve, reject) {
              var gen = fn.apply(self, args);

              function _next(value) {
                asyncGeneratorStep(
                  gen,
                  resolve,
                  reject,
                  _next,
                  _throw,
                  "next",
                  value
                );
              }

              function _throw(err) {
                asyncGeneratorStep(
                  gen,
                  resolve,
                  reject,
                  _next,
                  _throw,
                  "throw",
                  err
                );
              }

              _next(undefined);
            });
          };
        }

        (module.exports = _asyncToGenerator),
          (module.exports.__esModule = true),
          (module.exports["default"] = module.exports);

        /***/
      },
      /* 14 */
      /***/ function (module, exports, __webpack_require__) {
        var superPropBase = __webpack_require__(225);

        function _get() {
          if (typeof Reflect !== "undefined" && Reflect.get) {
            (module.exports = _get = Reflect.get.bind()),
              (module.exports.__esModule = true),
              (module.exports["default"] = module.exports);
          } else {
            (module.exports = _get =
              function _get(target, property, receiver) {
                var base = superPropBase(target, property);
                if (!base) return;
                var desc = Object.getOwnPropertyDescriptor(base, property);

                if (desc.get) {
                  return desc.get.call(
                    arguments.length < 3 ? target : receiver
                  );
                }

                return desc.value;
              }),
              (module.exports.__esModule = true),
              (module.exports["default"] = module.exports);
          }

          return _get.apply(this, arguments);
        }

        (module.exports = _get),
          (module.exports.__esModule = true),
          (module.exports["default"] = module.exports);

        /***/
      },
      /* 15 */
      /***/ function (module, exports) {
        /**
         * Checks if `value` is the
         * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
         * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is an object, else `false`.
         * @example
         *
         * _.isObject({});
         * // => true
         *
         * _.isObject([1, 2, 3]);
         * // => true
         *
         * _.isObject(_.noop);
         * // => true
         *
         * _.isObject(null);
         * // => false
         */
        function isObject(value) {
          var type = typeof value;
          return value != null && (type == "object" || type == "function");
        }

        module.exports = isObject;

        /***/
      },
      /* 16 */
      /***/ function (module, exports) {
        /**
         * Checks if `value` is classified as an `Array` object.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is an array, else `false`.
         * @example
         *
         * _.isArray([1, 2, 3]);
         * // => true
         *
         * _.isArray(document.body.children);
         * // => false
         *
         * _.isArray('abc');
         * // => false
         *
         * _.isArray(_.noop);
         * // => false
         */
        var isArray = Array.isArray;
        module.exports = isArray;

        /***/
      },
      /* 17 */
      /***/ function (module, exports) {
        function _typeof(obj) {
          "@babel/helpers - typeof";

          return (
            ((module.exports = _typeof =
              "function" == typeof Symbol && "symbol" == typeof Symbol.iterator
                ? function (obj) {
                    return typeof obj;
                  }
                : function (obj) {
                    return obj &&
                      "function" == typeof Symbol &&
                      obj.constructor === Symbol &&
                      obj !== Symbol.prototype
                      ? "symbol"
                      : typeof obj;
                  }),
            (module.exports.__esModule = true),
            (module.exports["default"] = module.exports)),
            _typeof(obj)
          );
        }

        (module.exports = _typeof),
          (module.exports.__esModule = true),
          (module.exports["default"] = module.exports);

        /***/
      },
      /* 18 */
      /***/ function (module, exports, __webpack_require__) {
        var baseMerge = __webpack_require__(90),
          createAssigner = __webpack_require__(145);
        /**
         * This method is like `_.assign` except that it recursively merges own and
         * inherited enumerable string keyed properties of source objects into the
         * destination object. Source properties that resolve to `undefined` are
         * skipped if a destination value exists. Array and plain object properties
         * are merged recursively. Other objects and value types are overridden by
         * assignment. Source objects are applied from left to right. Subsequent
         * sources overwrite property assignments of previous sources.
         *
         * **Note:** This method mutates `object`.
         *
         * @static
         * @memberOf _
         * @since 0.5.0
         * @category Object
         * @param {Object} object The destination object.
         * @param {...Object} [sources] The source objects.
         * @returns {Object} Returns `object`.
         * @example
         *
         * var object = {
         *   'a': [{ 'b': 2 }, { 'd': 4 }]
         * };
         *
         * var other = {
         *   'a': [{ 'c': 3 }, { 'e': 5 }]
         * };
         *
         * _.merge(object, other);
         * // => { 'a': [{ 'b': 2, 'c': 3 }, { 'd': 4, 'e': 5 }] }
         */

        var merge = createAssigner(function (object, source, srcIndex) {
          baseMerge(object, source, srcIndex);
        });
        module.exports = merge;

        /***/
      },
      /* 19 */
      /***/ function (module, exports, __webpack_require__) {
        var freeGlobal = __webpack_require__(45);
        /** Detect free variable `self`. */

        var freeSelf =
          typeof self == "object" && self && self.Object === Object && self;
        /** Used as a reference to the global object. */

        var root = freeGlobal || freeSelf || Function("return this")();
        module.exports = root;

        /***/
      },
      /* 20 */
      /***/ function (module, exports) {
        /**
         * Checks if `value` is object-like. A value is object-like if it's not `null`
         * and has a `typeof` result of "object".
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
         * @example
         *
         * _.isObjectLike({});
         * // => true
         *
         * _.isObjectLike([1, 2, 3]);
         * // => true
         *
         * _.isObjectLike(_.noop);
         * // => false
         *
         * _.isObjectLike(null);
         * // => false
         */
        function isObjectLike(value) {
          return value != null && typeof value == "object";
        }

        module.exports = isObjectLike;

        /***/
      },
      /* 21 */
      /***/ function (module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /**
         * http://www.codeproject.com/Tips/407172/Connected-Component-Labeling-and-Vectorization
         */
        var Tracer = {
          searchDirections: [
            [0, 1],
            [1, 1],
            [1, 0],
            [1, -1],
            [0, -1],
            [-1, -1],
            [-1, 0],
            [-1, 1],
          ],
          create: function create(imageWrapper, labelWrapper) {
            var imageData = imageWrapper.data;
            var labelData = labelWrapper.data;
            var searchDirections = this.searchDirections;
            var width = imageWrapper.size.x;
            var pos;

            function _trace(current, color, label, edgelabel) {
              var i;
              var y;
              var x;

              for (i = 0; i < searchDirections.length; i++) {
                y = current.cy + searchDirections[current.dir][0];
                x = current.cx + searchDirections[current.dir][1];
                pos = y * width + x;

                if (
                  imageData[pos] === color &&
                  (labelData[pos] === 0 || labelData[pos] === label)
                ) {
                  labelData[pos] = label;
                  current.cy = y;
                  current.cx = x;
                  return true;
                }

                if (labelData[pos] === 0) {
                  labelData[pos] = edgelabel;
                }

                current.dir = (current.dir + 1) % 8;
              }

              return false;
            }

            function vertex2D(x, y, dir) {
              return {
                dir: dir,
                x: x,
                y: y,
                next: null,
                prev: null,
              };
            }

            function _contourTracing(sy, sx, label, color, edgelabel) {
              var Fv = null;
              var Cv;
              var P;
              var ldir;
              var current = {
                cx: sx,
                cy: sy,
                dir: 0,
              };

              if (_trace(current, color, label, edgelabel)) {
                Fv = vertex2D(sx, sy, current.dir);
                Cv = Fv;
                ldir = current.dir;
                P = vertex2D(current.cx, current.cy, 0);
                P.prev = Cv;
                Cv.next = P;
                P.next = null;
                Cv = P;
                var totalPixelCount = imageWrapper.size.x * imageWrapper.size.y;
                var pixelCounter = 0;

                do {
                  current.dir = (current.dir + 6) % 8;

                  _trace(current, color, label, edgelabel);

                  if (ldir !== current.dir) {
                    Cv.dir = current.dir;
                    P = vertex2D(current.cx, current.cy, 0);
                    P.prev = Cv;
                    Cv.next = P;
                    P.next = null;
                    Cv = P;
                  } else {
                    Cv.dir = ldir;
                    Cv.x = current.cx;
                    Cv.y = current.cy;
                  }

                  ldir = current.dir;
                } while (
                  (current.cx !== sx || current.cy !== sy) &&
                  ++pixelCounter < totalPixelCount
                );

                Fv.prev = Cv.prev;
                Cv.prev.next = Fv;
              }

              return Fv;
            }

            return {
              trace: function trace(current, color, label, edgelabel) {
                return _trace(current, color, label, edgelabel);
              },
              contourTracing: function contourTracing(
                sy,
                sx,
                label,
                color,
                edgelabel
              ) {
                return _contourTracing(sy, sx, label, color, edgelabel);
              },
            };
          },
        };
        /* harmony default export */ __webpack_exports__["a"] = Tracer;

        /***/
      },
      /* 22 */
      /***/ function (module, exports, __webpack_require__) {
        var Symbol = __webpack_require__(27),
          getRawTag = __webpack_require__(103),
          objectToString = __webpack_require__(104);
        /** `Object#toString` result references. */

        var nullTag = "[object Null]",
          undefinedTag = "[object Undefined]";
        /** Built-in value references. */

        var symToStringTag = Symbol ? Symbol.toStringTag : undefined;
        /**
         * The base implementation of `getTag` without fallbacks for buggy environments.
         *
         * @private
         * @param {*} value The value to query.
         * @returns {string} Returns the `toStringTag`.
         */

        function baseGetTag(value) {
          if (value == null) {
            return value === undefined ? undefinedTag : nullTag;
          }

          return symToStringTag && symToStringTag in Object(value)
            ? getRawTag(value)
            : objectToString(value);
        }

        module.exports = baseGetTag;

        /***/
      },
      /* 23 */
      /***/ function (module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* WEBPACK VAR INJECTION */ (function (global) {
          /* harmony import */ var gl_vec2__WEBPACK_IMPORTED_MODULE_0__ =
            __webpack_require__(7);
          /* harmony import */ var gl_vec2__WEBPACK_IMPORTED_MODULE_0___default =
            /*#__PURE__*/ __webpack_require__.n(
              gl_vec2__WEBPACK_IMPORTED_MODULE_0__
            );
          /* harmony import */ var gl_mat2__WEBPACK_IMPORTED_MODULE_1__ =
            __webpack_require__(34);
          /* harmony import */ var gl_mat2__WEBPACK_IMPORTED_MODULE_1___default =
            /*#__PURE__*/ __webpack_require__.n(
              gl_mat2__WEBPACK_IMPORTED_MODULE_1__
            );
          /* harmony import */ var _common_image_wrapper__WEBPACK_IMPORTED_MODULE_2__ =
            __webpack_require__(12);
          /* harmony import */ var _common_cv_utils__WEBPACK_IMPORTED_MODULE_3__ =
            __webpack_require__(9);
          /* harmony import */ var _common_array_helper__WEBPACK_IMPORTED_MODULE_4__ =
            __webpack_require__(11);
          /* harmony import */ var _common_image_debug__WEBPACK_IMPORTED_MODULE_5__ =
            __webpack_require__(10);
          /* harmony import */ var _rasterizer__WEBPACK_IMPORTED_MODULE_6__ =
            __webpack_require__(87);
          /* harmony import */ var _tracer__WEBPACK_IMPORTED_MODULE_7__ =
            __webpack_require__(21);
          /* harmony import */ var _skeletonizer__WEBPACK_IMPORTED_MODULE_8__ =
            __webpack_require__(88);

          var _config;

          var _currentImageWrapper;

          var _skelImageWrapper;

          var _subImageWrapper;

          var _labelImageWrapper;

          var _patchGrid;

          var _patchLabelGrid;

          var _imageToPatchGrid;

          var _binaryImageWrapper;

          var _patchSize;

          var _canvasContainer = {
            ctx: {
              binary: null,
            },
            dom: {
              binary: null,
            },
          };
          var _numPatches = {
            x: 0,
            y: 0,
          };

          var _inputImageWrapper;

          var _skeletonizer;

          function initBuffers() {
            if (_config.halfSample) {
              _currentImageWrapper =
                new _common_image_wrapper__WEBPACK_IMPORTED_MODULE_2__[
                  /* default */ "a"
                ]({
                  // eslint-disable-next-line no-bitwise
                  x: (_inputImageWrapper.size.x / 2) | 0,
                  // eslint-disable-next-line no-bitwise
                  y: (_inputImageWrapper.size.y / 2) | 0,
                });
            } else {
              _currentImageWrapper = _inputImageWrapper;
            }

            _patchSize = Object(
              _common_cv_utils__WEBPACK_IMPORTED_MODULE_3__[
                /* calculatePatchSize */ "a"
              ]
            )(_config.patchSize, _currentImageWrapper.size); // eslint-disable-next-line no-bitwise

            _numPatches.x = (_currentImageWrapper.size.x / _patchSize.x) | 0; // eslint-disable-next-line no-bitwise

            _numPatches.y = (_currentImageWrapper.size.y / _patchSize.y) | 0;
            _binaryImageWrapper =
              new _common_image_wrapper__WEBPACK_IMPORTED_MODULE_2__[
                /* default */ "a"
              ](_currentImageWrapper.size, undefined, Uint8Array, false);
            _labelImageWrapper =
              new _common_image_wrapper__WEBPACK_IMPORTED_MODULE_2__[
                /* default */ "a"
              ](_patchSize, undefined, Array, true);
            var skeletonImageData = new ArrayBuffer(64 * 1024);
            _subImageWrapper =
              new _common_image_wrapper__WEBPACK_IMPORTED_MODULE_2__[
                /* default */ "a"
              ](
                _patchSize,
                new Uint8Array(
                  skeletonImageData,
                  0,
                  _patchSize.x * _patchSize.y
                )
              );
            _skelImageWrapper =
              new _common_image_wrapper__WEBPACK_IMPORTED_MODULE_2__[
                /* default */ "a"
              ](
                _patchSize,
                new Uint8Array(
                  skeletonImageData,
                  _patchSize.x * _patchSize.y * 3,
                  _patchSize.x * _patchSize.y
                ),
                undefined,
                true
              );
            _skeletonizer = Object(
              _skeletonizer__WEBPACK_IMPORTED_MODULE_8__[/* default */ "a"]
            )(
              typeof window !== "undefined"
                ? window
                : typeof self !== "undefined"
                ? self
                : global,
              {
                size: _patchSize.x,
              },
              skeletonImageData
            );
            _imageToPatchGrid =
              new _common_image_wrapper__WEBPACK_IMPORTED_MODULE_2__[
                /* default */ "a"
              ](
                {
                  // eslint-disable-next-line no-bitwise
                  x:
                    (_currentImageWrapper.size.x / _subImageWrapper.size.x) | 0,
                  // eslint-disable-next-line no-bitwise
                  y:
                    (_currentImageWrapper.size.y / _subImageWrapper.size.y) | 0,
                },
                undefined,
                Array,
                true
              );
            _patchGrid = new _common_image_wrapper__WEBPACK_IMPORTED_MODULE_2__[
              /* default */ "a"
            ](_imageToPatchGrid.size, undefined, undefined, true);
            _patchLabelGrid =
              new _common_image_wrapper__WEBPACK_IMPORTED_MODULE_2__[
                /* default */ "a"
              ](_imageToPatchGrid.size, undefined, Int32Array, true);
          }

          function initCanvas() {
            if (_config.useWorker || typeof document === "undefined") {
              return;
            }

            _canvasContainer.dom.binary = document.createElement("canvas");
            _canvasContainer.dom.binary.className = "binaryBuffer";

            if (true && _config.debug.showCanvas === true) {
              document
                .querySelector("#debug")
                .appendChild(_canvasContainer.dom.binary);
            }

            _canvasContainer.ctx.binary =
              _canvasContainer.dom.binary.getContext("2d");
            _canvasContainer.dom.binary.width = _binaryImageWrapper.size.x;
            _canvasContainer.dom.binary.height = _binaryImageWrapper.size.y;
          }
          /**
           * Creates a bounding box which encloses all the given patches
           * @returns {Array} The minimal bounding box
           */

          function boxFromPatches(patches) {
            var overAvg;
            var i;
            var j;
            var patch;
            var transMat;
            var minx = _binaryImageWrapper.size.x;
            var miny = _binaryImageWrapper.size.y;
            var maxx = -_binaryImageWrapper.size.x;
            var maxy = -_binaryImageWrapper.size.y;
            var box;
            var scale; // draw all patches which are to be taken into consideration

            overAvg = 0;

            for (i = 0; i < patches.length; i++) {
              patch = patches[i];
              overAvg += patch.rad;

              if (true && _config.debug.showPatches) {
                _common_image_debug__WEBPACK_IMPORTED_MODULE_5__[
                  /* default */ "a"
                ].drawRect(
                  patch.pos,
                  _subImageWrapper.size,
                  _canvasContainer.ctx.binary,
                  {
                    color: "red",
                  }
                );
              }
            }

            overAvg /= patches.length;
            overAvg = (((overAvg * 180) / Math.PI + 90) % 180) - 90;

            if (overAvg < 0) {
              overAvg += 180;
            }

            overAvg = ((180 - overAvg) * Math.PI) / 180;
            transMat = gl_mat2__WEBPACK_IMPORTED_MODULE_1__["copy"](
              gl_mat2__WEBPACK_IMPORTED_MODULE_1__["create"](),
              [
                Math.cos(overAvg),
                Math.sin(overAvg),
                -Math.sin(overAvg),
                Math.cos(overAvg),
              ]
            ); // iterate over patches and rotate by angle

            for (i = 0; i < patches.length; i++) {
              patch = patches[i];

              for (j = 0; j < 4; j++) {
                gl_vec2__WEBPACK_IMPORTED_MODULE_0__["transformMat2"](
                  patch.box[j],
                  patch.box[j],
                  transMat
                );
              }

              if (true && _config.debug.boxFromPatches.showTransformed) {
                _common_image_debug__WEBPACK_IMPORTED_MODULE_5__[
                  /* default */ "a"
                ].drawPath(
                  patch.box,
                  {
                    x: 0,
                    y: 1,
                  },
                  _canvasContainer.ctx.binary,
                  {
                    color: "#99ff00",
                    lineWidth: 2,
                  }
                );
              }
            } // find bounding box

            for (i = 0; i < patches.length; i++) {
              patch = patches[i];

              for (j = 0; j < 4; j++) {
                if (patch.box[j][0] < minx) {
                  minx = patch.box[j][0];
                }

                if (patch.box[j][0] > maxx) {
                  maxx = patch.box[j][0];
                }

                if (patch.box[j][1] < miny) {
                  miny = patch.box[j][1];
                }

                if (patch.box[j][1] > maxy) {
                  maxy = patch.box[j][1];
                }
              }
            }

            box = [
              [minx, miny],
              [maxx, miny],
              [maxx, maxy],
              [minx, maxy],
            ];

            if (true && _config.debug.boxFromPatches.showTransformedBox) {
              _common_image_debug__WEBPACK_IMPORTED_MODULE_5__[
                /* default */ "a"
              ].drawPath(
                box,
                {
                  x: 0,
                  y: 1,
                },
                _canvasContainer.ctx.binary,
                {
                  color: "#ff0000",
                  lineWidth: 2,
                }
              );
            }

            scale = _config.halfSample ? 2 : 1; // reverse rotation;

            transMat = gl_mat2__WEBPACK_IMPORTED_MODULE_1__["invert"](
              transMat,
              transMat
            );

            for (j = 0; j < 4; j++) {
              gl_vec2__WEBPACK_IMPORTED_MODULE_0__["transformMat2"](
                box[j],
                box[j],
                transMat
              );
            }

            if (true && _config.debug.boxFromPatches.showBB) {
              _common_image_debug__WEBPACK_IMPORTED_MODULE_5__[
                /* default */ "a"
              ].drawPath(
                box,
                {
                  x: 0,
                  y: 1,
                },
                _canvasContainer.ctx.binary,
                {
                  color: "#ff0000",
                  lineWidth: 2,
                }
              );
            }

            for (j = 0; j < 4; j++) {
              gl_vec2__WEBPACK_IMPORTED_MODULE_0__["scale"](
                box[j],
                box[j],
                scale
              );
            }

            return box;
          }
          /**
           * Creates a binary image of the current image
           */

          function binarizeImage() {
            Object(
              _common_cv_utils__WEBPACK_IMPORTED_MODULE_3__[
                /* otsuThreshold */ "i"
              ]
            )(_currentImageWrapper, _binaryImageWrapper);

            _binaryImageWrapper.zeroBorder();

            if (true && _config.debug.showCanvas) {
              _binaryImageWrapper.show(_canvasContainer.dom.binary, 255);
            }
          }
          /**
           * Iterate over the entire image
           * extract patches
           */

          function findPatches() {
            var i;
            var j;
            var x;
            var y;
            var moments;
            var patchesFound = [];
            var rasterizer;
            var rasterResult;
            var patch;

            for (i = 0; i < _numPatches.x; i++) {
              for (j = 0; j < _numPatches.y; j++) {
                x = _subImageWrapper.size.x * i;
                y = _subImageWrapper.size.y * j; // seperate parts

                skeletonize(x, y); // Rasterize, find individual bars

                _skelImageWrapper.zeroBorder();

                _common_array_helper__WEBPACK_IMPORTED_MODULE_4__[
                  /* default */ "a"
                ].init(_labelImageWrapper.data, 0);
                rasterizer = _rasterizer__WEBPACK_IMPORTED_MODULE_6__[
                  /* default */ "a"
                ].create(_skelImageWrapper, _labelImageWrapper);
                rasterResult = rasterizer.rasterize(0);

                if (true && _config.debug.showLabels) {
                  _labelImageWrapper.overlay(
                    _canvasContainer.dom.binary,
                    Math.floor(360 / rasterResult.count),
                    {
                      x: x,
                      y: y,
                    }
                  );
                } // calculate moments from the skeletonized patch

                moments = _labelImageWrapper.moments(rasterResult.count); // extract eligible patches

                patchesFound = patchesFound.concat(
                  describePatch(moments, [i, j], x, y)
                );
              }
            }

            if (true && _config.debug.showFoundPatches) {
              for (i = 0; i < patchesFound.length; i++) {
                patch = patchesFound[i];
                _common_image_debug__WEBPACK_IMPORTED_MODULE_5__[
                  /* default */ "a"
                ].drawRect(
                  patch.pos,
                  _subImageWrapper.size,
                  _canvasContainer.ctx.binary,
                  {
                    color: "#99ff00",
                    lineWidth: 2,
                  }
                );
              }
            }

            return patchesFound;
          }
          /**
           * Finds those connected areas which contain at least 6 patches
           * and returns them ordered DESC by the number of contained patches
           * @param {Number} maxLabel
           */

          function findBiggestConnectedAreas(maxLabel) {
            var i;
            var sum;
            var labelHist = [];
            var topLabels = [];

            for (i = 0; i < maxLabel; i++) {
              labelHist.push(0);
            }

            sum = _patchLabelGrid.data.length;

            while (sum--) {
              if (_patchLabelGrid.data[sum] > 0) {
                labelHist[_patchLabelGrid.data[sum] - 1]++;
              }
            }

            labelHist = labelHist.map(function (val, idx) {
              return {
                val: val,
                label: idx + 1,
              };
            });
            labelHist.sort(function (a, b) {
              return b.val - a.val;
            }); // extract top areas with at least 6 patches present

            topLabels = labelHist.filter(function (el) {
              return el.val >= 5;
            });
            return topLabels;
          }
          /**
           *
           */

          function findBoxes(topLabels, maxLabel) {
            var i;
            var j;
            var sum;
            var patches = [];
            var patch;
            var box;
            var boxes = [];
            var hsv = [0, 1, 1];
            var rgb = [0, 0, 0];

            for (i = 0; i < topLabels.length; i++) {
              sum = _patchLabelGrid.data.length;
              patches.length = 0;

              while (sum--) {
                if (_patchLabelGrid.data[sum] === topLabels[i].label) {
                  patch = _imageToPatchGrid.data[sum];
                  patches.push(patch);
                }
              }

              box = boxFromPatches(patches);

              if (box) {
                boxes.push(box); // draw patch-labels if requested

                if (true && _config.debug.showRemainingPatchLabels) {
                  for (j = 0; j < patches.length; j++) {
                    patch = patches[j];
                    hsv[0] = (topLabels[i].label / (maxLabel + 1)) * 360;
                    Object(
                      _common_cv_utils__WEBPACK_IMPORTED_MODULE_3__[
                        /* hsv2rgb */ "g"
                      ]
                    )(hsv, rgb);
                    _common_image_debug__WEBPACK_IMPORTED_MODULE_5__[
                      /* default */ "a"
                    ].drawRect(
                      patch.pos,
                      _subImageWrapper.size,
                      _canvasContainer.ctx.binary,
                      {
                        color: "rgb(".concat(rgb.join(","), ")"),
                        lineWidth: 2,
                      }
                    );
                  }
                }
              }
            }

            return boxes;
          }
          /**
           * Find similar moments (via cluster)
           * @param {Object} moments
           */

          function similarMoments(moments) {
            var clusters = Object(
              _common_cv_utils__WEBPACK_IMPORTED_MODULE_3__[/* cluster */ "b"]
            )(moments, 0.9);
            var topCluster = Object(
              _common_cv_utils__WEBPACK_IMPORTED_MODULE_3__[
                /* topGeneric */ "j"
              ]
            )(clusters, 1, function (e) {
              return e.getPoints().length;
            });
            var points = [];
            var result = [];

            if (topCluster.length === 1) {
              points = topCluster[0].item.getPoints();

              for (var i = 0; i < points.length; i++) {
                result.push(points[i].point);
              }
            }

            return result;
          }

          function skeletonize(x, y) {
            _binaryImageWrapper.subImageAsCopy(
              _subImageWrapper,
              Object(
                _common_cv_utils__WEBPACK_IMPORTED_MODULE_3__[
                  /* imageRef */ "h"
                ]
              )(x, y)
            );

            _skeletonizer.skeletonize(); // Show skeleton if requested

            if (true && _config.debug.showSkeleton) {
              _skelImageWrapper.overlay(
                _canvasContainer.dom.binary,
                360,
                Object(
                  _common_cv_utils__WEBPACK_IMPORTED_MODULE_3__[
                    /* imageRef */ "h"
                  ]
                )(x, y)
              );
            }
          }
          /**
           * Extracts and describes those patches which seem to contain a barcode pattern
           * @param {Array} moments
           * @param {Object} patchPos,
           * @param {Number} x
           * @param {Number} y
           * @returns {Array} list of patches
           */

          function describePatch(moments, patchPos, x, y) {
            var k;
            var avg;
            var eligibleMoments = [];
            var matchingMoments;
            var patch;
            var patchesFound = [];
            var minComponentWeight = Math.ceil(_patchSize.x / 3);

            if (moments.length >= 2) {
              // only collect moments which's area covers at least minComponentWeight pixels.
              for (k = 0; k < moments.length; k++) {
                if (moments[k].m00 > minComponentWeight) {
                  eligibleMoments.push(moments[k]);
                }
              } // if at least 2 moments are found which have at least minComponentWeights covered

              if (eligibleMoments.length >= 2) {
                matchingMoments = similarMoments(eligibleMoments);
                avg = 0; // determine the similarity of the moments

                for (k = 0; k < matchingMoments.length; k++) {
                  var _matchingMoments$k$ra, _matchingMoments$k;

                  avg +=
                    (_matchingMoments$k$ra =
                      (_matchingMoments$k = matchingMoments[k]) === null ||
                      _matchingMoments$k === void 0
                        ? void 0
                        : _matchingMoments$k.rad) !== null &&
                    _matchingMoments$k$ra !== void 0
                      ? _matchingMoments$k$ra
                      : 0;
                } // Only two of the moments are allowed not to fit into the equation
                // add the patch to the set

                if (
                  matchingMoments.length > 1 &&
                  matchingMoments.length >= (eligibleMoments.length / 4) * 3 &&
                  matchingMoments.length > moments.length / 4
                ) {
                  avg /= matchingMoments.length;
                  patch = {
                    index: patchPos[1] * _numPatches.x + patchPos[0],
                    pos: {
                      x: x,
                      y: y,
                    },
                    box: [
                      gl_vec2__WEBPACK_IMPORTED_MODULE_0__["clone"]([x, y]),
                      gl_vec2__WEBPACK_IMPORTED_MODULE_0__["clone"]([
                        x + _subImageWrapper.size.x,
                        y,
                      ]),
                      gl_vec2__WEBPACK_IMPORTED_MODULE_0__["clone"]([
                        x + _subImageWrapper.size.x,
                        y + _subImageWrapper.size.y,
                      ]),
                      gl_vec2__WEBPACK_IMPORTED_MODULE_0__["clone"]([
                        x,
                        y + _subImageWrapper.size.y,
                      ]),
                    ],
                    moments: matchingMoments,
                    rad: avg,
                    vec: gl_vec2__WEBPACK_IMPORTED_MODULE_0__["clone"]([
                      Math.cos(avg),
                      Math.sin(avg),
                    ]),
                  };
                  patchesFound.push(patch);
                }
              }
            }

            return patchesFound;
          }
          /**
           * finds patches which are connected and share the same orientation
           * @param {Object} patchesFound
           */

          function rasterizeAngularSimilarity(patchesFound) {
            var label = 0;
            var threshold = 0.95;
            var currIdx = 0;
            var j;
            var patch;
            var hsv = [0, 1, 1];
            var rgb = [0, 0, 0];

            function notYetProcessed() {
              var i;

              for (i = 0; i < _patchLabelGrid.data.length; i++) {
                if (_patchLabelGrid.data[i] === 0 && _patchGrid.data[i] === 1) {
                  return i;
                }
              }

              return _patchLabelGrid.data.length;
            }

            function trace(currentIdx) {
              var x;
              var y;
              var currentPatch;
              var idx;
              var dir;
              var current = {
                x: currentIdx % _patchLabelGrid.size.x,
                y: (currentIdx / _patchLabelGrid.size.x) | 0,
              };
              var similarity;

              if (currentIdx < _patchLabelGrid.data.length) {
                currentPatch = _imageToPatchGrid.data[currentIdx]; // assign label

                _patchLabelGrid.data[currentIdx] = label;

                for (
                  dir = 0;
                  dir <
                  _tracer__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"]
                    .searchDirections.length;
                  dir++
                ) {
                  y =
                    current.y +
                    _tracer__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"]
                      .searchDirections[dir][0];
                  x =
                    current.x +
                    _tracer__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"]
                      .searchDirections[dir][1];
                  idx = y * _patchLabelGrid.size.x + x; // continue if patch empty

                  if (_patchGrid.data[idx] === 0) {
                    _patchLabelGrid.data[idx] = Number.MAX_VALUE; // eslint-disable-next-line no-continue

                    continue;
                  }

                  if (_patchLabelGrid.data[idx] === 0) {
                    similarity = Math.abs(
                      gl_vec2__WEBPACK_IMPORTED_MODULE_0__["dot"](
                        _imageToPatchGrid.data[idx].vec,
                        currentPatch.vec
                      )
                    );

                    if (similarity > threshold) {
                      trace(idx);
                    }
                  }
                }
              }
            } // prepare for finding the right patches

            _common_array_helper__WEBPACK_IMPORTED_MODULE_4__[
              /* default */ "a"
            ].init(_patchGrid.data, 0);
            _common_array_helper__WEBPACK_IMPORTED_MODULE_4__[
              /* default */ "a"
            ].init(_patchLabelGrid.data, 0);
            _common_array_helper__WEBPACK_IMPORTED_MODULE_4__[
              /* default */ "a"
            ].init(_imageToPatchGrid.data, null);

            for (j = 0; j < patchesFound.length; j++) {
              patch = patchesFound[j];
              _imageToPatchGrid.data[patch.index] = patch;
              _patchGrid.data[patch.index] = 1;
            } // rasterize the patches found to determine area

            _patchGrid.zeroBorder(); // eslint-disable-next-line no-cond-assign

            while (
              (currIdx = notYetProcessed()) < _patchLabelGrid.data.length
            ) {
              label++;
              trace(currIdx);
            } // draw patch-labels if requested

            if (true && _config.debug.showPatchLabels) {
              for (j = 0; j < _patchLabelGrid.data.length; j++) {
                if (
                  _patchLabelGrid.data[j] > 0 &&
                  _patchLabelGrid.data[j] <= label
                ) {
                  patch = _imageToPatchGrid.data[j];
                  hsv[0] = (_patchLabelGrid.data[j] / (label + 1)) * 360;
                  Object(
                    _common_cv_utils__WEBPACK_IMPORTED_MODULE_3__[
                      /* hsv2rgb */ "g"
                    ]
                  )(hsv, rgb);
                  _common_image_debug__WEBPACK_IMPORTED_MODULE_5__[
                    /* default */ "a"
                  ].drawRect(
                    patch.pos,
                    _subImageWrapper.size,
                    _canvasContainer.ctx.binary,
                    {
                      color: "rgb(".concat(rgb.join(","), ")"),
                      lineWidth: 2,
                    }
                  );
                }
              }
            }

            return label;
          }

          /* harmony default export */ __webpack_exports__["a"] = {
            init: function init(inputImageWrapper, config) {
              _config = config;
              _inputImageWrapper = inputImageWrapper;
              initBuffers();
              initCanvas();
            },
            locate: function locate() {
              if (_config.halfSample) {
                Object(
                  _common_cv_utils__WEBPACK_IMPORTED_MODULE_3__[
                    /* halfSample */ "f"
                  ]
                )(_inputImageWrapper, _currentImageWrapper);
              }

              binarizeImage();
              var patchesFound = findPatches(); // return unless 5% or more patches are found

              if (patchesFound.length < _numPatches.x * _numPatches.y * 0.05) {
                return null;
              } // rasterrize area by comparing angular similarity;

              var maxLabel = rasterizeAngularSimilarity(patchesFound);

              if (maxLabel < 1) {
                return null;
              } // search for area with the most patches (biggest connected area)

              var topLabels = findBiggestConnectedAreas(maxLabel);

              if (topLabels.length === 0) {
                return null;
              }

              var boxes = findBoxes(topLabels, maxLabel);
              return boxes;
            },
            checkImageConstraints: function checkImageConstraints(
              inputStream,
              config
            ) {
              var patchSize;
              var width = inputStream.getWidth();
              var height = inputStream.getHeight();
              var thisHalfSample = config.halfSample ? 0.5 : 1;
              var area; // calculate width and height based on area

              if (inputStream.getConfig().area) {
                area = Object(
                  _common_cv_utils__WEBPACK_IMPORTED_MODULE_3__[
                    /* computeImageArea */ "d"
                  ]
                )(width, height, inputStream.getConfig().area);
                inputStream.setTopRight({
                  x: area.sx,
                  y: area.sy,
                });
                inputStream.setCanvasSize({
                  x: width,
                  y: height,
                });
                width = area.sw;
                height = area.sh;
              }

              var size = {
                x: Math.floor(width * thisHalfSample),
                y: Math.floor(height * thisHalfSample),
              };
              patchSize = Object(
                _common_cv_utils__WEBPACK_IMPORTED_MODULE_3__[
                  /* calculatePatchSize */ "a"
                ]
              )(config.patchSize, size);

              if (true) {
                console.log("Patch-Size: ".concat(JSON.stringify(patchSize)));
              }

              inputStream.setWidth(
                Math.floor(
                  Math.floor(size.x / patchSize.x) *
                    (1 / thisHalfSample) *
                    patchSize.x
                )
              );
              inputStream.setHeight(
                Math.floor(
                  Math.floor(size.y / patchSize.y) *
                    (1 / thisHalfSample) *
                    patchSize.y
                )
              );

              if (
                inputStream.getWidth() % patchSize.x === 0 &&
                inputStream.getHeight() % patchSize.y === 0
              ) {
                return true;
              }

              throw new Error(
                "Image dimensions do not comply with the current settings: Width ("
                  .concat(width, " )and height (")
                  .concat(height, ") must a multiple of ")
                  .concat(patchSize.x)
              );
            },
          };
          /* WEBPACK VAR INJECTION */
        }.call(this, __webpack_require__(46)));

        /***/
      },
      /* 24 */
      /***/ function (module, exports, __webpack_require__) {
        var listCacheClear = __webpack_require__(92),
          listCacheDelete = __webpack_require__(93),
          listCacheGet = __webpack_require__(94),
          listCacheHas = __webpack_require__(95),
          listCacheSet = __webpack_require__(96);
        /**
         * Creates an list cache object.
         *
         * @private
         * @constructor
         * @param {Array} [entries] The key-value pairs to cache.
         */

        function ListCache(entries) {
          var index = -1,
            length = entries == null ? 0 : entries.length;
          this.clear();

          while (++index < length) {
            var entry = entries[index];
            this.set(entry[0], entry[1]);
          }
        } // Add methods to `ListCache`.

        ListCache.prototype.clear = listCacheClear;
        ListCache.prototype["delete"] = listCacheDelete;
        ListCache.prototype.get = listCacheGet;
        ListCache.prototype.has = listCacheHas;
        ListCache.prototype.set = listCacheSet;
        module.exports = ListCache;

        /***/
      },
      /* 25 */
      /***/ function (module, exports, __webpack_require__) {
        var eq = __webpack_require__(26);
        /**
         * Gets the index at which the `key` is found in `array` of key-value pairs.
         *
         * @private
         * @param {Array} array The array to inspect.
         * @param {*} key The key to search for.
         * @returns {number} Returns the index of the matched value, else `-1`.
         */

        function assocIndexOf(array, key) {
          var length = array.length;

          while (length--) {
            if (eq(array[length][0], key)) {
              return length;
            }
          }

          return -1;
        }

        module.exports = assocIndexOf;

        /***/
      },
      /* 26 */
      /***/ function (module, exports) {
        /**
         * Performs a
         * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
         * comparison between two values to determine if they are equivalent.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Lang
         * @param {*} value The value to compare.
         * @param {*} other The other value to compare.
         * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
         * @example
         *
         * var object = { 'a': 1 };
         * var other = { 'a': 1 };
         *
         * _.eq(object, object);
         * // => true
         *
         * _.eq(object, other);
         * // => false
         *
         * _.eq('a', 'a');
         * // => true
         *
         * _.eq('a', Object('a'));
         * // => false
         *
         * _.eq(NaN, NaN);
         * // => true
         */
        function eq(value, other) {
          return value === other || (value !== value && other !== other);
        }

        module.exports = eq;

        /***/
      },
      /* 27 */
      /***/ function (module, exports, __webpack_require__) {
        var root = __webpack_require__(19);
        /** Built-in value references. */

        var Symbol = root.Symbol;
        module.exports = Symbol;

        /***/
      },
      /* 28 */
      /***/ function (module, exports, __webpack_require__) {
        var getNative = __webpack_require__(35);
        /* Built-in method references that are verified to be native. */

        var nativeCreate = getNative(Object, "create");
        module.exports = nativeCreate;

        /***/
      },
      /* 29 */
      /***/ function (module, exports, __webpack_require__) {
        var isKeyable = __webpack_require__(117);
        /**
         * Gets the data for `map`.
         *
         * @private
         * @param {Object} map The map to query.
         * @param {string} key The reference key.
         * @returns {*} Returns the map data.
         */

        function getMapData(map, key) {
          var data = map.__data__;
          return isKeyable(key)
            ? data[typeof key == "string" ? "string" : "hash"]
            : data.map;
        }

        module.exports = getMapData;

        /***/
      },
      /* 30 */
      /***/ function (module, exports, __webpack_require__) {
        var baseIsArguments = __webpack_require__(132),
          isObjectLike = __webpack_require__(20);
        /** Used for built-in method references. */

        var objectProto = Object.prototype;
        /** Used to check objects for own properties. */

        var hasOwnProperty = objectProto.hasOwnProperty;
        /** Built-in value references. */

        var propertyIsEnumerable = objectProto.propertyIsEnumerable;
        /**
         * Checks if `value` is likely an `arguments` object.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is an `arguments` object,
         *  else `false`.
         * @example
         *
         * _.isArguments(function() { return arguments; }());
         * // => true
         *
         * _.isArguments([1, 2, 3]);
         * // => false
         */

        var isArguments = baseIsArguments(
          (function () {
            return arguments;
          })()
        )
          ? baseIsArguments
          : function (value) {
              return (
                isObjectLike(value) &&
                hasOwnProperty.call(value, "callee") &&
                !propertyIsEnumerable.call(value, "callee")
              );
            };
        module.exports = isArguments;

        /***/
      },
      /* 31 */
      /***/ function (module, exports) {
        /** Used as references for various `Number` constants. */
        var MAX_SAFE_INTEGER = 9007199254740991;
        /** Used to detect unsigned integer values. */

        var reIsUint = /^(?:0|[1-9]\d*)$/;
        /**
         * Checks if `value` is a valid array-like index.
         *
         * @private
         * @param {*} value The value to check.
         * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
         * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
         */

        function isIndex(value, length) {
          var type = typeof value;
          length = length == null ? MAX_SAFE_INTEGER : length;
          return (
            !!length &&
            (type == "number" || (type != "symbol" && reIsUint.test(value))) &&
            value > -1 &&
            value % 1 == 0 &&
            value < length
          );
        }

        module.exports = isIndex;

        /***/
      },
      /* 32 */
      /***/ function (module, exports, __webpack_require__) {
        var isArray = __webpack_require__(16),
          isKey = __webpack_require__(232),
          stringToPath = __webpack_require__(233),
          toString = __webpack_require__(236);
        /**
         * Casts `value` to a path array if it's not one.
         *
         * @private
         * @param {*} value The value to inspect.
         * @param {Object} [object] The object to query keys on.
         * @returns {Array} Returns the cast property path array.
         */

        function castPath(value, object) {
          if (isArray(value)) {
            return value;
          }

          return isKey(value, object) ? [value] : stringToPath(toString(value));
        }

        module.exports = castPath;

        /***/
      },
      /* 33 */
      /***/ function (module, exports, __webpack_require__) {
        var arrayWithoutHoles = __webpack_require__(226);

        var iterableToArray = __webpack_require__(227);

        var unsupportedIterableToArray = __webpack_require__(60);

        var nonIterableSpread = __webpack_require__(228);

        function _toConsumableArray(arr) {
          return (
            arrayWithoutHoles(arr) ||
            iterableToArray(arr) ||
            unsupportedIterableToArray(arr) ||
            nonIterableSpread()
          );
        }

        (module.exports = _toConsumableArray),
          (module.exports.__esModule = true),
          (module.exports["default"] = module.exports);

        /***/
      },
      /* 34 */
      /***/ function (module, exports, __webpack_require__) {
        module.exports = {
          determinant: __webpack_require__(251),
          transpose: __webpack_require__(252),
          multiply: __webpack_require__(253),
          identity: __webpack_require__(254),
          adjoint: __webpack_require__(255),
          rotate: __webpack_require__(256),
          invert: __webpack_require__(257),
          create: __webpack_require__(258),
          scale: __webpack_require__(259),
          copy: __webpack_require__(260),
          frob: __webpack_require__(261),
          ldu: __webpack_require__(262),
        };

        /***/
      },
      /* 35 */
      /***/ function (module, exports, __webpack_require__) {
        var baseIsNative = __webpack_require__(102),
          getValue = __webpack_require__(108);
        /**
         * Gets the native function at `key` of `object`.
         *
         * @private
         * @param {Object} object The object to query.
         * @param {string} key The key of the method to get.
         * @returns {*} Returns the function if it's native, else `undefined`.
         */

        function getNative(object, key) {
          var value = getValue(object, key);
          return baseIsNative(value) ? value : undefined;
        }

        module.exports = getNative;

        /***/
      },
      /* 36 */
      /***/ function (module, exports, __webpack_require__) {
        var baseGetTag = __webpack_require__(22),
          isObject = __webpack_require__(15);
        /** `Object#toString` result references. */

        var asyncTag = "[object AsyncFunction]",
          funcTag = "[object Function]",
          genTag = "[object GeneratorFunction]",
          proxyTag = "[object Proxy]";
        /**
         * Checks if `value` is classified as a `Function` object.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a function, else `false`.
         * @example
         *
         * _.isFunction(_);
         * // => true
         *
         * _.isFunction(/abc/);
         * // => false
         */

        function isFunction(value) {
          if (!isObject(value)) {
            return false;
          } // The use of `Object#toString` avoids issues with the `typeof` operator
          // in Safari 9 which returns 'object' for typed arrays and other constructors.

          var tag = baseGetTag(value);
          return (
            tag == funcTag ||
            tag == genTag ||
            tag == asyncTag ||
            tag == proxyTag
          );
        }

        module.exports = isFunction;

        /***/
      },
      /* 37 */
      /***/ function (module, exports, __webpack_require__) {
        var defineProperty = __webpack_require__(49);
        /**
         * The base implementation of `assignValue` and `assignMergeValue` without
         * value checks.
         *
         * @private
         * @param {Object} object The object to modify.
         * @param {string} key The key of the property to assign.
         * @param {*} value The value to assign.
         */

        function baseAssignValue(object, key, value) {
          if (key == "__proto__" && defineProperty) {
            defineProperty(object, key, {
              configurable: true,
              enumerable: true,
              value: value,
              writable: true,
            });
          } else {
            object[key] = value;
          }
        }

        module.exports = baseAssignValue;

        /***/
      },
      /* 38 */
      /***/ function (module, exports) {
        module.exports = function (module) {
          if (!module.webpackPolyfill) {
            module.deprecate = function () {};

            module.paths = []; // module.parent = undefined by default

            if (!module.children) module.children = [];
            Object.defineProperty(module, "loaded", {
              enumerable: true,
              get: function () {
                return module.l;
              },
            });
            Object.defineProperty(module, "id", {
              enumerable: true,
              get: function () {
                return module.i;
              },
            });
            module.webpackPolyfill = 1;
          }

          return module;
        };

        /***/
      },
      /* 39 */
      /***/ function (module, exports, __webpack_require__) {
        var isFunction = __webpack_require__(36),
          isLength = __webpack_require__(40);
        /**
         * Checks if `value` is array-like. A value is considered array-like if it's
         * not a function and has a `value.length` that's an integer greater than or
         * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
         * @example
         *
         * _.isArrayLike([1, 2, 3]);
         * // => true
         *
         * _.isArrayLike(document.body.children);
         * // => true
         *
         * _.isArrayLike('abc');
         * // => true
         *
         * _.isArrayLike(_.noop);
         * // => false
         */

        function isArrayLike(value) {
          return value != null && isLength(value.length) && !isFunction(value);
        }

        module.exports = isArrayLike;

        /***/
      },
      /* 40 */
      /***/ function (module, exports) {
        /** Used as references for various `Number` constants. */
        var MAX_SAFE_INTEGER = 9007199254740991;
        /**
         * Checks if `value` is a valid array-like length.
         *
         * **Note:** This method is loosely based on
         * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
         * @example
         *
         * _.isLength(3);
         * // => true
         *
         * _.isLength(Number.MIN_VALUE);
         * // => false
         *
         * _.isLength(Infinity);
         * // => false
         *
         * _.isLength('3');
         * // => false
         */

        function isLength(value) {
          return (
            typeof value == "number" &&
            value > -1 &&
            value % 1 == 0 &&
            value <= MAX_SAFE_INTEGER
          );
        }

        module.exports = isLength;

        /***/
      },
      /* 41 */
      /***/ function (module, exports) {
        function _setPrototypeOf(o, p) {
          (module.exports = _setPrototypeOf =
            Object.setPrototypeOf
              ? Object.setPrototypeOf.bind()
              : function _setPrototypeOf(o, p) {
                  o.__proto__ = p;
                  return o;
                }),
            (module.exports.__esModule = true),
            (module.exports["default"] = module.exports);
          return _setPrototypeOf(o, p);
        }

        (module.exports = _setPrototypeOf),
          (module.exports.__esModule = true),
          (module.exports["default"] = module.exports);

        /***/
      },
      /* 42 */
      /***/ function (module, exports, __webpack_require__) {
        var baseGetTag = __webpack_require__(22),
          isObjectLike = __webpack_require__(20);
        /** `Object#toString` result references. */

        var symbolTag = "[object Symbol]";
        /**
         * Checks if `value` is classified as a `Symbol` primitive or object.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
         * @example
         *
         * _.isSymbol(Symbol.iterator);
         * // => true
         *
         * _.isSymbol('abc');
         * // => false
         */

        function isSymbol(value) {
          return (
            typeof value == "symbol" ||
            (isObjectLike(value) && baseGetTag(value) == symbolTag)
          );
        }

        module.exports = isSymbol;

        /***/
      },
      /* 43 */
      /***/ function (module, exports, __webpack_require__) {
        var isSymbol = __webpack_require__(42);
        /** Used as references for various `Number` constants. */

        var INFINITY = 1 / 0;
        /**
         * Converts `value` to a string key if it's not a string or symbol.
         *
         * @private
         * @param {*} value The value to inspect.
         * @returns {string|symbol} Returns the key.
         */

        function toKey(value) {
          if (typeof value == "string" || isSymbol(value)) {
            return value;
          }

          var result = value + "";
          return result == "0" && 1 / value == -INFINITY ? "-0" : result;
        }

        module.exports = toKey;

        /***/
      },
      /* 44 */
      /***/ function (module, exports, __webpack_require__) {
        var getNative = __webpack_require__(35),
          root = __webpack_require__(19);
        /* Built-in method references that are verified to be native. */

        var Map = getNative(root, "Map");
        module.exports = Map;

        /***/
      },
      /* 45 */
      /***/ function (module, exports, __webpack_require__) {
        /* WEBPACK VAR INJECTION */ (function (global) {
          /** Detect free variable `global` from Node.js. */
          var freeGlobal =
            typeof global == "object" &&
            global &&
            global.Object === Object &&
            global;
          module.exports = freeGlobal;
          /* WEBPACK VAR INJECTION */
        }.call(this, __webpack_require__(46)));

        /***/
      },
      /* 46 */
      /***/ function (module, exports) {
        var g; // This works in non-strict mode

        g = (function () {
          return this;
        })();

        try {
          // This works if eval is allowed (see CSP)
          g = g || new Function("return this")();
        } catch (e) {
          // This works if the window reference is available
          if (typeof window === "object") g = window;
        } // g can still be undefined, but nothing to do about it...
        // We return undefined, instead of nothing here, so it's
        // easier to handle this case. if(!global) { ...}

        module.exports = g;

        /***/
      },
      /* 47 */
      /***/ function (module, exports, __webpack_require__) {
        var mapCacheClear = __webpack_require__(109),
          mapCacheDelete = __webpack_require__(116),
          mapCacheGet = __webpack_require__(118),
          mapCacheHas = __webpack_require__(119),
          mapCacheSet = __webpack_require__(120);
        /**
         * Creates a map cache object to store key-value pairs.
         *
         * @private
         * @constructor
         * @param {Array} [entries] The key-value pairs to cache.
         */

        function MapCache(entries) {
          var index = -1,
            length = entries == null ? 0 : entries.length;
          this.clear();

          while (++index < length) {
            var entry = entries[index];
            this.set(entry[0], entry[1]);
          }
        } // Add methods to `MapCache`.

        MapCache.prototype.clear = mapCacheClear;
        MapCache.prototype["delete"] = mapCacheDelete;
        MapCache.prototype.get = mapCacheGet;
        MapCache.prototype.has = mapCacheHas;
        MapCache.prototype.set = mapCacheSet;
        module.exports = MapCache;

        /***/
      },
      /* 48 */
      /***/ function (module, exports, __webpack_require__) {
        var baseAssignValue = __webpack_require__(37),
          eq = __webpack_require__(26);
        /**
         * This function is like `assignValue` except that it doesn't assign
         * `undefined` values.
         *
         * @private
         * @param {Object} object The object to modify.
         * @param {string} key The key of the property to assign.
         * @param {*} value The value to assign.
         */

        function assignMergeValue(object, key, value) {
          if (
            (value !== undefined && !eq(object[key], value)) ||
            (value === undefined && !(key in object))
          ) {
            baseAssignValue(object, key, value);
          }
        }

        module.exports = assignMergeValue;

        /***/
      },
      /* 49 */
      /***/ function (module, exports, __webpack_require__) {
        var getNative = __webpack_require__(35);

        var defineProperty = (function () {
          try {
            var func = getNative(Object, "defineProperty");
            func({}, "", {});
            return func;
          } catch (e) {}
        })();

        module.exports = defineProperty;

        /***/
      },
      /* 50 */
      /***/ function (module, exports, __webpack_require__) {
        var overArg = __webpack_require__(131);
        /** Built-in value references. */

        var getPrototype = overArg(Object.getPrototypeOf, Object);
        module.exports = getPrototype;

        /***/
      },
      /* 51 */
      /***/ function (module, exports) {
        /** Used for built-in method references. */
        var objectProto = Object.prototype;
        /**
         * Checks if `value` is likely a prototype object.
         *
         * @private
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
         */

        function isPrototype(value) {
          var Ctor = value && value.constructor,
            proto =
              (typeof Ctor == "function" && Ctor.prototype) || objectProto;
          return value === proto;
        }

        module.exports = isPrototype;

        /***/
      },
      /* 52 */
      /***/ function (module, exports, __webpack_require__) {
        /* WEBPACK VAR INJECTION */ (function (module) {
          var root = __webpack_require__(19),
            stubFalse = __webpack_require__(134);
          /** Detect free variable `exports`. */

          var freeExports = true && exports && !exports.nodeType && exports;
          /** Detect free variable `module`. */

          var freeModule =
            freeExports &&
            typeof module == "object" &&
            module &&
            !module.nodeType &&
            module;
          /** Detect the popular CommonJS extension `module.exports`. */

          var moduleExports = freeModule && freeModule.exports === freeExports;
          /** Built-in value references. */

          var Buffer = moduleExports ? root.Buffer : undefined;
          /* Built-in method references for those with the same name as other `lodash` methods. */

          var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;
          /**
           * Checks if `value` is a buffer.
           *
           * @static
           * @memberOf _
           * @since 4.3.0
           * @category Lang
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
           * @example
           *
           * _.isBuffer(new Buffer(2));
           * // => true
           *
           * _.isBuffer(new Uint8Array(2));
           * // => false
           */

          var isBuffer = nativeIsBuffer || stubFalse;
          module.exports = isBuffer;
          /* WEBPACK VAR INJECTION */
        }.call(this, __webpack_require__(38)(module)));

        /***/
      },
      /* 53 */
      /***/ function (module, exports, __webpack_require__) {
        var baseIsTypedArray = __webpack_require__(136),
          baseUnary = __webpack_require__(137),
          nodeUtil = __webpack_require__(138);
        /* Node.js helper references. */

        var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
        /**
         * Checks if `value` is classified as a typed array.
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
         * @example
         *
         * _.isTypedArray(new Uint8Array);
         * // => true
         *
         * _.isTypedArray([]);
         * // => false
         */

        var isTypedArray = nodeIsTypedArray
          ? baseUnary(nodeIsTypedArray)
          : baseIsTypedArray;
        module.exports = isTypedArray;

        /***/
      },
      /* 54 */
      /***/ function (module, exports) {
        /**
         * Gets the value at `key`, unless `key` is "__proto__" or "constructor".
         *
         * @private
         * @param {Object} object The object to query.
         * @param {string} key The key of the property to get.
         * @returns {*} Returns the property value.
         */
        function safeGet(object, key) {
          if (key === "constructor" && typeof object[key] === "function") {
            return;
          }

          if (key == "__proto__") {
            return;
          }

          return object[key];
        }

        module.exports = safeGet;

        /***/
      },
      /* 55 */
      /***/ function (module, exports, __webpack_require__) {
        var baseAssignValue = __webpack_require__(37),
          eq = __webpack_require__(26);
        /** Used for built-in method references. */

        var objectProto = Object.prototype;
        /** Used to check objects for own properties. */

        var hasOwnProperty = objectProto.hasOwnProperty;
        /**
         * Assigns `value` to `key` of `object` if the existing value is not equivalent
         * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
         * for equality comparisons.
         *
         * @private
         * @param {Object} object The object to modify.
         * @param {string} key The key of the property to assign.
         * @param {*} value The value to assign.
         */

        function assignValue(object, key, value) {
          var objValue = object[key];

          if (
            !(hasOwnProperty.call(object, key) && eq(objValue, value)) ||
            (value === undefined && !(key in object))
          ) {
            baseAssignValue(object, key, value);
          }
        }

        module.exports = assignValue;

        /***/
      },
      /* 56 */
      /***/ function (module, exports, __webpack_require__) {
        var arrayLikeKeys = __webpack_require__(141),
          baseKeysIn = __webpack_require__(143),
          isArrayLike = __webpack_require__(39);
        /**
         * Creates an array of the own and inherited enumerable property names of `object`.
         *
         * **Note:** Non-object values are coerced to objects.
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category Object
         * @param {Object} object The object to query.
         * @returns {Array} Returns the array of property names.
         * @example
         *
         * function Foo() {
         *   this.a = 1;
         *   this.b = 2;
         * }
         *
         * Foo.prototype.c = 3;
         *
         * _.keysIn(new Foo);
         * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
         */

        function keysIn(object) {
          return isArrayLike(object)
            ? arrayLikeKeys(object, true)
            : baseKeysIn(object);
        }

        module.exports = keysIn;

        /***/
      },
      /* 57 */
      /***/ function (module, exports) {
        /**
         * This method returns the first argument it receives.
         *
         * @static
         * @since 0.1.0
         * @memberOf _
         * @category Util
         * @param {*} value Any value.
         * @returns {*} Returns `value`.
         * @example
         *
         * var object = { 'a': 1 };
         *
         * console.log(_.identity(object) === object);
         * // => true
         */
        function identity(value) {
          return value;
        }

        module.exports = identity;

        /***/
      },
      /* 58 */
      /***/ function (module, exports, __webpack_require__) {
        var apply = __webpack_require__(147);
        /* Built-in method references for those with the same name as other `lodash` methods. */

        var nativeMax = Math.max;
        /**
         * A specialized version of `baseRest` which transforms the rest array.
         *
         * @private
         * @param {Function} func The function to apply a rest parameter to.
         * @param {number} [start=func.length-1] The start position of the rest parameter.
         * @param {Function} transform The rest array transform.
         * @returns {Function} Returns the new function.
         */

        function overRest(func, start, transform) {
          start = nativeMax(start === undefined ? func.length - 1 : start, 0);
          return function () {
            var args = arguments,
              index = -1,
              length = nativeMax(args.length - start, 0),
              array = Array(length);

            while (++index < length) {
              array[index] = args[start + index];
            }

            index = -1;
            var otherArgs = Array(start + 1);

            while (++index < start) {
              otherArgs[index] = args[index];
            }

            otherArgs[start] = transform(array);
            return apply(func, this, otherArgs);
          };
        }

        module.exports = overRest;

        /***/
      },
      /* 59 */
      /***/ function (module, exports, __webpack_require__) {
        var baseSetToString = __webpack_require__(148),
          shortOut = __webpack_require__(150);
        /**
         * Sets the `toString` method of `func` to return `string`.
         *
         * @private
         * @param {Function} func The function to modify.
         * @param {Function} string The `toString` result.
         * @returns {Function} Returns `func`.
         */

        var setToString = shortOut(baseSetToString);
        module.exports = setToString;

        /***/
      },
      /* 60 */
      /***/ function (module, exports, __webpack_require__) {
        var arrayLikeToArray = __webpack_require__(61);

        function _unsupportedIterableToArray(o, minLen) {
          if (!o) return;
          if (typeof o === "string") return arrayLikeToArray(o, minLen);
          var n = Object.prototype.toString.call(o).slice(8, -1);
          if (n === "Object" && o.constructor) n = o.constructor.name;
          if (n === "Map" || n === "Set") return Array.from(o);
          if (
            n === "Arguments" ||
            /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)
          )
            return arrayLikeToArray(o, minLen);
        }

        (module.exports = _unsupportedIterableToArray),
          (module.exports.__esModule = true),
          (module.exports["default"] = module.exports);

        /***/
      },
      /* 61 */
      /***/ function (module, exports) {
        function _arrayLikeToArray(arr, len) {
          if (len == null || len > arr.length) len = arr.length;

          for (var i = 0, arr2 = new Array(len); i < len; i++) {
            arr2[i] = arr[i];
          }

          return arr2;
        }

        (module.exports = _arrayLikeToArray),
          (module.exports.__esModule = true),
          (module.exports["default"] = module.exports);

        /***/
      },
      /* 62 */
      /***/ function (module, exports) {
        module.exports = 0.000001;

        /***/
      },
      /* 63 */
      /***/ function (module, exports) {
        module.exports = create;
        /**
         * Creates a new, empty vec2
         *
         * @returns {vec2} a new 2D vector
         */

        function create() {
          var out = new Float32Array(2);
          out[0] = 0;
          out[1] = 0;
          return out;
        }

        /***/
      },
      /* 64 */
      /***/ function (module, exports) {
        module.exports = subtract;
        /**
         * Subtracts vector b from vector a
         *
         * @param {vec2} out the receiving vector
         * @param {vec2} a the first operand
         * @param {vec2} b the second operand
         * @returns {vec2} out
         */

        function subtract(out, a, b) {
          out[0] = a[0] - b[0];
          out[1] = a[1] - b[1];
          return out;
        }

        /***/
      },
      /* 65 */
      /***/ function (module, exports) {
        module.exports = multiply;
        /**
         * Multiplies two vec2's
         *
         * @param {vec2} out the receiving vector
         * @param {vec2} a the first operand
         * @param {vec2} b the second operand
         * @returns {vec2} out
         */

        function multiply(out, a, b) {
          out[0] = a[0] * b[0];
          out[1] = a[1] * b[1];
          return out;
        }

        /***/
      },
      /* 66 */
      /***/ function (module, exports) {
        module.exports = divide;
        /**
         * Divides two vec2's
         *
         * @param {vec2} out the receiving vector
         * @param {vec2} a the first operand
         * @param {vec2} b the second operand
         * @returns {vec2} out
         */

        function divide(out, a, b) {
          out[0] = a[0] / b[0];
          out[1] = a[1] / b[1];
          return out;
        }

        /***/
      },
      /* 67 */
      /***/ function (module, exports) {
        module.exports = distance;
        /**
         * Calculates the euclidian distance between two vec2's
         *
         * @param {vec2} a the first operand
         * @param {vec2} b the second operand
         * @returns {Number} distance between a and b
         */

        function distance(a, b) {
          var x = b[0] - a[0],
            y = b[1] - a[1];
          return Math.sqrt(x * x + y * y);
        }

        /***/
      },
      /* 68 */
      /***/ function (module, exports) {
        module.exports = squaredDistance;
        /**
         * Calculates the squared euclidian distance between two vec2's
         *
         * @param {vec2} a the first operand
         * @param {vec2} b the second operand
         * @returns {Number} squared distance between a and b
         */

        function squaredDistance(a, b) {
          var x = b[0] - a[0],
            y = b[1] - a[1];
          return x * x + y * y;
        }

        /***/
      },
      /* 69 */
      /***/ function (module, exports) {
        module.exports = length;
        /**
         * Calculates the length of a vec2
         *
         * @param {vec2} a vector to calculate length of
         * @returns {Number} length of a
         */

        function length(a) {
          var x = a[0],
            y = a[1];
          return Math.sqrt(x * x + y * y);
        }

        /***/
      },
      /* 70 */
      /***/ function (module, exports) {
        module.exports = squaredLength;
        /**
         * Calculates the squared length of a vec2
         *
         * @param {vec2} a vector to calculate squared length of
         * @returns {Number} squared length of a
         */

        function squaredLength(a) {
          var x = a[0],
            y = a[1];
          return x * x + y * y;
        }

        /***/
      },
      /* 71 */
      /***/ function (module, exports) {
        module.exports = 0.000001;

        /***/
      },
      /* 72 */
      /***/ function (module, exports) {
        module.exports = create;
        /**
         * Creates a new, empty vec3
         *
         * @returns {vec3} a new 3D vector
         */

        function create() {
          var out = new Float32Array(3);
          out[0] = 0;
          out[1] = 0;
          out[2] = 0;
          return out;
        }

        /***/
      },
      /* 73 */
      /***/ function (module, exports) {
        module.exports = fromValues;
        /**
         * Creates a new vec3 initialized with the given values
         *
         * @param {Number} x X component
         * @param {Number} y Y component
         * @param {Number} z Z component
         * @returns {vec3} a new 3D vector
         */

        function fromValues(x, y, z) {
          var out = new Float32Array(3);
          out[0] = x;
          out[1] = y;
          out[2] = z;
          return out;
        }

        /***/
      },
      /* 74 */
      /***/ function (module, exports) {
        module.exports = normalize;
        /**
         * Normalize a vec3
         *
         * @param {vec3} out the receiving vector
         * @param {vec3} a vector to normalize
         * @returns {vec3} out
         */

        function normalize(out, a) {
          var x = a[0],
            y = a[1],
            z = a[2];
          var len = x * x + y * y + z * z;

          if (len > 0) {
            //TODO: evaluate use of glm_invsqrt here?
            len = 1 / Math.sqrt(len);
            out[0] = a[0] * len;
            out[1] = a[1] * len;
            out[2] = a[2] * len;
          }

          return out;
        }

        /***/
      },
      /* 75 */
      /***/ function (module, exports) {
        module.exports = dot;
        /**
         * Calculates the dot product of two vec3's
         *
         * @param {vec3} a the first operand
         * @param {vec3} b the second operand
         * @returns {Number} dot product of a and b
         */

        function dot(a, b) {
          return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
        }

        /***/
      },
      /* 76 */
      /***/ function (module, exports) {
        module.exports = subtract;
        /**
         * Subtracts vector b from vector a
         *
         * @param {vec3} out the receiving vector
         * @param {vec3} a the first operand
         * @param {vec3} b the second operand
         * @returns {vec3} out
         */

        function subtract(out, a, b) {
          out[0] = a[0] - b[0];
          out[1] = a[1] - b[1];
          out[2] = a[2] - b[2];
          return out;
        }

        /***/
      },
      /* 77 */
      /***/ function (module, exports) {
        module.exports = multiply;
        /**
         * Multiplies two vec3's
         *
         * @param {vec3} out the receiving vector
         * @param {vec3} a the first operand
         * @param {vec3} b the second operand
         * @returns {vec3} out
         */

        function multiply(out, a, b) {
          out[0] = a[0] * b[0];
          out[1] = a[1] * b[1];
          out[2] = a[2] * b[2];
          return out;
        }

        /***/
      },
      /* 78 */
      /***/ function (module, exports) {
        module.exports = divide;
        /**
         * Divides two vec3's
         *
         * @param {vec3} out the receiving vector
         * @param {vec3} a the first operand
         * @param {vec3} b the second operand
         * @returns {vec3} out
         */

        function divide(out, a, b) {
          out[0] = a[0] / b[0];
          out[1] = a[1] / b[1];
          out[2] = a[2] / b[2];
          return out;
        }

        /***/
      },
      /* 79 */
      /***/ function (module, exports) {
        module.exports = distance;
        /**
         * Calculates the euclidian distance between two vec3's
         *
         * @param {vec3} a the first operand
         * @param {vec3} b the second operand
         * @returns {Number} distance between a and b
         */

        function distance(a, b) {
          var x = b[0] - a[0],
            y = b[1] - a[1],
            z = b[2] - a[2];
          return Math.sqrt(x * x + y * y + z * z);
        }

        /***/
      },
      /* 80 */
      /***/ function (module, exports) {
        module.exports = squaredDistance;
        /**
         * Calculates the squared euclidian distance between two vec3's
         *
         * @param {vec3} a the first operand
         * @param {vec3} b the second operand
         * @returns {Number} squared distance between a and b
         */

        function squaredDistance(a, b) {
          var x = b[0] - a[0],
            y = b[1] - a[1],
            z = b[2] - a[2];
          return x * x + y * y + z * z;
        }

        /***/
      },
      /* 81 */
      /***/ function (module, exports) {
        module.exports = length;
        /**
         * Calculates the length of a vec3
         *
         * @param {vec3} a vector to calculate length of
         * @returns {Number} length of a
         */

        function length(a) {
          var x = a[0],
            y = a[1],
            z = a[2];
          return Math.sqrt(x * x + y * y + z * z);
        }

        /***/
      },
      /* 82 */
      /***/ function (module, exports) {
        module.exports = squaredLength;
        /**
         * Calculates the squared length of a vec3
         *
         * @param {vec3} a vector to calculate squared length of
         * @returns {Number} squared length of a
         */

        function squaredLength(a) {
          var x = a[0],
            y = a[1],
            z = a[2];
          return x * x + y * y + z * z;
        }

        /***/
      },
      /* 83 */
      /***/ function (module, exports, __webpack_require__) {
        var arrayWithHoles = __webpack_require__(153);

        var iterableToArrayLimit = __webpack_require__(154);

        var unsupportedIterableToArray = __webpack_require__(60);

        var nonIterableRest = __webpack_require__(155);

        function _slicedToArray(arr, i) {
          return (
            arrayWithHoles(arr) ||
            iterableToArrayLimit(arr, i) ||
            unsupportedIterableToArray(arr, i) ||
            nonIterableRest()
          );
        }

        (module.exports = _slicedToArray),
          (module.exports.__esModule = true),
          (module.exports["default"] = module.exports);

        /***/
      },
      /* 84 */
      /***/ function (module, exports, __webpack_require__) {
        module.exports = {
          EPSILON: __webpack_require__(71),
          create: __webpack_require__(72),
          clone: __webpack_require__(191),
          angle: __webpack_require__(192),
          fromValues: __webpack_require__(73),
          copy: __webpack_require__(193),
          set: __webpack_require__(194),
          equals: __webpack_require__(195),
          exactEquals: __webpack_require__(196),
          add: __webpack_require__(197),
          subtract: __webpack_require__(76),
          sub: __webpack_require__(198),
          multiply: __webpack_require__(77),
          mul: __webpack_require__(199),
          divide: __webpack_require__(78),
          div: __webpack_require__(200),
          min: __webpack_require__(201),
          max: __webpack_require__(202),
          floor: __webpack_require__(203),
          ceil: __webpack_require__(204),
          round: __webpack_require__(205),
          scale: __webpack_require__(206),
          scaleAndAdd: __webpack_require__(207),
          distance: __webpack_require__(79),
          dist: __webpack_require__(208),
          squaredDistance: __webpack_require__(80),
          sqrDist: __webpack_require__(209),
          length: __webpack_require__(81),
          len: __webpack_require__(210),
          squaredLength: __webpack_require__(82),
          sqrLen: __webpack_require__(211),
          negate: __webpack_require__(212),
          inverse: __webpack_require__(213),
          normalize: __webpack_require__(74),
          dot: __webpack_require__(75),
          cross: __webpack_require__(214),
          lerp: __webpack_require__(215),
          random: __webpack_require__(216),
          transformMat4: __webpack_require__(217),
          transformMat3: __webpack_require__(218),
          transformQuat: __webpack_require__(219),
          rotateX: __webpack_require__(220),
          rotateY: __webpack_require__(221),
          rotateZ: __webpack_require__(222),
          forEach: __webpack_require__(223),
        };

        /***/
      },
      /* 85 */
      /***/ function (module, exports, __webpack_require__) {
        var basePick = __webpack_require__(229),
          flatRest = __webpack_require__(243);
        /**
         * Creates an object composed of the picked `object` properties.
         *
         * @static
         * @since 0.1.0
         * @memberOf _
         * @category Object
         * @param {Object} object The source object.
         * @param {...(string|string[])} [paths] The property paths to pick.
         * @returns {Object} Returns the new object.
         * @example
         *
         * var object = { 'a': 1, 'b': '2', 'c': 3 };
         *
         * _.pick(object, ['a', 'c']);
         * // => { 'a': 1, 'c': 3 }
         */

        var pick = flatRest(function (object, paths) {
          return object == null ? {} : basePick(object, paths);
        });
        module.exports = pick;

        /***/
      },
      /* 86 */
      /***/ function (module, exports, __webpack_require__) {
        var getPrototypeOf = __webpack_require__(2);

        var setPrototypeOf = __webpack_require__(41);

        var isNativeFunction = __webpack_require__(248);

        var construct = __webpack_require__(249);

        function _wrapNativeSuper(Class) {
          var _cache = typeof Map === "function" ? new Map() : undefined;

          (module.exports = _wrapNativeSuper =
            function _wrapNativeSuper(Class) {
              if (Class === null || !isNativeFunction(Class)) return Class;

              if (typeof Class !== "function") {
                throw new TypeError(
                  "Super expression must either be null or a function"
                );
              }

              if (typeof _cache !== "undefined") {
                if (_cache.has(Class)) return _cache.get(Class);

                _cache.set(Class, Wrapper);
              }

              function Wrapper() {
                return construct(
                  Class,
                  arguments,
                  getPrototypeOf(this).constructor
                );
              }

              Wrapper.prototype = Object.create(Class.prototype, {
                constructor: {
                  value: Wrapper,
                  enumerable: false,
                  writable: true,
                  configurable: true,
                },
              });
              return setPrototypeOf(Wrapper, Class);
            }),
            (module.exports.__esModule = true),
            (module.exports["default"] = module.exports);
          return _wrapNativeSuper(Class);
        }

        (module.exports = _wrapNativeSuper),
          (module.exports.__esModule = true),
          (module.exports["default"] = module.exports);

        /***/
      },
      /* 87 */
      /***/ function (module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony import */ var _tracer__WEBPACK_IMPORTED_MODULE_0__ =
          __webpack_require__(21);

        /**
         * http://www.codeproject.com/Tips/407172/Connected-Component-Labeling-and-Vectorization
         */

        var Rasterizer = {
          createContour2D: function createContour2D() {
            return {
              dir: null,
              index: null,
              firstVertex: null,
              insideContours: null,
              nextpeer: null,
              prevpeer: null,
            };
          },
          CONTOUR_DIR: {
            CW_DIR: 0,
            CCW_DIR: 1,
            UNKNOWN_DIR: 2,
          },
          DIR: {
            OUTSIDE_EDGE: -32767,
            INSIDE_EDGE: -32766,
          },
          create: function create(imageWrapper, labelWrapper) {
            var imageData = imageWrapper.data;
            var labelData = labelWrapper.data;
            var width = imageWrapper.size.x;
            var height = imageWrapper.size.y;
            var tracer = _tracer__WEBPACK_IMPORTED_MODULE_0__[
              /* default */ "a"
            ].create(imageWrapper, labelWrapper);
            return {
              rasterize: function rasterize(depthlabel) {
                var color;
                var bc;
                var lc;
                var labelindex;
                var cx;
                var cy;
                var colorMap = [];
                var vertex;
                var p;
                var cc;
                var sc;
                var pos;
                var connectedCount = 0;
                var i;

                for (i = 0; i < 400; i++) {
                  colorMap[i] = 0;
                }

                colorMap[0] = imageData[0];
                cc = null;

                for (cy = 1; cy < height - 1; cy++) {
                  labelindex = 0;
                  bc = colorMap[0];

                  for (cx = 1; cx < width - 1; cx++) {
                    pos = cy * width + cx;

                    if (labelData[pos] === 0) {
                      color = imageData[pos];

                      if (color !== bc) {
                        if (labelindex === 0) {
                          lc = connectedCount + 1;
                          colorMap[lc] = color;
                          bc = color;
                          vertex = tracer.contourTracing(
                            cy,
                            cx,
                            lc,
                            color,
                            Rasterizer.DIR.OUTSIDE_EDGE
                          );

                          if (vertex !== null) {
                            connectedCount++;
                            labelindex = lc;
                            p = Rasterizer.createContour2D();
                            p.dir = Rasterizer.CONTOUR_DIR.CW_DIR;
                            p.index = labelindex;
                            p.firstVertex = vertex;
                            p.nextpeer = cc;
                            p.insideContours = null;

                            if (cc !== null) {
                              cc.prevpeer = p;
                            }

                            cc = p;
                          }
                        } else {
                          vertex = tracer.contourTracing(
                            cy,
                            cx,
                            Rasterizer.DIR.INSIDE_EDGE,
                            color,
                            labelindex
                          );

                          if (vertex !== null) {
                            p = Rasterizer.createContour2D();
                            p.firstVertex = vertex;
                            p.insideContours = null;

                            if (depthlabel === 0) {
                              p.dir = Rasterizer.CONTOUR_DIR.CCW_DIR;
                            } else {
                              p.dir = Rasterizer.CONTOUR_DIR.CW_DIR;
                            }

                            p.index = depthlabel;
                            sc = cc;

                            while (sc !== null && sc.index !== labelindex) {
                              sc = sc.nextpeer;
                            }

                            if (sc !== null) {
                              p.nextpeer = sc.insideContours;

                              if (sc.insideContours !== null) {
                                sc.insideContours.prevpeer = p;
                              }

                              sc.insideContours = p;
                            }
                          }
                        }
                      } else {
                        labelData[pos] = labelindex;
                      }
                    } else if (
                      labelData[pos] === Rasterizer.DIR.OUTSIDE_EDGE ||
                      labelData[pos] === Rasterizer.DIR.INSIDE_EDGE
                    ) {
                      labelindex = 0;

                      if (labelData[pos] === Rasterizer.DIR.INSIDE_EDGE) {
                        bc = imageData[pos];
                      } else {
                        bc = colorMap[0];
                      }
                    } else {
                      labelindex = labelData[pos];
                      bc = colorMap[labelindex];
                    }
                  }
                }

                sc = cc;

                while (sc !== null) {
                  sc.index = depthlabel;
                  sc = sc.nextpeer;
                }

                return {
                  cc: cc,
                  count: connectedCount,
                };
              },
              debug: {
                drawContour: function drawContour(canvas, firstContour) {
                  var ctx = canvas.getContext("2d");
                  var pq = firstContour;
                  var iq;
                  var q;
                  var p;
                  ctx.strokeStyle = "red";
                  ctx.fillStyle = "red";
                  ctx.lineWidth = 1;

                  if (pq !== null) {
                    iq = pq.insideContours;
                  } else {
                    iq = null;
                  }

                  while (pq !== null) {
                    if (iq !== null) {
                      q = iq;
                      iq = iq.nextpeer;
                    } else {
                      q = pq;
                      pq = pq.nextpeer;

                      if (pq !== null) {
                        iq = pq.insideContours;
                      } else {
                        iq = null;
                      }
                    }

                    switch (q.dir) {
                      case Rasterizer.CONTOUR_DIR.CW_DIR:
                        ctx.strokeStyle = "red";
                        break;

                      case Rasterizer.CONTOUR_DIR.CCW_DIR:
                        ctx.strokeStyle = "blue";
                        break;

                      case Rasterizer.CONTOUR_DIR.UNKNOWN_DIR:
                        ctx.strokeStyle = "green";
                        break;
                    }

                    p = q.firstVertex;
                    ctx.beginPath();
                    ctx.moveTo(p.x, p.y);

                    do {
                      p = p.next;
                      ctx.lineTo(p.x, p.y);
                    } while (p !== q.firstVertex);

                    ctx.stroke();
                  }
                },
              },
            };
          },
        };
        /* harmony default export */ __webpack_exports__["a"] = Rasterizer;

        /***/
      },
      /* 88 */
      /***/ function (module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* eslint-disable no-param-reassign */

        /* eslint-disable no-bitwise */

        /* eslint-disable eqeqeq */

        /* @preserve ASM BEGIN */
        function Skeletonizer(stdlib, foreign, buffer) {
          "use asm";

          var images = new stdlib.Uint8Array(buffer);
          var size = foreign.size | 0;
          var imul = stdlib.Math.imul;

          function erode(inImagePtr, outImagePtr) {
            inImagePtr |= 0;
            outImagePtr |= 0;
            var v = 0;
            var u = 0;
            var sum = 0;
            var yStart1 = 0;
            var yStart2 = 0;
            var xStart1 = 0;
            var xStart2 = 0;
            var offset = 0;

            for (v = 1; (v | 0) < ((size - 1) | 0); v = (v + 1) | 0) {
              offset = (offset + size) | 0;

              for (u = 1; (u | 0) < ((size - 1) | 0); u = (u + 1) | 0) {
                yStart1 = (offset - size) | 0;
                yStart2 = (offset + size) | 0;
                xStart1 = (u - 1) | 0;
                xStart2 = (u + 1) | 0;
                sum =
                  ((images[(inImagePtr + yStart1 + xStart1) | 0] | 0) +
                    (images[(inImagePtr + yStart1 + xStart2) | 0] | 0) +
                    (images[(inImagePtr + offset + u) | 0] | 0) +
                    (images[(inImagePtr + yStart2 + xStart1) | 0] | 0) +
                    (images[(inImagePtr + yStart2 + xStart2) | 0] | 0)) |
                  0;

                if ((sum | 0) == (5 | 0)) {
                  images[(outImagePtr + offset + u) | 0] = 1;
                } else {
                  images[(outImagePtr + offset + u) | 0] = 0;
                }
              }
            }
          }

          function subtract(aImagePtr, bImagePtr, outImagePtr) {
            aImagePtr |= 0;
            bImagePtr |= 0;
            outImagePtr |= 0;
            var length = 0;
            length = imul(size, size) | 0;

            while ((length | 0) > 0) {
              length = (length - 1) | 0;
              images[(outImagePtr + length) | 0] =
                ((images[(aImagePtr + length) | 0] | 0) -
                  (images[(bImagePtr + length) | 0] | 0)) |
                0;
            }
          }

          function bitwiseOr(aImagePtr, bImagePtr, outImagePtr) {
            aImagePtr |= 0;
            bImagePtr |= 0;
            outImagePtr |= 0;
            var length = 0;
            length = imul(size, size) | 0;

            while ((length | 0) > 0) {
              length = (length - 1) | 0;
              images[(outImagePtr + length) | 0] =
                images[(aImagePtr + length) | 0] |
                0 |
                (images[(bImagePtr + length) | 0] | 0) |
                0;
            }
          }

          function countNonZero(imagePtr) {
            imagePtr |= 0;
            var sum = 0;
            var length = 0;
            length = imul(size, size) | 0;

            while ((length | 0) > 0) {
              length = (length - 1) | 0;
              sum = ((sum | 0) + (images[(imagePtr + length) | 0] | 0)) | 0;
            }

            return sum | 0;
          }

          function init(imagePtr, value) {
            imagePtr |= 0;
            value |= 0;
            var length = 0;
            length = imul(size, size) | 0;

            while ((length | 0) > 0) {
              length = (length - 1) | 0;
              images[(imagePtr + length) | 0] = value;
            }
          }

          function dilate(inImagePtr, outImagePtr) {
            inImagePtr |= 0;
            outImagePtr |= 0;
            var v = 0;
            var u = 0;
            var sum = 0;
            var yStart1 = 0;
            var yStart2 = 0;
            var xStart1 = 0;
            var xStart2 = 0;
            var offset = 0;

            for (v = 1; (v | 0) < ((size - 1) | 0); v = (v + 1) | 0) {
              offset = (offset + size) | 0;

              for (u = 1; (u | 0) < ((size - 1) | 0); u = (u + 1) | 0) {
                yStart1 = (offset - size) | 0;
                yStart2 = (offset + size) | 0;
                xStart1 = (u - 1) | 0;
                xStart2 = (u + 1) | 0;
                sum =
                  ((images[(inImagePtr + yStart1 + xStart1) | 0] | 0) +
                    (images[(inImagePtr + yStart1 + xStart2) | 0] | 0) +
                    (images[(inImagePtr + offset + u) | 0] | 0) +
                    (images[(inImagePtr + yStart2 + xStart1) | 0] | 0) +
                    (images[(inImagePtr + yStart2 + xStart2) | 0] | 0)) |
                  0;

                if ((sum | 0) > (0 | 0)) {
                  images[(outImagePtr + offset + u) | 0] = 1;
                } else {
                  images[(outImagePtr + offset + u) | 0] = 0;
                }
              }
            }
          }

          function memcpy(srcImagePtr, dstImagePtr) {
            srcImagePtr |= 0;
            dstImagePtr |= 0;
            var length = 0;
            length = imul(size, size) | 0;

            while ((length | 0) > 0) {
              length = (length - 1) | 0;
              images[(dstImagePtr + length) | 0] =
                images[(srcImagePtr + length) | 0] | 0;
            }
          }

          function zeroBorder(imagePtr) {
            imagePtr |= 0;
            var x = 0;
            var y = 0;

            for (x = 0; (x | 0) < ((size - 1) | 0); x = (x + 1) | 0) {
              images[(imagePtr + x) | 0] = 0;
              images[(imagePtr + y) | 0] = 0;
              y = (y + size - 1) | 0;
              images[(imagePtr + y) | 0] = 0;
              y = (y + 1) | 0;
            }

            for (x = 0; (x | 0) < (size | 0); x = (x + 1) | 0) {
              images[(imagePtr + y) | 0] = 0;
              y = (y + 1) | 0;
            }
          }

          function skeletonize() {
            var subImagePtr = 0;
            var erodedImagePtr = 0;
            var tempImagePtr = 0;
            var skelImagePtr = 0;
            var sum = 0;
            var done = 0;
            erodedImagePtr = imul(size, size) | 0;
            tempImagePtr = (erodedImagePtr + erodedImagePtr) | 0;
            skelImagePtr = (tempImagePtr + erodedImagePtr) | 0; // init skel-image

            init(skelImagePtr, 0);
            zeroBorder(subImagePtr);

            do {
              erode(subImagePtr, erodedImagePtr);
              dilate(erodedImagePtr, tempImagePtr);
              subtract(subImagePtr, tempImagePtr, tempImagePtr);
              bitwiseOr(skelImagePtr, tempImagePtr, skelImagePtr);
              memcpy(erodedImagePtr, subImagePtr);
              sum = countNonZero(subImagePtr) | 0;
              done = ((sum | 0) == 0) | 0;
            } while (!done);
          }

          return {
            skeletonize: skeletonize,
          };
        }
        /* @preserve ASM END */

        /* harmony default export */ __webpack_exports__["a"] = Skeletonizer;
        /* eslint-enable eqeqeq */

        /***/
      },
      /* 89 */
      /***/ function (module, exports, __webpack_require__) {
        module.exports = __webpack_require__(263);

        /***/
      },
      /* 90 */
      /***/ function (module, exports, __webpack_require__) {
        var Stack = __webpack_require__(91),
          assignMergeValue = __webpack_require__(48),
          baseFor = __webpack_require__(121),
          baseMergeDeep = __webpack_require__(123),
          isObject = __webpack_require__(15),
          keysIn = __webpack_require__(56),
          safeGet = __webpack_require__(54);
        /**
         * The base implementation of `_.merge` without support for multiple sources.
         *
         * @private
         * @param {Object} object The destination object.
         * @param {Object} source The source object.
         * @param {number} srcIndex The index of `source`.
         * @param {Function} [customizer] The function to customize merged values.
         * @param {Object} [stack] Tracks traversed source values and their merged
         *  counterparts.
         */

        function baseMerge(object, source, srcIndex, customizer, stack) {
          if (object === source) {
            return;
          }

          baseFor(
            source,
            function (srcValue, key) {
              stack || (stack = new Stack());

              if (isObject(srcValue)) {
                baseMergeDeep(
                  object,
                  source,
                  key,
                  srcIndex,
                  baseMerge,
                  customizer,
                  stack
                );
              } else {
                var newValue = customizer
                  ? customizer(
                      safeGet(object, key),
                      srcValue,
                      key + "",
                      object,
                      source,
                      stack
                    )
                  : undefined;

                if (newValue === undefined) {
                  newValue = srcValue;
                }

                assignMergeValue(object, key, newValue);
              }
            },
            keysIn
          );
        }

        module.exports = baseMerge;

        /***/
      },
      /* 91 */
      /***/ function (module, exports, __webpack_require__) {
        var ListCache = __webpack_require__(24),
          stackClear = __webpack_require__(97),
          stackDelete = __webpack_require__(98),
          stackGet = __webpack_require__(99),
          stackHas = __webpack_require__(100),
          stackSet = __webpack_require__(101);
        /**
         * Creates a stack cache object to store key-value pairs.
         *
         * @private
         * @constructor
         * @param {Array} [entries] The key-value pairs to cache.
         */

        function Stack(entries) {
          var data = (this.__data__ = new ListCache(entries));
          this.size = data.size;
        } // Add methods to `Stack`.

        Stack.prototype.clear = stackClear;
        Stack.prototype["delete"] = stackDelete;
        Stack.prototype.get = stackGet;
        Stack.prototype.has = stackHas;
        Stack.prototype.set = stackSet;
        module.exports = Stack;

        /***/
      },
      /* 92 */
      /***/ function (module, exports) {
        /**
         * Removes all key-value entries from the list cache.
         *
         * @private
         * @name clear
         * @memberOf ListCache
         */
        function listCacheClear() {
          this.__data__ = [];
          this.size = 0;
        }

        module.exports = listCacheClear;

        /***/
      },
      /* 93 */
      /***/ function (module, exports, __webpack_require__) {
        var assocIndexOf = __webpack_require__(25);
        /** Used for built-in method references. */

        var arrayProto = Array.prototype;
        /** Built-in value references. */

        var splice = arrayProto.splice;
        /**
         * Removes `key` and its value from the list cache.
         *
         * @private
         * @name delete
         * @memberOf ListCache
         * @param {string} key The key of the value to remove.
         * @returns {boolean} Returns `true` if the entry was removed, else `false`.
         */

        function listCacheDelete(key) {
          var data = this.__data__,
            index = assocIndexOf(data, key);

          if (index < 0) {
            return false;
          }

          var lastIndex = data.length - 1;

          if (index == lastIndex) {
            data.pop();
          } else {
            splice.call(data, index, 1);
          }

          --this.size;
          return true;
        }

        module.exports = listCacheDelete;

        /***/
      },
      /* 94 */
      /***/ function (module, exports, __webpack_require__) {
        var assocIndexOf = __webpack_require__(25);
        /**
         * Gets the list cache value for `key`.
         *
         * @private
         * @name get
         * @memberOf ListCache
         * @param {string} key The key of the value to get.
         * @returns {*} Returns the entry value.
         */

        function listCacheGet(key) {
          var data = this.__data__,
            index = assocIndexOf(data, key);
          return index < 0 ? undefined : data[index][1];
        }

        module.exports = listCacheGet;

        /***/
      },
      /* 95 */
      /***/ function (module, exports, __webpack_require__) {
        var assocIndexOf = __webpack_require__(25);
        /**
         * Checks if a list cache value for `key` exists.
         *
         * @private
         * @name has
         * @memberOf ListCache
         * @param {string} key The key of the entry to check.
         * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
         */

        function listCacheHas(key) {
          return assocIndexOf(this.__data__, key) > -1;
        }

        module.exports = listCacheHas;

        /***/
      },
      /* 96 */
      /***/ function (module, exports, __webpack_require__) {
        var assocIndexOf = __webpack_require__(25);
        /**
         * Sets the list cache `key` to `value`.
         *
         * @private
         * @name set
         * @memberOf ListCache
         * @param {string} key The key of the value to set.
         * @param {*} value The value to set.
         * @returns {Object} Returns the list cache instance.
         */

        function listCacheSet(key, value) {
          var data = this.__data__,
            index = assocIndexOf(data, key);

          if (index < 0) {
            ++this.size;
            data.push([key, value]);
          } else {
            data[index][1] = value;
          }

          return this;
        }

        module.exports = listCacheSet;

        /***/
      },
      /* 97 */
      /***/ function (module, exports, __webpack_require__) {
        var ListCache = __webpack_require__(24);
        /**
         * Removes all key-value entries from the stack.
         *
         * @private
         * @name clear
         * @memberOf Stack
         */

        function stackClear() {
          this.__data__ = new ListCache();
          this.size = 0;
        }

        module.exports = stackClear;

        /***/
      },
      /* 98 */
      /***/ function (module, exports) {
        /**
         * Removes `key` and its value from the stack.
         *
         * @private
         * @name delete
         * @memberOf Stack
         * @param {string} key The key of the value to remove.
         * @returns {boolean} Returns `true` if the entry was removed, else `false`.
         */
        function stackDelete(key) {
          var data = this.__data__,
            result = data["delete"](key);
          this.size = data.size;
          return result;
        }

        module.exports = stackDelete;

        /***/
      },
      /* 99 */
      /***/ function (module, exports) {
        /**
         * Gets the stack value for `key`.
         *
         * @private
         * @name get
         * @memberOf Stack
         * @param {string} key The key of the value to get.
         * @returns {*} Returns the entry value.
         */
        function stackGet(key) {
          return this.__data__.get(key);
        }

        module.exports = stackGet;

        /***/
      },
      /* 100 */
      /***/ function (module, exports) {
        /**
         * Checks if a stack value for `key` exists.
         *
         * @private
         * @name has
         * @memberOf Stack
         * @param {string} key The key of the entry to check.
         * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
         */
        function stackHas(key) {
          return this.__data__.has(key);
        }

        module.exports = stackHas;

        /***/
      },
      /* 101 */
      /***/ function (module, exports, __webpack_require__) {
        var ListCache = __webpack_require__(24),
          Map = __webpack_require__(44),
          MapCache = __webpack_require__(47);
        /** Used as the size to enable large array optimizations. */

        var LARGE_ARRAY_SIZE = 200;
        /**
         * Sets the stack `key` to `value`.
         *
         * @private
         * @name set
         * @memberOf Stack
         * @param {string} key The key of the value to set.
         * @param {*} value The value to set.
         * @returns {Object} Returns the stack cache instance.
         */

        function stackSet(key, value) {
          var data = this.__data__;

          if (data instanceof ListCache) {
            var pairs = data.__data__;

            if (!Map || pairs.length < LARGE_ARRAY_SIZE - 1) {
              pairs.push([key, value]);
              this.size = ++data.size;
              return this;
            }

            data = this.__data__ = new MapCache(pairs);
          }

          data.set(key, value);
          this.size = data.size;
          return this;
        }

        module.exports = stackSet;

        /***/
      },
      /* 102 */
      /***/ function (module, exports, __webpack_require__) {
        var isFunction = __webpack_require__(36),
          isMasked = __webpack_require__(105),
          isObject = __webpack_require__(15),
          toSource = __webpack_require__(107);
        /**
         * Used to match `RegExp`
         * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
         */

        var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
        /** Used to detect host constructors (Safari). */

        var reIsHostCtor = /^\[object .+?Constructor\]$/;
        /** Used for built-in method references. */

        var funcProto = Function.prototype,
          objectProto = Object.prototype;
        /** Used to resolve the decompiled source of functions. */

        var funcToString = funcProto.toString;
        /** Used to check objects for own properties. */

        var hasOwnProperty = objectProto.hasOwnProperty;
        /** Used to detect if a method is native. */

        var reIsNative = RegExp(
          "^" +
            funcToString
              .call(hasOwnProperty)
              .replace(reRegExpChar, "\\$&")
              .replace(
                /hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,
                "$1.*?"
              ) +
            "$"
        );
        /**
         * The base implementation of `_.isNative` without bad shim checks.
         *
         * @private
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a native function,
         *  else `false`.
         */

        function baseIsNative(value) {
          if (!isObject(value) || isMasked(value)) {
            return false;
          }

          var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
          return pattern.test(toSource(value));
        }

        module.exports = baseIsNative;

        /***/
      },
      /* 103 */
      /***/ function (module, exports, __webpack_require__) {
        var Symbol = __webpack_require__(27);
        /** Used for built-in method references. */

        var objectProto = Object.prototype;
        /** Used to check objects for own properties. */

        var hasOwnProperty = objectProto.hasOwnProperty;
        /**
         * Used to resolve the
         * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
         * of values.
         */

        var nativeObjectToString = objectProto.toString;
        /** Built-in value references. */

        var symToStringTag = Symbol ? Symbol.toStringTag : undefined;
        /**
         * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
         *
         * @private
         * @param {*} value The value to query.
         * @returns {string} Returns the raw `toStringTag`.
         */

        function getRawTag(value) {
          var isOwn = hasOwnProperty.call(value, symToStringTag),
            tag = value[symToStringTag];

          try {
            value[symToStringTag] = undefined;
            var unmasked = true;
          } catch (e) {}

          var result = nativeObjectToString.call(value);

          if (unmasked) {
            if (isOwn) {
              value[symToStringTag] = tag;
            } else {
              delete value[symToStringTag];
            }
          }

          return result;
        }

        module.exports = getRawTag;

        /***/
      },
      /* 104 */
      /***/ function (module, exports) {
        /** Used for built-in method references. */
        var objectProto = Object.prototype;
        /**
         * Used to resolve the
         * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
         * of values.
         */

        var nativeObjectToString = objectProto.toString;
        /**
         * Converts `value` to a string using `Object.prototype.toString`.
         *
         * @private
         * @param {*} value The value to convert.
         * @returns {string} Returns the converted string.
         */

        function objectToString(value) {
          return nativeObjectToString.call(value);
        }

        module.exports = objectToString;

        /***/
      },
      /* 105 */
      /***/ function (module, exports, __webpack_require__) {
        var coreJsData = __webpack_require__(106);
        /** Used to detect methods masquerading as native. */

        var maskSrcKey = (function () {
          var uid = /[^.]+$/.exec(
            (coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO) || ""
          );
          return uid ? "Symbol(src)_1." + uid : "";
        })();
        /**
         * Checks if `func` has its source masked.
         *
         * @private
         * @param {Function} func The function to check.
         * @returns {boolean} Returns `true` if `func` is masked, else `false`.
         */

        function isMasked(func) {
          return !!maskSrcKey && maskSrcKey in func;
        }

        module.exports = isMasked;

        /***/
      },
      /* 106 */
      /***/ function (module, exports, __webpack_require__) {
        var root = __webpack_require__(19);
        /** Used to detect overreaching core-js shims. */

        var coreJsData = root["__core-js_shared__"];
        module.exports = coreJsData;

        /***/
      },
      /* 107 */
      /***/ function (module, exports) {
        /** Used for built-in method references. */
        var funcProto = Function.prototype;
        /** Used to resolve the decompiled source of functions. */

        var funcToString = funcProto.toString;
        /**
         * Converts `func` to its source code.
         *
         * @private
         * @param {Function} func The function to convert.
         * @returns {string} Returns the source code.
         */

        function toSource(func) {
          if (func != null) {
            try {
              return funcToString.call(func);
            } catch (e) {}

            try {
              return func + "";
            } catch (e) {}
          }

          return "";
        }

        module.exports = toSource;

        /***/
      },
      /* 108 */
      /***/ function (module, exports) {
        /**
         * Gets the value at `key` of `object`.
         *
         * @private
         * @param {Object} [object] The object to query.
         * @param {string} key The key of the property to get.
         * @returns {*} Returns the property value.
         */
        function getValue(object, key) {
          return object == null ? undefined : object[key];
        }

        module.exports = getValue;

        /***/
      },
      /* 109 */
      /***/ function (module, exports, __webpack_require__) {
        var Hash = __webpack_require__(110),
          ListCache = __webpack_require__(24),
          Map = __webpack_require__(44);
        /**
         * Removes all key-value entries from the map.
         *
         * @private
         * @name clear
         * @memberOf MapCache
         */

        function mapCacheClear() {
          this.size = 0;
          this.__data__ = {
            hash: new Hash(),
            map: new (Map || ListCache)(),
            string: new Hash(),
          };
        }

        module.exports = mapCacheClear;

        /***/
      },
      /* 110 */
      /***/ function (module, exports, __webpack_require__) {
        var hashClear = __webpack_require__(111),
          hashDelete = __webpack_require__(112),
          hashGet = __webpack_require__(113),
          hashHas = __webpack_require__(114),
          hashSet = __webpack_require__(115);
        /**
         * Creates a hash object.
         *
         * @private
         * @constructor
         * @param {Array} [entries] The key-value pairs to cache.
         */

        function Hash(entries) {
          var index = -1,
            length = entries == null ? 0 : entries.length;
          this.clear();

          while (++index < length) {
            var entry = entries[index];
            this.set(entry[0], entry[1]);
          }
        } // Add methods to `Hash`.

        Hash.prototype.clear = hashClear;
        Hash.prototype["delete"] = hashDelete;
        Hash.prototype.get = hashGet;
        Hash.prototype.has = hashHas;
        Hash.prototype.set = hashSet;
        module.exports = Hash;

        /***/
      },
      /* 111 */
      /***/ function (module, exports, __webpack_require__) {
        var nativeCreate = __webpack_require__(28);
        /**
         * Removes all key-value entries from the hash.
         *
         * @private
         * @name clear
         * @memberOf Hash
         */

        function hashClear() {
          this.__data__ = nativeCreate ? nativeCreate(null) : {};
          this.size = 0;
        }

        module.exports = hashClear;

        /***/
      },
      /* 112 */
      /***/ function (module, exports) {
        /**
         * Removes `key` and its value from the hash.
         *
         * @private
         * @name delete
         * @memberOf Hash
         * @param {Object} hash The hash to modify.
         * @param {string} key The key of the value to remove.
         * @returns {boolean} Returns `true` if the entry was removed, else `false`.
         */
        function hashDelete(key) {
          var result = this.has(key) && delete this.__data__[key];
          this.size -= result ? 1 : 0;
          return result;
        }

        module.exports = hashDelete;

        /***/
      },
      /* 113 */
      /***/ function (module, exports, __webpack_require__) {
        var nativeCreate = __webpack_require__(28);
        /** Used to stand-in for `undefined` hash values. */

        var HASH_UNDEFINED = "__lodash_hash_undefined__";
        /** Used for built-in method references. */

        var objectProto = Object.prototype;
        /** Used to check objects for own properties. */

        var hasOwnProperty = objectProto.hasOwnProperty;
        /**
         * Gets the hash value for `key`.
         *
         * @private
         * @name get
         * @memberOf Hash
         * @param {string} key The key of the value to get.
         * @returns {*} Returns the entry value.
         */

        function hashGet(key) {
          var data = this.__data__;

          if (nativeCreate) {
            var result = data[key];
            return result === HASH_UNDEFINED ? undefined : result;
          }

          return hasOwnProperty.call(data, key) ? data[key] : undefined;
        }

        module.exports = hashGet;

        /***/
      },
      /* 114 */
      /***/ function (module, exports, __webpack_require__) {
        var nativeCreate = __webpack_require__(28);
        /** Used for built-in method references. */

        var objectProto = Object.prototype;
        /** Used to check objects for own properties. */

        var hasOwnProperty = objectProto.hasOwnProperty;
        /**
         * Checks if a hash value for `key` exists.
         *
         * @private
         * @name has
         * @memberOf Hash
         * @param {string} key The key of the entry to check.
         * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
         */

        function hashHas(key) {
          var data = this.__data__;
          return nativeCreate
            ? data[key] !== undefined
            : hasOwnProperty.call(data, key);
        }

        module.exports = hashHas;

        /***/
      },
      /* 115 */
      /***/ function (module, exports, __webpack_require__) {
        var nativeCreate = __webpack_require__(28);
        /** Used to stand-in for `undefined` hash values. */

        var HASH_UNDEFINED = "__lodash_hash_undefined__";
        /**
         * Sets the hash `key` to `value`.
         *
         * @private
         * @name set
         * @memberOf Hash
         * @param {string} key The key of the value to set.
         * @param {*} value The value to set.
         * @returns {Object} Returns the hash instance.
         */

        function hashSet(key, value) {
          var data = this.__data__;
          this.size += this.has(key) ? 0 : 1;
          data[key] =
            nativeCreate && value === undefined ? HASH_UNDEFINED : value;
          return this;
        }

        module.exports = hashSet;

        /***/
      },
      /* 116 */
      /***/ function (module, exports, __webpack_require__) {
        var getMapData = __webpack_require__(29);
        /**
         * Removes `key` and its value from the map.
         *
         * @private
         * @name delete
         * @memberOf MapCache
         * @param {string} key The key of the value to remove.
         * @returns {boolean} Returns `true` if the entry was removed, else `false`.
         */

        function mapCacheDelete(key) {
          var result = getMapData(this, key)["delete"](key);
          this.size -= result ? 1 : 0;
          return result;
        }

        module.exports = mapCacheDelete;

        /***/
      },
      /* 117 */
      /***/ function (module, exports) {
        /**
         * Checks if `value` is suitable for use as unique object key.
         *
         * @private
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
         */
        function isKeyable(value) {
          var type = typeof value;
          return type == "string" ||
            type == "number" ||
            type == "symbol" ||
            type == "boolean"
            ? value !== "__proto__"
            : value === null;
        }

        module.exports = isKeyable;

        /***/
      },
      /* 118 */
      /***/ function (module, exports, __webpack_require__) {
        var getMapData = __webpack_require__(29);
        /**
         * Gets the map value for `key`.
         *
         * @private
         * @name get
         * @memberOf MapCache
         * @param {string} key The key of the value to get.
         * @returns {*} Returns the entry value.
         */

        function mapCacheGet(key) {
          return getMapData(this, key).get(key);
        }

        module.exports = mapCacheGet;

        /***/
      },
      /* 119 */
      /***/ function (module, exports, __webpack_require__) {
        var getMapData = __webpack_require__(29);
        /**
         * Checks if a map value for `key` exists.
         *
         * @private
         * @name has
         * @memberOf MapCache
         * @param {string} key The key of the entry to check.
         * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
         */

        function mapCacheHas(key) {
          return getMapData(this, key).has(key);
        }

        module.exports = mapCacheHas;

        /***/
      },
      /* 120 */
      /***/ function (module, exports, __webpack_require__) {
        var getMapData = __webpack_require__(29);
        /**
         * Sets the map `key` to `value`.
         *
         * @private
         * @name set
         * @memberOf MapCache
         * @param {string} key The key of the value to set.
         * @param {*} value The value to set.
         * @returns {Object} Returns the map cache instance.
         */

        function mapCacheSet(key, value) {
          var data = getMapData(this, key),
            size = data.size;
          data.set(key, value);
          this.size += data.size == size ? 0 : 1;
          return this;
        }

        module.exports = mapCacheSet;

        /***/
      },
      /* 121 */
      /***/ function (module, exports, __webpack_require__) {
        var createBaseFor = __webpack_require__(122);
        /**
         * The base implementation of `baseForOwn` which iterates over `object`
         * properties returned by `keysFunc` and invokes `iteratee` for each property.
         * Iteratee functions may exit iteration early by explicitly returning `false`.
         *
         * @private
         * @param {Object} object The object to iterate over.
         * @param {Function} iteratee The function invoked per iteration.
         * @param {Function} keysFunc The function to get the keys of `object`.
         * @returns {Object} Returns `object`.
         */

        var baseFor = createBaseFor();
        module.exports = baseFor;

        /***/
      },
      /* 122 */
      /***/ function (module, exports) {
        /**
         * Creates a base function for methods like `_.forIn` and `_.forOwn`.
         *
         * @private
         * @param {boolean} [fromRight] Specify iterating from right to left.
         * @returns {Function} Returns the new base function.
         */
        function createBaseFor(fromRight) {
          return function (object, iteratee, keysFunc) {
            var index = -1,
              iterable = Object(object),
              props = keysFunc(object),
              length = props.length;

            while (length--) {
              var key = props[fromRight ? length : ++index];

              if (iteratee(iterable[key], key, iterable) === false) {
                break;
              }
            }

            return object;
          };
        }

        module.exports = createBaseFor;

        /***/
      },
      /* 123 */
      /***/ function (module, exports, __webpack_require__) {
        var assignMergeValue = __webpack_require__(48),
          cloneBuffer = __webpack_require__(124),
          cloneTypedArray = __webpack_require__(125),
          copyArray = __webpack_require__(128),
          initCloneObject = __webpack_require__(129),
          isArguments = __webpack_require__(30),
          isArray = __webpack_require__(16),
          isArrayLikeObject = __webpack_require__(133),
          isBuffer = __webpack_require__(52),
          isFunction = __webpack_require__(36),
          isObject = __webpack_require__(15),
          isPlainObject = __webpack_require__(135),
          isTypedArray = __webpack_require__(53),
          safeGet = __webpack_require__(54),
          toPlainObject = __webpack_require__(139);
        /**
         * A specialized version of `baseMerge` for arrays and objects which performs
         * deep merges and tracks traversed objects enabling objects with circular
         * references to be merged.
         *
         * @private
         * @param {Object} object The destination object.
         * @param {Object} source The source object.
         * @param {string} key The key of the value to merge.
         * @param {number} srcIndex The index of `source`.
         * @param {Function} mergeFunc The function to merge values.
         * @param {Function} [customizer] The function to customize assigned values.
         * @param {Object} [stack] Tracks traversed source values and their merged
         *  counterparts.
         */

        function baseMergeDeep(
          object,
          source,
          key,
          srcIndex,
          mergeFunc,
          customizer,
          stack
        ) {
          var objValue = safeGet(object, key),
            srcValue = safeGet(source, key),
            stacked = stack.get(srcValue);

          if (stacked) {
            assignMergeValue(object, key, stacked);
            return;
          }

          var newValue = customizer
            ? customizer(objValue, srcValue, key + "", object, source, stack)
            : undefined;
          var isCommon = newValue === undefined;

          if (isCommon) {
            var isArr = isArray(srcValue),
              isBuff = !isArr && isBuffer(srcValue),
              isTyped = !isArr && !isBuff && isTypedArray(srcValue);
            newValue = srcValue;

            if (isArr || isBuff || isTyped) {
              if (isArray(objValue)) {
                newValue = objValue;
              } else if (isArrayLikeObject(objValue)) {
                newValue = copyArray(objValue);
              } else if (isBuff) {
                isCommon = false;
                newValue = cloneBuffer(srcValue, true);
              } else if (isTyped) {
                isCommon = false;
                newValue = cloneTypedArray(srcValue, true);
              } else {
                newValue = [];
              }
            } else if (isPlainObject(srcValue) || isArguments(srcValue)) {
              newValue = objValue;

              if (isArguments(objValue)) {
                newValue = toPlainObject(objValue);
              } else if (!isObject(objValue) || isFunction(objValue)) {
                newValue = initCloneObject(srcValue);
              }
            } else {
              isCommon = false;
            }
          }

          if (isCommon) {
            // Recursively merge objects and arrays (susceptible to call stack limits).
            stack.set(srcValue, newValue);
            mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
            stack["delete"](srcValue);
          }

          assignMergeValue(object, key, newValue);
        }

        module.exports = baseMergeDeep;

        /***/
      },
      /* 124 */
      /***/ function (module, exports, __webpack_require__) {
        /* WEBPACK VAR INJECTION */ (function (module) {
          var root = __webpack_require__(19);
          /** Detect free variable `exports`. */

          var freeExports = true && exports && !exports.nodeType && exports;
          /** Detect free variable `module`. */

          var freeModule =
            freeExports &&
            typeof module == "object" &&
            module &&
            !module.nodeType &&
            module;
          /** Detect the popular CommonJS extension `module.exports`. */

          var moduleExports = freeModule && freeModule.exports === freeExports;
          /** Built-in value references. */

          var Buffer = moduleExports ? root.Buffer : undefined,
            allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined;
          /**
           * Creates a clone of  `buffer`.
           *
           * @private
           * @param {Buffer} buffer The buffer to clone.
           * @param {boolean} [isDeep] Specify a deep clone.
           * @returns {Buffer} Returns the cloned buffer.
           */

          function cloneBuffer(buffer, isDeep) {
            if (isDeep) {
              return buffer.slice();
            }

            var length = buffer.length,
              result = allocUnsafe
                ? allocUnsafe(length)
                : new buffer.constructor(length);
            buffer.copy(result);
            return result;
          }

          module.exports = cloneBuffer;
          /* WEBPACK VAR INJECTION */
        }.call(this, __webpack_require__(38)(module)));

        /***/
      },
      /* 125 */
      /***/ function (module, exports, __webpack_require__) {
        var cloneArrayBuffer = __webpack_require__(126);
        /**
         * Creates a clone of `typedArray`.
         *
         * @private
         * @param {Object} typedArray The typed array to clone.
         * @param {boolean} [isDeep] Specify a deep clone.
         * @returns {Object} Returns the cloned typed array.
         */

        function cloneTypedArray(typedArray, isDeep) {
          var buffer = isDeep
            ? cloneArrayBuffer(typedArray.buffer)
            : typedArray.buffer;
          return new typedArray.constructor(
            buffer,
            typedArray.byteOffset,
            typedArray.length
          );
        }

        module.exports = cloneTypedArray;

        /***/
      },
      /* 126 */
      /***/ function (module, exports, __webpack_require__) {
        var Uint8Array = __webpack_require__(127);
        /**
         * Creates a clone of `arrayBuffer`.
         *
         * @private
         * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
         * @returns {ArrayBuffer} Returns the cloned array buffer.
         */

        function cloneArrayBuffer(arrayBuffer) {
          var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
          new Uint8Array(result).set(new Uint8Array(arrayBuffer));
          return result;
        }

        module.exports = cloneArrayBuffer;

        /***/
      },
      /* 127 */
      /***/ function (module, exports, __webpack_require__) {
        var root = __webpack_require__(19);
        /** Built-in value references. */

        var Uint8Array = root.Uint8Array;
        module.exports = Uint8Array;

        /***/
      },
      /* 128 */
      /***/ function (module, exports) {
        /**
         * Copies the values of `source` to `array`.
         *
         * @private
         * @param {Array} source The array to copy values from.
         * @param {Array} [array=[]] The array to copy values to.
         * @returns {Array} Returns `array`.
         */
        function copyArray(source, array) {
          var index = -1,
            length = source.length;
          array || (array = Array(length));

          while (++index < length) {
            array[index] = source[index];
          }

          return array;
        }

        module.exports = copyArray;

        /***/
      },
      /* 129 */
      /***/ function (module, exports, __webpack_require__) {
        var baseCreate = __webpack_require__(130),
          getPrototype = __webpack_require__(50),
          isPrototype = __webpack_require__(51);
        /**
         * Initializes an object clone.
         *
         * @private
         * @param {Object} object The object to clone.
         * @returns {Object} Returns the initialized clone.
         */

        function initCloneObject(object) {
          return typeof object.constructor == "function" && !isPrototype(object)
            ? baseCreate(getPrototype(object))
            : {};
        }

        module.exports = initCloneObject;

        /***/
      },
      /* 130 */
      /***/ function (module, exports, __webpack_require__) {
        var isObject = __webpack_require__(15);
        /** Built-in value references. */

        var objectCreate = Object.create;
        /**
         * The base implementation of `_.create` without support for assigning
         * properties to the created object.
         *
         * @private
         * @param {Object} proto The object to inherit from.
         * @returns {Object} Returns the new object.
         */

        var baseCreate = (function () {
          function object() {}

          return function (proto) {
            if (!isObject(proto)) {
              return {};
            }

            if (objectCreate) {
              return objectCreate(proto);
            }

            object.prototype = proto;
            var result = new object();
            object.prototype = undefined;
            return result;
          };
        })();

        module.exports = baseCreate;

        /***/
      },
      /* 131 */
      /***/ function (module, exports) {
        /**
         * Creates a unary function that invokes `func` with its argument transformed.
         *
         * @private
         * @param {Function} func The function to wrap.
         * @param {Function} transform The argument transform.
         * @returns {Function} Returns the new function.
         */
        function overArg(func, transform) {
          return function (arg) {
            return func(transform(arg));
          };
        }

        module.exports = overArg;

        /***/
      },
      /* 132 */
      /***/ function (module, exports, __webpack_require__) {
        var baseGetTag = __webpack_require__(22),
          isObjectLike = __webpack_require__(20);
        /** `Object#toString` result references. */

        var argsTag = "[object Arguments]";
        /**
         * The base implementation of `_.isArguments`.
         *
         * @private
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is an `arguments` object,
         */

        function baseIsArguments(value) {
          return isObjectLike(value) && baseGetTag(value) == argsTag;
        }

        module.exports = baseIsArguments;

        /***/
      },
      /* 133 */
      /***/ function (module, exports, __webpack_require__) {
        var isArrayLike = __webpack_require__(39),
          isObjectLike = __webpack_require__(20);
        /**
         * This method is like `_.isArrayLike` except that it also checks if `value`
         * is an object.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is an array-like object,
         *  else `false`.
         * @example
         *
         * _.isArrayLikeObject([1, 2, 3]);
         * // => true
         *
         * _.isArrayLikeObject(document.body.children);
         * // => true
         *
         * _.isArrayLikeObject('abc');
         * // => false
         *
         * _.isArrayLikeObject(_.noop);
         * // => false
         */

        function isArrayLikeObject(value) {
          return isObjectLike(value) && isArrayLike(value);
        }

        module.exports = isArrayLikeObject;

        /***/
      },
      /* 134 */
      /***/ function (module, exports) {
        /**
         * This method returns `false`.
         *
         * @static
         * @memberOf _
         * @since 4.13.0
         * @category Util
         * @returns {boolean} Returns `false`.
         * @example
         *
         * _.times(2, _.stubFalse);
         * // => [false, false]
         */
        function stubFalse() {
          return false;
        }

        module.exports = stubFalse;

        /***/
      },
      /* 135 */
      /***/ function (module, exports, __webpack_require__) {
        var baseGetTag = __webpack_require__(22),
          getPrototype = __webpack_require__(50),
          isObjectLike = __webpack_require__(20);
        /** `Object#toString` result references. */

        var objectTag = "[object Object]";
        /** Used for built-in method references. */

        var funcProto = Function.prototype,
          objectProto = Object.prototype;
        /** Used to resolve the decompiled source of functions. */

        var funcToString = funcProto.toString;
        /** Used to check objects for own properties. */

        var hasOwnProperty = objectProto.hasOwnProperty;
        /** Used to infer the `Object` constructor. */

        var objectCtorString = funcToString.call(Object);
        /**
         * Checks if `value` is a plain object, that is, an object created by the
         * `Object` constructor or one with a `[[Prototype]]` of `null`.
         *
         * @static
         * @memberOf _
         * @since 0.8.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
         * @example
         *
         * function Foo() {
         *   this.a = 1;
         * }
         *
         * _.isPlainObject(new Foo);
         * // => false
         *
         * _.isPlainObject([1, 2, 3]);
         * // => false
         *
         * _.isPlainObject({ 'x': 0, 'y': 0 });
         * // => true
         *
         * _.isPlainObject(Object.create(null));
         * // => true
         */

        function isPlainObject(value) {
          if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
            return false;
          }

          var proto = getPrototype(value);

          if (proto === null) {
            return true;
          }

          var Ctor =
            hasOwnProperty.call(proto, "constructor") && proto.constructor;
          return (
            typeof Ctor == "function" &&
            Ctor instanceof Ctor &&
            funcToString.call(Ctor) == objectCtorString
          );
        }

        module.exports = isPlainObject;

        /***/
      },
      /* 136 */
      /***/ function (module, exports, __webpack_require__) {
        var baseGetTag = __webpack_require__(22),
          isLength = __webpack_require__(40),
          isObjectLike = __webpack_require__(20);
        /** `Object#toString` result references. */

        var argsTag = "[object Arguments]",
          arrayTag = "[object Array]",
          boolTag = "[object Boolean]",
          dateTag = "[object Date]",
          errorTag = "[object Error]",
          funcTag = "[object Function]",
          mapTag = "[object Map]",
          numberTag = "[object Number]",
          objectTag = "[object Object]",
          regexpTag = "[object RegExp]",
          setTag = "[object Set]",
          stringTag = "[object String]",
          weakMapTag = "[object WeakMap]";
        var arrayBufferTag = "[object ArrayBuffer]",
          dataViewTag = "[object DataView]",
          float32Tag = "[object Float32Array]",
          float64Tag = "[object Float64Array]",
          int8Tag = "[object Int8Array]",
          int16Tag = "[object Int16Array]",
          int32Tag = "[object Int32Array]",
          uint8Tag = "[object Uint8Array]",
          uint8ClampedTag = "[object Uint8ClampedArray]",
          uint16Tag = "[object Uint16Array]",
          uint32Tag = "[object Uint32Array]";
        /** Used to identify `toStringTag` values of typed arrays. */

        var typedArrayTags = {};
        typedArrayTags[float32Tag] =
          typedArrayTags[float64Tag] =
          typedArrayTags[int8Tag] =
          typedArrayTags[int16Tag] =
          typedArrayTags[int32Tag] =
          typedArrayTags[uint8Tag] =
          typedArrayTags[uint8ClampedTag] =
          typedArrayTags[uint16Tag] =
          typedArrayTags[uint32Tag] =
            true;
        typedArrayTags[argsTag] =
          typedArrayTags[arrayTag] =
          typedArrayTags[arrayBufferTag] =
          typedArrayTags[boolTag] =
          typedArrayTags[dataViewTag] =
          typedArrayTags[dateTag] =
          typedArrayTags[errorTag] =
          typedArrayTags[funcTag] =
          typedArrayTags[mapTag] =
          typedArrayTags[numberTag] =
          typedArrayTags[objectTag] =
          typedArrayTags[regexpTag] =
          typedArrayTags[setTag] =
          typedArrayTags[stringTag] =
          typedArrayTags[weakMapTag] =
            false;
        /**
         * The base implementation of `_.isTypedArray` without Node.js optimizations.
         *
         * @private
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
         */

        function baseIsTypedArray(value) {
          return (
            isObjectLike(value) &&
            isLength(value.length) &&
            !!typedArrayTags[baseGetTag(value)]
          );
        }

        module.exports = baseIsTypedArray;

        /***/
      },
      /* 137 */
      /***/ function (module, exports) {
        /**
         * The base implementation of `_.unary` without support for storing metadata.
         *
         * @private
         * @param {Function} func The function to cap arguments for.
         * @returns {Function} Returns the new capped function.
         */
        function baseUnary(func) {
          return function (value) {
            return func(value);
          };
        }

        module.exports = baseUnary;

        /***/
      },
      /* 138 */
      /***/ function (module, exports, __webpack_require__) {
        /* WEBPACK VAR INJECTION */ (function (module) {
          var freeGlobal = __webpack_require__(45);
          /** Detect free variable `exports`. */

          var freeExports = true && exports && !exports.nodeType && exports;
          /** Detect free variable `module`. */

          var freeModule =
            freeExports &&
            typeof module == "object" &&
            module &&
            !module.nodeType &&
            module;
          /** Detect the popular CommonJS extension `module.exports`. */

          var moduleExports = freeModule && freeModule.exports === freeExports;
          /** Detect free variable `process` from Node.js. */

          var freeProcess = moduleExports && freeGlobal.process;
          /** Used to access faster Node.js helpers. */

          var nodeUtil = (function () {
            try {
              // Use `util.types` for Node.js 10+.
              var types =
                freeModule &&
                freeModule.require &&
                freeModule.require("util").types;

              if (types) {
                return types;
              } // Legacy `process.binding('util')` for Node.js < 10.

              return (
                freeProcess &&
                freeProcess.binding &&
                freeProcess.binding("util")
              );
            } catch (e) {}
          })();

          module.exports = nodeUtil;
          /* WEBPACK VAR INJECTION */
        }.call(this, __webpack_require__(38)(module)));

        /***/
      },
      /* 139 */
      /***/ function (module, exports, __webpack_require__) {
        var copyObject = __webpack_require__(140),
          keysIn = __webpack_require__(56);
        /**
         * Converts `value` to a plain object flattening inherited enumerable string
         * keyed properties of `value` to own properties of the plain object.
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category Lang
         * @param {*} value The value to convert.
         * @returns {Object} Returns the converted plain object.
         * @example
         *
         * function Foo() {
         *   this.b = 2;
         * }
         *
         * Foo.prototype.c = 3;
         *
         * _.assign({ 'a': 1 }, new Foo);
         * // => { 'a': 1, 'b': 2 }
         *
         * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
         * // => { 'a': 1, 'b': 2, 'c': 3 }
         */

        function toPlainObject(value) {
          return copyObject(value, keysIn(value));
        }

        module.exports = toPlainObject;

        /***/
      },
      /* 140 */
      /***/ function (module, exports, __webpack_require__) {
        var assignValue = __webpack_require__(55),
          baseAssignValue = __webpack_require__(37);
        /**
         * Copies properties of `source` to `object`.
         *
         * @private
         * @param {Object} source The object to copy properties from.
         * @param {Array} props The property identifiers to copy.
         * @param {Object} [object={}] The object to copy properties to.
         * @param {Function} [customizer] The function to customize copied values.
         * @returns {Object} Returns `object`.
         */

        function copyObject(source, props, object, customizer) {
          var isNew = !object;
          object || (object = {});
          var index = -1,
            length = props.length;

          while (++index < length) {
            var key = props[index];
            var newValue = customizer
              ? customizer(object[key], source[key], key, object, source)
              : undefined;

            if (newValue === undefined) {
              newValue = source[key];
            }

            if (isNew) {
              baseAssignValue(object, key, newValue);
            } else {
              assignValue(object, key, newValue);
            }
          }

          return object;
        }

        module.exports = copyObject;

        /***/
      },
      /* 141 */
      /***/ function (module, exports, __webpack_require__) {
        var baseTimes = __webpack_require__(142),
          isArguments = __webpack_require__(30),
          isArray = __webpack_require__(16),
          isBuffer = __webpack_require__(52),
          isIndex = __webpack_require__(31),
          isTypedArray = __webpack_require__(53);
        /** Used for built-in method references. */

        var objectProto = Object.prototype;
        /** Used to check objects for own properties. */

        var hasOwnProperty = objectProto.hasOwnProperty;
        /**
         * Creates an array of the enumerable property names of the array-like `value`.
         *
         * @private
         * @param {*} value The value to query.
         * @param {boolean} inherited Specify returning inherited property names.
         * @returns {Array} Returns the array of property names.
         */

        function arrayLikeKeys(value, inherited) {
          var isArr = isArray(value),
            isArg = !isArr && isArguments(value),
            isBuff = !isArr && !isArg && isBuffer(value),
            isType = !isArr && !isArg && !isBuff && isTypedArray(value),
            skipIndexes = isArr || isArg || isBuff || isType,
            result = skipIndexes ? baseTimes(value.length, String) : [],
            length = result.length;

          for (var key in value) {
            if (
              (inherited || hasOwnProperty.call(value, key)) &&
              !(
                skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
                (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
                  (isBuff && (key == "offset" || key == "parent")) || // PhantomJS 2 has enumerable non-index properties on typed arrays.
                  (isType &&
                    (key == "buffer" ||
                      key == "byteLength" ||
                      key == "byteOffset")) || // Skip index properties.
                  isIndex(key, length))
              )
            ) {
              result.push(key);
            }
          }

          return result;
        }

        module.exports = arrayLikeKeys;

        /***/
      },
      /* 142 */
      /***/ function (module, exports) {
        /**
         * The base implementation of `_.times` without support for iteratee shorthands
         * or max array length checks.
         *
         * @private
         * @param {number} n The number of times to invoke `iteratee`.
         * @param {Function} iteratee The function invoked per iteration.
         * @returns {Array} Returns the array of results.
         */
        function baseTimes(n, iteratee) {
          var index = -1,
            result = Array(n);

          while (++index < n) {
            result[index] = iteratee(index);
          }

          return result;
        }

        module.exports = baseTimes;

        /***/
      },
      /* 143 */
      /***/ function (module, exports, __webpack_require__) {
        var isObject = __webpack_require__(15),
          isPrototype = __webpack_require__(51),
          nativeKeysIn = __webpack_require__(144);
        /** Used for built-in method references. */

        var objectProto = Object.prototype;
        /** Used to check objects for own properties. */

        var hasOwnProperty = objectProto.hasOwnProperty;
        /**
         * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
         *
         * @private
         * @param {Object} object The object to query.
         * @returns {Array} Returns the array of property names.
         */

        function baseKeysIn(object) {
          if (!isObject(object)) {
            return nativeKeysIn(object);
          }

          var isProto = isPrototype(object),
            result = [];

          for (var key in object) {
            if (
              !(
                key == "constructor" &&
                (isProto || !hasOwnProperty.call(object, key))
              )
            ) {
              result.push(key);
            }
          }

          return result;
        }

        module.exports = baseKeysIn;

        /***/
      },
      /* 144 */
      /***/ function (module, exports) {
        /**
         * This function is like
         * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
         * except that it includes inherited enumerable properties.
         *
         * @private
         * @param {Object} object The object to query.
         * @returns {Array} Returns the array of property names.
         */
        function nativeKeysIn(object) {
          var result = [];

          if (object != null) {
            for (var key in Object(object)) {
              result.push(key);
            }
          }

          return result;
        }

        module.exports = nativeKeysIn;

        /***/
      },
      /* 145 */
      /***/ function (module, exports, __webpack_require__) {
        var baseRest = __webpack_require__(146),
          isIterateeCall = __webpack_require__(151);
        /**
         * Creates a function like `_.assign`.
         *
         * @private
         * @param {Function} assigner The function to assign values.
         * @returns {Function} Returns the new assigner function.
         */

        function createAssigner(assigner) {
          return baseRest(function (object, sources) {
            var index = -1,
              length = sources.length,
              customizer = length > 1 ? sources[length - 1] : undefined,
              guard = length > 2 ? sources[2] : undefined;
            customizer =
              assigner.length > 3 && typeof customizer == "function"
                ? (length--, customizer)
                : undefined;

            if (guard && isIterateeCall(sources[0], sources[1], guard)) {
              customizer = length < 3 ? undefined : customizer;
              length = 1;
            }

            object = Object(object);

            while (++index < length) {
              var source = sources[index];

              if (source) {
                assigner(object, source, index, customizer);
              }
            }

            return object;
          });
        }

        module.exports = createAssigner;

        /***/
      },
      /* 146 */
      /***/ function (module, exports, __webpack_require__) {
        var identity = __webpack_require__(57),
          overRest = __webpack_require__(58),
          setToString = __webpack_require__(59);
        /**
         * The base implementation of `_.rest` which doesn't validate or coerce arguments.
         *
         * @private
         * @param {Function} func The function to apply a rest parameter to.
         * @param {number} [start=func.length-1] The start position of the rest parameter.
         * @returns {Function} Returns the new function.
         */

        function baseRest(func, start) {
          return setToString(overRest(func, start, identity), func + "");
        }

        module.exports = baseRest;

        /***/
      },
      /* 147 */
      /***/ function (module, exports) {
        /**
         * A faster alternative to `Function#apply`, this function invokes `func`
         * with the `this` binding of `thisArg` and the arguments of `args`.
         *
         * @private
         * @param {Function} func The function to invoke.
         * @param {*} thisArg The `this` binding of `func`.
         * @param {Array} args The arguments to invoke `func` with.
         * @returns {*} Returns the result of `func`.
         */
        function apply(func, thisArg, args) {
          switch (args.length) {
            case 0:
              return func.call(thisArg);

            case 1:
              return func.call(thisArg, args[0]);

            case 2:
              return func.call(thisArg, args[0], args[1]);

            case 3:
              return func.call(thisArg, args[0], args[1], args[2]);
          }

          return func.apply(thisArg, args);
        }

        module.exports = apply;

        /***/
      },
      /* 148 */
      /***/ function (module, exports, __webpack_require__) {
        var constant = __webpack_require__(149),
          defineProperty = __webpack_require__(49),
          identity = __webpack_require__(57);
        /**
         * The base implementation of `setToString` without support for hot loop shorting.
         *
         * @private
         * @param {Function} func The function to modify.
         * @param {Function} string The `toString` result.
         * @returns {Function} Returns `func`.
         */

        var baseSetToString = !defineProperty
          ? identity
          : function (func, string) {
              return defineProperty(func, "toString", {
                configurable: true,
                enumerable: false,
                value: constant(string),
                writable: true,
              });
            };
        module.exports = baseSetToString;

        /***/
      },
      /* 149 */
      /***/ function (module, exports) {
        /**
         * Creates a function that returns `value`.
         *
         * @static
         * @memberOf _
         * @since 2.4.0
         * @category Util
         * @param {*} value The value to return from the new function.
         * @returns {Function} Returns the new constant function.
         * @example
         *
         * var objects = _.times(2, _.constant({ 'a': 1 }));
         *
         * console.log(objects);
         * // => [{ 'a': 1 }, { 'a': 1 }]
         *
         * console.log(objects[0] === objects[1]);
         * // => true
         */
        function constant(value) {
          return function () {
            return value;
          };
        }

        module.exports = constant;

        /***/
      },
      /* 150 */
      /***/ function (module, exports) {
        /** Used to detect hot functions by number of calls within a span of milliseconds. */
        var HOT_COUNT = 800,
          HOT_SPAN = 16;
        /* Built-in method references for those with the same name as other `lodash` methods. */

        var nativeNow = Date.now;
        /**
         * Creates a function that'll short out and invoke `identity` instead
         * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
         * milliseconds.
         *
         * @private
         * @param {Function} func The function to restrict.
         * @returns {Function} Returns the new shortable function.
         */

        function shortOut(func) {
          var count = 0,
            lastCalled = 0;
          return function () {
            var stamp = nativeNow(),
              remaining = HOT_SPAN - (stamp - lastCalled);
            lastCalled = stamp;

            if (remaining > 0) {
              if (++count >= HOT_COUNT) {
                return arguments[0];
              }
            } else {
              count = 0;
            }

            return func.apply(undefined, arguments);
          };
        }

        module.exports = shortOut;

        /***/
      },
      /* 151 */
      /***/ function (module, exports, __webpack_require__) {
        var eq = __webpack_require__(26),
          isArrayLike = __webpack_require__(39),
          isIndex = __webpack_require__(31),
          isObject = __webpack_require__(15);
        /**
         * Checks if the given arguments are from an iteratee call.
         *
         * @private
         * @param {*} value The potential iteratee value argument.
         * @param {*} index The potential iteratee index or key argument.
         * @param {*} object The potential iteratee object argument.
         * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
         *  else `false`.
         */

        function isIterateeCall(value, index, object) {
          if (!isObject(object)) {
            return false;
          }

          var type = typeof index;

          if (
            type == "number"
              ? isArrayLike(object) && isIndex(index, object.length)
              : type == "string" && index in object
          ) {
            return eq(object[index], value);
          }

          return false;
        }

        module.exports = isIterateeCall;

        /***/
      },
      /* 152 */
      /***/ function (module, exports) {
        /*
         * typedefs.js
         * Normalizes browser-specific prefixes and provide some basic polyfills
         */
        if (typeof window !== "undefined") {
          if (!window.requestAnimationFrame) {
            window.requestAnimationFrame = (function () {
              return (
                window.webkitRequestAnimationFrame ||
                window.mozRequestAnimationFrame ||
                window.oRequestAnimationFrame ||
                window.msRequestAnimationFrame ||
                function (
                  /* function FrameRequestCallback */
                  callback
                ) {
                  window.setTimeout(callback, 1000 / 60);
                }
              );
            })();
          }
        }

        if (typeof Math.imul !== "function") {
          /* eslint-disable no-bitwise */
          Math.imul = function (a, b) {
            var ah = (a >>> 16) & 0xffff;
            var al = a & 0xffff;
            var bh = (b >>> 16) & 0xffff;
            var bl = b & 0xffff; // the shift by 0 fixes the sign on the high part
            // the final |0 converts the unsigned value into a signed value

            return (al * bl + (((ah * bl + al * bh) << 16) >>> 0)) | 0;
          };
          /* eslint-enable no-bitwise */
        }

        if (typeof Object.assign !== "function") {
          Object.assign = function (target) {
            // .length of function is 2
            "use strict";

            if (target === null) {
              // TypeError if undefined or null
              throw new TypeError("Cannot convert undefined or null to object");
            }

            var to = Object(target);

            for (var index = 1; index < arguments.length; index++) {
              // eslint-disable-next-line prefer-rest-params
              var nextSource = arguments[index];

              if (nextSource !== null) {
                // Skip over if undefined or null
                // eslint-disable-next-line no-restricted-syntax
                for (var nextKey in nextSource) {
                  // Avoid bugs when hasOwnProperty is shadowed
                  if (
                    Object.prototype.hasOwnProperty.call(nextSource, nextKey)
                  ) {
                    to[nextKey] = nextSource[nextKey];
                  }
                }
              }
            }

            return to;
          };
        }

        /***/
      },
      /* 153 */
      /***/ function (module, exports) {
        function _arrayWithHoles(arr) {
          if (Array.isArray(arr)) return arr;
        }

        (module.exports = _arrayWithHoles),
          (module.exports.__esModule = true),
          (module.exports["default"] = module.exports);

        /***/
      },
      /* 154 */
      /***/ function (module, exports) {
        function _iterableToArrayLimit(arr, i) {
          var _i =
            arr == null
              ? null
              : (typeof Symbol !== "undefined" && arr[Symbol.iterator]) ||
                arr["@@iterator"];

          if (_i == null) return;
          var _arr = [];
          var _n = true;
          var _d = false;

          var _s, _e;

          try {
            for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
              _arr.push(_s.value);

              if (i && _arr.length === i) break;
            }
          } catch (err) {
            _d = true;
            _e = err;
          } finally {
            try {
              if (!_n && _i["return"] != null) _i["return"]();
            } finally {
              if (_d) throw _e;
            }
          }

          return _arr;
        }

        (module.exports = _iterableToArrayLimit),
          (module.exports.__esModule = true),
          (module.exports["default"] = module.exports);

        /***/
      },
      /* 155 */
      /***/ function (module, exports) {
        function _nonIterableRest() {
          throw new TypeError(
            "Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."
          );
        }

        (module.exports = _nonIterableRest),
          (module.exports.__esModule = true),
          (module.exports["default"] = module.exports);

        /***/
      },
      /* 156 */
      /***/ function (module, exports) {
        module.exports = clone;
        /**
         * Creates a new vec2 initialized with values from an existing vector
         *
         * @param {vec2} a vector to clone
         * @returns {vec2} a new 2D vector
         */

        function clone(a) {
          var out = new Float32Array(2);
          out[0] = a[0];
          out[1] = a[1];
          return out;
        }

        /***/
      },
      /* 157 */
      /***/ function (module, exports) {
        module.exports = fromValues;
        /**
         * Creates a new vec2 initialized with the given values
         *
         * @param {Number} x X component
         * @param {Number} y Y component
         * @returns {vec2} a new 2D vector
         */

        function fromValues(x, y) {
          var out = new Float32Array(2);
          out[0] = x;
          out[1] = y;
          return out;
        }

        /***/
      },
      /* 158 */
      /***/ function (module, exports) {
        module.exports = copy;
        /**
         * Copy the values from one vec2 to another
         *
         * @param {vec2} out the receiving vector
         * @param {vec2} a the source vector
         * @returns {vec2} out
         */

        function copy(out, a) {
          out[0] = a[0];
          out[1] = a[1];
          return out;
        }

        /***/
      },
      /* 159 */
      /***/ function (module, exports) {
        module.exports = set;
        /**
         * Set the components of a vec2 to the given values
         *
         * @param {vec2} out the receiving vector
         * @param {Number} x X component
         * @param {Number} y Y component
         * @returns {vec2} out
         */

        function set(out, x, y) {
          out[0] = x;
          out[1] = y;
          return out;
        }

        /***/
      },
      /* 160 */
      /***/ function (module, exports, __webpack_require__) {
        module.exports = equals;

        var EPSILON = __webpack_require__(62);
        /**
         * Returns whether or not the vectors have approximately the same elements in the same position.
         *
         * @param {vec2} a The first vector.
         * @param {vec2} b The second vector.
         * @returns {Boolean} True if the vectors are equal, false otherwise.
         */

        function equals(a, b) {
          var a0 = a[0];
          var a1 = a[1];
          var b0 = b[0];
          var b1 = b[1];
          return (
            Math.abs(a0 - b0) <=
              EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) &&
            Math.abs(a1 - b1) <=
              EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1))
          );
        }

        /***/
      },
      /* 161 */
      /***/ function (module, exports) {
        module.exports = exactEquals;
        /**
         * Returns whether or not the vectors exactly have the same elements in the same position (when compared with ===)
         *
         * @param {vec2} a The first vector.
         * @param {vec2} b The second vector.
         * @returns {Boolean} True if the vectors are equal, false otherwise.
         */

        function exactEquals(a, b) {
          return a[0] === b[0] && a[1] === b[1];
        }

        /***/
      },
      /* 162 */
      /***/ function (module, exports) {
        module.exports = add;
        /**
         * Adds two vec2's
         *
         * @param {vec2} out the receiving vector
         * @param {vec2} a the first operand
         * @param {vec2} b the second operand
         * @returns {vec2} out
         */

        function add(out, a, b) {
          out[0] = a[0] + b[0];
          out[1] = a[1] + b[1];
          return out;
        }

        /***/
      },
      /* 163 */
      /***/ function (module, exports, __webpack_require__) {
        module.exports = __webpack_require__(64);

        /***/
      },
      /* 164 */
      /***/ function (module, exports, __webpack_require__) {
        module.exports = __webpack_require__(65);

        /***/
      },
      /* 165 */
      /***/ function (module, exports, __webpack_require__) {
        module.exports = __webpack_require__(66);

        /***/
      },
      /* 166 */
      /***/ function (module, exports) {
        module.exports = inverse;
        /**
         * Returns the inverse of the components of a vec2
         *
         * @param {vec2} out the receiving vector
         * @param {vec2} a vector to invert
         * @returns {vec2} out
         */

        function inverse(out, a) {
          out[0] = 1.0 / a[0];
          out[1] = 1.0 / a[1];
          return out;
        }

        /***/
      },
      /* 167 */
      /***/ function (module, exports) {
        module.exports = min;
        /**
         * Returns the minimum of two vec2's
         *
         * @param {vec2} out the receiving vector
         * @param {vec2} a the first operand
         * @param {vec2} b the second operand
         * @returns {vec2} out
         */

        function min(out, a, b) {
          out[0] = Math.min(a[0], b[0]);
          out[1] = Math.min(a[1], b[1]);
          return out;
        }

        /***/
      },
      /* 168 */
      /***/ function (module, exports) {
        module.exports = max;
        /**
         * Returns the maximum of two vec2's
         *
         * @param {vec2} out the receiving vector
         * @param {vec2} a the first operand
         * @param {vec2} b the second operand
         * @returns {vec2} out
         */

        function max(out, a, b) {
          out[0] = Math.max(a[0], b[0]);
          out[1] = Math.max(a[1], b[1]);
          return out;
        }

        /***/
      },
      /* 169 */
      /***/ function (module, exports) {
        module.exports = rotate;
        /**
         * Rotates a vec2 by an angle
         *
         * @param {vec2} out the receiving vector
         * @param {vec2} a the vector to rotate
         * @param {Number} angle the angle of rotation (in radians)
         * @returns {vec2} out
         */

        function rotate(out, a, angle) {
          var c = Math.cos(angle),
            s = Math.sin(angle);
          var x = a[0],
            y = a[1];
          out[0] = x * c - y * s;
          out[1] = x * s + y * c;
          return out;
        }

        /***/
      },
      /* 170 */
      /***/ function (module, exports) {
        module.exports = floor;
        /**
         * Math.floor the components of a vec2
         *
         * @param {vec2} out the receiving vector
         * @param {vec2} a vector to floor
         * @returns {vec2} out
         */

        function floor(out, a) {
          out[0] = Math.floor(a[0]);
          out[1] = Math.floor(a[1]);
          return out;
        }

        /***/
      },
      /* 171 */
      /***/ function (module, exports) {
        module.exports = ceil;
        /**
         * Math.ceil the components of a vec2
         *
         * @param {vec2} out the receiving vector
         * @param {vec2} a vector to ceil
         * @returns {vec2} out
         */

        function ceil(out, a) {
          out[0] = Math.ceil(a[0]);
          out[1] = Math.ceil(a[1]);
          return out;
        }

        /***/
      },
      /* 172 */
      /***/ function (module, exports) {
        module.exports = round;
        /**
         * Math.round the components of a vec2
         *
         * @param {vec2} out the receiving vector
         * @param {vec2} a vector to round
         * @returns {vec2} out
         */

        function round(out, a) {
          out[0] = Math.round(a[0]);
          out[1] = Math.round(a[1]);
          return out;
        }

        /***/
      },
      /* 173 */
      /***/ function (module, exports) {
        module.exports = scale;
        /**
         * Scales a vec2 by a scalar number
         *
         * @param {vec2} out the receiving vector
         * @param {vec2} a the vector to scale
         * @param {Number} b amount to scale the vector by
         * @returns {vec2} out
         */

        function scale(out, a, b) {
          out[0] = a[0] * b;
          out[1] = a[1] * b;
          return out;
        }

        /***/
      },
      /* 174 */
      /***/ function (module, exports) {
        module.exports = scaleAndAdd;
        /**
         * Adds two vec2's after scaling the second operand by a scalar value
         *
         * @param {vec2} out the receiving vector
         * @param {vec2} a the first operand
         * @param {vec2} b the second operand
         * @param {Number} scale the amount to scale b by before adding
         * @returns {vec2} out
         */

        function scaleAndAdd(out, a, b, scale) {
          out[0] = a[0] + b[0] * scale;
          out[1] = a[1] + b[1] * scale;
          return out;
        }

        /***/
      },
      /* 175 */
      /***/ function (module, exports, __webpack_require__) {
        module.exports = __webpack_require__(67);

        /***/
      },
      /* 176 */
      /***/ function (module, exports, __webpack_require__) {
        module.exports = __webpack_require__(68);

        /***/
      },
      /* 177 */
      /***/ function (module, exports, __webpack_require__) {
        module.exports = __webpack_require__(69);

        /***/
      },
      /* 178 */
      /***/ function (module, exports, __webpack_require__) {
        module.exports = __webpack_require__(70);

        /***/
      },
      /* 179 */
      /***/ function (module, exports) {
        module.exports = negate;
        /**
         * Negates the components of a vec2
         *
         * @param {vec2} out the receiving vector
         * @param {vec2} a vector to negate
         * @returns {vec2} out
         */

        function negate(out, a) {
          out[0] = -a[0];
          out[1] = -a[1];
          return out;
        }

        /***/
      },
      /* 180 */
      /***/ function (module, exports) {
        module.exports = normalize;
        /**
         * Normalize a vec2
         *
         * @param {vec2} out the receiving vector
         * @param {vec2} a vector to normalize
         * @returns {vec2} out
         */

        function normalize(out, a) {
          var x = a[0],
            y = a[1];
          var len = x * x + y * y;

          if (len > 0) {
            //TODO: evaluate use of glm_invsqrt here?
            len = 1 / Math.sqrt(len);
            out[0] = a[0] * len;
            out[1] = a[1] * len;
          }

          return out;
        }

        /***/
      },
      /* 181 */
      /***/ function (module, exports) {
        module.exports = dot;
        /**
         * Calculates the dot product of two vec2's
         *
         * @param {vec2} a the first operand
         * @param {vec2} b the second operand
         * @returns {Number} dot product of a and b
         */

        function dot(a, b) {
          return a[0] * b[0] + a[1] * b[1];
        }

        /***/
      },
      /* 182 */
      /***/ function (module, exports) {
        module.exports = cross;
        /**
         * Computes the cross product of two vec2's
         * Note that the cross product must by definition produce a 3D vector
         *
         * @param {vec3} out the receiving vector
         * @param {vec2} a the first operand
         * @param {vec2} b the second operand
         * @returns {vec3} out
         */

        function cross(out, a, b) {
          var z = a[0] * b[1] - a[1] * b[0];
          out[0] = out[1] = 0;
          out[2] = z;
          return out;
        }

        /***/
      },
      /* 183 */
      /***/ function (module, exports) {
        module.exports = lerp;
        /**
         * Performs a linear interpolation between two vec2's
         *
         * @param {vec2} out the receiving vector
         * @param {vec2} a the first operand
         * @param {vec2} b the second operand
         * @param {Number} t interpolation amount between the two inputs
         * @returns {vec2} out
         */

        function lerp(out, a, b, t) {
          var ax = a[0],
            ay = a[1];
          out[0] = ax + t * (b[0] - ax);
          out[1] = ay + t * (b[1] - ay);
          return out;
        }

        /***/
      },
      /* 184 */
      /***/ function (module, exports) {
        module.exports = random;
        /**
         * Generates a random vector with the given scale
         *
         * @param {vec2} out the receiving vector
         * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
         * @returns {vec2} out
         */

        function random(out, scale) {
          scale = scale || 1.0;
          var r = Math.random() * 2.0 * Math.PI;
          out[0] = Math.cos(r) * scale;
          out[1] = Math.sin(r) * scale;
          return out;
        }

        /***/
      },
      /* 185 */
      /***/ function (module, exports) {
        module.exports = transformMat2;
        /**
         * Transforms the vec2 with a mat2
         *
         * @param {vec2} out the receiving vector
         * @param {vec2} a the vector to transform
         * @param {mat2} m matrix to transform with
         * @returns {vec2} out
         */

        function transformMat2(out, a, m) {
          var x = a[0],
            y = a[1];
          out[0] = m[0] * x + m[2] * y;
          out[1] = m[1] * x + m[3] * y;
          return out;
        }

        /***/
      },
      /* 186 */
      /***/ function (module, exports) {
        module.exports = transformMat2d;
        /**
         * Transforms the vec2 with a mat2d
         *
         * @param {vec2} out the receiving vector
         * @param {vec2} a the vector to transform
         * @param {mat2d} m matrix to transform with
         * @returns {vec2} out
         */

        function transformMat2d(out, a, m) {
          var x = a[0],
            y = a[1];
          out[0] = m[0] * x + m[2] * y + m[4];
          out[1] = m[1] * x + m[3] * y + m[5];
          return out;
        }

        /***/
      },
      /* 187 */
      /***/ function (module, exports) {
        module.exports = transformMat3;
        /**
         * Transforms the vec2 with a mat3
         * 3rd vector component is implicitly '1'
         *
         * @param {vec2} out the receiving vector
         * @param {vec2} a the vector to transform
         * @param {mat3} m matrix to transform with
         * @returns {vec2} out
         */

        function transformMat3(out, a, m) {
          var x = a[0],
            y = a[1];
          out[0] = m[0] * x + m[3] * y + m[6];
          out[1] = m[1] * x + m[4] * y + m[7];
          return out;
        }

        /***/
      },
      /* 188 */
      /***/ function (module, exports) {
        module.exports = transformMat4;
        /**
         * Transforms the vec2 with a mat4
         * 3rd vector component is implicitly '0'
         * 4th vector component is implicitly '1'
         *
         * @param {vec2} out the receiving vector
         * @param {vec2} a the vector to transform
         * @param {mat4} m matrix to transform with
         * @returns {vec2} out
         */

        function transformMat4(out, a, m) {
          var x = a[0],
            y = a[1];
          out[0] = m[0] * x + m[4] * y + m[12];
          out[1] = m[1] * x + m[5] * y + m[13];
          return out;
        }

        /***/
      },
      /* 189 */
      /***/ function (module, exports, __webpack_require__) {
        module.exports = forEach;

        var vec = __webpack_require__(63)();
        /**
         * Perform some operation over an array of vec2s.
         *
         * @param {Array} a the array of vectors to iterate over
         * @param {Number} stride Number of elements between the start of each vec2. If 0 assumes tightly packed
         * @param {Number} offset Number of elements to skip at the beginning of the array
         * @param {Number} count Number of vec2s to iterate over. If 0 iterates over entire array
         * @param {Function} fn Function to call for each vector in the array
         * @param {Object} [arg] additional argument to pass to fn
         * @returns {Array} a
         * @function
         */

        function forEach(a, stride, offset, count, fn, arg) {
          var i, l;

          if (!stride) {
            stride = 2;
          }

          if (!offset) {
            offset = 0;
          }

          if (count) {
            l = Math.min(count * stride + offset, a.length);
          } else {
            l = a.length;
          }

          for (i = offset; i < l; i += stride) {
            vec[0] = a[i];
            vec[1] = a[i + 1];
            fn(vec, vec, arg);
            a[i] = vec[0];
            a[i + 1] = vec[1];
          }

          return a;
        }

        /***/
      },
      /* 190 */
      /***/ function (module, exports) {
        module.exports = limit;
        /**
         * Limit the magnitude of this vector to the value used for the `max`
         * parameter.
         *
         * @param  {vec2} the vector to limit
         * @param  {Number} max the maximum magnitude for the vector
         * @returns {vec2} out
         */

        function limit(out, a, max) {
          var mSq = a[0] * a[0] + a[1] * a[1];

          if (mSq > max * max) {
            var n = Math.sqrt(mSq);
            out[0] = (a[0] / n) * max;
            out[1] = (a[1] / n) * max;
          } else {
            out[0] = a[0];
            out[1] = a[1];
          }

          return out;
        }

        /***/
      },
      /* 191 */
      /***/ function (module, exports) {
        module.exports = clone;
        /**
         * Creates a new vec3 initialized with values from an existing vector
         *
         * @param {vec3} a vector to clone
         * @returns {vec3} a new 3D vector
         */

        function clone(a) {
          var out = new Float32Array(3);
          out[0] = a[0];
          out[1] = a[1];
          out[2] = a[2];
          return out;
        }

        /***/
      },
      /* 192 */
      /***/ function (module, exports, __webpack_require__) {
        module.exports = angle;

        var fromValues = __webpack_require__(73);

        var normalize = __webpack_require__(74);

        var dot = __webpack_require__(75);
        /**
         * Get the angle between two 3D vectors
         * @param {vec3} a The first operand
         * @param {vec3} b The second operand
         * @returns {Number} The angle in radians
         */

        function angle(a, b) {
          var tempA = fromValues(a[0], a[1], a[2]);
          var tempB = fromValues(b[0], b[1], b[2]);
          normalize(tempA, tempA);
          normalize(tempB, tempB);
          var cosine = dot(tempA, tempB);

          if (cosine > 1.0) {
            return 0;
          } else {
            return Math.acos(cosine);
          }
        }

        /***/
      },
      /* 193 */
      /***/ function (module, exports) {
        module.exports = copy;
        /**
         * Copy the values from one vec3 to another
         *
         * @param {vec3} out the receiving vector
         * @param {vec3} a the source vector
         * @returns {vec3} out
         */

        function copy(out, a) {
          out[0] = a[0];
          out[1] = a[1];
          out[2] = a[2];
          return out;
        }

        /***/
      },
      /* 194 */
      /***/ function (module, exports) {
        module.exports = set;
        /**
         * Set the components of a vec3 to the given values
         *
         * @param {vec3} out the receiving vector
         * @param {Number} x X component
         * @param {Number} y Y component
         * @param {Number} z Z component
         * @returns {vec3} out
         */

        function set(out, x, y, z) {
          out[0] = x;
          out[1] = y;
          out[2] = z;
          return out;
        }

        /***/
      },
      /* 195 */
      /***/ function (module, exports, __webpack_require__) {
        module.exports = equals;

        var EPSILON = __webpack_require__(71);
        /**
         * Returns whether or not the vectors have approximately the same elements in the same position.
         *
         * @param {vec3} a The first vector.
         * @param {vec3} b The second vector.
         * @returns {Boolean} True if the vectors are equal, false otherwise.
         */

        function equals(a, b) {
          var a0 = a[0];
          var a1 = a[1];
          var a2 = a[2];
          var b0 = b[0];
          var b1 = b[1];
          var b2 = b[2];
          return (
            Math.abs(a0 - b0) <=
              EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) &&
            Math.abs(a1 - b1) <=
              EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) &&
            Math.abs(a2 - b2) <=
              EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2))
          );
        }

        /***/
      },
      /* 196 */
      /***/ function (module, exports) {
        module.exports = exactEquals;
        /**
         * Returns whether or not the vectors exactly have the same elements in the same position (when compared with ===)
         *
         * @param {vec3} a The first vector.
         * @param {vec3} b The second vector.
         * @returns {Boolean} True if the vectors are equal, false otherwise.
         */

        function exactEquals(a, b) {
          return a[0] === b[0] && a[1] === b[1] && a[2] === b[2];
        }

        /***/
      },
      /* 197 */
      /***/ function (module, exports) {
        module.exports = add;
        /**
         * Adds two vec3's
         *
         * @param {vec3} out the receiving vector
         * @param {vec3} a the first operand
         * @param {vec3} b the second operand
         * @returns {vec3} out
         */

        function add(out, a, b) {
          out[0] = a[0] + b[0];
          out[1] = a[1] + b[1];
          out[2] = a[2] + b[2];
          return out;
        }

        /***/
      },
      /* 198 */
      /***/ function (module, exports, __webpack_require__) {
        module.exports = __webpack_require__(76);

        /***/
      },
      /* 199 */
      /***/ function (module, exports, __webpack_require__) {
        module.exports = __webpack_require__(77);

        /***/
      },
      /* 200 */
      /***/ function (module, exports, __webpack_require__) {
        module.exports = __webpack_require__(78);

        /***/
      },
      /* 201 */
      /***/ function (module, exports) {
        module.exports = min;
        /**
         * Returns the minimum of two vec3's
         *
         * @param {vec3} out the receiving vector
         * @param {vec3} a the first operand
         * @param {vec3} b the second operand
         * @returns {vec3} out
         */

        function min(out, a, b) {
          out[0] = Math.min(a[0], b[0]);
          out[1] = Math.min(a[1], b[1]);
          out[2] = Math.min(a[2], b[2]);
          return out;
        }

        /***/
      },
      /* 202 */
      /***/ function (module, exports) {
        module.exports = max;
        /**
         * Returns the maximum of two vec3's
         *
         * @param {vec3} out the receiving vector
         * @param {vec3} a the first operand
         * @param {vec3} b the second operand
         * @returns {vec3} out
         */

        function max(out, a, b) {
          out[0] = Math.max(a[0], b[0]);
          out[1] = Math.max(a[1], b[1]);
          out[2] = Math.max(a[2], b[2]);
          return out;
        }

        /***/
      },
      /* 203 */
      /***/ function (module, exports) {
        module.exports = floor;
        /**
         * Math.floor the components of a vec3
         *
         * @param {vec3} out the receiving vector
         * @param {vec3} a vector to floor
         * @returns {vec3} out
         */

        function floor(out, a) {
          out[0] = Math.floor(a[0]);
          out[1] = Math.floor(a[1]);
          out[2] = Math.floor(a[2]);
          return out;
        }

        /***/
      },
      /* 204 */
      /***/ function (module, exports) {
        module.exports = ceil;
        /**
         * Math.ceil the components of a vec3
         *
         * @param {vec3} out the receiving vector
         * @param {vec3} a vector to ceil
         * @returns {vec3} out
         */

        function ceil(out, a) {
          out[0] = Math.ceil(a[0]);
          out[1] = Math.ceil(a[1]);
          out[2] = Math.ceil(a[2]);
          return out;
        }

        /***/
      },
      /* 205 */
      /***/ function (module, exports) {
        module.exports = round;
        /**
         * Math.round the components of a vec3
         *
         * @param {vec3} out the receiving vector
         * @param {vec3} a vector to round
         * @returns {vec3} out
         */

        function round(out, a) {
          out[0] = Math.round(a[0]);
          out[1] = Math.round(a[1]);
          out[2] = Math.round(a[2]);
          return out;
        }

        /***/
      },
      /* 206 */
      /***/ function (module, exports) {
        module.exports = scale;
        /**
         * Scales a vec3 by a scalar number
         *
         * @param {vec3} out the receiving vector
         * @param {vec3} a the vector to scale
         * @param {Number} b amount to scale the vector by
         * @returns {vec3} out
         */

        function scale(out, a, b) {
          out[0] = a[0] * b;
          out[1] = a[1] * b;
          out[2] = a[2] * b;
          return out;
        }

        /***/
      },
      /* 207 */
      /***/ function (module, exports) {
        module.exports = scaleAndAdd;
        /**
         * Adds two vec3's after scaling the second operand by a scalar value
         *
         * @param {vec3} out the receiving vector
         * @param {vec3} a the first operand
         * @param {vec3} b the second operand
         * @param {Number} scale the amount to scale b by before adding
         * @returns {vec3} out
         */

        function scaleAndAdd(out, a, b, scale) {
          out[0] = a[0] + b[0] * scale;
          out[1] = a[1] + b[1] * scale;
          out[2] = a[2] + b[2] * scale;
          return out;
        }

        /***/
      },
      /* 208 */
      /***/ function (module, exports, __webpack_require__) {
        module.exports = __webpack_require__(79);

        /***/
      },
      /* 209 */
      /***/ function (module, exports, __webpack_require__) {
        module.exports = __webpack_require__(80);

        /***/
      },
      /* 210 */
      /***/ function (module, exports, __webpack_require__) {
        module.exports = __webpack_require__(81);

        /***/
      },
      /* 211 */
      /***/ function (module, exports, __webpack_require__) {
        module.exports = __webpack_require__(82);

        /***/
      },
      /* 212 */
      /***/ function (module, exports) {
        module.exports = negate;
        /**
         * Negates the components of a vec3
         *
         * @param {vec3} out the receiving vector
         * @param {vec3} a vector to negate
         * @returns {vec3} out
         */

        function negate(out, a) {
          out[0] = -a[0];
          out[1] = -a[1];
          out[2] = -a[2];
          return out;
        }

        /***/
      },
      /* 213 */
      /***/ function (module, exports) {
        module.exports = inverse;
        /**
         * Returns the inverse of the components of a vec3
         *
         * @param {vec3} out the receiving vector
         * @param {vec3} a vector to invert
         * @returns {vec3} out
         */

        function inverse(out, a) {
          out[0] = 1.0 / a[0];
          out[1] = 1.0 / a[1];
          out[2] = 1.0 / a[2];
          return out;
        }

        /***/
      },
      /* 214 */
      /***/ function (module, exports) {
        module.exports = cross;
        /**
         * Computes the cross product of two vec3's
         *
         * @param {vec3} out the receiving vector
         * @param {vec3} a the first operand
         * @param {vec3} b the second operand
         * @returns {vec3} out
         */

        function cross(out, a, b) {
          var ax = a[0],
            ay = a[1],
            az = a[2],
            bx = b[0],
            by = b[1],
            bz = b[2];
          out[0] = ay * bz - az * by;
          out[1] = az * bx - ax * bz;
          out[2] = ax * by - ay * bx;
          return out;
        }

        /***/
      },
      /* 215 */
      /***/ function (module, exports) {
        module.exports = lerp;
        /**
         * Performs a linear interpolation between two vec3's
         *
         * @param {vec3} out the receiving vector
         * @param {vec3} a the first operand
         * @param {vec3} b the second operand
         * @param {Number} t interpolation amount between the two inputs
         * @returns {vec3} out
         */

        function lerp(out, a, b, t) {
          var ax = a[0],
            ay = a[1],
            az = a[2];
          out[0] = ax + t * (b[0] - ax);
          out[1] = ay + t * (b[1] - ay);
          out[2] = az + t * (b[2] - az);
          return out;
        }

        /***/
      },
      /* 216 */
      /***/ function (module, exports) {
        module.exports = random;
        /**
         * Generates a random vector with the given scale
         *
         * @param {vec3} out the receiving vector
         * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
         * @returns {vec3} out
         */

        function random(out, scale) {
          scale = scale || 1.0;
          var r = Math.random() * 2.0 * Math.PI;
          var z = Math.random() * 2.0 - 1.0;
          var zScale = Math.sqrt(1.0 - z * z) * scale;
          out[0] = Math.cos(r) * zScale;
          out[1] = Math.sin(r) * zScale;
          out[2] = z * scale;
          return out;
        }

        /***/
      },
      /* 217 */
      /***/ function (module, exports) {
        module.exports = transformMat4;
        /**
         * Transforms the vec3 with a mat4.
         * 4th vector component is implicitly '1'
         *
         * @param {vec3} out the receiving vector
         * @param {vec3} a the vector to transform
         * @param {mat4} m matrix to transform with
         * @returns {vec3} out
         */

        function transformMat4(out, a, m) {
          var x = a[0],
            y = a[1],
            z = a[2],
            w = m[3] * x + m[7] * y + m[11] * z + m[15];
          w = w || 1.0;
          out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w;
          out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w;
          out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w;
          return out;
        }

        /***/
      },
      /* 218 */
      /***/ function (module, exports) {
        module.exports = transformMat3;
        /**
         * Transforms the vec3 with a mat3.
         *
         * @param {vec3} out the receiving vector
         * @param {vec3} a the vector to transform
         * @param {mat4} m the 3x3 matrix to transform with
         * @returns {vec3} out
         */

        function transformMat3(out, a, m) {
          var x = a[0],
            y = a[1],
            z = a[2];
          out[0] = x * m[0] + y * m[3] + z * m[6];
          out[1] = x * m[1] + y * m[4] + z * m[7];
          out[2] = x * m[2] + y * m[5] + z * m[8];
          return out;
        }

        /***/
      },
      /* 219 */
      /***/ function (module, exports) {
        module.exports = transformQuat;
        /**
         * Transforms the vec3 with a quat
         *
         * @param {vec3} out the receiving vector
         * @param {vec3} a the vector to transform
         * @param {quat} q quaternion to transform with
         * @returns {vec3} out
         */

        function transformQuat(out, a, q) {
          // benchmarks: http://jsperf.com/quaternion-transform-vec3-implementations
          var x = a[0],
            y = a[1],
            z = a[2],
            qx = q[0],
            qy = q[1],
            qz = q[2],
            qw = q[3],
            // calculate quat * vec
            ix = qw * x + qy * z - qz * y,
            iy = qw * y + qz * x - qx * z,
            iz = qw * z + qx * y - qy * x,
            iw = -qx * x - qy * y - qz * z; // calculate result * inverse quat

          out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;
          out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;
          out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;
          return out;
        }

        /***/
      },
      /* 220 */
      /***/ function (module, exports) {
        module.exports = rotateX;
        /**
         * Rotate a 3D vector around the x-axis
         * @param {vec3} out The receiving vec3
         * @param {vec3} a The vec3 point to rotate
         * @param {vec3} b The origin of the rotation
         * @param {Number} c The angle of rotation
         * @returns {vec3} out
         */

        function rotateX(out, a, b, c) {
          var by = b[1];
          var bz = b[2]; // Translate point to the origin

          var py = a[1] - by;
          var pz = a[2] - bz;
          var sc = Math.sin(c);
          var cc = Math.cos(c); // perform rotation and translate to correct position

          out[0] = a[0];
          out[1] = by + py * cc - pz * sc;
          out[2] = bz + py * sc + pz * cc;
          return out;
        }

        /***/
      },
      /* 221 */
      /***/ function (module, exports) {
        module.exports = rotateY;
        /**
         * Rotate a 3D vector around the y-axis
         * @param {vec3} out The receiving vec3
         * @param {vec3} a The vec3 point to rotate
         * @param {vec3} b The origin of the rotation
         * @param {Number} c The angle of rotation
         * @returns {vec3} out
         */

        function rotateY(out, a, b, c) {
          var bx = b[0];
          var bz = b[2]; // translate point to the origin

          var px = a[0] - bx;
          var pz = a[2] - bz;
          var sc = Math.sin(c);
          var cc = Math.cos(c); // perform rotation and translate to correct position

          out[0] = bx + pz * sc + px * cc;
          out[1] = a[1];
          out[2] = bz + pz * cc - px * sc;
          return out;
        }

        /***/
      },
      /* 222 */
      /***/ function (module, exports) {
        module.exports = rotateZ;
        /**
         * Rotate a 3D vector around the z-axis
         * @param {vec3} out The receiving vec3
         * @param {vec3} a The vec3 point to rotate
         * @param {vec3} b The origin of the rotation
         * @param {Number} c The angle of rotation
         * @returns {vec3} out
         */

        function rotateZ(out, a, b, c) {
          var bx = b[0];
          var by = b[1]; //Translate point to the origin

          var px = a[0] - bx;
          var py = a[1] - by;
          var sc = Math.sin(c);
          var cc = Math.cos(c); // perform rotation and translate to correct position

          out[0] = bx + px * cc - py * sc;
          out[1] = by + px * sc + py * cc;
          out[2] = a[2];
          return out;
        }

        /***/
      },
      /* 223 */
      /***/ function (module, exports, __webpack_require__) {
        module.exports = forEach;

        var vec = __webpack_require__(72)();
        /**
         * Perform some operation over an array of vec3s.
         *
         * @param {Array} a the array of vectors to iterate over
         * @param {Number} stride Number of elements between the start of each vec3. If 0 assumes tightly packed
         * @param {Number} offset Number of elements to skip at the beginning of the array
         * @param {Number} count Number of vec3s to iterate over. If 0 iterates over entire array
         * @param {Function} fn Function to call for each vector in the array
         * @param {Object} [arg] additional argument to pass to fn
         * @returns {Array} a
         * @function
         */

        function forEach(a, stride, offset, count, fn, arg) {
          var i, l;

          if (!stride) {
            stride = 3;
          }

          if (!offset) {
            offset = 0;
          }

          if (count) {
            l = Math.min(count * stride + offset, a.length);
          } else {
            l = a.length;
          }

          for (i = offset; i < l; i += stride) {
            vec[0] = a[i];
            vec[1] = a[i + 1];
            vec[2] = a[i + 2];
            fn(vec, vec, arg);
            a[i] = vec[0];
            a[i + 1] = vec[1];
            a[i + 2] = vec[2];
          }

          return a;
        }

        /***/
      },
      /* 224 */
      /***/ function (module, exports, __webpack_require__) {
        var _typeof = __webpack_require__(17)["default"];

        function _regeneratorRuntime() {
          "use strict";
          /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */

          (module.exports = _regeneratorRuntime =
            function _regeneratorRuntime() {
              return exports;
            }),
            (module.exports.__esModule = true),
            (module.exports["default"] = module.exports);
          var exports = {},
            Op = Object.prototype,
            hasOwn = Op.hasOwnProperty,
            $Symbol = "function" == typeof Symbol ? Symbol : {},
            iteratorSymbol = $Symbol.iterator || "@@iterator",
            asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator",
            toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

          function define(obj, key, value) {
            return (
              Object.defineProperty(obj, key, {
                value: value,
                enumerable: !0,
                configurable: !0,
                writable: !0,
              }),
              obj[key]
            );
          }

          try {
            define({}, "");
          } catch (err) {
            define = function define(obj, key, value) {
              return (obj[key] = value);
            };
          }

          function wrap(innerFn, outerFn, self, tryLocsList) {
            var protoGenerator =
                outerFn && outerFn.prototype instanceof Generator
                  ? outerFn
                  : Generator,
              generator = Object.create(protoGenerator.prototype),
              context = new Context(tryLocsList || []);
            return (
              (generator._invoke = (function (innerFn, self, context) {
                var state = "suspendedStart";
                return function (method, arg) {
                  if ("executing" === state)
                    throw new Error("Generator is already running");

                  if ("completed" === state) {
                    if ("throw" === method) throw arg;
                    return doneResult();
                  }

                  for (context.method = method, context.arg = arg; ; ) {
                    var delegate = context.delegate;

                    if (delegate) {
                      var delegateResult = maybeInvokeDelegate(
                        delegate,
                        context
                      );

                      if (delegateResult) {
                        if (delegateResult === ContinueSentinel) continue;
                        return delegateResult;
                      }
                    }

                    if ("next" === context.method)
                      context.sent = context._sent = context.arg;
                    else if ("throw" === context.method) {
                      if ("suspendedStart" === state)
                        throw ((state = "completed"), context.arg);
                      context.dispatchException(context.arg);
                    } else
                      "return" === context.method &&
                        context.abrupt("return", context.arg);
                    state = "executing";
                    var record = tryCatch(innerFn, self, context);

                    if ("normal" === record.type) {
                      if (
                        ((state = context.done
                          ? "completed"
                          : "suspendedYield"),
                        record.arg === ContinueSentinel)
                      )
                        continue;
                      return {
                        value: record.arg,
                        done: context.done,
                      };
                    }

                    "throw" === record.type &&
                      ((state = "completed"),
                      (context.method = "throw"),
                      (context.arg = record.arg));
                  }
                };
              })(innerFn, self, context)),
              generator
            );
          }

          function tryCatch(fn, obj, arg) {
            try {
              return {
                type: "normal",
                arg: fn.call(obj, arg),
              };
            } catch (err) {
              return {
                type: "throw",
                arg: err,
              };
            }
          }

          exports.wrap = wrap;
          var ContinueSentinel = {};

          function Generator() {}

          function GeneratorFunction() {}

          function GeneratorFunctionPrototype() {}

          var IteratorPrototype = {};
          define(IteratorPrototype, iteratorSymbol, function () {
            return this;
          });
          var getProto = Object.getPrototypeOf,
            NativeIteratorPrototype =
              getProto && getProto(getProto(values([])));
          NativeIteratorPrototype &&
            NativeIteratorPrototype !== Op &&
            hasOwn.call(NativeIteratorPrototype, iteratorSymbol) &&
            (IteratorPrototype = NativeIteratorPrototype);
          var Gp =
            (GeneratorFunctionPrototype.prototype =
            Generator.prototype =
              Object.create(IteratorPrototype));

          function defineIteratorMethods(prototype) {
            ["next", "throw", "return"].forEach(function (method) {
              define(prototype, method, function (arg) {
                return this._invoke(method, arg);
              });
            });
          }

          function AsyncIterator(generator, PromiseImpl) {
            function invoke(method, arg, resolve, reject) {
              var record = tryCatch(generator[method], generator, arg);

              if ("throw" !== record.type) {
                var result = record.arg,
                  value = result.value;
                return value &&
                  "object" == _typeof(value) &&
                  hasOwn.call(value, "__await")
                  ? PromiseImpl.resolve(value.__await).then(
                      function (value) {
                        invoke("next", value, resolve, reject);
                      },
                      function (err) {
                        invoke("throw", err, resolve, reject);
                      }
                    )
                  : PromiseImpl.resolve(value).then(
                      function (unwrapped) {
                        (result.value = unwrapped), resolve(result);
                      },
                      function (error) {
                        return invoke("throw", error, resolve, reject);
                      }
                    );
              }

              reject(record.arg);
            }

            var previousPromise;

            this._invoke = function (method, arg) {
              function callInvokeWithMethodAndArg() {
                return new PromiseImpl(function (resolve, reject) {
                  invoke(method, arg, resolve, reject);
                });
              }

              return (previousPromise = previousPromise
                ? previousPromise.then(
                    callInvokeWithMethodAndArg,
                    callInvokeWithMethodAndArg
                  )
                : callInvokeWithMethodAndArg());
            };
          }

          function maybeInvokeDelegate(delegate, context) {
            var method = delegate.iterator[context.method];

            if (undefined === method) {
              if (((context.delegate = null), "throw" === context.method)) {
                if (
                  delegate.iterator["return"] &&
                  ((context.method = "return"),
                  (context.arg = undefined),
                  maybeInvokeDelegate(delegate, context),
                  "throw" === context.method)
                )
                  return ContinueSentinel;
                (context.method = "throw"),
                  (context.arg = new TypeError(
                    "The iterator does not provide a 'throw' method"
                  ));
              }

              return ContinueSentinel;
            }

            var record = tryCatch(method, delegate.iterator, context.arg);
            if ("throw" === record.type)
              return (
                (context.method = "throw"),
                (context.arg = record.arg),
                (context.delegate = null),
                ContinueSentinel
              );
            var info = record.arg;
            return info
              ? info.done
                ? ((context[delegate.resultName] = info.value),
                  (context.next = delegate.nextLoc),
                  "return" !== context.method &&
                    ((context.method = "next"), (context.arg = undefined)),
                  (context.delegate = null),
                  ContinueSentinel)
                : info
              : ((context.method = "throw"),
                (context.arg = new TypeError(
                  "iterator result is not an object"
                )),
                (context.delegate = null),
                ContinueSentinel);
          }

          function pushTryEntry(locs) {
            var entry = {
              tryLoc: locs[0],
            };
            1 in locs && (entry.catchLoc = locs[1]),
              2 in locs &&
                ((entry.finallyLoc = locs[2]), (entry.afterLoc = locs[3])),
              this.tryEntries.push(entry);
          }

          function resetTryEntry(entry) {
            var record = entry.completion || {};
            (record.type = "normal"),
              delete record.arg,
              (entry.completion = record);
          }

          function Context(tryLocsList) {
            (this.tryEntries = [
              {
                tryLoc: "root",
              },
            ]),
              tryLocsList.forEach(pushTryEntry, this),
              this.reset(!0);
          }

          function values(iterable) {
            if (iterable) {
              var iteratorMethod = iterable[iteratorSymbol];
              if (iteratorMethod) return iteratorMethod.call(iterable);
              if ("function" == typeof iterable.next) return iterable;

              if (!isNaN(iterable.length)) {
                var i = -1,
                  next = function next() {
                    for (; ++i < iterable.length; ) {
                      if (hasOwn.call(iterable, i))
                        return (
                          (next.value = iterable[i]), (next.done = !1), next
                        );
                    }

                    return (next.value = undefined), (next.done = !0), next;
                  };

                return (next.next = next);
              }
            }

            return {
              next: doneResult,
            };
          }

          function doneResult() {
            return {
              value: undefined,
              done: !0,
            };
          }

          return (
            (GeneratorFunction.prototype = GeneratorFunctionPrototype),
            define(Gp, "constructor", GeneratorFunctionPrototype),
            define(
              GeneratorFunctionPrototype,
              "constructor",
              GeneratorFunction
            ),
            (GeneratorFunction.displayName = define(
              GeneratorFunctionPrototype,
              toStringTagSymbol,
              "GeneratorFunction"
            )),
            (exports.isGeneratorFunction = function (genFun) {
              var ctor = "function" == typeof genFun && genFun.constructor;
              return (
                !!ctor &&
                (ctor === GeneratorFunction ||
                  "GeneratorFunction" === (ctor.displayName || ctor.name))
              );
            }),
            (exports.mark = function (genFun) {
              return (
                Object.setPrototypeOf
                  ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype)
                  : ((genFun.__proto__ = GeneratorFunctionPrototype),
                    define(genFun, toStringTagSymbol, "GeneratorFunction")),
                (genFun.prototype = Object.create(Gp)),
                genFun
              );
            }),
            (exports.awrap = function (arg) {
              return {
                __await: arg,
              };
            }),
            defineIteratorMethods(AsyncIterator.prototype),
            define(AsyncIterator.prototype, asyncIteratorSymbol, function () {
              return this;
            }),
            (exports.AsyncIterator = AsyncIterator),
            (exports.async = function (
              innerFn,
              outerFn,
              self,
              tryLocsList,
              PromiseImpl
            ) {
              void 0 === PromiseImpl && (PromiseImpl = Promise);
              var iter = new AsyncIterator(
                wrap(innerFn, outerFn, self, tryLocsList),
                PromiseImpl
              );
              return exports.isGeneratorFunction(outerFn)
                ? iter
                : iter.next().then(function (result) {
                    return result.done ? result.value : iter.next();
                  });
            }),
            defineIteratorMethods(Gp),
            define(Gp, toStringTagSymbol, "Generator"),
            define(Gp, iteratorSymbol, function () {
              return this;
            }),
            define(Gp, "toString", function () {
              return "[object Generator]";
            }),
            (exports.keys = function (object) {
              var keys = [];

              for (var key in object) {
                keys.push(key);
              }

              return (
                keys.reverse(),
                function next() {
                  for (; keys.length; ) {
                    var key = keys.pop();
                    if (key in object)
                      return (next.value = key), (next.done = !1), next;
                  }

                  return (next.done = !0), next;
                }
              );
            }),
            (exports.values = values),
            (Context.prototype = {
              constructor: Context,
              reset: function reset(skipTempReset) {
                if (
                  ((this.prev = 0),
                  (this.next = 0),
                  (this.sent = this._sent = undefined),
                  (this.done = !1),
                  (this.delegate = null),
                  (this.method = "next"),
                  (this.arg = undefined),
                  this.tryEntries.forEach(resetTryEntry),
                  !skipTempReset)
                )
                  for (var name in this) {
                    "t" === name.charAt(0) &&
                      hasOwn.call(this, name) &&
                      !isNaN(+name.slice(1)) &&
                      (this[name] = undefined);
                  }
              },
              stop: function stop() {
                this.done = !0;
                var rootRecord = this.tryEntries[0].completion;
                if ("throw" === rootRecord.type) throw rootRecord.arg;
                return this.rval;
              },
              dispatchException: function dispatchException(exception) {
                if (this.done) throw exception;
                var context = this;

                function handle(loc, caught) {
                  return (
                    (record.type = "throw"),
                    (record.arg = exception),
                    (context.next = loc),
                    caught &&
                      ((context.method = "next"), (context.arg = undefined)),
                    !!caught
                  );
                }

                for (var i = this.tryEntries.length - 1; i >= 0; --i) {
                  var entry = this.tryEntries[i],
                    record = entry.completion;
                  if ("root" === entry.tryLoc) return handle("end");

                  if (entry.tryLoc <= this.prev) {
                    var hasCatch = hasOwn.call(entry, "catchLoc"),
                      hasFinally = hasOwn.call(entry, "finallyLoc");

                    if (hasCatch && hasFinally) {
                      if (this.prev < entry.catchLoc)
                        return handle(entry.catchLoc, !0);
                      if (this.prev < entry.finallyLoc)
                        return handle(entry.finallyLoc);
                    } else if (hasCatch) {
                      if (this.prev < entry.catchLoc)
                        return handle(entry.catchLoc, !0);
                    } else {
                      if (!hasFinally)
                        throw new Error(
                          "try statement without catch or finally"
                        );
                      if (this.prev < entry.finallyLoc)
                        return handle(entry.finallyLoc);
                    }
                  }
                }
              },
              abrupt: function abrupt(type, arg) {
                for (var i = this.tryEntries.length - 1; i >= 0; --i) {
                  var entry = this.tryEntries[i];

                  if (
                    entry.tryLoc <= this.prev &&
                    hasOwn.call(entry, "finallyLoc") &&
                    this.prev < entry.finallyLoc
                  ) {
                    var finallyEntry = entry;
                    break;
                  }
                }

                finallyEntry &&
                  ("break" === type || "continue" === type) &&
                  finallyEntry.tryLoc <= arg &&
                  arg <= finallyEntry.finallyLoc &&
                  (finallyEntry = null);
                var record = finallyEntry ? finallyEntry.completion : {};
                return (
                  (record.type = type),
                  (record.arg = arg),
                  finallyEntry
                    ? ((this.method = "next"),
                      (this.next = finallyEntry.finallyLoc),
                      ContinueSentinel)
                    : this.complete(record)
                );
              },
              complete: function complete(record, afterLoc) {
                if ("throw" === record.type) throw record.arg;
                return (
                  "break" === record.type || "continue" === record.type
                    ? (this.next = record.arg)
                    : "return" === record.type
                    ? ((this.rval = this.arg = record.arg),
                      (this.method = "return"),
                      (this.next = "end"))
                    : "normal" === record.type &&
                      afterLoc &&
                      (this.next = afterLoc),
                  ContinueSentinel
                );
              },
              finish: function finish(finallyLoc) {
                for (var i = this.tryEntries.length - 1; i >= 0; --i) {
                  var entry = this.tryEntries[i];
                  if (entry.finallyLoc === finallyLoc)
                    return (
                      this.complete(entry.completion, entry.afterLoc),
                      resetTryEntry(entry),
                      ContinueSentinel
                    );
                }
              },
              catch: function _catch(tryLoc) {
                for (var i = this.tryEntries.length - 1; i >= 0; --i) {
                  var entry = this.tryEntries[i];

                  if (entry.tryLoc === tryLoc) {
                    var record = entry.completion;

                    if ("throw" === record.type) {
                      var thrown = record.arg;
                      resetTryEntry(entry);
                    }

                    return thrown;
                  }
                }

                throw new Error("illegal catch attempt");
              },
              delegateYield: function delegateYield(
                iterable,
                resultName,
                nextLoc
              ) {
                return (
                  (this.delegate = {
                    iterator: values(iterable),
                    resultName: resultName,
                    nextLoc: nextLoc,
                  }),
                  "next" === this.method && (this.arg = undefined),
                  ContinueSentinel
                );
              },
            }),
            exports
          );
        }

        (module.exports = _regeneratorRuntime),
          (module.exports.__esModule = true),
          (module.exports["default"] = module.exports);

        /***/
      },
      /* 225 */
      /***/ function (module, exports, __webpack_require__) {
        var getPrototypeOf = __webpack_require__(2);

        function _superPropBase(object, property) {
          while (!Object.prototype.hasOwnProperty.call(object, property)) {
            object = getPrototypeOf(object);
            if (object === null) break;
          }

          return object;
        }

        (module.exports = _superPropBase),
          (module.exports.__esModule = true),
          (module.exports["default"] = module.exports);

        /***/
      },
      /* 226 */
      /***/ function (module, exports, __webpack_require__) {
        var arrayLikeToArray = __webpack_require__(61);

        function _arrayWithoutHoles(arr) {
          if (Array.isArray(arr)) return arrayLikeToArray(arr);
        }

        (module.exports = _arrayWithoutHoles),
          (module.exports.__esModule = true),
          (module.exports["default"] = module.exports);

        /***/
      },
      /* 227 */
      /***/ function (module, exports) {
        function _iterableToArray(iter) {
          if (
            (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null) ||
            iter["@@iterator"] != null
          )
            return Array.from(iter);
        }

        (module.exports = _iterableToArray),
          (module.exports.__esModule = true),
          (module.exports["default"] = module.exports);

        /***/
      },
      /* 228 */
      /***/ function (module, exports) {
        function _nonIterableSpread() {
          throw new TypeError(
            "Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."
          );
        }

        (module.exports = _nonIterableSpread),
          (module.exports.__esModule = true),
          (module.exports["default"] = module.exports);

        /***/
      },
      /* 229 */
      /***/ function (module, exports, __webpack_require__) {
        var basePickBy = __webpack_require__(230),
          hasIn = __webpack_require__(240);
        /**
         * The base implementation of `_.pick` without support for individual
         * property identifiers.
         *
         * @private
         * @param {Object} object The source object.
         * @param {string[]} paths The property paths to pick.
         * @returns {Object} Returns the new object.
         */

        function basePick(object, paths) {
          return basePickBy(object, paths, function (value, path) {
            return hasIn(object, path);
          });
        }

        module.exports = basePick;

        /***/
      },
      /* 230 */
      /***/ function (module, exports, __webpack_require__) {
        var baseGet = __webpack_require__(231),
          baseSet = __webpack_require__(239),
          castPath = __webpack_require__(32);
        /**
         * The base implementation of  `_.pickBy` without support for iteratee shorthands.
         *
         * @private
         * @param {Object} object The source object.
         * @param {string[]} paths The property paths to pick.
         * @param {Function} predicate The function invoked per property.
         * @returns {Object} Returns the new object.
         */

        function basePickBy(object, paths, predicate) {
          var index = -1,
            length = paths.length,
            result = {};

          while (++index < length) {
            var path = paths[index],
              value = baseGet(object, path);

            if (predicate(value, path)) {
              baseSet(result, castPath(path, object), value);
            }
          }

          return result;
        }

        module.exports = basePickBy;

        /***/
      },
      /* 231 */
      /***/ function (module, exports, __webpack_require__) {
        var castPath = __webpack_require__(32),
          toKey = __webpack_require__(43);
        /**
         * The base implementation of `_.get` without support for default values.
         *
         * @private
         * @param {Object} object The object to query.
         * @param {Array|string} path The path of the property to get.
         * @returns {*} Returns the resolved value.
         */

        function baseGet(object, path) {
          path = castPath(path, object);
          var index = 0,
            length = path.length;

          while (object != null && index < length) {
            object = object[toKey(path[index++])];
          }

          return index && index == length ? object : undefined;
        }

        module.exports = baseGet;

        /***/
      },
      /* 232 */
      /***/ function (module, exports, __webpack_require__) {
        var isArray = __webpack_require__(16),
          isSymbol = __webpack_require__(42);
        /** Used to match property names within property paths. */

        var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
          reIsPlainProp = /^\w*$/;
        /**
         * Checks if `value` is a property name and not a property path.
         *
         * @private
         * @param {*} value The value to check.
         * @param {Object} [object] The object to query keys on.
         * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
         */

        function isKey(value, object) {
          if (isArray(value)) {
            return false;
          }

          var type = typeof value;

          if (
            type == "number" ||
            type == "symbol" ||
            type == "boolean" ||
            value == null ||
            isSymbol(value)
          ) {
            return true;
          }

          return (
            reIsPlainProp.test(value) ||
            !reIsDeepProp.test(value) ||
            (object != null && value in Object(object))
          );
        }

        module.exports = isKey;

        /***/
      },
      /* 233 */
      /***/ function (module, exports, __webpack_require__) {
        var memoizeCapped = __webpack_require__(234);
        /** Used to match property names within property paths. */

        var rePropName =
          /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
        /** Used to match backslashes in property paths. */

        var reEscapeChar = /\\(\\)?/g;
        /**
         * Converts `string` to a property path array.
         *
         * @private
         * @param {string} string The string to convert.
         * @returns {Array} Returns the property path array.
         */

        var stringToPath = memoizeCapped(function (string) {
          var result = [];

          if (
            string.charCodeAt(0) === 46
            /* . */
          ) {
            result.push("");
          }

          string.replace(
            rePropName,
            function (match, number, quote, subString) {
              result.push(
                quote ? subString.replace(reEscapeChar, "$1") : number || match
              );
            }
          );
          return result;
        });
        module.exports = stringToPath;

        /***/
      },
      /* 234 */
      /***/ function (module, exports, __webpack_require__) {
        var memoize = __webpack_require__(235);
        /** Used as the maximum memoize cache size. */

        var MAX_MEMOIZE_SIZE = 500;
        /**
         * A specialized version of `_.memoize` which clears the memoized function's
         * cache when it exceeds `MAX_MEMOIZE_SIZE`.
         *
         * @private
         * @param {Function} func The function to have its output memoized.
         * @returns {Function} Returns the new memoized function.
         */

        function memoizeCapped(func) {
          var result = memoize(func, function (key) {
            if (cache.size === MAX_MEMOIZE_SIZE) {
              cache.clear();
            }

            return key;
          });
          var cache = result.cache;
          return result;
        }

        module.exports = memoizeCapped;

        /***/
      },
      /* 235 */
      /***/ function (module, exports, __webpack_require__) {
        var MapCache = __webpack_require__(47);
        /** Error message constants. */

        var FUNC_ERROR_TEXT = "Expected a function";
        /**
         * Creates a function that memoizes the result of `func`. If `resolver` is
         * provided, it determines the cache key for storing the result based on the
         * arguments provided to the memoized function. By default, the first argument
         * provided to the memoized function is used as the map cache key. The `func`
         * is invoked with the `this` binding of the memoized function.
         *
         * **Note:** The cache is exposed as the `cache` property on the memoized
         * function. Its creation may be customized by replacing the `_.memoize.Cache`
         * constructor with one whose instances implement the
         * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
         * method interface of `clear`, `delete`, `get`, `has`, and `set`.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Function
         * @param {Function} func The function to have its output memoized.
         * @param {Function} [resolver] The function to resolve the cache key.
         * @returns {Function} Returns the new memoized function.
         * @example
         *
         * var object = { 'a': 1, 'b': 2 };
         * var other = { 'c': 3, 'd': 4 };
         *
         * var values = _.memoize(_.values);
         * values(object);
         * // => [1, 2]
         *
         * values(other);
         * // => [3, 4]
         *
         * object.a = 2;
         * values(object);
         * // => [1, 2]
         *
         * // Modify the result cache.
         * values.cache.set(object, ['a', 'b']);
         * values(object);
         * // => ['a', 'b']
         *
         * // Replace `_.memoize.Cache`.
         * _.memoize.Cache = WeakMap;
         */

        function memoize(func, resolver) {
          if (
            typeof func != "function" ||
            (resolver != null && typeof resolver != "function")
          ) {
            throw new TypeError(FUNC_ERROR_TEXT);
          }

          var memoized = function () {
            var args = arguments,
              key = resolver ? resolver.apply(this, args) : args[0],
              cache = memoized.cache;

            if (cache.has(key)) {
              return cache.get(key);
            }

            var result = func.apply(this, args);
            memoized.cache = cache.set(key, result) || cache;
            return result;
          };

          memoized.cache = new (memoize.Cache || MapCache)();
          return memoized;
        } // Expose `MapCache`.

        memoize.Cache = MapCache;
        module.exports = memoize;

        /***/
      },
      /* 236 */
      /***/ function (module, exports, __webpack_require__) {
        var baseToString = __webpack_require__(237);
        /**
         * Converts `value` to a string. An empty string is returned for `null`
         * and `undefined` values. The sign of `-0` is preserved.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Lang
         * @param {*} value The value to convert.
         * @returns {string} Returns the converted string.
         * @example
         *
         * _.toString(null);
         * // => ''
         *
         * _.toString(-0);
         * // => '-0'
         *
         * _.toString([1, 2, 3]);
         * // => '1,2,3'
         */

        function toString(value) {
          return value == null ? "" : baseToString(value);
        }

        module.exports = toString;

        /***/
      },
      /* 237 */
      /***/ function (module, exports, __webpack_require__) {
        var Symbol = __webpack_require__(27),
          arrayMap = __webpack_require__(238),
          isArray = __webpack_require__(16),
          isSymbol = __webpack_require__(42);
        /** Used as references for various `Number` constants. */

        var INFINITY = 1 / 0;
        /** Used to convert symbols to primitives and strings. */

        var symbolProto = Symbol ? Symbol.prototype : undefined,
          symbolToString = symbolProto ? symbolProto.toString : undefined;
        /**
         * The base implementation of `_.toString` which doesn't convert nullish
         * values to empty strings.
         *
         * @private
         * @param {*} value The value to process.
         * @returns {string} Returns the string.
         */

        function baseToString(value) {
          // Exit early for strings to avoid a performance hit in some environments.
          if (typeof value == "string") {
            return value;
          }

          if (isArray(value)) {
            // Recursively convert values (susceptible to call stack limits).
            return arrayMap(value, baseToString) + "";
          }

          if (isSymbol(value)) {
            return symbolToString ? symbolToString.call(value) : "";
          }

          var result = value + "";
          return result == "0" && 1 / value == -INFINITY ? "-0" : result;
        }

        module.exports = baseToString;

        /***/
      },
      /* 238 */
      /***/ function (module, exports) {
        /**
         * A specialized version of `_.map` for arrays without support for iteratee
         * shorthands.
         *
         * @private
         * @param {Array} [array] The array to iterate over.
         * @param {Function} iteratee The function invoked per iteration.
         * @returns {Array} Returns the new mapped array.
         */
        function arrayMap(array, iteratee) {
          var index = -1,
            length = array == null ? 0 : array.length,
            result = Array(length);

          while (++index < length) {
            result[index] = iteratee(array[index], index, array);
          }

          return result;
        }

        module.exports = arrayMap;

        /***/
      },
      /* 239 */
      /***/ function (module, exports, __webpack_require__) {
        var assignValue = __webpack_require__(55),
          castPath = __webpack_require__(32),
          isIndex = __webpack_require__(31),
          isObject = __webpack_require__(15),
          toKey = __webpack_require__(43);
        /**
         * The base implementation of `_.set`.
         *
         * @private
         * @param {Object} object The object to modify.
         * @param {Array|string} path The path of the property to set.
         * @param {*} value The value to set.
         * @param {Function} [customizer] The function to customize path creation.
         * @returns {Object} Returns `object`.
         */

        function baseSet(object, path, value, customizer) {
          if (!isObject(object)) {
            return object;
          }

          path = castPath(path, object);
          var index = -1,
            length = path.length,
            lastIndex = length - 1,
            nested = object;

          while (nested != null && ++index < length) {
            var key = toKey(path[index]),
              newValue = value;

            if (
              key === "__proto__" ||
              key === "constructor" ||
              key === "prototype"
            ) {
              return object;
            }

            if (index != lastIndex) {
              var objValue = nested[key];
              newValue = customizer
                ? customizer(objValue, key, nested)
                : undefined;

              if (newValue === undefined) {
                newValue = isObject(objValue)
                  ? objValue
                  : isIndex(path[index + 1])
                  ? []
                  : {};
              }
            }

            assignValue(nested, key, newValue);
            nested = nested[key];
          }

          return object;
        }

        module.exports = baseSet;

        /***/
      },
      /* 240 */
      /***/ function (module, exports, __webpack_require__) {
        var baseHasIn = __webpack_require__(241),
          hasPath = __webpack_require__(242);
        /**
         * Checks if `path` is a direct or inherited property of `object`.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Object
         * @param {Object} object The object to query.
         * @param {Array|string} path The path to check.
         * @returns {boolean} Returns `true` if `path` exists, else `false`.
         * @example
         *
         * var object = _.create({ 'a': _.create({ 'b': 2 }) });
         *
         * _.hasIn(object, 'a');
         * // => true
         *
         * _.hasIn(object, 'a.b');
         * // => true
         *
         * _.hasIn(object, ['a', 'b']);
         * // => true
         *
         * _.hasIn(object, 'b');
         * // => false
         */

        function hasIn(object, path) {
          return object != null && hasPath(object, path, baseHasIn);
        }

        module.exports = hasIn;

        /***/
      },
      /* 241 */
      /***/ function (module, exports) {
        /**
         * The base implementation of `_.hasIn` without support for deep paths.
         *
         * @private
         * @param {Object} [object] The object to query.
         * @param {Array|string} key The key to check.
         * @returns {boolean} Returns `true` if `key` exists, else `false`.
         */
        function baseHasIn(object, key) {
          return object != null && key in Object(object);
        }

        module.exports = baseHasIn;

        /***/
      },
      /* 242 */
      /***/ function (module, exports, __webpack_require__) {
        var castPath = __webpack_require__(32),
          isArguments = __webpack_require__(30),
          isArray = __webpack_require__(16),
          isIndex = __webpack_require__(31),
          isLength = __webpack_require__(40),
          toKey = __webpack_require__(43);
        /**
         * Checks if `path` exists on `object`.
         *
         * @private
         * @param {Object} object The object to query.
         * @param {Array|string} path The path to check.
         * @param {Function} hasFunc The function to check properties.
         * @returns {boolean} Returns `true` if `path` exists, else `false`.
         */

        function hasPath(object, path, hasFunc) {
          path = castPath(path, object);
          var index = -1,
            length = path.length,
            result = false;

          while (++index < length) {
            var key = toKey(path[index]);

            if (!(result = object != null && hasFunc(object, key))) {
              break;
            }

            object = object[key];
          }

          if (result || ++index != length) {
            return result;
          }

          length = object == null ? 0 : object.length;
          return (
            !!length &&
            isLength(length) &&
            isIndex(key, length) &&
            (isArray(object) || isArguments(object))
          );
        }

        module.exports = hasPath;

        /***/
      },
      /* 243 */
      /***/ function (module, exports, __webpack_require__) {
        var flatten = __webpack_require__(244),
          overRest = __webpack_require__(58),
          setToString = __webpack_require__(59);
        /**
         * A specialized version of `baseRest` which flattens the rest array.
         *
         * @private
         * @param {Function} func The function to apply a rest parameter to.
         * @returns {Function} Returns the new function.
         */

        function flatRest(func) {
          return setToString(overRest(func, undefined, flatten), func + "");
        }

        module.exports = flatRest;

        /***/
      },
      /* 244 */
      /***/ function (module, exports, __webpack_require__) {
        var baseFlatten = __webpack_require__(245);
        /**
         * Flattens `array` a single level deep.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Array
         * @param {Array} array The array to flatten.
         * @returns {Array} Returns the new flattened array.
         * @example
         *
         * _.flatten([1, [2, [3, [4]], 5]]);
         * // => [1, 2, [3, [4]], 5]
         */

        function flatten(array) {
          var length = array == null ? 0 : array.length;
          return length ? baseFlatten(array, 1) : [];
        }

        module.exports = flatten;

        /***/
      },
      /* 245 */
      /***/ function (module, exports, __webpack_require__) {
        var arrayPush = __webpack_require__(246),
          isFlattenable = __webpack_require__(247);
        /**
         * The base implementation of `_.flatten` with support for restricting flattening.
         *
         * @private
         * @param {Array} array The array to flatten.
         * @param {number} depth The maximum recursion depth.
         * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.
         * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.
         * @param {Array} [result=[]] The initial result value.
         * @returns {Array} Returns the new flattened array.
         */

        function baseFlatten(array, depth, predicate, isStrict, result) {
          var index = -1,
            length = array.length;
          predicate || (predicate = isFlattenable);
          result || (result = []);

          while (++index < length) {
            var value = array[index];

            if (depth > 0 && predicate(value)) {
              if (depth > 1) {
                // Recursively flatten arrays (susceptible to call stack limits).
                baseFlatten(value, depth - 1, predicate, isStrict, result);
              } else {
                arrayPush(result, value);
              }
            } else if (!isStrict) {
              result[result.length] = value;
            }
          }

          return result;
        }

        module.exports = baseFlatten;

        /***/
      },
      /* 246 */
      /***/ function (module, exports) {
        /**
         * Appends the elements of `values` to `array`.
         *
         * @private
         * @param {Array} array The array to modify.
         * @param {Array} values The values to append.
         * @returns {Array} Returns `array`.
         */
        function arrayPush(array, values) {
          var index = -1,
            length = values.length,
            offset = array.length;

          while (++index < length) {
            array[offset + index] = values[index];
          }

          return array;
        }

        module.exports = arrayPush;

        /***/
      },
      /* 247 */
      /***/ function (module, exports, __webpack_require__) {
        var Symbol = __webpack_require__(27),
          isArguments = __webpack_require__(30),
          isArray = __webpack_require__(16);
        /** Built-in value references. */

        var spreadableSymbol = Symbol ? Symbol.isConcatSpreadable : undefined;
        /**
         * Checks if `value` is a flattenable `arguments` object or array.
         *
         * @private
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.
         */

        function isFlattenable(value) {
          return (
            isArray(value) ||
            isArguments(value) ||
            !!(spreadableSymbol && value && value[spreadableSymbol])
          );
        }

        module.exports = isFlattenable;

        /***/
      },
      /* 248 */
      /***/ function (module, exports) {
        function _isNativeFunction(fn) {
          return Function.toString.call(fn).indexOf("[native code]") !== -1;
        }

        (module.exports = _isNativeFunction),
          (module.exports.__esModule = true),
          (module.exports["default"] = module.exports);

        /***/
      },
      /* 249 */
      /***/ function (module, exports, __webpack_require__) {
        var setPrototypeOf = __webpack_require__(41);

        var isNativeReflectConstruct = __webpack_require__(250);

        function _construct(Parent, args, Class) {
          if (isNativeReflectConstruct()) {
            (module.exports = _construct = Reflect.construct.bind()),
              (module.exports.__esModule = true),
              (module.exports["default"] = module.exports);
          } else {
            (module.exports = _construct =
              function _construct(Parent, args, Class) {
                var a = [null];
                a.push.apply(a, args);
                var Constructor = Function.bind.apply(Parent, a);
                var instance = new Constructor();
                if (Class) setPrototypeOf(instance, Class.prototype);
                return instance;
              }),
              (module.exports.__esModule = true),
              (module.exports["default"] = module.exports);
          }

          return _construct.apply(null, arguments);
        }

        (module.exports = _construct),
          (module.exports.__esModule = true),
          (module.exports["default"] = module.exports);

        /***/
      },
      /* 250 */
      /***/ function (module, exports) {
        function _isNativeReflectConstruct() {
          if (typeof Reflect === "undefined" || !Reflect.construct)
            return false;
          if (Reflect.construct.sham) return false;
          if (typeof Proxy === "function") return true;

          try {
            Boolean.prototype.valueOf.call(
              Reflect.construct(Boolean, [], function () {})
            );
            return true;
          } catch (e) {
            return false;
          }
        }

        (module.exports = _isNativeReflectConstruct),
          (module.exports.__esModule = true),
          (module.exports["default"] = module.exports);

        /***/
      },
      /* 251 */
      /***/ function (module, exports) {
        module.exports = determinant;
        /**
         * Calculates the determinant of a mat2
         *
         * @alias mat2.determinant
         * @param {mat2} a the source matrix
         * @returns {Number} determinant of a
         */

        function determinant(a) {
          return a[0] * a[3] - a[2] * a[1];
        }

        /***/
      },
      /* 252 */
      /***/ function (module, exports) {
        module.exports = transpose;
        /**
         * Transpose the values of a mat2
         *
         * @alias mat2.transpose
         * @param {mat2} out the receiving matrix
         * @param {mat2} a the source matrix
         * @returns {mat2} out
         */

        function transpose(out, a) {
          // If we are transposing ourselves we can skip a few steps but have to cache some values
          if (out === a) {
            var a1 = a[1];
            out[1] = a[2];
            out[2] = a1;
          } else {
            out[0] = a[0];
            out[1] = a[2];
            out[2] = a[1];
            out[3] = a[3];
          }

          return out;
        }

        /***/
      },
      /* 253 */
      /***/ function (module, exports) {
        module.exports = multiply;
        /**
         * Multiplies two mat2's
         *
         * @alias mat2.multiply
         * @param {mat2} out the receiving matrix
         * @param {mat2} a the first operand
         * @param {mat2} b the second operand
         * @returns {mat2} out
         */

        function multiply(out, a, b) {
          var a0 = a[0],
            a1 = a[1],
            a2 = a[2],
            a3 = a[3];
          var b0 = b[0],
            b1 = b[1],
            b2 = b[2],
            b3 = b[3];
          out[0] = a0 * b0 + a2 * b1;
          out[1] = a1 * b0 + a3 * b1;
          out[2] = a0 * b2 + a2 * b3;
          out[3] = a1 * b2 + a3 * b3;
          return out;
        }

        /***/
      },
      /* 254 */
      /***/ function (module, exports) {
        module.exports = identity;
        /**
         * Set a mat2 to the identity matrix
         *
         * @alias mat2.identity
         * @param {mat2} out the receiving matrix
         * @returns {mat2} out
         */

        function identity(out) {
          out[0] = 1;
          out[1] = 0;
          out[2] = 0;
          out[3] = 1;
          return out;
        }

        /***/
      },
      /* 255 */
      /***/ function (module, exports) {
        module.exports = adjoint;
        /**
         * Calculates the adjugate of a mat2
         *
         * @alias mat2.adjoint
         * @param {mat2} out the receiving matrix
         * @param {mat2} a the source matrix
         * @returns {mat2} out
         */

        function adjoint(out, a) {
          // Caching this value is nessecary if out == a
          var a0 = a[0];
          out[0] = a[3];
          out[1] = -a[1];
          out[2] = -a[2];
          out[3] = a0;
          return out;
        }

        /***/
      },
      /* 256 */
      /***/ function (module, exports) {
        module.exports = rotate;
        /**
         * Rotates a mat2 by the given angle
         *
         * @alias mat2.rotate
         * @param {mat2} out the receiving matrix
         * @param {mat2} a the matrix to rotate
         * @param {Number} rad the angle to rotate the matrix by
         * @returns {mat2} out
         */

        function rotate(out, a, rad) {
          var a0 = a[0],
            a1 = a[1],
            a2 = a[2],
            a3 = a[3];
          var s = Math.sin(rad);
          var c = Math.cos(rad);
          out[0] = a0 * c + a2 * s;
          out[1] = a1 * c + a3 * s;
          out[2] = a0 * -s + a2 * c;
          out[3] = a1 * -s + a3 * c;
          return out;
        }

        /***/
      },
      /* 257 */
      /***/ function (module, exports) {
        module.exports = invert;
        /**
         * Inverts a mat2
         *
         * @alias mat2.invert
         * @param {mat2} out the receiving matrix
         * @param {mat2} a the source matrix
         * @returns {mat2} out
         */

        function invert(out, a) {
          var a0 = a[0];
          var a1 = a[1];
          var a2 = a[2];
          var a3 = a[3];
          var det = a0 * a3 - a2 * a1;
          if (!det) return null;
          det = 1.0 / det;
          out[0] = a3 * det;
          out[1] = -a1 * det;
          out[2] = -a2 * det;
          out[3] = a0 * det;
          return out;
        }

        /***/
      },
      /* 258 */
      /***/ function (module, exports) {
        module.exports = create;
        /**
         * Creates a new identity mat2
         *
         * @alias mat2.create
         * @returns {mat2} a new 2x2 matrix
         */

        function create() {
          var out = new Float32Array(4);
          out[0] = 1;
          out[1] = 0;
          out[2] = 0;
          out[3] = 1;
          return out;
        }

        /***/
      },
      /* 259 */
      /***/ function (module, exports) {
        module.exports = scale;
        /**
         * Scales the mat2 by the dimensions in the given vec2
         *
         * @alias mat2.scale
         * @param {mat2} out the receiving matrix
         * @param {mat2} a the matrix to rotate
         * @param {vec2} v the vec2 to scale the matrix by
         * @returns {mat2} out
         **/

        function scale(out, a, v) {
          var a0 = a[0],
            a1 = a[1],
            a2 = a[2],
            a3 = a[3];
          var v0 = v[0],
            v1 = v[1];
          out[0] = a0 * v0;
          out[1] = a1 * v0;
          out[2] = a2 * v1;
          out[3] = a3 * v1;
          return out;
        }

        /***/
      },
      /* 260 */
      /***/ function (module, exports) {
        module.exports = copy;
        /**
         * Copy the values from one mat2 to another
         *
         * @alias mat2.copy
         * @param {mat2} out the receiving matrix
         * @param {mat2} a the source matrix
         * @returns {mat2} out
         */

        function copy(out, a) {
          out[0] = a[0];
          out[1] = a[1];
          out[2] = a[2];
          out[3] = a[3];
          return out;
        }

        /***/
      },
      /* 261 */
      /***/ function (module, exports) {
        module.exports = frob;
        /**
         * Returns Frobenius norm of a mat2
         *
         * @alias mat2.frob
         * @param {mat2} a the matrix to calculate Frobenius norm of
         * @returns {Number} Frobenius norm
         */

        function frob(a) {
          return Math.sqrt(
            Math.pow(a[0], 2) +
              Math.pow(a[1], 2) +
              Math.pow(a[2], 2) +
              Math.pow(a[3], 2)
          );
        }

        /***/
      },
      /* 262 */
      /***/ function (module, exports) {
        module.exports = ldu;
        /**
         * Returns L, D and U matrices (Lower triangular, Diagonal and Upper triangular) by factorizing the input matrix
         *
         * @alias mat2.ldu
         * @param {mat2} L the lower triangular matrix
         * @param {mat2} D the diagonal matrix
         * @param {mat2} U the upper triangular matrix
         * @param {mat2} a the input matrix to factorize
         */

        function ldu(L, D, U, a) {
          L[2] = a[2] / a[0];
          U[0] = a[0];
          U[1] = a[1];
          U[3] = a[3] - L[2] * U[1];
          return [L, D, U];
        }

        /***/
      },
      /* 263 */
      /***/ function (module, __webpack_exports__, __webpack_require__) {
        "use strict";
        // ESM COMPAT FLAG
        __webpack_require__.r(__webpack_exports__);

        // EXPORTS
        __webpack_require__.d(
          __webpack_exports__,
          "BarcodeDecoder",
          function () {
            return /* reexport */ barcode_decoder;
          }
        );
        __webpack_require__.d(__webpack_exports__, "Readers", function () {
          return /* reexport */ reader_namespaceObject;
        });
        __webpack_require__.d(__webpack_exports__, "CameraAccess", function () {
          return /* reexport */ camera_access;
        });
        __webpack_require__.d(__webpack_exports__, "ImageDebug", function () {
          return /* reexport */ image_debug["a" /* default */];
        });
        __webpack_require__.d(__webpack_exports__, "ImageWrapper", function () {
          return /* reexport */ image_wrapper["a" /* default */];
        });
        __webpack_require__.d(
          __webpack_exports__,
          "ResultCollector",
          function () {
            return /* reexport */ result_collector;
          }
        );

        // NAMESPACE OBJECT: ./src/reader/index.ts
        var reader_namespaceObject = {};
        __webpack_require__.r(reader_namespaceObject);
        __webpack_require__.d(
          reader_namespaceObject,
          "BarcodeReader",
          function () {
            return barcode_reader;
          }
        );
        __webpack_require__.d(
          reader_namespaceObject,
          "TwoOfFiveReader",
          function () {
            return _2of5_reader;
          }
        );
        __webpack_require__.d(
          reader_namespaceObject,
          "NewCodabarReader",
          function () {
            return codabar_reader;
          }
        );
        __webpack_require__.d(
          reader_namespaceObject,
          "Code128Reader",
          function () {
            return code_128_reader;
          }
        );
        __webpack_require__.d(
          reader_namespaceObject,
          "Code32Reader",
          function () {
            return code_32_reader;
          }
        );
        __webpack_require__.d(
          reader_namespaceObject,
          "Code39Reader",
          function () {
            return code_39_reader;
          }
        );
        __webpack_require__.d(
          reader_namespaceObject,
          "Code39VINReader",
          function () {
            return code_39_vin_reader;
          }
        );
        __webpack_require__.d(
          reader_namespaceObject,
          "Code93Reader",
          function () {
            return code_93_reader;
          }
        );
        __webpack_require__.d(
          reader_namespaceObject,
          "EAN2Reader",
          function () {
            return ean_2_reader;
          }
        );
        __webpack_require__.d(
          reader_namespaceObject,
          "EAN5Reader",
          function () {
            return ean_5_reader;
          }
        );
        __webpack_require__.d(
          reader_namespaceObject,
          "EAN8Reader",
          function () {
            return ean_8_reader;
          }
        );
        __webpack_require__.d(reader_namespaceObject, "EANReader", function () {
          return ean_reader;
        });
        __webpack_require__.d(
          reader_namespaceObject,
          "I2of5Reader",
          function () {
            return i2of5_reader;
          }
        );
        __webpack_require__.d(
          reader_namespaceObject,
          "UPCEReader",
          function () {
            return upc_e_reader;
          }
        );
        __webpack_require__.d(reader_namespaceObject, "UPCReader", function () {
          return upc_reader;
        });

        // EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/typeof.js
        var helpers_typeof = __webpack_require__(17);
        var typeof_default =
          /*#__PURE__*/ __webpack_require__.n(helpers_typeof);

        // EXTERNAL MODULE: ./node_modules/lodash/merge.js
        var merge = __webpack_require__(18);
        var merge_default = /*#__PURE__*/ __webpack_require__.n(merge);

        // EXTERNAL MODULE: ./src/common/typedefs.js
        var typedefs = __webpack_require__(152);

        // EXTERNAL MODULE: ./src/common/image_wrapper.ts
        var image_wrapper = __webpack_require__(12);

        // EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/asyncToGenerator.js
        var asyncToGenerator = __webpack_require__(13);
        var asyncToGenerator_default =
          /*#__PURE__*/ __webpack_require__.n(asyncToGenerator);

        // EXTERNAL MODULE: ./node_modules/@babel/runtime/regenerator/index.js
        var regenerator = __webpack_require__(8);
        var regenerator_default =
          /*#__PURE__*/ __webpack_require__.n(regenerator);

        // EXTERNAL MODULE: ./src/common/image_debug.ts
        var image_debug = __webpack_require__(10);

        // EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/classCallCheck.js
        var classCallCheck = __webpack_require__(3);
        var classCallCheck_default =
          /*#__PURE__*/ __webpack_require__.n(classCallCheck);

        // EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/createClass.js
        var createClass = __webpack_require__(4);
        var createClass_default =
          /*#__PURE__*/ __webpack_require__.n(createClass);

        // EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/assertThisInitialized.js
        var assertThisInitialized = __webpack_require__(1);
        var assertThisInitialized_default = /*#__PURE__*/ __webpack_require__.n(
          assertThisInitialized
        );

        // EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/inherits.js
        var inherits = __webpack_require__(6);
        var inherits_default = /*#__PURE__*/ __webpack_require__.n(inherits);

        // EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js
        var possibleConstructorReturn = __webpack_require__(5);
        var possibleConstructorReturn_default =
          /*#__PURE__*/ __webpack_require__.n(possibleConstructorReturn);

        // EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/getPrototypeOf.js
        var getPrototypeOf = __webpack_require__(2);
        var getPrototypeOf_default =
          /*#__PURE__*/ __webpack_require__.n(getPrototypeOf);

        // EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/defineProperty.js
        var defineProperty = __webpack_require__(0);
        var defineProperty_default =
          /*#__PURE__*/ __webpack_require__.n(defineProperty);

        // EXTERNAL MODULE: ./src/common/array_helper.ts
        var array_helper = __webpack_require__(11);

        // CONCATENATED MODULE: ./src/reader/barcode_reader.ts

        /* eslint-disable no-unused-vars */

        /* eslint-disable class-methods-use-this */
        // eslint-disable-next-line import/no-cycle
        // for some reason this throws a shadow error on itself?!
        // eslint-disable-next-line no-shadow

        var BarcodeDirection;

        (function (BarcodeDirection) {
          BarcodeDirection[(BarcodeDirection["Forward"] = 1)] = "Forward";
          BarcodeDirection[(BarcodeDirection["Reverse"] = -1)] = "Reverse";
        })(BarcodeDirection || (BarcodeDirection = {}));

        var barcode_reader_BarcodeReader = /*#__PURE__*/ (function () {
          function BarcodeReader(config, supplements) {
            classCallCheck_default()(this, BarcodeReader);

            defineProperty_default()(this, "_row", []);

            defineProperty_default()(this, "config", {});

            defineProperty_default()(this, "supplements", []);

            defineProperty_default()(this, "SINGLE_CODE_ERROR", 0);

            defineProperty_default()(this, "FORMAT", "unknown");

            defineProperty_default()(this, "CONFIG_KEYS", {});

            this._row = [];
            this.config = config || {};

            if (supplements) {
              this.supplements = supplements;
            }
          }

          createClass_default()(
            BarcodeReader,
            [
              {
                key: "_nextUnset",
                value: function _nextUnset(line) {
                  var start =
                    arguments.length > 1 && arguments[1] !== undefined
                      ? arguments[1]
                      : 0;

                  for (var i = start; i < line.length; i++) {
                    if (!line[i]) return i;
                  }

                  return line.length;
                },
              },
              {
                key: "_matchPattern",
                value: function _matchPattern(counter, code) {
                  var maxSingleError =
                    arguments.length > 2 && arguments[2] !== undefined
                      ? arguments[2]
                      : this.SINGLE_CODE_ERROR || 1;
                  var error = 0;
                  var singleError = 0;
                  var sum = 0;
                  var modulo = 0;
                  var barWidth = 0;
                  var count = 0;
                  var scaled = 0;

                  for (var i = 0; i < counter.length; i++) {
                    sum += counter[i];
                    modulo += code[i];
                  }

                  if (sum < modulo) {
                    return Number.MAX_VALUE;
                  }

                  barWidth = sum / modulo; // eslint-disable-next-line no-param-reassign

                  maxSingleError *= barWidth;

                  for (var _i = 0; _i < counter.length; _i++) {
                    count = counter[_i];
                    scaled = code[_i] * barWidth;
                    singleError = Math.abs(count - scaled) / scaled;

                    if (singleError > maxSingleError) {
                      return Number.MAX_VALUE;
                    }

                    error += singleError;
                  }

                  return error / modulo;
                },
              },
              {
                key: "_nextSet",
                value: function _nextSet(line) {
                  var offset =
                    arguments.length > 1 && arguments[1] !== undefined
                      ? arguments[1]
                      : 0;

                  for (var i = offset; i < line.length; i++) {
                    if (line[i]) return i;
                  }

                  return line.length;
                },
              },
              {
                key: "_correctBars",
                value: function _correctBars(counter, correction, indices) {
                  var length = indices.length;
                  var tmp = 0;

                  while (length--) {
                    tmp = counter[indices[length]] * (1 - (1 - correction) / 2);

                    if (tmp > 1) {
                      // eslint-disable-next-line no-param-reassign
                      counter[indices[length]] = tmp;
                    }
                  }
                },
              },
              {
                key: "decodePattern",
                value: function decodePattern(pattern) {
                  // console.warn('* decodePattern', pattern);
                  this._row = pattern; // console.warn('* decodePattern calling decode', typeof this, this.constructor, this.FORMAT, JSON.stringify(this));

                  var result = this.decode(); // console.warn('* first result=', result);

                  if (result === null) {
                    this._row.reverse();

                    result = this.decode(); // console.warn('* reversed result=', result);

                    if (result) {
                      result.direction = BarcodeDirection.Reverse;
                      result.start = this._row.length - result.start;
                      result.end = this._row.length - result.end;
                    }
                  } else {
                    result.direction = BarcodeDirection.Forward;
                  }

                  if (result) {
                    result.format = this.FORMAT;
                  } // console.warn('* returning', result);

                  return result;
                },
              },
              {
                key: "_matchRange",
                value: function _matchRange(start, end, value) {
                  // eslint-disable-next-line no-param-reassign
                  start = start < 0 ? 0 : start;
                  var i;

                  for (i = start; i < end; i++) {
                    if (this._row[i] !== value) {
                      return false;
                    }
                  }

                  return true;
                },
              },
              {
                key: "_fillCounters",
                value: function _fillCounters() {
                  var offset =
                    arguments.length > 0 && arguments[0] !== undefined
                      ? arguments[0]
                      : this._nextUnset(this._row);
                  var end =
                    arguments.length > 1 && arguments[1] !== undefined
                      ? arguments[1]
                      : this._row.length;
                  var isWhite =
                    arguments.length > 2 && arguments[2] !== undefined
                      ? arguments[2]
                      : true;
                  var counters = [];
                  var counterPos = 0;
                  counters[counterPos] = 0;

                  for (var i = offset; i < end; i++) {
                    // eslint-disable-next-line no-bitwise
                    if (this._row[i] ^ (isWhite ? 1 : 0)) {
                      counters[counterPos]++;
                    } else {
                      counterPos++;
                      counters[counterPos] = 1; // eslint-disable-next-line no-param-reassign

                      isWhite = !isWhite;
                    }
                  }

                  return counters;
                },
              },
              {
                key: "_toCounters",
                value: function _toCounters(start, counters) {
                  var numCounters = counters.length;
                  var end = this._row.length;
                  var isWhite = !this._row[start];
                  var counterPos = 0;
                  array_helper["a" /* default */].init(counters, 0);

                  for (var i = start; i < end; i++) {
                    // eslint-disable-next-line no-bitwise
                    if (this._row[i] ^ (isWhite ? 1 : 0)) {
                      // eslint-disable-next-line no-param-reassign
                      counters[counterPos]++;
                    } else {
                      counterPos++;

                      if (counterPos === numCounters) {
                        break;
                      } else {
                        // eslint-disable-next-line no-param-reassign
                        counters[counterPos] = 1;
                        isWhite = !isWhite;
                      }
                    }
                  }

                  return counters;
                }, // override/implement this in your custom readers.
              },
              {
                key: "decodeImage",
                value: function decodeImage(imageWrapper) {
                  // eslint-disable-next-line no-void
                  void imageWrapper;
                  return null;
                },
              },
            ],
            [
              {
                key: "Exception",
                get: function get() {
                  return {
                    StartNotFoundException: "Start-Info was not found!",
                    CodeNotFoundException: "Code could not be found!",
                    PatternNotFoundException: "Pattern could not be found!",
                  };
                },
              },
            ]
          );

          return BarcodeReader;
        })();
        /* harmony default export */ var barcode_reader =
          barcode_reader_BarcodeReader;
        // CONCATENATED MODULE: ./src/reader/2of5_reader.ts

        function _createSuper(Derived) {
          var hasNativeReflectConstruct = _isNativeReflectConstruct();
          return function _createSuperInternal() {
            var Super = getPrototypeOf_default()(Derived),
              result;
            if (hasNativeReflectConstruct) {
              var NewTarget = getPrototypeOf_default()(this).constructor;
              result = Reflect.construct(Super, arguments, NewTarget);
            } else {
              result = Super.apply(this, arguments);
            }
            return possibleConstructorReturn_default()(this, result);
          };
        }

        function _isNativeReflectConstruct() {
          if (typeof Reflect === "undefined" || !Reflect.construct)
            return false;
          if (Reflect.construct.sham) return false;
          if (typeof Proxy === "function") return true;
          try {
            Boolean.prototype.valueOf.call(
              Reflect.construct(Boolean, [], function () {})
            );
            return true;
          } catch (e) {
            return false;
          }
        }

        var N = 1;
        var W = 3;
        var START_PATTERN = [W, N, W, N, N, N];
        var STOP_PATTERN = [W, N, N, N, W];
        var CODE_PATTERN = [
          [N, N, W, W, N],
          [W, N, N, N, W],
          [N, W, N, N, W],
          [W, W, N, N, N],
          [N, N, W, N, W],
          [W, N, W, N, N],
          [N, W, W, N, N],
          [N, N, N, W, W],
          [W, N, N, W, N],
          [N, W, N, W, N],
        ];
        var START_PATTERN_LENGTH = START_PATTERN.reduce(function (sum, val) {
          return sum + val;
        }, 0);

        var _2of5_reader_TwoOfFiveReader = /*#__PURE__*/ (function (
          _BarcodeReader
        ) {
          inherits_default()(TwoOfFiveReader, _BarcodeReader);

          var _super = _createSuper(TwoOfFiveReader);

          function TwoOfFiveReader() {
            var _this;

            classCallCheck_default()(this, TwoOfFiveReader);

            for (
              var _len = arguments.length, args = new Array(_len), _key = 0;
              _key < _len;
              _key++
            ) {
              args[_key] = arguments[_key];
            }

            _this = _super.call.apply(_super, [this].concat(args));

            defineProperty_default()(
              assertThisInitialized_default()(_this),
              "barSpaceRatio",
              [1, 1]
            );

            defineProperty_default()(
              assertThisInitialized_default()(_this),
              "FORMAT",
              "2of5"
            );

            defineProperty_default()(
              assertThisInitialized_default()(_this),
              "SINGLE_CODE_ERROR",
              0.78
            );

            defineProperty_default()(
              assertThisInitialized_default()(_this),
              "AVG_CODE_ERROR",
              0.3
            );

            return _this;
          }

          createClass_default()(TwoOfFiveReader, [
            {
              key: "_findPattern",
              value: function _findPattern(pattern, offset) {
                var isWhite =
                  arguments.length > 2 && arguments[2] !== undefined
                    ? arguments[2]
                    : false;
                var tryHarder =
                  arguments.length > 3 && arguments[3] !== undefined
                    ? arguments[3]
                    : false;
                var counter = [];
                var counterPos = 0;
                var bestMatch = {
                  error: Number.MAX_VALUE,
                  code: -1,
                  start: 0,
                  end: 0,
                };
                var sum = 0;
                var error = 0;
                var epsilon = this.AVG_CODE_ERROR;

                if (!offset) {
                  offset = this._nextSet(this._row);
                }

                for (var i = 0; i < pattern.length; i++) {
                  counter[i] = 0;
                }

                for (var _i = offset; _i < this._row.length; _i++) {
                  if (this._row[_i] ^ (isWhite ? 1 : 0)) {
                    counter[counterPos]++;
                  } else {
                    if (counterPos === counter.length - 1) {
                      sum = 0;

                      for (var j = 0; j < counter.length; j++) {
                        sum += counter[j];
                      }

                      error = this._matchPattern(counter, pattern);

                      if (error < epsilon) {
                        bestMatch.error = error;
                        bestMatch.start = _i - sum;
                        bestMatch.end = _i;
                        return bestMatch;
                      }

                      if (tryHarder) {
                        for (var _j = 0; _j < counter.length - 2; _j++) {
                          counter[_j] = counter[_j + 2];
                        }

                        counter[counter.length - 2] = 0;
                        counter[counter.length - 1] = 0;
                        counterPos--;
                      } else {
                        return null;
                      }
                    } else {
                      counterPos++;
                    }

                    counter[counterPos] = 1;
                    isWhite = !isWhite;
                  }
                }

                return null;
              },
            },
            {
              key: "_findStart",
              value: function _findStart() {
                var startInfo = null;

                var offset = this._nextSet(this._row);

                var narrowBarWidth = 1;
                var leadingWhitespaceStart = 0;

                while (!startInfo) {
                  startInfo = this._findPattern(
                    START_PATTERN,
                    offset,
                    false,
                    true
                  );

                  if (!startInfo) {
                    return null;
                  }

                  narrowBarWidth = Math.floor(
                    (startInfo.end - startInfo.start) / START_PATTERN_LENGTH
                  );
                  leadingWhitespaceStart = startInfo.start - narrowBarWidth * 5;

                  if (leadingWhitespaceStart >= 0) {
                    if (
                      this._matchRange(
                        leadingWhitespaceStart,
                        startInfo.start,
                        0
                      )
                    ) {
                      return startInfo;
                    }
                  }

                  offset = startInfo.end;
                  startInfo = null;
                }

                return startInfo;
              },
            },
            {
              key: "_verifyTrailingWhitespace",
              value: function _verifyTrailingWhitespace(endInfo) {
                var trailingWhitespaceEnd =
                  endInfo.end + (endInfo.end - endInfo.start) / 2;

                if (trailingWhitespaceEnd < this._row.length) {
                  if (this._matchRange(endInfo.end, trailingWhitespaceEnd, 0)) {
                    return endInfo;
                  }
                }

                return null;
              },
            },
            {
              key: "_findEnd",
              value: function _findEnd() {
                // TODO: reverse, followed by some calcs, followed by another reverse? really?
                this._row.reverse();

                var offset = this._nextSet(this._row);

                var endInfo = this._findPattern(
                  STOP_PATTERN,
                  offset,
                  false,
                  true
                );

                this._row.reverse();

                if (endInfo === null) {
                  return null;
                } // reverse numbers

                var tmp = endInfo.start;
                endInfo.start = this._row.length - endInfo.end;
                endInfo.end = this._row.length - tmp;
                return endInfo !== null
                  ? this._verifyTrailingWhitespace(endInfo)
                  : null;
              },
            },
            {
              key: "_verifyCounterLength",
              value: function _verifyCounterLength(counters) {
                return counters.length % 10 === 0;
              },
            },
            {
              key: "_decodeCode",
              value: function _decodeCode(counter) {
                var epsilon = this.AVG_CODE_ERROR;
                var bestMatch = {
                  error: Number.MAX_VALUE,
                  code: -1,
                  start: 0,
                  end: 0,
                };

                for (var code = 0; code < CODE_PATTERN.length; code++) {
                  var error = this._matchPattern(counter, CODE_PATTERN[code]);

                  if (error < bestMatch.error) {
                    bestMatch.code = code;
                    bestMatch.error = error;
                  }
                }

                if (bestMatch.error < epsilon) {
                  return bestMatch;
                }

                return null;
              },
            },
            {
              key: "_decodePayload",
              value: function _decodePayload(counters, result, decodedCodes) {
                var pos = 0;
                var counterLength = counters.length;
                var counter = [0, 0, 0, 0, 0];
                var code = null;

                while (pos < counterLength) {
                  for (var i = 0; i < 5; i++) {
                    counter[i] = counters[pos] * this.barSpaceRatio[0];
                    pos += 2;
                  }

                  code = this._decodeCode(counter);

                  if (!code) {
                    return null;
                  }

                  result.push("".concat(code.code));
                  decodedCodes.push(code);
                }

                return code;
              },
            },
            {
              key: "decode",
              value: function decode(row, start) {
                var startInfo = this._findStart();

                if (!startInfo) {
                  return null;
                }

                var endInfo = this._findEnd();

                if (!endInfo) {
                  return null;
                }

                var counters = this._fillCounters(
                  startInfo.end,
                  endInfo.start,
                  false
                );

                if (!this._verifyCounterLength(counters)) {
                  return null;
                }

                var decodedCodes = [];
                decodedCodes.push(startInfo);
                var result = [];

                var code = this._decodePayload(counters, result, decodedCodes);

                if (!code) {
                  return null;
                }

                if (result.length < 5) {
                  return null;
                }

                decodedCodes.push(endInfo);
                return {
                  code: result.join(""),
                  start: startInfo.start,
                  end: endInfo.end,
                  startInfo: startInfo,
                  decodedCodes: decodedCodes,
                  format: this.FORMAT,
                };
              },
            },
          ]);

          return TwoOfFiveReader;
        })(barcode_reader);

        /* harmony default export */ var _2of5_reader =
          _2of5_reader_TwoOfFiveReader;
        // CONCATENATED MODULE: ./src/reader/codabar_reader.ts

        function codabar_reader_createSuper(Derived) {
          var hasNativeReflectConstruct =
            codabar_reader_isNativeReflectConstruct();
          return function _createSuperInternal() {
            var Super = getPrototypeOf_default()(Derived),
              result;
            if (hasNativeReflectConstruct) {
              var NewTarget = getPrototypeOf_default()(this).constructor;
              result = Reflect.construct(Super, arguments, NewTarget);
            } else {
              result = Super.apply(this, arguments);
            }
            return possibleConstructorReturn_default()(this, result);
          };
        }

        function codabar_reader_isNativeReflectConstruct() {
          if (typeof Reflect === "undefined" || !Reflect.construct)
            return false;
          if (Reflect.construct.sham) return false;
          if (typeof Proxy === "function") return true;
          try {
            Boolean.prototype.valueOf.call(
              Reflect.construct(Boolean, [], function () {})
            );
            return true;
          } catch (e) {
            return false;
          }
        }

        // const ALPHABETH_STRING = '0123456789-$:/.+ABCD';

        var ALPHABET = [
          48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 45, 36, 58, 47, 46, 43, 65,
          66, 67, 68,
        ];
        var CHARACTER_ENCODINGS = [
          0x003, 0x006, 0x009, 0x060, 0x012, 0x042, 0x021, 0x024, 0x030, 0x048,
          0x00c, 0x018, 0x045, 0x051, 0x054, 0x015, 0x01a, 0x029, 0x00b, 0x00e,
        ];
        var START_END = [0x01a, 0x029, 0x00b, 0x00e];
        var MIN_ENCODED_CHARS = 4;
        var MAX_ACCEPTABLE = 2.0;
        var PADDING = 1.5;
        var codabar_reader_NewCodabarReader = /*#__PURE__*/ (function (
          _BarcodeReader
        ) {
          inherits_default()(NewCodabarReader, _BarcodeReader);

          var _super = codabar_reader_createSuper(NewCodabarReader);

          function NewCodabarReader() {
            var _this;

            classCallCheck_default()(this, NewCodabarReader);

            for (
              var _len = arguments.length, args = new Array(_len), _key = 0;
              _key < _len;
              _key++
            ) {
              args[_key] = arguments[_key];
            }

            _this = _super.call.apply(_super, [this].concat(args));

            defineProperty_default()(
              assertThisInitialized_default()(_this),
              "_counters",
              []
            );

            defineProperty_default()(
              assertThisInitialized_default()(_this),
              "FORMAT",
              "codabar"
            );

            return _this;
          }

          createClass_default()(NewCodabarReader, [
            {
              key: "_computeAlternatingThreshold",
              value: function _computeAlternatingThreshold(offset, end) {
                var min = Number.MAX_VALUE;
                var max = 0;
                var counter = 0;

                for (var i = offset; i < end; i += 2) {
                  counter = this._counters[i];

                  if (counter > max) {
                    max = counter;
                  }

                  if (counter < min) {
                    min = counter;
                  }
                }

                return ((min + max) / 2.0) | 0;
              },
            },
            {
              key: "_toPattern",
              value: function _toPattern(offset) {
                var numCounters = 7;
                var end = offset + numCounters;

                if (end > this._counters.length) {
                  return -1;
                }

                var barThreshold = this._computeAlternatingThreshold(
                  offset,
                  end
                );

                var spaceThreshold = this._computeAlternatingThreshold(
                  offset + 1,
                  end
                );

                var bitmask = 1 << (numCounters - 1);
                var threshold = 0;
                var pattern = 0;

                for (var i = 0; i < numCounters; i++) {
                  threshold = (i & 1) === 0 ? barThreshold : spaceThreshold;

                  if (this._counters[offset + i] > threshold) {
                    pattern |= bitmask;
                  }

                  bitmask >>= 1;
                }

                return pattern;
              },
            },
            {
              key: "_isStartEnd",
              value: function _isStartEnd(pattern) {
                for (var i = 0; i < START_END.length; i++) {
                  if (START_END[i] === pattern) {
                    return true;
                  }
                }

                return false;
              },
            },
            {
              key: "_sumCounters",
              value: function _sumCounters(start, end) {
                var sum = 0;

                for (var i = start; i < end; i++) {
                  sum += this._counters[i];
                }

                return sum;
              },
            },
            {
              key: "_findStart",
              value: function _findStart() {
                var start = this._nextUnset(this._row);

                var end = start;

                for (var i = 1; i < this._counters.length; i++) {
                  var pattern = this._toPattern(i);

                  if (pattern !== -1 && this._isStartEnd(pattern)) {
                    // TODO: Look for whitespace ahead
                    start += this._sumCounters(0, i);
                    end = start + this._sumCounters(i, i + 8);
                    return {
                      start: start,
                      end: end,
                      startCounter: i,
                      endCounter: i + 8,
                    };
                  }
                }

                return null;
              },
            },
            {
              key: "_patternToChar",
              value: function _patternToChar(pattern) {
                for (var i = 0; i < CHARACTER_ENCODINGS.length; i++) {
                  if (CHARACTER_ENCODINGS[i] === pattern) {
                    return String.fromCharCode(ALPHABET[i]);
                  }
                }

                return null;
              },
            },
            {
              key: "_calculatePatternLength",
              value: function _calculatePatternLength(offset) {
                var sum = 0;

                for (var i = offset; i < offset + 7; i++) {
                  sum += this._counters[i];
                }

                return sum;
              },
            },
            {
              key: "_verifyWhitespace",
              value: function _verifyWhitespace(startCounter, endCounter) {
                if (
                  startCounter - 1 <= 0 ||
                  this._counters[startCounter - 1] >=
                    this._calculatePatternLength(startCounter) / 2.0
                ) {
                  if (
                    endCounter + 8 >= this._counters.length ||
                    this._counters[endCounter + 7] >=
                      this._calculatePatternLength(endCounter) / 2.0
                  ) {
                    return true;
                  }
                }

                return false;
              },
            },
            {
              key: "_charToPattern",
              value: function _charToPattern(_char) {
                var charCode = _char.charCodeAt(0);

                for (var i = 0; i < ALPHABET.length; i++) {
                  if (ALPHABET[i] === charCode) {
                    return CHARACTER_ENCODINGS[i];
                  }
                }

                return 0x0;
              },
            },
            {
              key: "_thresholdResultPattern",
              value: function _thresholdResultPattern(result, startCounter) {
                var categorization = {
                  space: {
                    narrow: {
                      size: 0,
                      counts: 0,
                      min: 0,
                      max: Number.MAX_VALUE,
                    },
                    wide: {
                      size: 0,
                      counts: 0,
                      min: 0,
                      max: Number.MAX_VALUE,
                    },
                  },
                  bar: {
                    narrow: {
                      size: 0,
                      counts: 0,
                      min: 0,
                      max: Number.MAX_VALUE,
                    },
                    wide: {
                      size: 0,
                      counts: 0,
                      min: 0,
                      max: Number.MAX_VALUE,
                    },
                  },
                };
                var pos = startCounter;
                var pattern;

                for (var i = 0; i < result.length; i++) {
                  pattern = this._charToPattern(result[i]);

                  for (var j = 6; j >= 0; j--) {
                    var kind =
                      (j & 1) === 2 ? categorization.bar : categorization.space;
                    var cat = (pattern & 1) === 1 ? kind.wide : kind.narrow;
                    cat.size += this._counters[pos + j];
                    cat.counts++;
                    pattern >>= 1;
                  }

                  pos += 8;
                }

                ["space", "bar"].forEach(function (key) {
                  var newkind = categorization[key];
                  newkind.wide.min = Math.floor(
                    (newkind.narrow.size / newkind.narrow.counts +
                      newkind.wide.size / newkind.wide.counts) /
                      2
                  );
                  newkind.narrow.max = Math.ceil(newkind.wide.min);
                  newkind.wide.max = Math.ceil(
                    (newkind.wide.size * MAX_ACCEPTABLE + PADDING) /
                      newkind.wide.counts
                  );
                });
                return categorization;
              },
            },
            {
              key: "_validateResult",
              value: function _validateResult(result, startCounter) {
                var thresholds = this._thresholdResultPattern(
                  result,
                  startCounter
                );

                var pos = startCounter;
                var pattern;

                for (var i = 0; i < result.length; i++) {
                  pattern = this._charToPattern(result[i]);

                  for (var j = 6; j >= 0; j--) {
                    var kind =
                      (j & 1) === 0 ? thresholds.bar : thresholds.space;
                    var cat = (pattern & 1) === 1 ? kind.wide : kind.narrow;
                    var size = this._counters[pos + j];

                    if (size < cat.min || size > cat.max) {
                      return false;
                    }

                    pattern >>= 1;
                  }

                  pos += 8;
                }

                return true;
              },
            },
            {
              key: "decode",
              value: function decode(row, start) {
                this._counters = this._fillCounters();
                start = this._findStart();

                if (!start) {
                  return null;
                }

                var nextStart = start.startCounter;
                var result = [];
                var pattern;

                do {
                  pattern = this._toPattern(nextStart);

                  if (pattern < 0) {
                    return null;
                  }

                  var decodedChar = this._patternToChar(pattern);

                  if (decodedChar === null) {
                    return null;
                  }

                  result.push(decodedChar);
                  nextStart += 8;

                  if (result.length > 1 && this._isStartEnd(pattern)) {
                    break;
                  }
                } while (nextStart < this._counters.length); // verify end

                if (
                  result.length - 2 < MIN_ENCODED_CHARS ||
                  !this._isStartEnd(pattern)
                ) {
                  return null;
                } // verify end white space

                if (
                  !this._verifyWhitespace(start.startCounter, nextStart - 8)
                ) {
                  return null;
                }

                if (!this._validateResult(result, start.startCounter)) {
                  return null;
                }

                nextStart =
                  nextStart > this._counters.length
                    ? this._counters.length
                    : nextStart;

                var end =
                  start.start +
                  this._sumCounters(start.startCounter, nextStart - 8);

                return {
                  code: result.join(""),
                  start: start.start,
                  end: end,
                  startInfo: start,
                  decodedCodes: result,
                  format: this.FORMAT, // TODO: i think it should not be required to return format from this, as barcode_reader force sets the format anyway
                };
              },
            },
          ]);

          return NewCodabarReader;
        })(barcode_reader);

        /* harmony default export */ var codabar_reader =
          codabar_reader_NewCodabarReader;
        // CONCATENATED MODULE: ./src/reader/code_128_reader.ts

        function code_128_reader_createSuper(Derived) {
          var hasNativeReflectConstruct =
            code_128_reader_isNativeReflectConstruct();
          return function _createSuperInternal() {
            var Super = getPrototypeOf_default()(Derived),
              result;
            if (hasNativeReflectConstruct) {
              var NewTarget = getPrototypeOf_default()(this).constructor;
              result = Reflect.construct(Super, arguments, NewTarget);
            } else {
              result = Super.apply(this, arguments);
            }
            return possibleConstructorReturn_default()(this, result);
          };
        }

        function code_128_reader_isNativeReflectConstruct() {
          if (typeof Reflect === "undefined" || !Reflect.construct)
            return false;
          if (Reflect.construct.sham) return false;
          if (typeof Proxy === "function") return true;
          try {
            Boolean.prototype.valueOf.call(
              Reflect.construct(Boolean, [], function () {})
            );
            return true;
          } catch (e) {
            return false;
          }
        }

        var code_128_reader_Code128Reader = /*#__PURE__*/ (function (
          _BarcodeReader
        ) {
          inherits_default()(Code128Reader, _BarcodeReader);

          var _super = code_128_reader_createSuper(Code128Reader);

          function Code128Reader() {
            var _this;

            classCallCheck_default()(this, Code128Reader);

            for (
              var _len = arguments.length, args = new Array(_len), _key = 0;
              _key < _len;
              _key++
            ) {
              args[_key] = arguments[_key];
            }

            _this = _super.call.apply(_super, [this].concat(args));

            defineProperty_default()(
              assertThisInitialized_default()(_this),
              "CODE_SHIFT",
              98
            );

            defineProperty_default()(
              assertThisInitialized_default()(_this),
              "CODE_C",
              99
            );

            defineProperty_default()(
              assertThisInitialized_default()(_this),
              "CODE_B",
              100
            );

            defineProperty_default()(
              assertThisInitialized_default()(_this),
              "CODE_A",
              101
            );

            defineProperty_default()(
              assertThisInitialized_default()(_this),
              "START_CODE_A",
              103
            );

            defineProperty_default()(
              assertThisInitialized_default()(_this),
              "START_CODE_B",
              104
            );

            defineProperty_default()(
              assertThisInitialized_default()(_this),
              "START_CODE_C",
              105
            );

            defineProperty_default()(
              assertThisInitialized_default()(_this),
              "STOP_CODE",
              106
            );

            defineProperty_default()(
              assertThisInitialized_default()(_this),
              "CODE_PATTERN",
              [
                [2, 1, 2, 2, 2, 2],
                [2, 2, 2, 1, 2, 2],
                [2, 2, 2, 2, 2, 1],
                [1, 2, 1, 2, 2, 3],
                [1, 2, 1, 3, 2, 2],
                [1, 3, 1, 2, 2, 2],
                [1, 2, 2, 2, 1, 3],
                [1, 2, 2, 3, 1, 2],
                [1, 3, 2, 2, 1, 2],
                [2, 2, 1, 2, 1, 3],
                [2, 2, 1, 3, 1, 2],
                [2, 3, 1, 2, 1, 2],
                [1, 1, 2, 2, 3, 2],
                [1, 2, 2, 1, 3, 2],
                [1, 2, 2, 2, 3, 1],
                [1, 1, 3, 2, 2, 2],
                [1, 2, 3, 1, 2, 2],
                [1, 2, 3, 2, 2, 1],
                [2, 2, 3, 2, 1, 1],
                [2, 2, 1, 1, 3, 2],
                [2, 2, 1, 2, 3, 1],
                [2, 1, 3, 2, 1, 2],
                [2, 2, 3, 1, 1, 2],
                [3, 1, 2, 1, 3, 1],
                [3, 1, 1, 2, 2, 2],
                [3, 2, 1, 1, 2, 2],
                [3, 2, 1, 2, 2, 1],
                [3, 1, 2, 2, 1, 2],
                [3, 2, 2, 1, 1, 2],
                [3, 2, 2, 2, 1, 1],
                [2, 1, 2, 1, 2, 3],
                [2, 1, 2, 3, 2, 1],
                [2, 3, 2, 1, 2, 1],
                [1, 1, 1, 3, 2, 3],
                [1, 3, 1, 1, 2, 3],
                [1, 3, 1, 3, 2, 1],
                [1, 1, 2, 3, 1, 3],
                [1, 3, 2, 1, 1, 3],
                [1, 3, 2, 3, 1, 1],
                [2, 1, 1, 3, 1, 3],
                [2, 3, 1, 1, 1, 3],
                [2, 3, 1, 3, 1, 1],
                [1, 1, 2, 1, 3, 3],
                [1, 1, 2, 3, 3, 1],
                [1, 3, 2, 1, 3, 1],
                [1, 1, 3, 1, 2, 3],
                [1, 1, 3, 3, 2, 1],
                [1, 3, 3, 1, 2, 1],
                [3, 1, 3, 1, 2, 1],
                [2, 1, 1, 3, 3, 1],
                [2, 3, 1, 1, 3, 1],
                [2, 1, 3, 1, 1, 3],
                [2, 1, 3, 3, 1, 1],
                [2, 1, 3, 1, 3, 1],
                [3, 1, 1, 1, 2, 3],
                [3, 1, 1, 3, 2, 1],
                [3, 3, 1, 1, 2, 1],
                [3, 1, 2, 1, 1, 3],
                [3, 1, 2, 3, 1, 1],
                [3, 3, 2, 1, 1, 1],
                [3, 1, 4, 1, 1, 1],
                [2, 2, 1, 4, 1, 1],
                [4, 3, 1, 1, 1, 1],
                [1, 1, 1, 2, 2, 4],
                [1, 1, 1, 4, 2, 2],
                [1, 2, 1, 1, 2, 4],
                [1, 2, 1, 4, 2, 1],
                [1, 4, 1, 1, 2, 2],
                [1, 4, 1, 2, 2, 1],
                [1, 1, 2, 2, 1, 4],
                [1, 1, 2, 4, 1, 2],
                [1, 2, 2, 1, 1, 4],
                [1, 2, 2, 4, 1, 1],
                [1, 4, 2, 1, 1, 2],
                [1, 4, 2, 2, 1, 1],
                [2, 4, 1, 2, 1, 1],
                [2, 2, 1, 1, 1, 4],
                [4, 1, 3, 1, 1, 1],
                [2, 4, 1, 1, 1, 2],
                [1, 3, 4, 1, 1, 1],
                [1, 1, 1, 2, 4, 2],
                [1, 2, 1, 1, 4, 2],
                [1, 2, 1, 2, 4, 1],
                [1, 1, 4, 2, 1, 2],
                [1, 2, 4, 1, 1, 2],
                [1, 2, 4, 2, 1, 1],
                [4, 1, 1, 2, 1, 2],
                [4, 2, 1, 1, 1, 2],
                [4, 2, 1, 2, 1, 1],
                [2, 1, 2, 1, 4, 1],
                [2, 1, 4, 1, 2, 1],
                [4, 1, 2, 1, 2, 1],
                [1, 1, 1, 1, 4, 3],
                [1, 1, 1, 3, 4, 1],
                [1, 3, 1, 1, 4, 1],
                [1, 1, 4, 1, 1, 3],
                [1, 1, 4, 3, 1, 1],
                [4, 1, 1, 1, 1, 3],
                [4, 1, 1, 3, 1, 1],
                [1, 1, 3, 1, 4, 1],
                [1, 1, 4, 1, 3, 1],
                [3, 1, 1, 1, 4, 1],
                [4, 1, 1, 1, 3, 1],
                [2, 1, 1, 4, 1, 2],
                [2, 1, 1, 2, 1, 4],
                [2, 1, 1, 2, 3, 2],
                [2, 3, 3, 1, 1, 1, 2],
              ]
            );

            defineProperty_default()(
              assertThisInitialized_default()(_this),
              "SINGLE_CODE_ERROR",
              0.64
            );

            defineProperty_default()(
              assertThisInitialized_default()(_this),
              "AVG_CODE_ERROR",
              0.3
            );

            defineProperty_default()(
              assertThisInitialized_default()(_this),
              "FORMAT",
              "code_128"
            );

            defineProperty_default()(
              assertThisInitialized_default()(_this),
              "MODULE_INDICES",
              {
                bar: [0, 2, 4],
                space: [1, 3, 5],
              }
            );

            return _this;
          }

          createClass_default()(Code128Reader, [
            {
              key: "_decodeCode",
              value: function _decodeCode(start, correction) {
                var bestMatch = {
                  error: Number.MAX_VALUE,
                  code: -1,
                  start: start,
                  end: start,
                  correction: {
                    bar: 1,
                    space: 1,
                  },
                };
                var counter = [0, 0, 0, 0, 0, 0];
                var offset = start;
                var isWhite = !this._row[offset];
                var counterPos = 0;

                for (var i = offset; i < this._row.length; i++) {
                  if (this._row[i] ^ (isWhite ? 1 : 0)) {
                    counter[counterPos]++;
                  } else {
                    if (counterPos === counter.length - 1) {
                      if (correction) {
                        this._correct(counter, correction);
                      }

                      for (
                        var code = 0;
                        code < this.CODE_PATTERN.length;
                        code++
                      ) {
                        var error = this._matchPattern(
                          counter,
                          this.CODE_PATTERN[code]
                        );

                        if (error < bestMatch.error) {
                          bestMatch.code = code;
                          bestMatch.error = error;
                        }
                      }

                      bestMatch.end = i;

                      if (
                        bestMatch.code === -1 ||
                        bestMatch.error > this.AVG_CODE_ERROR
                      ) {
                        return null;
                      }

                      if (this.CODE_PATTERN[bestMatch.code]) {
                        bestMatch.correction.bar = this.calculateCorrection(
                          this.CODE_PATTERN[bestMatch.code],
                          counter,
                          this.MODULE_INDICES.bar
                        );
                        bestMatch.correction.space = this.calculateCorrection(
                          this.CODE_PATTERN[bestMatch.code],
                          counter,
                          this.MODULE_INDICES.space
                        );
                      }

                      return bestMatch;
                    } else {
                      counterPos++;
                    }

                    counter[counterPos] = 1;
                    isWhite = !isWhite;
                  }
                }

                return null;
              },
            },
            {
              key: "_correct",
              value: function _correct(counter, correction) {
                this._correctBars(
                  counter,
                  correction.bar,
                  this.MODULE_INDICES.bar
                );

                this._correctBars(
                  counter,
                  correction.space,
                  this.MODULE_INDICES.space
                );
              },
            },
            {
              key: "_findStart",
              // TODO: _findStart and decodeCode share similar code, can we re-use some?
              value: function _findStart() {
                var counter = [0, 0, 0, 0, 0, 0];

                var offset = this._nextSet(this._row);

                var bestMatch = {
                  error: Number.MAX_VALUE,
                  code: -1,
                  start: 0,
                  end: 0,
                  correction: {
                    bar: 1,
                    space: 1,
                  },
                };
                var isWhite = false;
                var counterPos = 0;

                for (var i = offset; i < this._row.length; i++) {
                  if (this._row[i] ^ (isWhite ? 1 : 0)) {
                    counter[counterPos]++;
                  } else {
                    if (counterPos === counter.length - 1) {
                      var sum = counter.reduce(function (prev, next) {
                        return prev + next;
                      }, 0);

                      for (
                        var code = this.START_CODE_A;
                        code <= this.START_CODE_C;
                        code++
                      ) {
                        var error = this._matchPattern(
                          counter,
                          this.CODE_PATTERN[code]
                        );

                        if (error < bestMatch.error) {
                          bestMatch.code = code;
                          bestMatch.error = error;
                        }
                      }

                      if (bestMatch.error < this.AVG_CODE_ERROR) {
                        bestMatch.start = i - sum;
                        bestMatch.end = i;
                        bestMatch.correction.bar = this.calculateCorrection(
                          this.CODE_PATTERN[bestMatch.code],
                          counter,
                          this.MODULE_INDICES.bar
                        );
                        bestMatch.correction.space = this.calculateCorrection(
                          this.CODE_PATTERN[bestMatch.code],
                          counter,
                          this.MODULE_INDICES.space
                        );
                        return bestMatch;
                      }

                      for (var j = 0; j < 4; j++) {
                        counter[j] = counter[j + 2];
                      }

                      counter[4] = 0;
                      counter[5] = 0;
                      counterPos--;
                    } else {
                      counterPos++;
                    }

                    counter[counterPos] = 1;
                    isWhite = !isWhite;
                  }
                }

                return null;
              },
            },
            {
              key: "decode",
              value: function decode(row, start) {
                var _this2 = this;

                var startInfo = this._findStart();

                if (startInfo === null) {
                  return null;
                } // var self = this,
                //     done = false,
                //     result = [],
                //     multiplier = 0,
                //     checksum = 0,
                //     codeset,
                //     rawResult = [],
                //     decodedCodes = [],
                //     shiftNext = false,
                //     unshift,
                //     removeLastCharacter = true;

                var code = {
                  code: startInfo.code,
                  start: startInfo.start,
                  end: startInfo.end,
                  correction: {
                    bar: startInfo.correction.bar,
                    space: startInfo.correction.space,
                  },
                };
                var decodedCodes = [];
                decodedCodes.push(code);
                var checksum = code.code;

                var codeset = (function (c) {
                  switch (c) {
                    case _this2.START_CODE_A:
                      return _this2.CODE_A;

                    case _this2.START_CODE_B:
                      return _this2.CODE_B;

                    case _this2.START_CODE_C:
                      return _this2.CODE_C;

                    default:
                      return null;
                  }
                })(code.code);

                var done = false;
                var shiftNext = false;
                var unshift = shiftNext;
                var removeLastCharacter = true;
                var multiplier = 0;
                var rawResult = [];
                var result = []; // TODO: i think this should be string only, but it creates problems if it is

                while (!done) {
                  unshift = shiftNext;
                  shiftNext = false;
                  code = this._decodeCode(code.end, code.correction);

                  if (code !== null) {
                    if (code.code !== this.STOP_CODE) {
                      removeLastCharacter = true;
                    }

                    if (code.code !== this.STOP_CODE) {
                      rawResult.push(code.code);
                      multiplier++;
                      checksum += multiplier * code.code;
                    }

                    decodedCodes.push(code);

                    switch (codeset) {
                      case this.CODE_A:
                        if (code.code < 64) {
                          result.push(String.fromCharCode(32 + code.code));
                        } else if (code.code < 96) {
                          result.push(String.fromCharCode(code.code - 64));
                        } else {
                          if (code.code !== this.STOP_CODE) {
                            removeLastCharacter = false;
                          }

                          switch (code.code) {
                            case this.CODE_SHIFT:
                              shiftNext = true;
                              codeset = this.CODE_B;
                              break;

                            case this.CODE_B:
                              codeset = this.CODE_B;
                              break;

                            case this.CODE_C:
                              codeset = this.CODE_C;
                              break;

                            case this.STOP_CODE:
                              done = true;
                              break;
                          }
                        }

                        break;

                      case this.CODE_B:
                        if (code.code < 96) {
                          result.push(String.fromCharCode(32 + code.code));
                        } else {
                          if (code.code !== this.STOP_CODE) {
                            removeLastCharacter = false;
                          }

                          switch (code.code) {
                            case this.CODE_SHIFT:
                              shiftNext = true;
                              codeset = this.CODE_A;
                              break;

                            case this.CODE_A:
                              codeset = this.CODE_A;
                              break;

                            case this.CODE_C:
                              codeset = this.CODE_C;
                              break;

                            case this.STOP_CODE:
                              done = true;
                              break;
                          }
                        }

                        break;

                      case this.CODE_C:
                        if (code.code < 100) {
                          result.push(
                            code.code < 10 ? "0" + code.code : code.code
                          );
                        } else {
                          if (code.code !== this.STOP_CODE) {
                            removeLastCharacter = false;
                          }

                          switch (code.code) {
                            case this.CODE_A:
                              codeset = this.CODE_A;
                              break;

                            case this.CODE_B:
                              codeset = this.CODE_B;
                              break;

                            case this.STOP_CODE:
                              done = true;
                              break;
                          }
                        }

                        break;
                    }
                  } else {
                    done = true;
                  }

                  if (unshift) {
                    codeset =
                      codeset === this.CODE_A ? this.CODE_B : this.CODE_A;
                  }
                }

                if (code === null) {
                  return null;
                }

                code.end = this._nextUnset(this._row, code.end);

                if (!this._verifyTrailingWhitespace(code)) {
                  return null;
                }

                checksum -= multiplier * rawResult[rawResult.length - 1];

                if (checksum % 103 !== rawResult[rawResult.length - 1]) {
                  return null;
                }

                if (!result.length) {
                  return null;
                } // remove last code from result (checksum)

                if (removeLastCharacter) {
                  result.splice(result.length - 1, 1);
                }

                return {
                  code: result.join(""),
                  start: startInfo.start,
                  end: code.end,
                  codeset: codeset,
                  startInfo: startInfo,
                  decodedCodes: decodedCodes,
                  endInfo: code,
                  format: this.FORMAT,
                };
              },
            },
            {
              key: "_verifyTrailingWhitespace",
              value: function _verifyTrailingWhitespace(endInfo) {
                var self = this,
                  trailingWhitespaceEnd;
                trailingWhitespaceEnd =
                  endInfo.end + (endInfo.end - endInfo.start) / 2;

                if (trailingWhitespaceEnd < self._row.length) {
                  if (self._matchRange(endInfo.end, trailingWhitespaceEnd, 0)) {
                    return endInfo;
                  }
                }

                return null;
              },
            },
            {
              key: "calculateCorrection",
              value: function calculateCorrection(
                expected,
                normalized,
                indices
              ) {
                var length = indices.length,
                  sumNormalized = 0,
                  sumExpected = 0;

                while (length--) {
                  sumExpected += expected[indices[length]];
                  sumNormalized += normalized[indices[length]];
                }

                return sumExpected / sumNormalized;
              },
            },
          ]);

          return Code128Reader;
        })(barcode_reader);

        /* harmony default export */ var code_128_reader =
          code_128_reader_Code128Reader;
        // EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/get.js
        var get = __webpack_require__(14);
        var get_default = /*#__PURE__*/ __webpack_require__.n(get);

        // EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/toConsumableArray.js
        var toConsumableArray = __webpack_require__(33);
        var toConsumableArray_default =
          /*#__PURE__*/ __webpack_require__.n(toConsumableArray);

        // CONCATENATED MODULE: ./src/reader/code_39_reader.ts

        function code_39_reader_createSuper(Derived) {
          var hasNativeReflectConstruct =
            code_39_reader_isNativeReflectConstruct();
          return function _createSuperInternal() {
            var Super = getPrototypeOf_default()(Derived),
              result;
            if (hasNativeReflectConstruct) {
              var NewTarget = getPrototypeOf_default()(this).constructor;
              result = Reflect.construct(Super, arguments, NewTarget);
            } else {
              result = Super.apply(this, arguments);
            }
            return possibleConstructorReturn_default()(this, result);
          };
        }

        function code_39_reader_isNativeReflectConstruct() {
          if (typeof Reflect === "undefined" || !Reflect.construct)
            return false;
          if (Reflect.construct.sham) return false;
          if (typeof Proxy === "function") return true;
          try {
            Boolean.prototype.valueOf.call(
              Reflect.construct(Boolean, [], function () {})
            );
            return true;
          } catch (e) {
            return false;
          }
        }

        /* eslint-disable class-methods-use-this */

        var ALPHABETH_STRING = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ-. *$/+%";
        var code_39_reader_ALPHABET = new Uint16Array(
          toConsumableArray_default()(ALPHABETH_STRING).map(function (_char) {
            return _char.charCodeAt(0);
          })
        );
        var code_39_reader_CHARACTER_ENCODINGS = new Uint16Array([
          0x034, 0x121, 0x061, 0x160, 0x031, 0x130, 0x070, 0x025, 0x124, 0x064,
          0x109, 0x049, 0x148, 0x019, 0x118, 0x058, 0x00d, 0x10c, 0x04c, 0x01c,
          0x103, 0x043, 0x142, 0x013, 0x112, 0x052, 0x007, 0x106, 0x046, 0x016,
          0x181, 0x0c1, 0x1c0, 0x091, 0x190, 0x0d0, 0x085, 0x184, 0x0c4, 0x094,
          0x0a8, 0x0a2, 0x08a, 0x02a,
        ]);
        var ASTERISK = 0x094;

        var code_39_reader_Code39Reader = /*#__PURE__*/ (function (
          _BarcodeReader
        ) {
          inherits_default()(Code39Reader, _BarcodeReader);

          var _super = code_39_reader_createSuper(Code39Reader);

          function Code39Reader() {
            var _this;

            classCallCheck_default()(this, Code39Reader);

            for (
              var _len = arguments.length, args = new Array(_len), _key = 0;
              _key < _len;
              _key++
            ) {
              args[_key] = arguments[_key];
            }

            _this = _super.call.apply(_super, [this].concat(args));

            defineProperty_default()(
              assertThisInitialized_default()(_this),
              "FORMAT",
              "code_39"
            );

            return _this;
          }

          createClass_default()(Code39Reader, [
            {
              key: "_findStart",
              value: function _findStart() {
                var offset = this._nextSet(this._row);

                var patternStart = offset;
                var counter = new Uint16Array([0, 0, 0, 0, 0, 0, 0, 0, 0]);
                var counterPos = 0;
                var isWhite = false;

                for (var i = offset; i < this._row.length; i++) {
                  // eslint-disable-next-line no-bitwise
                  if (this._row[i] ^ (isWhite ? 1 : 0)) {
                    counter[counterPos]++;
                  } else {
                    if (counterPos === counter.length - 1) {
                      // find start pattern
                      if (this._toPattern(counter) === ASTERISK) {
                        var whiteSpaceMustStart = Math.floor(
                          Math.max(0, patternStart - (i - patternStart) / 4)
                        );

                        if (
                          this._matchRange(whiteSpaceMustStart, patternStart, 0)
                        ) {
                          return {
                            start: patternStart,
                            end: i,
                          };
                        }
                      }

                      patternStart += counter[0] + counter[1];

                      for (var j = 0; j < 7; j++) {
                        counter[j] = counter[j + 2];
                      }

                      counter[7] = 0;
                      counter[8] = 0;
                      counterPos--;
                    } else {
                      counterPos++;
                    }

                    counter[counterPos] = 1;
                    isWhite = !isWhite;
                  }
                }

                return null;
              },
            },
            {
              key: "_toPattern",
              value: function _toPattern(counters) {
                var numCounters = counters.length;
                var maxNarrowWidth = 0;
                var numWideBars = numCounters;
                var wideBarWidth = 0;

                while (numWideBars > 3) {
                  maxNarrowWidth = this._findNextWidth(
                    counters,
                    maxNarrowWidth
                  );
                  numWideBars = 0;
                  var pattern = 0;

                  for (var i = 0; i < numCounters; i++) {
                    if (counters[i] > maxNarrowWidth) {
                      // eslint-disable-next-line no-bitwise
                      pattern |= 1 << (numCounters - 1 - i);
                      numWideBars++;
                      wideBarWidth += counters[i];
                    }
                  }

                  if (numWideBars === 3) {
                    for (
                      var _i = 0;
                      _i < numCounters && numWideBars > 0;
                      _i++
                    ) {
                      if (counters[_i] > maxNarrowWidth) {
                        numWideBars--;

                        if (counters[_i] * 2 >= wideBarWidth) {
                          return -1;
                        }
                      }
                    }

                    return pattern;
                  }
                }

                return -1;
              },
            },
            {
              key: "_findNextWidth",
              value: function _findNextWidth(counters, current) {
                var minWidth = Number.MAX_VALUE;

                for (var i = 0; i < counters.length; i++) {
                  if (counters[i] < minWidth && counters[i] > current) {
                    minWidth = counters[i];
                  }
                }

                return minWidth;
              },
            },
            {
              key: "_patternToChar",
              value: function _patternToChar(pattern) {
                for (
                  var i = 0;
                  i < code_39_reader_CHARACTER_ENCODINGS.length;
                  i++
                ) {
                  if (code_39_reader_CHARACTER_ENCODINGS[i] === pattern) {
                    return String.fromCharCode(code_39_reader_ALPHABET[i]);
                  }
                }

                return null;
              },
            },
            {
              key: "_verifyTrailingWhitespace",
              value: function _verifyTrailingWhitespace(
                lastStart,
                nextStart,
                counters
              ) {
                var patternSize = array_helper["a" /* default */].sum(counters);
                var trailingWhitespaceEnd = nextStart - lastStart - patternSize;

                if (trailingWhitespaceEnd * 3 >= patternSize) {
                  return true;
                }

                return false;
              },
            },
            {
              key: "decode",
              value: function decode() {
                var counters = new Uint16Array([0, 0, 0, 0, 0, 0, 0, 0, 0]);
                var result = [];

                var start = this._findStart();

                if (!start) {
                  return null;
                }

                var nextStart = this._nextSet(this._row, start.end);

                var decodedChar;
                var lastStart;

                do {
                  counters = this._toCounters(nextStart, counters);

                  var pattern = this._toPattern(counters);

                  if (pattern < 0) {
                    return null;
                  }

                  decodedChar = this._patternToChar(pattern);

                  if (decodedChar === null) {
                    return null;
                  }

                  result.push(decodedChar);
                  lastStart = nextStart;
                  nextStart += array_helper["a" /* default */].sum(counters);
                  nextStart = this._nextSet(this._row, nextStart);
                } while (decodedChar !== "*");

                result.pop();

                if (!result.length) {
                  return null;
                }

                if (
                  !this._verifyTrailingWhitespace(
                    lastStart,
                    nextStart,
                    counters
                  )
                ) {
                  return null;
                }

                return {
                  code: result.join(""),
                  start: start.start,
                  end: nextStart,
                  startInfo: start,
                  decodedCodes: result,
                  format: this.FORMAT,
                };
              },
            },
          ]);

          return Code39Reader;
        })(barcode_reader);

        /* harmony default export */ var code_39_reader =
          code_39_reader_Code39Reader;
        // CONCATENATED MODULE: ./src/reader/code_32_reader.ts

        function code_32_reader_createSuper(Derived) {
          var hasNativeReflectConstruct =
            code_32_reader_isNativeReflectConstruct();
          return function _createSuperInternal() {
            var Super = getPrototypeOf_default()(Derived),
              result;
            if (hasNativeReflectConstruct) {
              var NewTarget = getPrototypeOf_default()(this).constructor;
              result = Reflect.construct(Super, arguments, NewTarget);
            } else {
              result = Super.apply(this, arguments);
            }
            return possibleConstructorReturn_default()(this, result);
          };
        }

        function code_32_reader_isNativeReflectConstruct() {
          if (typeof Reflect === "undefined" || !Reflect.construct)
            return false;
          if (Reflect.construct.sham) return false;
          if (typeof Proxy === "function") return true;
          try {
            Boolean.prototype.valueOf.call(
              Reflect.construct(Boolean, [], function () {})
            );
            return true;
          } catch (e) {
            return false;
          }
        }

        var patterns = {
          AEIO: /[AEIO]/g,
          AZ09: /[A-Z0-9]/,
        };
        var code32set = "0123456789BCDFGHJKLMNPQRSTUVWXYZ";

        var code_32_reader_Code32Reader = /*#__PURE__*/ (function (
          _Code39Reader
        ) {
          inherits_default()(Code32Reader, _Code39Reader);

          var _super = code_32_reader_createSuper(Code32Reader);

          function Code32Reader() {
            var _this;

            classCallCheck_default()(this, Code32Reader);

            for (
              var _len = arguments.length, args = new Array(_len), _key = 0;
              _key < _len;
              _key++
            ) {
              args[_key] = arguments[_key];
            }

            _this = _super.call.apply(_super, [this].concat(args));

            defineProperty_default()(
              assertThisInitialized_default()(_this),
              "FORMAT",
              "code_32_reader"
            );

            return _this;
          }

          createClass_default()(Code32Reader, [
            {
              key: "_decodeCode32",
              value: function _decodeCode32(code) {
                if (/[^0-9BCDFGHJKLMNPQRSTUVWXYZ]/.test(code)) {
                  return null;
                }

                var res = 0;

                for (var i = 0; i < code.length; i++) {
                  res = res * 32 + code32set.indexOf(code[i]);
                }

                var code32 = "".concat(res);

                if (code32.length < 9) {
                  code32 = ("000000000" + code32).slice(-9);
                }

                return "A" + code32;
              }, // TODO (this was todo in original repo, no text was there. sorry.)
            },
            {
              key: "_checkChecksum",
              value: function _checkChecksum(code) {
                return !!code;
              },
            },
            {
              key: "decode",
              value: function decode() {
                var result = get_default()(
                  getPrototypeOf_default()(Code32Reader.prototype),
                  "decode",
                  this
                ).call(this);

                if (!result) {
                  return null;
                }

                var code = result.code;

                if (!code) {
                  return null;
                }

                code = code.replace(patterns.AEIO, "");

                if (!this._checkChecksum(code)) {
                  return null;
                }

                var code32 = this._decodeCode32(code);

                if (!code32) {
                  return null;
                }

                result.code = code32;
                return result;
              },
            },
          ]);

          return Code32Reader;
        })(code_39_reader);

        /* harmony default export */ var code_32_reader =
          code_32_reader_Code32Reader;
        // CONCATENATED MODULE: ./src/reader/code_39_vin_reader.ts

        function code_39_vin_reader_createSuper(Derived) {
          var hasNativeReflectConstruct =
            code_39_vin_reader_isNativeReflectConstruct();
          return function _createSuperInternal() {
            var Super = getPrototypeOf_default()(Derived),
              result;
            if (hasNativeReflectConstruct) {
              var NewTarget = getPrototypeOf_default()(this).constructor;
              result = Reflect.construct(Super, arguments, NewTarget);
            } else {
              result = Super.apply(this, arguments);
            }
            return possibleConstructorReturn_default()(this, result);
          };
        }

        function code_39_vin_reader_isNativeReflectConstruct() {
          if (typeof Reflect === "undefined" || !Reflect.construct)
            return false;
          if (Reflect.construct.sham) return false;
          if (typeof Proxy === "function") return true;
          try {
            Boolean.prototype.valueOf.call(
              Reflect.construct(Boolean, [], function () {})
            );
            return true;
          } catch (e) {
            return false;
          }
        }

        /* eslint-disable class-methods-use-this */

        var code_39_vin_reader_patterns = {
          IOQ: /[IOQ]/g,
          AZ09: /[A-Z0-9]{17}/,
        };

        var code_39_vin_reader_Code39VINReader = /*#__PURE__*/ (function (
          _Code39Reader
        ) {
          inherits_default()(Code39VINReader, _Code39Reader);

          var _super = code_39_vin_reader_createSuper(Code39VINReader);

          function Code39VINReader() {
            var _this;

            classCallCheck_default()(this, Code39VINReader);

            for (
              var _len = arguments.length, args = new Array(_len), _key = 0;
              _key < _len;
              _key++
            ) {
              args[_key] = arguments[_key];
            }

            _this = _super.call.apply(_super, [this].concat(args));

            defineProperty_default()(
              assertThisInitialized_default()(_this),
              "FORMAT",
              "code_39_vin"
            );

            return _this;
          }

          createClass_default()(Code39VINReader, [
            {
              key: "_checkChecksum",
              // TODO (this was todo in original repo, no text was there. sorry.)
              value: function _checkChecksum(code) {
                return !!code;
              }, // Cribbed from:
              // https://github.com/zxing/zxing/blob/master/core/src/main/java/com/google/zxing/client/result/VINResultParser.java
            },
            {
              key: "decode",
              value: function decode() {
                var result = get_default()(
                  getPrototypeOf_default()(Code39VINReader.prototype),
                  "decode",
                  this
                ).call(this);

                if (!result) {
                  return null;
                }

                var code = result.code;

                if (!code) {
                  return null;
                }

                code = code.replace(code_39_vin_reader_patterns.IOQ, "");

                if (!code.match(code_39_vin_reader_patterns.AZ09)) {
                  if (true) {
                    console.log("Failed AZ09 pattern code:", code);
                  }

                  return null;
                }

                if (!this._checkChecksum(code)) {
                  return null;
                }

                result.code = code;
                return result;
              },
            },
          ]);

          return Code39VINReader;
        })(code_39_reader);

        /* harmony default export */ var code_39_vin_reader =
          code_39_vin_reader_Code39VINReader;
        // CONCATENATED MODULE: ./src/reader/code_93_reader.ts

        function code_93_reader_createSuper(Derived) {
          var hasNativeReflectConstruct =
            code_93_reader_isNativeReflectConstruct();
          return function _createSuperInternal() {
            var Super = getPrototypeOf_default()(Derived),
              result;
            if (hasNativeReflectConstruct) {
              var NewTarget = getPrototypeOf_default()(this).constructor;
              result = Reflect.construct(Super, arguments, NewTarget);
            } else {
              result = Super.apply(this, arguments);
            }
            return possibleConstructorReturn_default()(this, result);
          };
        }

        function code_93_reader_isNativeReflectConstruct() {
          if (typeof Reflect === "undefined" || !Reflect.construct)
            return false;
          if (Reflect.construct.sham) return false;
          if (typeof Proxy === "function") return true;
          try {
            Boolean.prototype.valueOf.call(
              Reflect.construct(Boolean, [], function () {})
            );
            return true;
          } catch (e) {
            return false;
          }
        }

        var code_93_reader_ALPHABETH_STRING =
          "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ-. $/+%abcd*";
        var code_93_reader_ALPHABET = new Uint16Array(
          toConsumableArray_default()(code_93_reader_ALPHABETH_STRING).map(
            function (_char) {
              return _char.charCodeAt(0);
            }
          )
        );
        var code_93_reader_CHARACTER_ENCODINGS = new Uint16Array([
          0x114, 0x148, 0x144, 0x142, 0x128, 0x124, 0x122, 0x150, 0x112, 0x10a,
          0x1a8, 0x1a4, 0x1a2, 0x194, 0x192, 0x18a, 0x168, 0x164, 0x162, 0x134,
          0x11a, 0x158, 0x14c, 0x146, 0x12c, 0x116, 0x1b4, 0x1b2, 0x1ac, 0x1a6,
          0x196, 0x19a, 0x16c, 0x166, 0x136, 0x13a, 0x12e, 0x1d4, 0x1d2, 0x1ca,
          0x16e, 0x176, 0x1ae, 0x126, 0x1da, 0x1d6, 0x132, 0x15e,
        ]);
        var code_93_reader_ASTERISK = 0x15e;

        var code_93_reader_Code93Reader = /*#__PURE__*/ (function (
          _BarcodeReader
        ) {
          inherits_default()(Code93Reader, _BarcodeReader);

          var _super = code_93_reader_createSuper(Code93Reader);

          function Code93Reader() {
            var _this;

            classCallCheck_default()(this, Code93Reader);

            for (
              var _len = arguments.length, args = new Array(_len), _key = 0;
              _key < _len;
              _key++
            ) {
              args[_key] = arguments[_key];
            }

            _this = _super.call.apply(_super, [this].concat(args));

            defineProperty_default()(
              assertThisInitialized_default()(_this),
              "FORMAT",
              "code_93"
            );

            return _this;
          }

          createClass_default()(Code93Reader, [
            {
              key: "_patternToChar",
              value: function _patternToChar(pattern) {
                for (
                  var i = 0;
                  i < code_93_reader_CHARACTER_ENCODINGS.length;
                  i++
                ) {
                  if (code_93_reader_CHARACTER_ENCODINGS[i] === pattern) {
                    return String.fromCharCode(code_93_reader_ALPHABET[i]);
                  }
                }

                return null;
              },
            },
            {
              key: "_toPattern",
              value: function _toPattern(counters) {
                var numCounters = counters.length;
                var sum = counters.reduce(function (prev, next) {
                  return prev + next;
                }, 0);
                var pattern = 0;

                for (var i = 0; i < numCounters; i++) {
                  var normalized = Math.round((counters[i] * 9) / sum);

                  if (normalized < 1 || normalized > 4) {
                    return -1;
                  }

                  if ((i & 1) === 0) {
                    for (var j = 0; j < normalized; j++) {
                      pattern = (pattern << 1) | 1;
                    }
                  } else {
                    pattern <<= normalized;
                  }
                }

                return pattern;
              },
            },
            {
              key: "_findStart",
              value: function _findStart() {
                var offset = this._nextSet(this._row);

                var patternStart = offset;
                var counter = new Uint16Array([0, 0, 0, 0, 0, 0]);
                var counterPos = 0;
                var isWhite = false;

                for (var i = offset; i < this._row.length; i++) {
                  if (this._row[i] ^ (isWhite ? 1 : 0)) {
                    counter[counterPos]++;
                  } else {
                    if (counterPos === counter.length - 1) {
                      // find start pattern
                      if (
                        this._toPattern(counter) === code_93_reader_ASTERISK
                      ) {
                        var whiteSpaceMustStart = Math.floor(
                          Math.max(0, patternStart - (i - patternStart) / 4)
                        );

                        if (
                          this._matchRange(whiteSpaceMustStart, patternStart, 0)
                        ) {
                          return {
                            start: patternStart,
                            end: i,
                          };
                        }
                      }

                      patternStart += counter[0] + counter[1];

                      for (var j = 0; j < 4; j++) {
                        counter[j] = counter[j + 2];
                      }

                      counter[4] = 0;
                      counter[5] = 0;
                      counterPos--;
                    } else {
                      counterPos++;
                    }

                    counter[counterPos] = 1;
                    isWhite = !isWhite;
                  }
                }

                return null;
              },
            },
            {
              key: "_verifyEnd",
              value: function _verifyEnd(lastStart, nextStart) {
                if (lastStart === nextStart || !this._row[nextStart]) {
                  return false;
                }

                return true;
              },
            },
            {
              key: "_decodeExtended",
              value: function _decodeExtended(charArray) {
                var length = charArray.length;
                var result = [];

                for (var i = 0; i < length; i++) {
                  var _char2 = charArray[i];

                  if (_char2 >= "a" && _char2 <= "d") {
                    if (i > length - 2) {
                      return null;
                    }

                    var nextChar = charArray[++i];
                    var nextCharCode = nextChar.charCodeAt(0);
                    var decodedChar = void 0;

                    switch (_char2) {
                      case "a":
                        if (nextChar >= "A" && nextChar <= "Z") {
                          decodedChar = String.fromCharCode(nextCharCode - 64);
                        } else {
                          return null;
                        }

                        break;

                      case "b":
                        if (nextChar >= "A" && nextChar <= "E") {
                          decodedChar = String.fromCharCode(nextCharCode - 38);
                        } else if (nextChar >= "F" && nextChar <= "J") {
                          decodedChar = String.fromCharCode(nextCharCode - 11);
                        } else if (nextChar >= "K" && nextChar <= "O") {
                          decodedChar = String.fromCharCode(nextCharCode + 16);
                        } else if (nextChar >= "P" && nextChar <= "S") {
                          decodedChar = String.fromCharCode(nextCharCode + 43);
                        } else if (nextChar >= "T" && nextChar <= "Z") {
                          decodedChar = String.fromCharCode(127);
                        } else {
                          return null;
                        }

                        break;

                      case "c":
                        if (nextChar >= "A" && nextChar <= "O") {
                          decodedChar = String.fromCharCode(nextCharCode - 32);
                        } else if (nextChar === "Z") {
                          decodedChar = ":";
                        } else {
                          return null;
                        }

                        break;

                      case "d":
                        if (nextChar >= "A" && nextChar <= "Z") {
                          decodedChar = String.fromCharCode(nextCharCode + 32);
                        } else {
                          return null;
                        }

                        break;

                      default:
                        console.warn(
                          "* code_93_reader _decodeExtended hit default case, this may be an error",
                          decodedChar
                        );
                        return null;
                    }

                    result.push(decodedChar);
                  } else {
                    result.push(_char2);
                  }
                }

                return result;
              },
            },
            {
              key: "_matchCheckChar",
              value: function _matchCheckChar(charArray, index, maxWeight) {
                var arrayToCheck = charArray.slice(0, index);
                var length = arrayToCheck.length;
                var weightedSums = arrayToCheck.reduce(function (
                  sum,
                  _char3,
                  i
                ) {
                  var weight = ((i * -1 + (length - 1)) % maxWeight) + 1;
                  var value = code_93_reader_ALPHABET.indexOf(
                    _char3.charCodeAt(0)
                  );
                  return sum + weight * value;
                },
                0);
                var checkChar = code_93_reader_ALPHABET[weightedSums % 47];
                return checkChar === charArray[index].charCodeAt(0);
              },
            },
            {
              key: "_verifyChecksums",
              value: function _verifyChecksums(charArray) {
                return (
                  this._matchCheckChar(charArray, charArray.length - 2, 20) &&
                  this._matchCheckChar(charArray, charArray.length - 1, 15)
                );
              },
            },
            {
              key: "decode",
              value: function decode(row, start) {
                start = this._findStart();

                if (!start) {
                  return null;
                }

                var counters = new Uint16Array([0, 0, 0, 0, 0, 0]);
                var result = [];

                var nextStart = this._nextSet(this._row, start.end);

                var lastStart;
                var decodedChar;

                do {
                  counters = this._toCounters(nextStart, counters);

                  var pattern = this._toPattern(counters);

                  if (pattern < 0) {
                    return null;
                  }

                  decodedChar = this._patternToChar(pattern);

                  if (decodedChar === null) {
                    return null;
                  }

                  result.push(decodedChar);
                  lastStart = nextStart;
                  nextStart += array_helper["a" /* default */].sum(counters);
                  nextStart = this._nextSet(this._row, nextStart);
                } while (decodedChar !== "*");

                result.pop();

                if (!result.length) {
                  return null;
                }

                if (!this._verifyEnd(lastStart, nextStart)) {
                  return null;
                }

                if (!this._verifyChecksums(result)) {
                  return null;
                }

                result = result.slice(0, result.length - 2); // yes, this is an assign inside an if.

                if ((result = this._decodeExtended(result)) === null) {
                  return null;
                }

                return {
                  code: result.join(""),
                  start: start.start,
                  end: nextStart,
                  startInfo: start,
                  decodedCodes: result,
                  format: this.FORMAT,
                };
              },
            },
          ]);

          return Code93Reader;
        })(barcode_reader);

        /* harmony default export */ var code_93_reader =
          code_93_reader_Code93Reader;
        // CONCATENATED MODULE: ./src/reader/ean_reader.ts

        function ownKeys(object, enumerableOnly) {
          var keys = Object.keys(object);
          if (Object.getOwnPropertySymbols) {
            var symbols = Object.getOwnPropertySymbols(object);
            enumerableOnly &&
              (symbols = symbols.filter(function (sym) {
                return Object.getOwnPropertyDescriptor(object, sym).enumerable;
              })),
              keys.push.apply(keys, symbols);
          }
          return keys;
        }

        function _objectSpread(target) {
          for (var i = 1; i < arguments.length; i++) {
            var source = null != arguments[i] ? arguments[i] : {};
            i % 2
              ? ownKeys(Object(source), !0).forEach(function (key) {
                  defineProperty_default()(target, key, source[key]);
                })
              : Object.getOwnPropertyDescriptors
              ? Object.defineProperties(
                  target,
                  Object.getOwnPropertyDescriptors(source)
                )
              : ownKeys(Object(source)).forEach(function (key) {
                  Object.defineProperty(
                    target,
                    key,
                    Object.getOwnPropertyDescriptor(source, key)
                  );
                });
          }
          return target;
        }

        function ean_reader_createSuper(Derived) {
          var hasNativeReflectConstruct = ean_reader_isNativeReflectConstruct();
          return function _createSuperInternal() {
            var Super = getPrototypeOf_default()(Derived),
              result;
            if (hasNativeReflectConstruct) {
              var NewTarget = getPrototypeOf_default()(this).constructor;
              result = Reflect.construct(Super, arguments, NewTarget);
            } else {
              result = Super.apply(this, arguments);
            }
            return possibleConstructorReturn_default()(this, result);
          };
        }

        function ean_reader_isNativeReflectConstruct() {
          if (typeof Reflect === "undefined" || !Reflect.construct)
            return false;
          if (Reflect.construct.sham) return false;
          if (typeof Proxy === "function") return true;
          try {
            Boolean.prototype.valueOf.call(
              Reflect.construct(Boolean, [], function () {})
            );
            return true;
          } catch (e) {
            return false;
          }
        }

        // const CODE_L_START = 0;

        var CODE_G_START = 10;

        var ean_reader_START_PATTERN = [1, 1, 1];
        var MIDDLE_PATTERN = [1, 1, 1, 1, 1];

        var EXTENSION_START_PATTERN = [1, 1, 2];
        var ean_reader_CODE_PATTERN = [
          [3, 2, 1, 1],
          [2, 2, 2, 1],
          [2, 1, 2, 2],
          [1, 4, 1, 1],
          [1, 1, 3, 2],
          [1, 2, 3, 1],
          [1, 1, 1, 4],
          [1, 3, 1, 2],
          [1, 2, 1, 3],
          [3, 1, 1, 2],
          [1, 1, 2, 3],
          [1, 2, 2, 2],
          [2, 2, 1, 2],
          [1, 1, 4, 1],
          [2, 3, 1, 1],
          [1, 3, 2, 1],
          [4, 1, 1, 1],
          [2, 1, 3, 1],
          [3, 1, 2, 1],
          [2, 1, 1, 3],
        ];
        var CODE_FREQUENCY = [0, 11, 13, 14, 19, 25, 28, 21, 22, 26]; // const SINGLE_CODE_ERROR = 0.70;

        var AVG_CODE_ERROR = 0.48;

        var ean_reader_EANReader = /*#__PURE__*/ (function (_BarcodeReader) {
          inherits_default()(EANReader, _BarcodeReader);

          var _super = ean_reader_createSuper(EANReader);

          // TODO: does this need to be in the class?
          function EANReader(config, supplements) {
            var _this;

            classCallCheck_default()(this, EANReader);

            _this = _super.call(
              this,
              merge_default()(
                {
                  supplements: [],
                },
                config
              ),
              supplements
            );

            defineProperty_default()(
              assertThisInitialized_default()(_this),
              "FORMAT",
              "ean_13"
            );

            defineProperty_default()(
              assertThisInitialized_default()(_this),
              "SINGLE_CODE_ERROR",
              0.7
            );

            defineProperty_default()(
              assertThisInitialized_default()(_this),
              "STOP_PATTERN",
              [1, 1, 1]
            );

            return _this;
          }

          createClass_default()(EANReader, [
            {
              key: "_findPattern",
              value: function _findPattern(
                pattern,
                offset,
                isWhite,
                tryHarder
              ) {
                var counter = new Array(pattern.length).fill(0);
                var bestMatch = {
                  error: Number.MAX_VALUE,
                  start: 0,
                  end: 0,
                };
                var epsilon = AVG_CODE_ERROR; // console.warn('* findPattern', pattern, offset, isWhite, tryHarder, epsilon);

                var counterPos = 0;

                if (!offset) {
                  offset = this._nextSet(this._row);
                }

                var found = false;

                for (var i = offset; i < this._row.length; i++) {
                  // console.warn(`* loop i=${offset} len=${this._row.length} isWhite=${isWhite} counterPos=${counterPos}`);
                  if (this._row[i] ^ (isWhite ? 1 : 0)) {
                    counter[counterPos] += 1;
                  } else {
                    if (counterPos === counter.length - 1) {
                      var error = this._matchPattern(counter, pattern); // console.warn('* matchPattern', error, counter, pattern);

                      if (
                        error < epsilon &&
                        bestMatch.error &&
                        error < bestMatch.error
                      ) {
                        found = true;
                        bestMatch.error = error;
                        bestMatch.start =
                          i -
                          counter.reduce(function (sum, value) {
                            return sum + value;
                          }, 0);
                        bestMatch.end = i; // console.warn('* return bestMatch', JSON.stringify(bestMatch));

                        return bestMatch;
                      }

                      if (tryHarder) {
                        for (var j = 0; j < counter.length - 2; j++) {
                          counter[j] = counter[j + 2];
                        }

                        counter[counter.length - 2] = 0;
                        counter[counter.length - 1] = 0;
                        counterPos--;
                      }
                    } else {
                      counterPos++;
                    }

                    counter[counterPos] = 1;
                    isWhite = !isWhite;
                  }
                }

                if (found) {
                  // console.warn('* return bestMatch', JSON.stringify(bestMatch));
                } else {
                  // console.warn('* return null');
                }

                return found ? bestMatch : null;
              }, // TODO: findPattern and decodeCode appear to share quite similar code, can it be reduced?
            },
            {
              key: "_decodeCode",
              value: function _decodeCode(start, coderange) {
                // console.warn('* decodeCode', start, coderange);
                var counter = [0, 0, 0, 0];
                var offset = start;
                var bestMatch = {
                  error: Number.MAX_VALUE,
                  code: -1,
                  start: start,
                  end: start,
                };
                var epsilon = AVG_CODE_ERROR;
                var isWhite = !this._row[offset];
                var counterPos = 0;

                if (!coderange) {
                  // console.warn('* decodeCode before length');
                  coderange = ean_reader_CODE_PATTERN.length; // console.warn('* decodeCode after length');
                }

                var found = false;

                for (var i = offset; i < this._row.length; i++) {
                  if (this._row[i] ^ (isWhite ? 1 : 0)) {
                    counter[counterPos]++;
                  } else {
                    if (counterPos === counter.length - 1) {
                      for (var code = 0; code < coderange; code++) {
                        var error = this._matchPattern(
                          counter,
                          ean_reader_CODE_PATTERN[code]
                        );

                        bestMatch.end = i;

                        if (error < bestMatch.error) {
                          bestMatch.code = code;
                          bestMatch.error = error;
                        }
                      }

                      if (bestMatch.error > epsilon) {
                        // console.warn('* return null');
                        return null;
                      } // console.warn('* return bestMatch', JSON.stringify(bestMatch));

                      return bestMatch;
                    } else {
                      counterPos++;
                    }

                    counter[counterPos] = 1;
                    isWhite = !isWhite;
                  }
                }

                return found ? bestMatch : null;
              },
            },
            {
              key: "_findStart",
              value: function _findStart() {
                // console.warn('* findStart');
                var offset = this._nextSet(this._row);

                var startInfo = null;

                while (!startInfo) {
                  startInfo = this._findPattern(
                    ean_reader_START_PATTERN,
                    offset,
                    false,
                    true
                  ); // console.warn('* startInfo=', JSON.stringify(startInfo));

                  if (!startInfo) {
                    return null;
                  }

                  var leadingWhitespaceStart =
                    startInfo.start - (startInfo.end - startInfo.start);

                  if (leadingWhitespaceStart >= 0) {
                    if (
                      this._matchRange(
                        leadingWhitespaceStart,
                        startInfo.start,
                        0
                      )
                    ) {
                      // console.warn('* returning startInfo');
                      return startInfo;
                    }
                  }

                  offset = startInfo.end;
                  startInfo = null;
                } // console.warn('* returning null');

                return null;
              },
            },
            {
              key: "_calculateFirstDigit",
              value: function _calculateFirstDigit(codeFrequency) {
                // console.warn('* calculateFirstDigit', codeFrequency);
                for (var i = 0; i < CODE_FREQUENCY.length; i++) {
                  if (codeFrequency === CODE_FREQUENCY[i]) {
                    // console.warn('* returning', i);
                    return i;
                  }
                } // console.warn('* return null');

                return null;
              },
            },
            {
              key: "_decodePayload",
              value: function _decodePayload(inCode, result, decodedCodes) {
                // console.warn('* decodePayload', inCode, result, decodedCodes);
                var outCode = _objectSpread({}, inCode);

                var codeFrequency = 0x0;

                for (var i = 0; i < 6; i++) {
                  outCode = this._decodeCode(outCode.end); // console.warn('* decodeCode=', outCode);

                  if (!outCode) {
                    // console.warn('* return null');
                    return null;
                  }

                  if (outCode.code >= CODE_G_START) {
                    outCode.code -= CODE_G_START;
                    codeFrequency |= 1 << (5 - i);
                  } else {
                    codeFrequency |= 0 << (5 - i);
                  }

                  result.push(outCode.code);
                  decodedCodes.push(outCode);
                }

                var firstDigit = this._calculateFirstDigit(codeFrequency); // console.warn('* firstDigit=', firstDigit);

                if (firstDigit === null) {
                  // console.warn('* return null');
                  return null;
                }

                result.unshift(firstDigit);

                var middlePattern = this._findPattern(
                  MIDDLE_PATTERN,
                  outCode.end,
                  true,
                  false
                ); // console.warn('* findPattern=', JSON.stringify(middlePattern));

                if (middlePattern === null || !middlePattern.end) {
                  // console.warn('* return null');
                  return null;
                }

                decodedCodes.push(middlePattern);

                for (var _i = 0; _i < 6; _i++) {
                  middlePattern = this._decodeCode(
                    middlePattern.end,
                    CODE_G_START
                  ); // console.warn('* decodeCode=', JSON.stringify(middlePattern));

                  if (!middlePattern) {
                    // console.warn('* return null');
                    return null;
                  }

                  decodedCodes.push(middlePattern);
                  result.push(middlePattern.code);
                } // console.warn('* end code=', JSON.stringify(middlePattern));
                // console.warn('* end result=', JSON.stringify(result));
                // console.warn('* end decodedCodes=', decodedCodes);

                return middlePattern;
              },
            },
            {
              key: "_verifyTrailingWhitespace",
              value: function _verifyTrailingWhitespace(endInfo) {
                // console.warn('* verifyTrailingWhitespace', JSON.stringify(endInfo));
                var trailingWhitespaceEnd =
                  endInfo.end + (endInfo.end - endInfo.start);

                if (trailingWhitespaceEnd < this._row.length) {
                  if (this._matchRange(endInfo.end, trailingWhitespaceEnd, 0)) {
                    // console.warn('* returning', JSON.stringify(endInfo));
                    return endInfo;
                  }
                } // console.warn('* return null');

                return null;
              },
            },
            {
              key: "_findEnd",
              value: function _findEnd(offset, isWhite) {
                // console.warn('* findEnd', offset, isWhite);
                var endInfo = this._findPattern(
                  this.STOP_PATTERN,
                  offset,
                  isWhite,
                  false
                );

                return endInfo !== null
                  ? this._verifyTrailingWhitespace(endInfo)
                  : null;
              },
            },
            {
              key: "_checksum",
              value: function _checksum(result) {
                // console.warn('* _checksum', result);
                var sum = 0;

                for (var i = result.length - 2; i >= 0; i -= 2) {
                  sum += result[i];
                }

                sum *= 3;

                for (var _i2 = result.length - 1; _i2 >= 0; _i2 -= 2) {
                  sum += result[_i2];
                } // console.warn('* end checksum', sum % 10 === 0);

                return sum % 10 === 0;
              },
            },
            {
              key: "_decodeExtensions",
              value: function _decodeExtensions(offset) {
                var start = this._nextSet(this._row, offset);

                var startInfo = this._findPattern(
                  EXTENSION_START_PATTERN,
                  start,
                  false,
                  false
                );

                if (startInfo === null) {
                  return null;
                } // console.warn('* decodeExtensions', this.supplements);
                // console.warn('* there are ', this.supplements.length, ' supplements');

                for (var i = 0; i < this.supplements.length; i++) {
                  // console.warn('* extensions loop', i, this.supplements[i], this.supplements[i]._decode);
                  try {
                    var result = this.supplements[i].decode(
                      this._row,
                      startInfo.end
                    ); // console.warn('* decode result=', result);

                    if (result !== null) {
                      return {
                        code: result.code,
                        start: start,
                        startInfo: startInfo,
                        end: result.end,
                        decodedCodes: result.decodedCodes,
                        format: this.supplements[i].FORMAT,
                      };
                    }
                  } catch (err) {
                    console.error(
                      "* decodeExtensions error in ",
                      this.supplements[i],
                      ": ",
                      err
                    );
                  }
                } // console.warn('* end decodeExtensions');

                return null;
              },
            },
            {
              key: "decode",
              value: function decode(row, start) {
                // console.warn('* decode', row);
                // console.warn('* decode', start);
                var result = new Array();
                var decodedCodes = new Array();
                var resultInfo = {};

                var startInfo = this._findStart();

                if (!startInfo) {
                  return null;
                }

                var code = {
                  start: startInfo.start,
                  end: startInfo.end,
                };
                decodedCodes.push(code);
                code = this._decodePayload(code, result, decodedCodes);

                if (!code) {
                  return null;
                }

                code = this._findEnd(code.end, false);

                if (!code) {
                  return null;
                }

                decodedCodes.push(code); // Checksum

                if (!this._checksum(result)) {
                  return null;
                } // console.warn('* this.supplements=', this.supplements);

                if (this.supplements.length > 0) {
                  var supplement = this._decodeExtensions(code.end); // console.warn('* decodeExtensions returns', supplement);

                  if (!supplement) {
                    return null;
                  }

                  if (!supplement.decodedCodes) {
                    return null;
                  }

                  var lastCode =
                    supplement.decodedCodes[supplement.decodedCodes.length - 1];
                  var endInfo = {
                    start:
                      lastCode.start +
                      (((lastCode.end - lastCode.start) / 2) | 0),
                    end: lastCode.end,
                  };

                  if (!this._verifyTrailingWhitespace(endInfo)) {
                    return null;
                  }

                  resultInfo = {
                    supplement: supplement,
                    code: result.join("") + supplement.code,
                  };
                }

                return _objectSpread(
                  _objectSpread(
                    {
                      code: result.join(""),
                      start: startInfo.start,
                      end: code.end,
                      startInfo: startInfo,
                      decodedCodes: decodedCodes,
                    },
                    resultInfo
                  ),
                  {},
                  {
                    format: this.FORMAT,
                  }
                );
              },
            },
          ]);

          return EANReader;
        })(barcode_reader);

        /* harmony default export */ var ean_reader = ean_reader_EANReader;
        // CONCATENATED MODULE: ./src/reader/ean_2_reader.ts

        function ean_2_reader_createSuper(Derived) {
          var hasNativeReflectConstruct =
            ean_2_reader_isNativeReflectConstruct();
          return function _createSuperInternal() {
            var Super = getPrototypeOf_default()(Derived),
              result;
            if (hasNativeReflectConstruct) {
              var NewTarget = getPrototypeOf_default()(this).constructor;
              result = Reflect.construct(Super, arguments, NewTarget);
            } else {
              result = Super.apply(this, arguments);
            }
            return possibleConstructorReturn_default()(this, result);
          };
        }

        function ean_2_reader_isNativeReflectConstruct() {
          if (typeof Reflect === "undefined" || !Reflect.construct)
            return false;
          if (Reflect.construct.sham) return false;
          if (typeof Proxy === "function") return true;
          try {
            Boolean.prototype.valueOf.call(
              Reflect.construct(Boolean, [], function () {})
            );
            return true;
          } catch (e) {
            return false;
          }
        }

        var ean_2_reader_EAN2Reader = /*#__PURE__*/ (function (_EANReader) {
          inherits_default()(EAN2Reader, _EANReader);

          var _super = ean_2_reader_createSuper(EAN2Reader);

          function EAN2Reader() {
            var _this;

            classCallCheck_default()(this, EAN2Reader);

            for (
              var _len = arguments.length, args = new Array(_len), _key = 0;
              _key < _len;
              _key++
            ) {
              args[_key] = arguments[_key];
            }

            _this = _super.call.apply(_super, [this].concat(args));

            defineProperty_default()(
              assertThisInitialized_default()(_this),
              "FORMAT",
              "ean_2"
            );

            return _this;
          }

          createClass_default()(EAN2Reader, [
            {
              key: "decode",
              value: function decode(row, start) {
                if (row) {
                  this._row = row;
                }

                var codeFrequency = 0;
                var offset = start;
                var end = this._row.length;
                var result = [];
                var decodedCodes = [];
                var code = null;

                if (offset === undefined) {
                  return null;
                }

                for (var i = 0; i < 2 && offset < end; i++) {
                  code = this._decodeCode(offset);

                  if (!code) {
                    return null;
                  }

                  decodedCodes.push(code);
                  result.push(code.code % 10);

                  if (code.code >= CODE_G_START) {
                    codeFrequency |= 1 << (1 - i);
                  }

                  if (i !== 1) {
                    offset = this._nextSet(this._row, code.end);
                    offset = this._nextUnset(this._row, offset);
                  }
                }

                if (
                  result.length !== 2 ||
                  parseInt(result.join("")) % 4 !== codeFrequency
                ) {
                  return null;
                }

                var startInfo = this._findStart();

                return {
                  code: result.join(""),
                  decodedCodes: decodedCodes,
                  end: code.end,
                  format: this.FORMAT,
                  startInfo: startInfo,
                  start: startInfo.start,
                };
              },
            },
          ]);

          return EAN2Reader;
        })(ean_reader);

        /* harmony default export */ var ean_2_reader = ean_2_reader_EAN2Reader;
        // CONCATENATED MODULE: ./src/reader/ean_5_reader.ts

        function ean_5_reader_createSuper(Derived) {
          var hasNativeReflectConstruct =
            ean_5_reader_isNativeReflectConstruct();
          return function _createSuperInternal() {
            var Super = getPrototypeOf_default()(Derived),
              result;
            if (hasNativeReflectConstruct) {
              var NewTarget = getPrototypeOf_default()(this).constructor;
              result = Reflect.construct(Super, arguments, NewTarget);
            } else {
              result = Super.apply(this, arguments);
            }
            return possibleConstructorReturn_default()(this, result);
          };
        }

        function ean_5_reader_isNativeReflectConstruct() {
          if (typeof Reflect === "undefined" || !Reflect.construct)
            return false;
          if (Reflect.construct.sham) return false;
          if (typeof Proxy === "function") return true;
          try {
            Boolean.prototype.valueOf.call(
              Reflect.construct(Boolean, [], function () {})
            );
            return true;
          } catch (e) {
            return false;
          }
        }

        var CHECK_DIGIT_ENCODINGS = [24, 20, 18, 17, 12, 6, 3, 10, 9, 5];

        function determineCheckDigit(codeFrequency) {
          for (var i = 0; i < 10; i++) {
            if (codeFrequency === CHECK_DIGIT_ENCODINGS[i]) {
              return i;
            }
          }

          return null;
        }

        function extensionChecksum(result) {
          var length = result.length;
          var sum = 0;

          for (var i = length - 2; i >= 0; i -= 2) {
            sum += result[i];
          }

          sum *= 3;

          for (var _i = length - 1; _i >= 0; _i -= 2) {
            sum += result[_i];
          }

          sum *= 3;
          return sum % 10;
        }

        var ean_5_reader_EAN5Reader = /*#__PURE__*/ (function (_EANReader) {
          inherits_default()(EAN5Reader, _EANReader);

          var _super = ean_5_reader_createSuper(EAN5Reader);

          function EAN5Reader() {
            var _this;

            classCallCheck_default()(this, EAN5Reader);

            for (
              var _len = arguments.length, args = new Array(_len), _key = 0;
              _key < _len;
              _key++
            ) {
              args[_key] = arguments[_key];
            }

            _this = _super.call.apply(_super, [this].concat(args));

            defineProperty_default()(
              assertThisInitialized_default()(_this),
              "FORMAT",
              "ean_5"
            );

            return _this;
          }

          createClass_default()(EAN5Reader, [
            {
              key: "decode",
              value: function decode(row, start) {
                if (start === undefined) {
                  return null;
                }

                if (row) {
                  this._row = row;
                }

                var codeFrequency = 0;
                var offset = start;
                var end = this._row.length;
                var code = null;
                var result = [];
                var decodedCodes = [];

                for (var i = 0; i < 5 && offset < end; i++) {
                  code = this._decodeCode(offset);

                  if (!code) {
                    return null;
                  }

                  decodedCodes.push(code);
                  result.push(code.code % 10);

                  if (code.code >= CODE_G_START) {
                    codeFrequency |= 1 << (4 - i);
                  }

                  if (i !== 4) {
                    offset = this._nextSet(this._row, code.end);
                    offset = this._nextUnset(this._row, offset);
                  }
                }

                if (result.length !== 5) {
                  return null;
                }

                if (
                  extensionChecksum(result) !==
                  determineCheckDigit(codeFrequency)
                ) {
                  return null;
                }

                var startInfo = this._findStart();

                return {
                  code: result.join(""),
                  decodedCodes: decodedCodes,
                  end: code.end,
                  format: this.FORMAT,
                  startInfo: startInfo,
                  start: startInfo.start,
                };
              },
            },
          ]);

          return EAN5Reader;
        })(ean_reader);

        /* harmony default export */ var ean_5_reader = ean_5_reader_EAN5Reader;
        // CONCATENATED MODULE: ./src/reader/ean_8_reader.ts

        function ean_8_reader_createSuper(Derived) {
          var hasNativeReflectConstruct =
            ean_8_reader_isNativeReflectConstruct();
          return function _createSuperInternal() {
            var Super = getPrototypeOf_default()(Derived),
              result;
            if (hasNativeReflectConstruct) {
              var NewTarget = getPrototypeOf_default()(this).constructor;
              result = Reflect.construct(Super, arguments, NewTarget);
            } else {
              result = Super.apply(this, arguments);
            }
            return possibleConstructorReturn_default()(this, result);
          };
        }

        function ean_8_reader_isNativeReflectConstruct() {
          if (typeof Reflect === "undefined" || !Reflect.construct)
            return false;
          if (Reflect.construct.sham) return false;
          if (typeof Proxy === "function") return true;
          try {
            Boolean.prototype.valueOf.call(
              Reflect.construct(Boolean, [], function () {})
            );
            return true;
          } catch (e) {
            return false;
          }
        }

        var ean_8_reader_EAN8Reader = /*#__PURE__*/ (function (_EANReader) {
          inherits_default()(EAN8Reader, _EANReader);

          var _super = ean_8_reader_createSuper(EAN8Reader);

          function EAN8Reader() {
            var _this;

            classCallCheck_default()(this, EAN8Reader);

            for (
              var _len = arguments.length, args = new Array(_len), _key = 0;
              _key < _len;
              _key++
            ) {
              args[_key] = arguments[_key];
            }

            _this = _super.call.apply(_super, [this].concat(args));

            defineProperty_default()(
              assertThisInitialized_default()(_this),
              "FORMAT",
              "ean_8"
            );

            return _this;
          }

          createClass_default()(EAN8Reader, [
            {
              key: "_decodePayload",
              value: function _decodePayload(inCode, result, decodedCodes) {
                var code = inCode;

                for (var i = 0; i < 4; i++) {
                  code = this._decodeCode(code.end, CODE_G_START);

                  if (!code) {
                    return null;
                  }

                  result.push(code.code);
                  decodedCodes.push(code);
                }

                code = this._findPattern(MIDDLE_PATTERN, code.end, true, false);

                if (code === null) {
                  return null;
                }

                decodedCodes.push(code);

                for (var _i = 0; _i < 4; _i++) {
                  code = this._decodeCode(code.end, CODE_G_START);

                  if (!code) {
                    return null;
                  }

                  decodedCodes.push(code);
                  result.push(code.code);
                }

                return code;
              },
            },
          ]);

          return EAN8Reader;
        })(ean_reader);

        /* harmony default export */ var ean_8_reader = ean_8_reader_EAN8Reader;
        // CONCATENATED MODULE: ./src/reader/i2of5_reader.ts

        function i2of5_reader_createSuper(Derived) {
          var hasNativeReflectConstruct =
            i2of5_reader_isNativeReflectConstruct();
          return function _createSuperInternal() {
            var Super = getPrototypeOf_default()(Derived),
              result;
            if (hasNativeReflectConstruct) {
              var NewTarget = getPrototypeOf_default()(this).constructor;
              result = Reflect.construct(Super, arguments, NewTarget);
            } else {
              result = Super.apply(this, arguments);
            }
            return possibleConstructorReturn_default()(this, result);
          };
        }

        function i2of5_reader_isNativeReflectConstruct() {
          if (typeof Reflect === "undefined" || !Reflect.construct)
            return false;
          if (Reflect.construct.sham) return false;
          if (typeof Proxy === "function") return true;
          try {
            Boolean.prototype.valueOf.call(
              Reflect.construct(Boolean, [], function () {})
            );
            return true;
          } catch (e) {
            return false;
          }
        }

        // TODO: i2of5_reader and 2of5_reader share very similar code, make use of that

        var i2of5_reader_N = 1;
        var i2of5_reader_W = 3;

        var i2of5_reader_I2of5Reader = /*#__PURE__*/ (function (
          _BarcodeReader
        ) {
          inherits_default()(I2of5Reader, _BarcodeReader);

          var _super = i2of5_reader_createSuper(I2of5Reader);

          function I2of5Reader(opts) {
            var _this;

            classCallCheck_default()(this, I2of5Reader);

            _this = _super.call(
              this,
              merge_default()(
                {
                  normalizeBarSpaceWidth: false,
                },
                opts
              )
            );

            defineProperty_default()(
              assertThisInitialized_default()(_this),
              "barSpaceRatio",
              [1, 1]
            );

            defineProperty_default()(
              assertThisInitialized_default()(_this),
              "SINGLE_CODE_ERROR",
              0.78
            );

            defineProperty_default()(
              assertThisInitialized_default()(_this),
              "AVG_CODE_ERROR",
              0.38
            );

            defineProperty_default()(
              assertThisInitialized_default()(_this),
              "START_PATTERN",
              [i2of5_reader_N, i2of5_reader_N, i2of5_reader_N, i2of5_reader_N]
            );

            defineProperty_default()(
              assertThisInitialized_default()(_this),
              "STOP_PATTERN",
              [i2of5_reader_N, i2of5_reader_N, i2of5_reader_W]
            );

            defineProperty_default()(
              assertThisInitialized_default()(_this),
              "CODE_PATTERN",
              [
                [
                  i2of5_reader_N,
                  i2of5_reader_N,
                  i2of5_reader_W,
                  i2of5_reader_W,
                  i2of5_reader_N,
                ],
                [
                  i2of5_reader_W,
                  i2of5_reader_N,
                  i2of5_reader_N,
                  i2of5_reader_N,
                  i2of5_reader_W,
                ],
                [
                  i2of5_reader_N,
                  i2of5_reader_W,
                  i2of5_reader_N,
                  i2of5_reader_N,
                  i2of5_reader_W,
                ],
                [
                  i2of5_reader_W,
                  i2of5_reader_W,
                  i2of5_reader_N,
                  i2of5_reader_N,
                  i2of5_reader_N,
                ],
                [
                  i2of5_reader_N,
                  i2of5_reader_N,
                  i2of5_reader_W,
                  i2of5_reader_N,
                  i2of5_reader_W,
                ],
                [
                  i2of5_reader_W,
                  i2of5_reader_N,
                  i2of5_reader_W,
                  i2of5_reader_N,
                  i2of5_reader_N,
                ],
                [
                  i2of5_reader_N,
                  i2of5_reader_W,
                  i2of5_reader_W,
                  i2of5_reader_N,
                  i2of5_reader_N,
                ],
                [
                  i2of5_reader_N,
                  i2of5_reader_N,
                  i2of5_reader_N,
                  i2of5_reader_W,
                  i2of5_reader_W,
                ],
                [
                  i2of5_reader_W,
                  i2of5_reader_N,
                  i2of5_reader_N,
                  i2of5_reader_W,
                  i2of5_reader_N,
                ],
                [
                  i2of5_reader_N,
                  i2of5_reader_W,
                  i2of5_reader_N,
                  i2of5_reader_W,
                  i2of5_reader_N,
                ],
              ]
            );

            defineProperty_default()(
              assertThisInitialized_default()(_this),
              "MAX_CORRECTION_FACTOR",
              5
            );

            defineProperty_default()(
              assertThisInitialized_default()(_this),
              "FORMAT",
              "i2of5"
            );

            if (opts.normalizeBarSpaceWidth) {
              _this.SINGLE_CODE_ERROR = 0.38;
              _this.AVG_CODE_ERROR = 0.09;
            }

            _this.config = opts;
            return possibleConstructorReturn_default()(
              _this,
              assertThisInitialized_default()(_this)
            );
          }

          createClass_default()(I2of5Reader, [
            {
              key: "_matchPattern",
              value: function _matchPattern(counter, code) {
                if (this.config.normalizeBarSpaceWidth) {
                  var counterSum = [0, 0];
                  var codeSum = [0, 0];
                  var correction = [0, 0];
                  var correctionRatio = this.MAX_CORRECTION_FACTOR;
                  var correctionRatioInverse = 1 / correctionRatio;

                  for (var i = 0; i < counter.length; i++) {
                    counterSum[i % 2] += counter[i];
                    codeSum[i % 2] += code[i];
                  }

                  correction[0] = codeSum[0] / counterSum[0];
                  correction[1] = codeSum[1] / counterSum[1];
                  correction[0] = Math.max(
                    Math.min(correction[0], correctionRatio),
                    correctionRatioInverse
                  );
                  correction[1] = Math.max(
                    Math.min(correction[1], correctionRatio),
                    correctionRatioInverse
                  );
                  this.barSpaceRatio = correction;

                  for (var _i = 0; _i < counter.length; _i++) {
                    counter[_i] *= this.barSpaceRatio[_i % 2];
                  }
                }

                return get_default()(
                  getPrototypeOf_default()(I2of5Reader.prototype),
                  "_matchPattern",
                  this
                ).call(this, counter, code);
              },
            },
            {
              key: "_findPattern",
              value: function _findPattern(pattern, offset) {
                var isWhite =
                  arguments.length > 2 && arguments[2] !== undefined
                    ? arguments[2]
                    : false;
                var tryHarder =
                  arguments.length > 3 && arguments[3] !== undefined
                    ? arguments[3]
                    : false;
                var counter = new Array(pattern.length).fill(0);
                var counterPos = 0;
                var bestMatch = {
                  error: Number.MAX_VALUE,
                  start: 0,
                  end: 0,
                };
                var epsilon = this.AVG_CODE_ERROR;
                isWhite = isWhite || false;
                tryHarder = tryHarder || false;

                if (!offset) {
                  offset = this._nextSet(this._row);
                }

                for (var i = offset; i < this._row.length; i++) {
                  if (this._row[i] ^ (isWhite ? 1 : 0)) {
                    counter[counterPos]++;
                  } else {
                    if (counterPos === counter.length - 1) {
                      var sum = counter.reduce(function (prev, next) {
                        return prev + next;
                      }, 0);

                      var error = this._matchPattern(counter, pattern);

                      if (error < epsilon) {
                        bestMatch.error = error;
                        bestMatch.start = i - sum;
                        bestMatch.end = i;
                        return bestMatch;
                      }

                      if (tryHarder) {
                        for (var j = 0; j < counter.length - 2; j++) {
                          counter[j] = counter[j + 2];
                        }

                        counter[counter.length - 2] = 0;
                        counter[counter.length - 1] = 0;
                        counterPos--;
                      } else {
                        return null;
                      }
                    } else {
                      counterPos++;
                    }

                    counter[counterPos] = 1;
                    isWhite = !isWhite;
                  }
                }

                return null;
              },
            },
            {
              key: "_findStart",
              value: function _findStart() {
                var leadingWhitespaceStart = 0;

                var offset = this._nextSet(this._row);

                var startInfo = null;
                var narrowBarWidth = 1;

                while (!startInfo) {
                  startInfo = this._findPattern(
                    this.START_PATTERN,
                    offset,
                    false,
                    true
                  );

                  if (!startInfo) {
                    return null;
                  }

                  narrowBarWidth = Math.floor(
                    (startInfo.end - startInfo.start) / 4
                  );
                  leadingWhitespaceStart =
                    startInfo.start - narrowBarWidth * 10;

                  if (leadingWhitespaceStart >= 0) {
                    if (
                      this._matchRange(
                        leadingWhitespaceStart,
                        startInfo.start,
                        0
                      )
                    ) {
                      return startInfo;
                    }
                  }

                  offset = startInfo.end;
                  startInfo = null;
                }

                return null;
              },
            },
            {
              key: "_verifyTrailingWhitespace",
              value: function _verifyTrailingWhitespace(endInfo) {
                var trailingWhitespaceEnd =
                  endInfo.end + (endInfo.end - endInfo.start) / 2;

                if (trailingWhitespaceEnd < this._row.length) {
                  if (this._matchRange(endInfo.end, trailingWhitespaceEnd, 0)) {
                    return endInfo;
                  }
                }

                return null;
              },
            },
            {
              key: "_findEnd",
              value: function _findEnd() {
                this._row.reverse();

                var endInfo = this._findPattern(this.STOP_PATTERN);

                this._row.reverse();

                if (endInfo === null) {
                  return null;
                } // reverse numbers

                var tmp = endInfo.start;
                endInfo.start = this._row.length - endInfo.end;
                endInfo.end = this._row.length - tmp;
                return endInfo !== null
                  ? this._verifyTrailingWhitespace(endInfo)
                  : null;
              },
            },
            {
              key: "_decodePair",
              value: function _decodePair(counterPair) {
                var codes = [];

                for (var i = 0; i < counterPair.length; i++) {
                  var code = this._decodeCode(counterPair[i]);

                  if (!code) {
                    return null;
                  }

                  codes.push(code);
                }

                return codes;
              },
            },
            {
              key: "_decodeCode",
              value: function _decodeCode(counter) {
                var epsilon = this.AVG_CODE_ERROR;
                var bestMatch = {
                  error: Number.MAX_VALUE,
                  code: -1,
                  start: 0,
                  end: 0,
                };

                for (var code = 0; code < this.CODE_PATTERN.length; code++) {
                  var error = this._matchPattern(
                    counter,
                    this.CODE_PATTERN[code]
                  );

                  if (error < bestMatch.error) {
                    bestMatch.code = code;
                    bestMatch.error = error;
                  }
                }

                if (bestMatch.error < epsilon) {
                  return bestMatch;
                }

                return null;
              },
            },
            {
              key: "_decodePayload",
              value: function _decodePayload(counters, result, decodedCodes) {
                var pos = 0;
                var counterLength = counters.length;
                var counterPair = [
                  [0, 0, 0, 0, 0],
                  [0, 0, 0, 0, 0],
                ];
                var codes = null;

                while (pos < counterLength) {
                  for (var i = 0; i < 5; i++) {
                    counterPair[0][i] = counters[pos] * this.barSpaceRatio[0];
                    counterPair[1][i] =
                      counters[pos + 1] * this.barSpaceRatio[1];
                    pos += 2;
                  }

                  codes = this._decodePair(counterPair);

                  if (!codes) {
                    return null;
                  }

                  for (var _i2 = 0; _i2 < codes.length; _i2++) {
                    result.push(codes[_i2].code + "");
                    decodedCodes.push(codes[_i2]);
                  }
                }

                return codes;
              },
            },
            {
              key: "_verifyCounterLength",
              value: function _verifyCounterLength(counters) {
                return counters.length % 10 === 0;
              },
            },
            {
              key: "decode",
              value: function decode(row, start) {
                var result = new Array();
                var decodedCodes = new Array();

                var startInfo = this._findStart();

                if (!startInfo) {
                  return null;
                }

                decodedCodes.push(startInfo);

                var endInfo = this._findEnd();

                if (!endInfo) {
                  return null;
                }

                var counters = this._fillCounters(
                  startInfo.end,
                  endInfo.start,
                  false
                );

                if (!this._verifyCounterLength(counters)) {
                  return null;
                }

                var code = this._decodePayload(counters, result, decodedCodes);

                if (!code) {
                  return null;
                }

                if (result.length % 2 !== 0 || result.length < 6) {
                  return null;
                }

                decodedCodes.push(endInfo);
                return {
                  code: result.join(""),
                  start: startInfo.start,
                  end: endInfo.end,
                  startInfo: startInfo,
                  decodedCodes: decodedCodes,
                  format: this.FORMAT,
                };
              },
            },
          ]);

          return I2of5Reader;
        })(barcode_reader);

        /* harmony default export */ var i2of5_reader =
          i2of5_reader_I2of5Reader;
        // CONCATENATED MODULE: ./src/reader/upc_e_reader.ts

        function upc_e_reader_ownKeys(object, enumerableOnly) {
          var keys = Object.keys(object);
          if (Object.getOwnPropertySymbols) {
            var symbols = Object.getOwnPropertySymbols(object);
            enumerableOnly &&
              (symbols = symbols.filter(function (sym) {
                return Object.getOwnPropertyDescriptor(object, sym).enumerable;
              })),
              keys.push.apply(keys, symbols);
          }
          return keys;
        }

        function upc_e_reader_objectSpread(target) {
          for (var i = 1; i < arguments.length; i++) {
            var source = null != arguments[i] ? arguments[i] : {};
            i % 2
              ? upc_e_reader_ownKeys(Object(source), !0).forEach(function (
                  key
                ) {
                  defineProperty_default()(target, key, source[key]);
                })
              : Object.getOwnPropertyDescriptors
              ? Object.defineProperties(
                  target,
                  Object.getOwnPropertyDescriptors(source)
                )
              : upc_e_reader_ownKeys(Object(source)).forEach(function (key) {
                  Object.defineProperty(
                    target,
                    key,
                    Object.getOwnPropertyDescriptor(source, key)
                  );
                });
          }
          return target;
        }

        function upc_e_reader_createSuper(Derived) {
          var hasNativeReflectConstruct =
            upc_e_reader_isNativeReflectConstruct();
          return function _createSuperInternal() {
            var Super = getPrototypeOf_default()(Derived),
              result;
            if (hasNativeReflectConstruct) {
              var NewTarget = getPrototypeOf_default()(this).constructor;
              result = Reflect.construct(Super, arguments, NewTarget);
            } else {
              result = Super.apply(this, arguments);
            }
            return possibleConstructorReturn_default()(this, result);
          };
        }

        function upc_e_reader_isNativeReflectConstruct() {
          if (typeof Reflect === "undefined" || !Reflect.construct)
            return false;
          if (Reflect.construct.sham) return false;
          if (typeof Proxy === "function") return true;
          try {
            Boolean.prototype.valueOf.call(
              Reflect.construct(Boolean, [], function () {})
            );
            return true;
          } catch (e) {
            return false;
          }
        }

        var upc_e_reader_UPCEReader = /*#__PURE__*/ (function (_EANReader) {
          inherits_default()(UPCEReader, _EANReader);

          var _super = upc_e_reader_createSuper(UPCEReader);

          function UPCEReader() {
            var _this;

            classCallCheck_default()(this, UPCEReader);

            for (
              var _len = arguments.length, args = new Array(_len), _key = 0;
              _key < _len;
              _key++
            ) {
              args[_key] = arguments[_key];
            }

            _this = _super.call.apply(_super, [this].concat(args));

            defineProperty_default()(
              assertThisInitialized_default()(_this),
              "CODE_FREQUENCY",
              [
                [56, 52, 50, 49, 44, 38, 35, 42, 41, 37],
                [7, 11, 13, 14, 19, 25, 28, 21, 22, 26],
              ]
            );

            defineProperty_default()(
              assertThisInitialized_default()(_this),
              "STOP_PATTERN",
              [
                (1 / 6) * 7,
                (1 / 6) * 7,
                (1 / 6) * 7,
                (1 / 6) * 7,
                (1 / 6) * 7,
                (1 / 6) * 7,
              ]
            );

            defineProperty_default()(
              assertThisInitialized_default()(_this),
              "FORMAT",
              "upc_e"
            );

            return _this;
          }

          createClass_default()(UPCEReader, [
            {
              key: "_decodePayload",
              value: function _decodePayload(inCode, result, decodedCodes) {
                var outCode = upc_e_reader_objectSpread({}, inCode);

                var codeFrequency = 0x0;

                for (var i = 0; i < 6; i++) {
                  outCode = this._decodeCode(outCode.end);

                  if (!outCode) {
                    return null;
                  }

                  if (outCode.code >= CODE_G_START) {
                    outCode.code = outCode.code - CODE_G_START;
                    codeFrequency |= 1 << (5 - i);
                  }

                  result.push(outCode.code);
                  decodedCodes.push(outCode);
                }

                if (!this._determineParity(codeFrequency, result)) {
                  return null;
                }

                return outCode;
              },
            },
            {
              key: "_determineParity",
              value: function _determineParity(codeFrequency, result) {
                for (
                  var nrSystem = 0;
                  nrSystem < this.CODE_FREQUENCY.length;
                  nrSystem++
                ) {
                  for (
                    var i = 0;
                    i < this.CODE_FREQUENCY[nrSystem].length;
                    i++
                  ) {
                    if (codeFrequency === this.CODE_FREQUENCY[nrSystem][i]) {
                      result.unshift(nrSystem);
                      result.push(i);
                      return true;
                    }
                  }
                }

                return false;
              },
            },
            {
              key: "_convertToUPCA",
              value: function _convertToUPCA(result) {
                var upca = [result[0]];
                var lastDigit = result[result.length - 2];

                if (lastDigit <= 2) {
                  upca = upca
                    .concat(result.slice(1, 3))
                    .concat([lastDigit, 0, 0, 0, 0])
                    .concat(result.slice(3, 6));
                } else if (lastDigit === 3) {
                  upca = upca
                    .concat(result.slice(1, 4))
                    .concat([0, 0, 0, 0, 0])
                    .concat(result.slice(4, 6));
                } else if (lastDigit === 4) {
                  upca = upca
                    .concat(result.slice(1, 5))
                    .concat([0, 0, 0, 0, 0, result[5]]);
                } else {
                  upca = upca
                    .concat(result.slice(1, 6))
                    .concat([0, 0, 0, 0, lastDigit]);
                }

                upca.push(result[result.length - 1]);
                return upca;
              },
            },
            {
              key: "_checksum",
              value: function _checksum(result) {
                return get_default()(
                  getPrototypeOf_default()(UPCEReader.prototype),
                  "_checksum",
                  this
                ).call(this, this._convertToUPCA(result));
              },
            },
            {
              key: "_findEnd",
              value: function _findEnd(offset, isWhite) {
                return get_default()(
                  getPrototypeOf_default()(UPCEReader.prototype),
                  "_findEnd",
                  this
                ).call(this, offset, true);
              },
            },
            {
              key: "_verifyTrailingWhitespace",
              value: function _verifyTrailingWhitespace(endInfo) {
                var trailingWhitespaceEnd =
                  endInfo.end + (endInfo.end - endInfo.start) / 2;

                if (trailingWhitespaceEnd < this._row.length) {
                  if (this._matchRange(endInfo.end, trailingWhitespaceEnd, 0)) {
                    return endInfo;
                  }
                }

                return null;
              },
            },
          ]);

          return UPCEReader;
        })(ean_reader);

        /* harmony default export */ var upc_e_reader = upc_e_reader_UPCEReader;
        // CONCATENATED MODULE: ./src/reader/upc_reader.ts

        function upc_reader_createSuper(Derived) {
          var hasNativeReflectConstruct = upc_reader_isNativeReflectConstruct();
          return function _createSuperInternal() {
            var Super = getPrototypeOf_default()(Derived),
              result;
            if (hasNativeReflectConstruct) {
              var NewTarget = getPrototypeOf_default()(this).constructor;
              result = Reflect.construct(Super, arguments, NewTarget);
            } else {
              result = Super.apply(this, arguments);
            }
            return possibleConstructorReturn_default()(this, result);
          };
        }

        function upc_reader_isNativeReflectConstruct() {
          if (typeof Reflect === "undefined" || !Reflect.construct)
            return false;
          if (Reflect.construct.sham) return false;
          if (typeof Proxy === "function") return true;
          try {
            Boolean.prototype.valueOf.call(
              Reflect.construct(Boolean, [], function () {})
            );
            return true;
          } catch (e) {
            return false;
          }
        }

        var upc_reader_UPCReader = /*#__PURE__*/ (function (_EANReader) {
          inherits_default()(UPCReader, _EANReader);

          var _super = upc_reader_createSuper(UPCReader);

          function UPCReader() {
            var _this;

            classCallCheck_default()(this, UPCReader);

            for (
              var _len = arguments.length, args = new Array(_len), _key = 0;
              _key < _len;
              _key++
            ) {
              args[_key] = arguments[_key];
            }

            _this = _super.call.apply(_super, [this].concat(args));

            defineProperty_default()(
              assertThisInitialized_default()(_this),
              "FORMAT",
              "upc_a"
            );

            return _this;
          }

          createClass_default()(UPCReader, [
            {
              key: "decode",
              value: function decode(row, start) {
                var result = ean_reader.prototype.decode.call(this);

                if (
                  result &&
                  result.code &&
                  result.code.length === 13 &&
                  result.code.charAt(0) === "0"
                ) {
                  result.code = result.code.substring(1);
                  return result;
                }

                return null;
              },
            },
          ]);

          return UPCReader;
        })(ean_reader);

        /* harmony default export */ var upc_reader = upc_reader_UPCReader;
        // CONCATENATED MODULE: ./src/decoder/bresenham.js
        var Bresenham = {};
        var Slope = {
          DIR: {
            UP: 1,
            DOWN: -1,
          },
        };
        /**
         * Scans a line of the given image from point p1 to p2 and returns a result object containing
         * gray-scale values (0-255) of the underlying pixels in addition to the min
         * and max values.
         * @param {Object} imageWrapper
         * @param {Object} p1 The start point {x,y}
         * @param {Object} p2 The end point {x,y}
         * @returns {line, min, max}
         */

        Bresenham.getBarcodeLine = function (imageWrapper, p1, p2) {
          /* eslint-disable no-bitwise */
          var x0 = p1.x | 0;
          var y0 = p1.y | 0;
          var x1 = p2.x | 0;
          var y1 = p2.y | 0;
          /* eslint-disable no-bitwise */

          var steep = Math.abs(y1 - y0) > Math.abs(x1 - x0);
          var error;
          var y;
          var tmp;
          var x;
          var line = [];
          var imageData = imageWrapper.data;
          var width = imageWrapper.size.x;
          var val;
          var min = 255;
          var max = 0;

          function read(a, b) {
            val = imageData[b * width + a];
            min = val < min ? val : min;
            max = val > max ? val : max;
            line.push(val);
          }

          if (steep) {
            tmp = x0;
            x0 = y0;
            y0 = tmp;
            tmp = x1;
            x1 = y1;
            y1 = tmp;
          }

          if (x0 > x1) {
            tmp = x0;
            x0 = x1;
            x1 = tmp;
            tmp = y0;
            y0 = y1;
            y1 = tmp;
          }

          var deltaX = x1 - x0;
          var deltaY = Math.abs(y1 - y0);
          error = (deltaX / 2) | 0;
          y = y0;
          var yStep = y0 < y1 ? 1 : -1;

          for (x = x0; x < x1; x++) {
            if (steep) {
              read(y, x);
            } else {
              read(x, y);
            }

            error -= deltaY;

            if (error < 0) {
              y += yStep;
              error += deltaX;
            }
          }

          return {
            line: line,
            min: min,
            max: max,
          };
        };
        /**
         * Converts the result from getBarcodeLine into a binary representation
         * also considering the frequency and slope of the signal for more robust results
         * @param {Object} result {line, min, max}
         */

        Bresenham.toBinaryLine = function (result) {
          var min = result.min;
          var max = result.max;
          var line = result.line;
          var slope;
          var slope2;
          var center = min + (max - min) / 2;
          var extrema = [];
          var currentDir;
          var dir;
          var threshold = (max - min) / 12;
          var rThreshold = -threshold;
          var i;
          var j; // 1. find extrema

          currentDir = line[0] > center ? Slope.DIR.UP : Slope.DIR.DOWN;
          extrema.push({
            pos: 0,
            val: line[0],
          });

          for (i = 0; i < line.length - 2; i++) {
            slope = line[i + 1] - line[i];
            slope2 = line[i + 2] - line[i + 1];

            if (slope + slope2 < rThreshold && line[i + 1] < center * 1.5) {
              dir = Slope.DIR.DOWN;
            } else if (
              slope + slope2 > threshold &&
              line[i + 1] > center * 0.5
            ) {
              dir = Slope.DIR.UP;
            } else {
              dir = currentDir;
            }

            if (currentDir !== dir) {
              extrema.push({
                pos: i,
                val: line[i],
              });
              currentDir = dir;
            }
          }

          extrema.push({
            pos: line.length,
            val: line[line.length - 1],
          });

          for (j = extrema[0].pos; j < extrema[1].pos; j++) {
            line[j] = line[j] > center ? 0 : 1;
          } // iterate over extrema and convert to binary based on avg between minmax

          for (i = 1; i < extrema.length - 1; i++) {
            if (extrema[i + 1].val > extrema[i].val) {
              threshold =
                (extrema[i].val +
                  ((extrema[i + 1].val - extrema[i].val) / 3) * 2) |
                0;
            } else {
              threshold =
                (extrema[i + 1].val +
                  (extrema[i].val - extrema[i + 1].val) / 3) |
                0;
            }

            for (j = extrema[i].pos; j < extrema[i + 1].pos; j++) {
              line[j] = line[j] > threshold ? 0 : 1;
            }
          }

          return {
            line: line,
            threshold: threshold,
          };
        };
        /**
         * Used for development only
         */

        Bresenham.debug = {
          printFrequency: function printFrequency(line, canvas) {
            var i;
            var ctx = canvas.getContext("2d"); // eslint-disable-next-line no-param-reassign

            canvas.width = line.length; // eslint-disable-next-line no-param-reassign

            canvas.height = 256;
            ctx.beginPath();
            ctx.strokeStyle = "blue";

            for (i = 0; i < line.length; i++) {
              ctx.moveTo(i, 255);
              ctx.lineTo(i, 255 - line[i]);
            }

            ctx.stroke();
            ctx.closePath();
          },
          printPattern: function printPattern(line, canvas) {
            var ctx = canvas.getContext("2d");
            var i; // eslint-disable-next-line no-param-reassign

            canvas.width = line.length;
            ctx.fillColor = "black";

            for (i = 0; i < line.length; i++) {
              if (line[i] === 1) {
                ctx.fillRect(i, 0, 1, 100);
              }
            }
          },
        };
        /* harmony default export */ var bresenham = Bresenham;
        // CONCATENATED MODULE: ./src/decoder/barcode_decoder.js

        function _createForOfIteratorHelper(o, allowArrayLike) {
          var it =
            (typeof Symbol !== "undefined" && o[Symbol.iterator]) ||
            o["@@iterator"];
          if (!it) {
            if (
              Array.isArray(o) ||
              (it = _unsupportedIterableToArray(o)) ||
              (allowArrayLike && o && typeof o.length === "number")
            ) {
              if (it) o = it;
              var i = 0;
              var F = function F() {};
              return {
                s: F,
                n: function n() {
                  if (i >= o.length) return { done: true };
                  return { done: false, value: o[i++] };
                },
                e: function e(_e) {
                  throw _e;
                },
                f: F,
              };
            }
            throw new TypeError(
              "Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."
            );
          }
          var normalCompletion = true,
            didErr = false,
            err;
          return {
            s: function s() {
              it = it.call(o);
            },
            n: function n() {
              var step = it.next();
              normalCompletion = step.done;
              return step;
            },
            e: function e(_e2) {
              didErr = true;
              err = _e2;
            },
            f: function f() {
              try {
                if (!normalCompletion && it["return"] != null) it["return"]();
              } finally {
                if (didErr) throw err;
              }
            },
          };
        }

        function _unsupportedIterableToArray(o, minLen) {
          if (!o) return;
          if (typeof o === "string") return _arrayLikeToArray(o, minLen);
          var n = Object.prototype.toString.call(o).slice(8, -1);
          if (n === "Object" && o.constructor) n = o.constructor.name;
          if (n === "Map" || n === "Set") return Array.from(o);
          if (
            n === "Arguments" ||
            /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)
          )
            return _arrayLikeToArray(o, minLen);
        }

        function _arrayLikeToArray(arr, len) {
          if (len == null || len > arr.length) len = arr.length;
          for (var i = 0, arr2 = new Array(len); i < len; i++) {
            arr2[i] = arr[i];
          }
          return arr2;
        }

        /* eslint-disable import/no-cycle */

        var READERS = {
          code_128_reader: code_128_reader,
          ean_reader: ean_reader,
          ean_5_reader: ean_5_reader,
          ean_2_reader: ean_2_reader,
          ean_8_reader: ean_8_reader,
          code_39_reader: code_39_reader,
          code_39_vin_reader: code_39_vin_reader,
          codabar_reader: codabar_reader,
          upc_reader: upc_reader,
          upc_e_reader: upc_e_reader,
          i2of5_reader: i2of5_reader,
          "2of5_reader": _2of5_reader,
          code_93_reader: code_93_reader,
          code_32_reader: code_32_reader,
        };
        /* harmony default export */ var barcode_decoder = {
          registerReader: function registerReader(name, reader) {
            READERS[name] = reader;
          },
          create: function create(config, inputImageWrapper) {
            var _canvas = {
              ctx: {
                frequency: null,
                pattern: null,
                overlay: null,
              },
              dom: {
                frequency: null,
                pattern: null,
                overlay: null,
              },
            };
            var _barcodeReaders = [];
            initCanvas();
            initReaders();
            initConfig();

            function initCanvas() {
              if (true && typeof document !== "undefined") {
                var $debug = document.querySelector("#debug.detection");
                _canvas.dom.frequency =
                  document.querySelector("canvas.frequency");

                if (!_canvas.dom.frequency) {
                  _canvas.dom.frequency = document.createElement("canvas");
                  _canvas.dom.frequency.className = "frequency";

                  if ($debug) {
                    $debug.appendChild(_canvas.dom.frequency);
                  }
                }

                _canvas.ctx.frequency = _canvas.dom.frequency.getContext("2d");
                _canvas.dom.pattern = document.querySelector(
                  "canvas.patternBuffer"
                );

                if (!_canvas.dom.pattern) {
                  _canvas.dom.pattern = document.createElement("canvas");
                  _canvas.dom.pattern.className = "patternBuffer";

                  if ($debug) {
                    $debug.appendChild(_canvas.dom.pattern);
                  }
                }

                _canvas.ctx.pattern = _canvas.dom.pattern.getContext("2d");
                _canvas.dom.overlay = document.querySelector(
                  "canvas.drawingBuffer"
                );

                if (_canvas.dom.overlay) {
                  _canvas.ctx.overlay = _canvas.dom.overlay.getContext("2d");
                }
              }
            }

            function initReaders() {
              config.readers.forEach(function (readerConfig) {
                var reader;
                var configuration = {};
                var supplements = [];

                if (typeof_default()(readerConfig) === "object") {
                  reader = readerConfig.format;
                  configuration = readerConfig.config;
                } else if (typeof readerConfig === "string") {
                  reader = readerConfig;
                }

                if (true) {
                  console.log("Before registering reader: ", reader);
                }

                if (configuration.supplements) {
                  supplements = configuration.supplements.map(function (
                    supplement
                  ) {
                    return new READERS[supplement]();
                  });
                }

                try {
                  var readerObj = new READERS[reader](
                    configuration,
                    supplements
                  );

                  _barcodeReaders.push(readerObj);
                } catch (err) {
                  console.error("* Error constructing reader ", reader, err);
                  throw err;
                }
              });

              if (true) {
                console.log(
                  "Registered Readers: ".concat(
                    _barcodeReaders
                      .map(function (reader) {
                        return JSON.stringify({
                          format: reader.FORMAT,
                          config: reader.config,
                        });
                      })
                      .join(", ")
                  )
                );
              }
            }

            function initConfig() {
              if (true && typeof document !== "undefined") {
                var i;
                var vis = [
                  {
                    node: _canvas.dom.frequency,
                    prop: config.debug.showFrequency,
                  },
                  {
                    node: _canvas.dom.pattern,
                    prop: config.debug.showPattern,
                  },
                ];

                for (i = 0; i < vis.length; i++) {
                  if (vis[i].prop === true) {
                    vis[i].node.style.display = "block";
                  } else {
                    vis[i].node.style.display = "none";
                  }
                }
              }
            }
            /**
             * extend the line on both ends
             * @param {Array} line
             * @param {Number} angle
             */

            function getExtendedLine(line, angle, ext) {
              function extendLine(amount) {
                var extension = {
                  y: amount * Math.sin(angle),
                  x: amount * Math.cos(angle),
                };
                /* eslint-disable no-param-reassign */

                line[0].y -= extension.y;
                line[0].x -= extension.x;
                line[1].y += extension.y;
                line[1].x += extension.x;
                /* eslint-enable no-param-reassign */
              } // check if inside image

              extendLine(ext);

              while (
                ext > 1 &&
                (!inputImageWrapper.inImageWithBorder(line[0]) ||
                  !inputImageWrapper.inImageWithBorder(line[1]))
              ) {
                // eslint-disable-next-line no-param-reassign
                ext -= Math.ceil(ext / 2);
                extendLine(-ext);
              }

              return line;
            }

            function getLine(box) {
              return [
                {
                  x: (box[1][0] - box[0][0]) / 2 + box[0][0],
                  y: (box[1][1] - box[0][1]) / 2 + box[0][1],
                },
                {
                  x: (box[3][0] - box[2][0]) / 2 + box[2][0],
                  y: (box[3][1] - box[2][1]) / 2 + box[2][1],
                },
              ];
            }

            function tryDecode(line) {
              var result = null;
              var i;
              var barcodeLine = bresenham.getBarcodeLine(
                inputImageWrapper,
                line[0],
                line[1]
              );

              if (true && config.debug.showFrequency) {
                image_debug["a" /* default */].drawPath(
                  line,
                  {
                    x: "x",
                    y: "y",
                  },
                  _canvas.ctx.overlay,
                  {
                    color: "red",
                    lineWidth: 3,
                  }
                );
                bresenham.debug.printFrequency(
                  barcodeLine.line,
                  _canvas.dom.frequency
                );
              }

              bresenham.toBinaryLine(barcodeLine);

              if (true && config.debug.showPattern) {
                bresenham.debug.printPattern(
                  barcodeLine.line,
                  _canvas.dom.pattern
                );
              }

              for (i = 0; i < _barcodeReaders.length && result === null; i++) {
                result = _barcodeReaders[i].decodePattern(barcodeLine.line);
              }

              if (result === null) {
                return null;
              }

              return {
                codeResult: result,
                barcodeLine: barcodeLine,
              };
            }
            /**
             * This method slices the given area apart and tries to detect a barcode-pattern
             * for each slice. It returns the decoded barcode, or null if nothing was found
             * @param {Array} box
             * @param {Array} line
             * @param {Number} lineAngle
             */

            function tryDecodeBruteForce(box, line, lineAngle) {
              var sideLength = Math.sqrt(
                Math.pow(box[1][0] - box[0][0], 2) +
                  Math.pow(box[1][1] - box[0][1], 2)
              );
              var i;
              var slices = 16;
              var result = null;
              var dir;
              var extension;
              var xdir = Math.sin(lineAngle);
              var ydir = Math.cos(lineAngle);

              for (i = 1; i < slices && result === null; i++) {
                // move line perpendicular to angle
                // eslint-disable-next-line no-mixed-operators
                dir = (sideLength / slices) * i * (i % 2 === 0 ? -1 : 1);
                extension = {
                  y: dir * xdir,
                  x: dir * ydir,
                };
                /* eslint-disable no-param-reassign */

                line[0].y += extension.x;
                line[0].x -= extension.y;
                line[1].y += extension.x;
                line[1].x -= extension.y;
                /* eslint-enable no-param-reassign */

                result = tryDecode(line);
              }

              return result;
            }

            function getLineLength(line) {
              return Math.sqrt(
                Math.pow(Math.abs(line[1].y - line[0].y), 2) +
                  Math.pow(Math.abs(line[1].x - line[0].x), 2)
              );
            }

            function _decodeFromImage2(_x) {
              return _decodeFromImage.apply(this, arguments);
            }
            /**
             * With the help of the configured readers (Code128 or EAN) this function tries to detect a
             * valid barcode pattern within the given area.
             * @param {Object} box The area to search in
             * @returns {Object} the result {codeResult, line, angle, pattern, threshold}
             */

            function _decodeFromImage() {
              _decodeFromImage = asyncToGenerator_default()(
                /*#__PURE__*/ regenerator_default.a.mark(function _callee2(
                  imageWrapper
                ) {
                  var result, _iterator, _step, reader;

                  return regenerator_default.a.wrap(
                    function _callee2$(_context2) {
                      while (1) {
                        switch ((_context2.prev = _context2.next)) {
                          case 0:
                            result = null;
                            _iterator =
                              _createForOfIteratorHelper(_barcodeReaders);
                            _context2.prev = 2;

                            _iterator.s();

                          case 4:
                            if ((_step = _iterator.n()).done) {
                              _context2.next = 14;
                              break;
                            }

                            reader = _step.value;

                            if (!reader.decodeImage) {
                              _context2.next = 12;
                              break;
                            }

                            _context2.next = 9;
                            return reader.decodeImage(imageWrapper);

                          case 9:
                            result = _context2.sent;

                            if (!result) {
                              _context2.next = 12;
                              break;
                            }

                            return _context2.abrupt("break", 14);

                          case 12:
                            _context2.next = 4;
                            break;

                          case 14:
                            _context2.next = 19;
                            break;

                          case 16:
                            _context2.prev = 16;
                            _context2.t0 = _context2["catch"](2);

                            _iterator.e(_context2.t0);

                          case 19:
                            _context2.prev = 19;

                            _iterator.f();

                            return _context2.finish(19);

                          case 22:
                            return _context2.abrupt("return", result);

                          case 23:
                          case "end":
                            return _context2.stop();
                        }
                      }
                    },
                    _callee2,
                    null,
                    [[2, 16, 19, 22]]
                  );
                })
              );
              return _decodeFromImage.apply(this, arguments);
            }

            function _decodeFromBoundingBox(box) {
              var line;
              var ctx = _canvas.ctx.overlay;
              var result;

              if (true) {
                if (config.debug.drawBoundingBox && ctx) {
                  image_debug["a" /* default */].drawPath(
                    box,
                    {
                      x: 0,
                      y: 1,
                    },
                    ctx,
                    {
                      color: "blue",
                      lineWidth: 2,
                    }
                  );
                }
              }

              line = getLine(box);
              var lineLength = getLineLength(line);
              var lineAngle = Math.atan2(
                line[1].y - line[0].y,
                line[1].x - line[0].x
              );
              line = getExtendedLine(
                line,
                lineAngle,
                Math.floor(lineLength * 0.1)
              );

              if (line === null) {
                return null;
              }

              result = tryDecode(line);

              if (result === null) {
                result = tryDecodeBruteForce(box, line, lineAngle);
              }

              if (result === null) {
                return null;
              }

              if (true && result && config.debug.drawScanline && ctx) {
                image_debug["a" /* default */].drawPath(
                  line,
                  {
                    x: "x",
                    y: "y",
                  },
                  ctx,
                  {
                    color: "red",
                    lineWidth: 3,
                  }
                );
              }

              return {
                codeResult: result.codeResult,
                line: line,
                angle: lineAngle,
                pattern: result.barcodeLine.line,
                threshold: result.barcodeLine.threshold,
              };
            }

            return {
              decodeFromBoundingBox: function decodeFromBoundingBox(box) {
                return _decodeFromBoundingBox(box);
              },
              decodeFromBoundingBoxes: function decodeFromBoundingBoxes(boxes) {
                var i;
                var result;
                var barcodes = [];
                var multiple = config.multiple;

                for (i = 0; i < boxes.length; i++) {
                  var box = boxes[i];
                  result = _decodeFromBoundingBox(box) || {};
                  result.box = box;

                  if (multiple) {
                    barcodes.push(result);
                  } else if (result.codeResult) {
                    return result;
                  }
                }

                return {
                  barcodes: barcodes,
                };
              },
              decodeFromImage: function decodeFromImage(imageWrapperIn) {
                return asyncToGenerator_default()(
                  /*#__PURE__*/ regenerator_default.a.mark(function _callee() {
                    var result;
                    return regenerator_default.a.wrap(function _callee$(
                      _context
                    ) {
                      while (1) {
                        switch ((_context.prev = _context.next)) {
                          case 0:
                            _context.next = 2;
                            return _decodeFromImage2(imageWrapperIn);

                          case 2:
                            result = _context.sent;
                            return _context.abrupt("return", result);

                          case 4:
                          case "end":
                            return _context.stop();
                        }
                      }
                    },
                    _callee);
                  })
                )();
              },
              registerReader: function registerReader(name, reader) {
                if (READERS[name]) {
                  throw new Error("cannot register existing reader", name);
                }

                READERS[name] = reader;
              },
              setReaders: function setReaders(readers) {
                // eslint-disable-next-line no-param-reassign
                config.readers = readers;
                _barcodeReaders.length = 0;
                initReaders();
              },
            };
          },
        };
        // CONCATENATED MODULE: ./src/reader/index.ts

        // CONCATENATED MODULE: ./src/common/events.ts
        /* harmony default export */ var events = (function EventInterface() {
          var events = {};

          function getEvent(eventName) {
            if (!events[eventName]) {
              events[eventName] = {
                subscribers: [],
              };
            }

            return events[eventName];
          }

          function clearEvents() {
            events = {};
          }

          function publishSubscription(subscription, data) {
            if (subscription.async) {
              setTimeout(function () {
                subscription.callback(data);
              }, 4);
            } else {
              subscription.callback(data);
            }
          }

          function _subscribe(event, callback, async) {
            var subscription;

            if (typeof callback === "function") {
              subscription = {
                callback: callback,
                async: async,
              };
            } else {
              subscription = callback;

              if (!subscription.callback) {
                throw new Error("Callback was not specified on options");
              }
            }

            getEvent(event).subscribers.push(subscription);
          }

          return {
            subscribe: function subscribe(event, callback, async) {
              return _subscribe(event, callback, async);
            },
            publish: function publish(eventName, data) {
              var event = getEvent(eventName);
              var subscribers = event.subscribers; // Publish one-time subscriptions

              subscribers
                .filter(function (subscriber) {
                  return !!subscriber.once;
                })
                .forEach(function (subscriber) {
                  publishSubscription(subscriber, data);
                }); // remove them from the subscriber

              event.subscribers = subscribers.filter(function (subscriber) {
                return !subscriber.once;
              }); // publish the rest

              event.subscribers.forEach(function (subscriber) {
                publishSubscription(subscriber, data);
              });
            },
            once: function once(event, callback) {
              var async =
                arguments.length > 2 && arguments[2] !== undefined
                  ? arguments[2]
                  : false;

              _subscribe(event, {
                callback: callback,
                async: async,
                once: true,
              });
            },
            unsubscribe: function unsubscribe(eventName, callback) {
              if (eventName) {
                var _event = getEvent(eventName);

                if (_event && callback) {
                  _event.subscribers = _event.subscribers.filter(function (
                    subscriber
                  ) {
                    return subscriber.callback !== callback;
                  });
                } else {
                  _event.subscribers = [];
                }
              } else {
                clearEvents();
              }
            },
          };
        })();
        // EXTERNAL MODULE: ./node_modules/lodash/pick.js
        var pick = __webpack_require__(85);
        var pick_default = /*#__PURE__*/ __webpack_require__.n(pick);

        // EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/wrapNativeSuper.js
        var wrapNativeSuper = __webpack_require__(86);
        var wrapNativeSuper_default =
          /*#__PURE__*/ __webpack_require__.n(wrapNativeSuper);

        // CONCATENATED MODULE: ./src/quagga/Exception.ts

        function Exception_createSuper(Derived) {
          var hasNativeReflectConstruct = Exception_isNativeReflectConstruct();
          return function _createSuperInternal() {
            var Super = getPrototypeOf_default()(Derived),
              result;
            if (hasNativeReflectConstruct) {
              var NewTarget = getPrototypeOf_default()(this).constructor;
              result = Reflect.construct(Super, arguments, NewTarget);
            } else {
              result = Super.apply(this, arguments);
            }
            return possibleConstructorReturn_default()(this, result);
          };
        }

        function Exception_isNativeReflectConstruct() {
          if (typeof Reflect === "undefined" || !Reflect.construct)
            return false;
          if (Reflect.construct.sham) return false;
          if (typeof Proxy === "function") return true;
          try {
            Boolean.prototype.valueOf.call(
              Reflect.construct(Boolean, [], function () {})
            );
            return true;
          } catch (e) {
            return false;
          }
        }

        var Exception_Exception = /*#__PURE__*/ (function (_Error) {
          inherits_default()(Exception, _Error);

          var _super = Exception_createSuper(Exception);

          function Exception(m, code) {
            var _this;

            classCallCheck_default()(this, Exception);

            _this = _super.call(this, m);

            defineProperty_default()(
              assertThisInitialized_default()(_this),
              "code",
              void 0
            );

            _this.code = code;
            Object.setPrototypeOf(
              assertThisInitialized_default()(_this),
              Exception.prototype
            );
            return _this;
          }

          return createClass_default()(Exception);
        })(/*#__PURE__*/ wrapNativeSuper_default()(Error));

        // CONCATENATED MODULE: ./src/common/mediaDevices.ts

        var ERROR_DESC =
          "This may mean that the user has declined camera access, or the browser does not support media APIs. If you are running in iOS, you must use Safari.";
        function enumerateDevices() {
          try {
            return navigator.mediaDevices.enumerateDevices();
          } catch (err) {
            var error = new Exception_Exception(
              "enumerateDevices is not defined. ".concat(ERROR_DESC),
              -1
            );
            return Promise.reject(error);
          }
        }
        function getUserMedia(constraints) {
          try {
            return navigator.mediaDevices.getUserMedia(constraints);
          } catch (err) {
            var error = new Exception_Exception(
              "getUserMedia is not defined. ".concat(ERROR_DESC),
              -1
            );
            return Promise.reject(error);
          }
        }
        // CONCATENATED MODULE: ./src/input/camera_access.ts

        // TODO: when this file was written years ago, HTMLMediaElement.play() did not return a useful value
        // to let us know when the video started playing.  Now, it does.  So, we shouldn't need to run this
        // odd waitForVideo() function that polls to see if the video has started.

        var streamRef;

        function waitForVideo(video) {
          return new Promise(function (resolve, reject) {
            var attempts = 10;

            function checkVideo() {
              if (attempts > 0) {
                if (video.videoWidth > 10 && video.videoHeight > 10) {
                  if (true) {
                    console.log(
                      "* dev: checkVideo found "
                        .concat(video.videoWidth, "px x ")
                        .concat(video.videoHeight, "px")
                    );
                  }

                  resolve();
                } else {
                  window.setTimeout(checkVideo, 500);
                }
              } else {
                reject(
                  new Exception_Exception(
                    "Unable to play video stream. Is webcam working?",
                    -1
                  )
                ); // TODO: add error code
              }

              attempts--;
            }

            checkVideo();
          });
        }
        /**
         * Tries to attach the camera-stream to a given video-element
         * and calls the callback function when the content is ready
         * @param {Object} constraints
         * @param {Object} video
         */

        function initCamera(_x, _x2) {
          return _initCamera.apply(this, arguments);
        }

        function _initCamera() {
          _initCamera = asyncToGenerator_default()(
            /*#__PURE__*/ regenerator_default.a.mark(function _callee4(
              video,
              constraints
            ) {
              var stream;
              return regenerator_default.a.wrap(function _callee4$(_context4) {
                while (1) {
                  switch ((_context4.prev = _context4.next)) {
                    case 0:
                      _context4.next = 2;
                      return getUserMedia(constraints);

                    case 2:
                      stream = _context4.sent;
                      streamRef = stream;

                      if (!video) {
                        _context4.next = 11;
                        break;
                      }

                      video.setAttribute("autoplay", "true");
                      video.setAttribute("muted", "true");
                      video.setAttribute("playsinline", "true"); // not listed on MDN...
                      // eslint-disable-next-line no-param-reassign

                      video.srcObject = stream;
                      video.addEventListener("loadedmetadata", function () {
                        video.play()["catch"](function (err) {
                          console.warn(
                            "* Error while trying to play video stream:",
                            err
                          );
                        });
                      });
                      return _context4.abrupt("return", waitForVideo(video));

                    case 11:
                      return _context4.abrupt("return", Promise.resolve());

                    case 12:
                    case "end":
                      return _context4.stop();
                  }
                }
              }, _callee4);
            })
          );
          return _initCamera.apply(this, arguments);
        }

        function deprecatedConstraints(videoConstraints) {
          var normalized = pick_default()(videoConstraints, [
            "width",
            "height",
            "facingMode",
            "aspectRatio",
            "deviceId",
          ]);

          if (
            typeof videoConstraints.minAspectRatio !== "undefined" &&
            videoConstraints.minAspectRatio > 0
          ) {
            normalized.aspectRatio = videoConstraints.minAspectRatio;
            console.log(
              "WARNING: Constraint 'minAspectRatio' is deprecated; Use 'aspectRatio' instead"
            );
          }

          if (typeof videoConstraints.facing !== "undefined") {
            normalized.facingMode = videoConstraints.facing;
            console.log(
              "WARNING: Constraint 'facing' is deprecated. Use 'facingMode' instead'"
            );
          }

          return normalized;
        } // TODO: #192 I don't think there's any good reason pickConstraints should return a Promise,
        // I think it was just that way so it could be chained to other functions that did return a Promise.
        // That's not necessary with async functions being a thing, so that should be fixed.

        function pickConstraints() {
          var videoConstraints =
            arguments.length > 0 && arguments[0] !== undefined
              ? arguments[0]
              : {};
          var video = deprecatedConstraints(videoConstraints);

          if (video && video.deviceId && video.facingMode) {
            delete video.facingMode;
          }

          return Promise.resolve({
            audio: false,
            video: video,
          });
        }

        function enumerateVideoDevices() {
          return _enumerateVideoDevices.apply(this, arguments);
        }

        function _enumerateVideoDevices() {
          _enumerateVideoDevices = asyncToGenerator_default()(
            /*#__PURE__*/ regenerator_default.a.mark(function _callee5() {
              var devices;
              return regenerator_default.a.wrap(function _callee5$(_context5) {
                while (1) {
                  switch ((_context5.prev = _context5.next)) {
                    case 0:
                      _context5.next = 2;
                      return enumerateDevices();

                    case 2:
                      devices = _context5.sent;
                      return _context5.abrupt(
                        "return",
                        devices.filter(function (device) {
                          return device.kind === "videoinput";
                        })
                      );

                    case 4:
                    case "end":
                      return _context5.stop();
                  }
                }
              }, _callee5);
            })
          );
          return _enumerateVideoDevices.apply(this, arguments);
        }

        function getActiveTrack() {
          if (!streamRef) {
            return null;
          }

          var tracks = streamRef.getVideoTracks();
          return tracks && tracks !== null && tracks !== void 0 && tracks.length
            ? tracks[0]
            : null;
        }
        /**
         * Used for accessing information about the active stream track and available video devices.
         */

        var QuaggaJSCameraAccess = {
          requestedVideoElement: null,
          request: function request(video, videoConstraints) {
            return asyncToGenerator_default()(
              /*#__PURE__*/ regenerator_default.a.mark(function _callee() {
                var newConstraints;
                return regenerator_default.a.wrap(function _callee$(_context) {
                  while (1) {
                    switch ((_context.prev = _context.next)) {
                      case 0:
                        QuaggaJSCameraAccess.requestedVideoElement = video;
                        _context.next = 3;
                        return pickConstraints(videoConstraints);

                      case 3:
                        newConstraints = _context.sent;
                        return _context.abrupt(
                          "return",
                          initCamera(video, newConstraints)
                        );

                      case 5:
                      case "end":
                        return _context.stop();
                    }
                  }
                }, _callee);
              })
            )();
          },
          release: function release() {
            var tracks = streamRef && streamRef.getVideoTracks();

            if (QuaggaJSCameraAccess.requestedVideoElement !== null) {
              QuaggaJSCameraAccess.requestedVideoElement.pause();
            }

            return new Promise(function (resolve) {
              setTimeout(function () {
                if (tracks && tracks.length) {
                  tracks.forEach(function (track) {
                    return track.stop();
                  });
                }

                streamRef = null;
                QuaggaJSCameraAccess.requestedVideoElement = null;
                resolve();
              }, 0);
            });
          },
          enumerateVideoDevices: enumerateVideoDevices,
          getActiveStreamLabel: function getActiveStreamLabel() {
            var track = getActiveTrack();
            return track ? track.label : "";
          },
          getActiveTrack: getActiveTrack,
          disableTorch: function disableTorch() {
            return asyncToGenerator_default()(
              /*#__PURE__*/ regenerator_default.a.mark(function _callee2() {
                var track;
                return regenerator_default.a.wrap(function _callee2$(
                  _context2
                ) {
                  while (1) {
                    switch ((_context2.prev = _context2.next)) {
                      case 0:
                        track = getActiveTrack(); // TODO: should we acquire camera access even if there's no current camera open?
                        // TODO: what happens on iOS or another device where torch isn't supported at all? Should we throw an error?

                        if (!track) {
                          _context2.next = 4;
                          break;
                        }

                        _context2.next = 4;
                        return track.applyConstraints({
                          torch: false,
                        });

                      case 4:
                      case "end":
                        return _context2.stop();
                    }
                  }
                },
                _callee2);
              })
            )();
          },
          enableTorch: function enableTorch() {
            return asyncToGenerator_default()(
              /*#__PURE__*/ regenerator_default.a.mark(function _callee3() {
                var track;
                return regenerator_default.a.wrap(function _callee3$(
                  _context3
                ) {
                  while (1) {
                    switch ((_context3.prev = _context3.next)) {
                      case 0:
                        track = getActiveTrack(); // TODO: should we acquire camera access even if there's no current camera open?
                        // TODO: what happens on iOS or another device where torch isn't supported at all? Should we throw an error?

                        if (!track) {
                          _context3.next = 4;
                          break;
                        }

                        _context3.next = 4;
                        return track.applyConstraints({
                          torch: true,
                        });

                      case 4:
                      case "end":
                        return _context3.stop();
                    }
                  }
                },
                _callee3);
              })
            )();
          },
        };
        /* harmony default export */ var camera_access = QuaggaJSCameraAccess;
        // CONCATENATED MODULE: ./src/analytics/result_collector.ts

        function contains(codeResult, list) {
          return (
            list &&
            list.some(function (item) {
              var keys = Object.keys(item);
              return keys.every(function (key) {
                return item[key] === codeResult[key];
              });
            })
          );
        }

        function passesFilter(codeResult, filter) {
          return typeof filter === "function" ? filter(codeResult) : true;
        }

        /* harmony default export */ var result_collector = {
          create: function create(config) {
            var _config$capacity;

            var canvas = document.createElement("canvas");
            var ctx = canvas.getContext("2d");
            var results = [];
            var capacity =
              (_config$capacity = config.capacity) !== null &&
              _config$capacity !== void 0
                ? _config$capacity
                : 20;
            var capture = config.capture === true;

            function matchesConstraints(codeResult) {
              return (
                !!capacity &&
                codeResult &&
                !contains(codeResult, config.blacklist) &&
                passesFilter(codeResult, config.filter)
              );
            }

            return {
              addResult: function addResult(data, imageSize, codeResult) {
                var result = {}; // this is 'any' to avoid having to construct a whole QuaggaJSCodeResult :|

                if (matchesConstraints(codeResult)) {
                  capacity--;
                  result.codeResult = codeResult;

                  if (capture) {
                    canvas.width = imageSize.x;
                    canvas.height = imageSize.y;
                    image_debug["a" /* default */].drawImage(
                      data,
                      imageSize,
                      ctx
                    );
                    result.frame = canvas.toDataURL();
                  }

                  results.push(result);
                }
              },
              getResults: function getResults() {
                return results;
              },
            };
          },
        };
        // CONCATENATED MODULE: ./src/config/config.dev.ts
        var DevConfig = {
          inputStream: {
            name: "Live",
            type: "LiveStream",
            constraints: {
              width: 640,
              height: 480,
              // aspectRatio: 640/480, // optional
              facingMode: "environment", // or user
              // deviceId: "38745983457387598375983759834"
            },
            area: {
              top: "0%",
              right: "0%",
              left: "0%",
              bottom: "0%",
            },
            singleChannel: false, // true: only the red color-channel is read
          },
          locate: true,
          numOfWorkers: 0,
          decoder: {
            readers: ["code_128_reader"],
            debug: {
              drawBoundingBox: false,
              showFrequency: false,
              drawScanline: false,
              showPattern: false,
            },
          },
          locator: {
            halfSample: true,
            patchSize: "medium",
            // x-small, small, medium, large, x-large
            debug: {
              showCanvas: false,
              showPatches: false,
              showFoundPatches: false,
              showSkeleton: false,
              showLabels: false,
              showPatchLabels: false,
              showRemainingPatchLabels: false,
              boxFromPatches: {
                showTransformed: false,
                showTransformedBox: false,
                showBB: false,
              },
            },
          },
        };
        /* harmony default export */ var config_dev = DevConfig;
        // CONCATENATED MODULE: ./src/config/config.node.ts
        var NodeConfig = {
          inputStream: {
            type: "ImageStream",
            sequence: false,
            size: 800,
            area: {
              top: "0%",
              right: "0%",
              left: "0%",
              bottom: "0%",
            },
            singleChannel: false, // true: only the red color-channel is read
          },
          locate: true,
          numOfWorkers: 0,
          decoder: {
            readers: ["code_128_reader"],
          },
          locator: {
            halfSample: true,
            patchSize: "medium", // x-small, small, medium, large, x-large
          },
        };
        /* harmony default export */ var config_node = NodeConfig;
        // CONCATENATED MODULE: ./src/config/config.prod.ts
        var ProdConfig = {
          inputStream: {
            name: "Live",
            type: "LiveStream",
            constraints: {
              width: 640,
              height: 480,
              // aspectRatio: 640/480, // optional
              facingMode: "environment", // or user
              // deviceId: "38745983457387598375983759834"
            },
            area: {
              top: "0%",
              right: "0%",
              left: "0%",
              bottom: "0%",
            },
            singleChannel: false, // true: only the red color-channel is read
          },
          locate: true,
          numOfWorkers: 4,
          decoder: {
            readers: ["code_128_reader"],
          },
          locator: {
            halfSample: true,
            patchSize: "medium", // x-small, small, medium, large, x-large
          },
        };
        /* harmony default export */ var config_prod = ProdConfig;
        // CONCATENATED MODULE: ./src/config/config.ts

        var ExportConfig = (function () {
          var QuaggaConfig;

          if (true) {
            QuaggaConfig = config_dev;
          } else {
          }

          return QuaggaConfig;
        })();

        /* harmony default export */ var config_config = ExportConfig;
        // EXTERNAL MODULE: ./node_modules/gl-vec2/index.js
        var gl_vec2 = __webpack_require__(7);

        // EXTERNAL MODULE: ./src/common/cv_utils.js + 1 modules
        var cv_utils = __webpack_require__(9);

        // CONCATENATED MODULE: ./src/input/frame_grabber_browser.js
        // NOTE FOR ANYONE IN HERE IN THE FUTURE:
        // webpack.config.js replaces the frame_grabber module with THIS module when it is building for a Browser environment.

        var TO_RADIANS = Math.PI / 180;

        function adjustCanvasSize(canvas, targetSize) {
          if (canvas.width !== targetSize.x) {
            if (true) {
              console.log("WARNING: canvas-size needs to be adjusted");
            }

            canvas.width = targetSize.x;
          }

          if (canvas.height !== targetSize.y) {
            if (true) {
              console.log("WARNING: canvas-size needs to be adjusted");
            }

            canvas.height = targetSize.y;
          }
        }

        var FrameGrabber = {};

        FrameGrabber.create = function (inputStream, canvas) {
          // console.warn('*** FrameGrabberBrowser create');
          var _that = {};

          var _streamConfig = inputStream.getConfig();

          var _videoSize = Object(cv_utils["h" /* imageRef */])(
            inputStream.getRealWidth(),
            inputStream.getRealHeight()
          );

          var _canvasSize = inputStream.getCanvasSize();

          var _size = Object(cv_utils["h" /* imageRef */])(
            inputStream.getWidth(),
            inputStream.getHeight()
          );

          var topRight = inputStream.getTopRight();
          var _sx = topRight.x;
          var _sy = topRight.y;

          var _canvas;

          var _ctx = null;
          var _data = null;
          _canvas = canvas || document.createElement("canvas");
          _canvas.width = _canvasSize.x;
          _canvas.height = _canvasSize.y;
          _ctx = _canvas.getContext("2d");
          _data = new Uint8Array(_size.x * _size.y);

          if (true) {
            console.log(
              "FrameGrabber",
              JSON.stringify({
                size: _size,
                topRight: topRight,
                videoSize: _videoSize,
                canvasSize: _canvasSize,
              })
            );
          }
          /**
           * Uses the given array as frame-buffer
           */

          _that.attachData = function (data) {
            _data = data;
          };
          /**
           * Returns the used frame-buffer
           */

          _that.getData = function () {
            return _data;
          };
          /**
           * Fetches a frame from the input-stream and puts into the frame-buffer.
           * The image-data is converted to gray-scale and then half-sampled if configured.
           */

          _that.grab = function () {
            var doHalfSample = _streamConfig.halfSample;
            var frame = inputStream.getFrame();
            var drawable = frame;
            var drawAngle = 0;
            var ctxData;

            if (drawable) {
              adjustCanvasSize(_canvas, _canvasSize);

              if (_streamConfig.type === "ImageStream") {
                drawable = frame.img;

                if (frame.tags && frame.tags.orientation) {
                  switch (frame.tags.orientation) {
                    case 6:
                      drawAngle = 90 * TO_RADIANS;
                      break;

                    case 8:
                      drawAngle = -90 * TO_RADIANS;
                      break;
                  }
                }
              }

              if (drawAngle !== 0) {
                _ctx.translate(_canvasSize.x / 2, _canvasSize.y / 2);

                _ctx.rotate(drawAngle);

                _ctx.drawImage(
                  drawable,
                  -_canvasSize.y / 2,
                  -_canvasSize.x / 2,
                  _canvasSize.y,
                  _canvasSize.x
                );

                _ctx.rotate(-drawAngle);

                _ctx.translate(-_canvasSize.x / 2, -_canvasSize.y / 2);
              } else {
                _ctx.drawImage(drawable, 0, 0, _canvasSize.x, _canvasSize.y);
              }

              ctxData = _ctx.getImageData(_sx, _sy, _size.x, _size.y).data;

              if (doHalfSample) {
                Object(cv_utils["e" /* grayAndHalfSampleFromCanvasData */])(
                  ctxData,
                  _size,
                  _data
                );
              } else {
                Object(cv_utils["c" /* computeGray */])(
                  ctxData,
                  _data,
                  _streamConfig
                );
              }

              return true;
            }

            return false;
          };

          _that.getSize = function () {
            return _size;
          };

          return _that;
        };

        /* harmony default export */ var frame_grabber_browser = FrameGrabber;
        // CONCATENATED MODULE: ./src/input/exif_helper.js
        // NOTE: (SOME OF) THIS IS BROWSER ONLY CODE.  Node does not have 'atob' built in, nor XMLHttpRequest.
        // How exactly is this set of functions used in Quagga? Do we need the browser specific code? Do we
        // need to port any part of this that doesn't work in Node to node?
        // Tags scraped from https://github.com/exif-js/exif-js
        var ExifTags = {
          0x0112: "orientation",
        };
        var AvailableTags = Object.keys(ExifTags).map(function (key) {
          return ExifTags[key];
        });
        function findTagsInObjectURL(src) {
          var tags =
            arguments.length > 1 && arguments[1] !== undefined
              ? arguments[1]
              : AvailableTags;

          if (/^blob:/i.test(src)) {
            return objectURLToBlob(src)
              .then(readToBuffer)
              .then(function (buffer) {
                return findTagsInBuffer(buffer, tags);
              });
          }

          return Promise.resolve(null);
        }
        function base64ToArrayBuffer(dataUrl) {
          var base64 = dataUrl.replace(/^data:([^;]+);base64,/gim, "");
          var binary = atob(base64);
          var len = binary.length;
          var buffer = new ArrayBuffer(len);
          var view = new Uint8Array(buffer);

          for (var i = 0; i < len; i++) {
            view[i] = binary.charCodeAt(i);
          }

          return buffer;
        }

        function readToBuffer(blob) {
          return new Promise(function (resolve) {
            var fileReader = new FileReader();

            fileReader.onload = function (e) {
              return resolve(e.target.result);
            };

            fileReader.readAsArrayBuffer(blob);
          });
        }

        function objectURLToBlob(url) {
          return new Promise(function (resolve, reject) {
            var http = new XMLHttpRequest();
            http.open("GET", url, true);
            http.responseType = "blob";

            http.onreadystatechange = function () {
              if (
                http.readyState === XMLHttpRequest.DONE &&
                (http.status === 200 || http.status === 0)
              ) {
                resolve(this.response);
              }
            };

            http.onerror = reject;
            http.send();
          });
        }

        function findTagsInBuffer(file) {
          var selectedTags =
            arguments.length > 1 && arguments[1] !== undefined
              ? arguments[1]
              : AvailableTags;
          var dataView = new DataView(file);
          var length = file.byteLength;
          var exifTags = selectedTags.reduce(function (result, selectedTag) {
            var exifTag = Object.keys(ExifTags).filter(function (tag) {
              return ExifTags[tag] === selectedTag;
            })[0];

            if (exifTag) {
              result[exifTag] = selectedTag;
            }

            return result;
          }, {});
          var offset = 2;
          var marker;

          if (dataView.getUint8(0) !== 0xff || dataView.getUint8(1) !== 0xd8) {
            return false;
          }

          while (offset < length) {
            if (dataView.getUint8(offset) !== 0xff) {
              return false;
            }

            marker = dataView.getUint8(offset + 1);

            if (marker === 0xe1) {
              return readEXIFData(dataView, offset + 4, exifTags);
            }

            offset += 2 + dataView.getUint16(offset + 2);
          }

          return false;
        }

        function readEXIFData(file, start, exifTags) {
          if (getStringFromBuffer(file, start, 4) !== "Exif") {
            return false;
          }

          var tiffOffset = start + 6;
          var bigEnd;

          if (file.getUint16(tiffOffset) === 0x4949) {
            bigEnd = false;
          } else if (file.getUint16(tiffOffset) === 0x4d4d) {
            bigEnd = true;
          } else {
            return false;
          }

          if (file.getUint16(tiffOffset + 2, !bigEnd) !== 0x002a) {
            return false;
          }

          var firstIFDOffset = file.getUint32(tiffOffset + 4, !bigEnd);

          if (firstIFDOffset < 0x00000008) {
            return false;
          }

          var tags = readTags(
            file,
            tiffOffset,
            tiffOffset + firstIFDOffset,
            exifTags,
            bigEnd
          );
          return tags;
        }

        function readTags(file, tiffStart, dirStart, strings, bigEnd) {
          var entries = file.getUint16(dirStart, !bigEnd);
          var tags = {};

          for (var i = 0; i < entries; i++) {
            var entryOffset = dirStart + i * 12 + 2;
            var tag = strings[file.getUint16(entryOffset, !bigEnd)];

            if (tag) {
              tags[tag] = readTagValue(
                file,
                entryOffset,
                tiffStart,
                dirStart,
                bigEnd
              );
            }
          }

          return tags;
        }

        function readTagValue(file, entryOffset, tiffStart, dirStart, bigEnd) {
          var type = file.getUint16(entryOffset + 2, !bigEnd);
          var numValues = file.getUint32(entryOffset + 4, !bigEnd);

          switch (type) {
            case 3:
              if (numValues === 1) {
                return file.getUint16(entryOffset + 8, !bigEnd);
              }
          }

          return null;
        }

        function getStringFromBuffer(buffer, start, length) {
          var outstr = "";

          for (var n = start; n < start + length; n++) {
            outstr += String.fromCharCode(buffer.getUint8(n));
          }

          return outstr;
        }
        // CONCATENATED MODULE: ./src/input/image_loader.js

        var ImageLoader = {};

        ImageLoader.load = function (
          directory,
          callback,
          offset,
          size,
          sequence
        ) {
          var htmlImagesSrcArray = new Array(size);
          var htmlImagesArray = new Array(htmlImagesSrcArray.length);
          var i;
          var img;
          var num;

          if (sequence === false) {
            htmlImagesSrcArray[0] = directory;
          } else {
            for (i = 0; i < htmlImagesSrcArray.length; i++) {
              num = offset + i;
              htmlImagesSrcArray[i] = ""
                .concat(directory, "image-")
                .concat("00".concat(num).slice(-3), ".jpg");
            }
          }

          htmlImagesArray.notLoaded = [];

          htmlImagesArray.addImage = function (image) {
            htmlImagesArray.notLoaded.push(image);
          };

          htmlImagesArray.loaded = function (loadedImg) {
            var notloadedImgs = htmlImagesArray.notLoaded;

            for (var x = 0; x < notloadedImgs.length; x++) {
              if (notloadedImgs[x] === loadedImg) {
                notloadedImgs.splice(x, 1);

                for (var y = 0; y < htmlImagesSrcArray.length; y++) {
                  var imgName = htmlImagesSrcArray[y].substr(
                    htmlImagesSrcArray[y].lastIndexOf("/")
                  );

                  if (loadedImg.src.lastIndexOf(imgName) !== -1) {
                    htmlImagesArray[y] = {
                      img: loadedImg,
                    };
                    break;
                  }
                }

                break;
              }
            }

            if (notloadedImgs.length === 0) {
              if (true) {
                console.log("Images loaded");
              }

              if (sequence === false) {
                findTagsInObjectURL(directory, ["orientation"])
                  .then(function (tags) {
                    htmlImagesArray[0].tags = tags;
                    callback(htmlImagesArray);
                  })
                  ["catch"](function (e) {
                    console.log(e);
                    callback(htmlImagesArray);
                  });
              } else {
                callback(htmlImagesArray);
              }
            }
          };

          for (i = 0; i < htmlImagesSrcArray.length; i++) {
            img = new Image();
            htmlImagesArray.addImage(img);
            addOnloadHandler(img, htmlImagesArray);
            img.src = htmlImagesSrcArray[i];
          }
        };

        function addOnloadHandler(img, htmlImagesArray) {
          img.onload = function () {
            htmlImagesArray.loaded(this);
          };
        }

        /* harmony default export */ var image_loader = ImageLoader;
        // CONCATENATED MODULE: ./src/input/input_stream/input_stream_browser.ts
        /* eslint-disable @typescript-eslint/no-explicit-any */

        var inputStreamFactory = {
          createVideoStream: function createVideoStream(video) {
            console.warn("**** InputStreamBrowser createVideoStream");
            var _config = null;
            var _eventNames = ["canrecord", "ended"];
            var _eventHandlers = {};

            var _calculatedWidth;

            var _calculatedHeight;

            var _topRight = {
              x: 0,
              y: 0,
              type: "Point",
            };
            var _canvasSize = {
              x: 0,
              y: 0,
              type: "XYSize",
            };

            function initSize() {
              var _config2, _config3;

              var width = video.videoWidth;
              var height = video.videoHeight; // eslint-disable-next-line no-nested-ternary

              _calculatedWidth =
                (_config2 = _config) !== null &&
                _config2 !== void 0 &&
                _config2.size
                  ? width / height > 1
                    ? _config.size
                    : Math.floor((width / height) * _config.size)
                  : width; // eslint-disable-next-line no-nested-ternary

              _calculatedHeight =
                (_config3 = _config) !== null &&
                _config3 !== void 0 &&
                _config3.size
                  ? width / height > 1
                    ? Math.floor((height / width) * _config.size)
                    : _config.size
                  : height;
              _canvasSize.x = _calculatedWidth;
              _canvasSize.y = _calculatedHeight;
            }

            var inputStream = {
              getRealWidth: function getRealWidth() {
                return video.videoWidth;
              },
              getRealHeight: function getRealHeight() {
                return video.videoHeight;
              },
              getWidth: function getWidth() {
                return _calculatedWidth;
              },
              getHeight: function getHeight() {
                return _calculatedHeight;
              },
              setWidth: function setWidth(width) {
                _calculatedWidth = width;
              },
              setHeight: function setHeight(height) {
                _calculatedHeight = height;
              },
              setInputStream: function setInputStream(config) {
                // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
                _config = config; // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access

                this.setAttribute(
                  "src",
                  typeof config.src !== "undefined" ? config.src : ""
                );
              },
              ended: function ended() {
                return video.ended;
              },
              getConfig: function getConfig() {
                return _config;
              },
              setAttribute: function setAttribute(name, value) {
                if (video) {
                  video.setAttribute(name, value);
                }
              },
              pause: function pause() {
                video.pause();
              },
              play: function play() {
                // eslint-disable-next-line @typescript-eslint/no-floating-promises
                video.play();
              },
              setCurrentTime: function setCurrentTime(time) {
                var _config4;

                if (
                  ((_config4 = _config) === null || _config4 === void 0
                    ? void 0
                    : _config4.type) !== "LiveStream"
                ) {
                  this.setAttribute("currentTime", time.toString());
                }
              },
              addEventListener: function addEventListener(event, f, bool) {
                if (_eventNames.indexOf(event) !== -1) {
                  if (!_eventHandlers[event]) {
                    _eventHandlers[event] = [];
                  }

                  _eventHandlers[event].push(f);
                } else {
                  video.addEventListener(event, f, bool);
                }
              },
              clearEventHandlers: function clearEventHandlers() {
                _eventNames.forEach(function (eventName) {
                  var handlers = _eventHandlers[eventName];

                  if (handlers && handlers.length > 0) {
                    handlers.forEach(function (handler) {
                      video.removeEventListener(eventName, handler);
                    });
                  }
                });
              },
              trigger: function trigger(eventName, args) {
                var j; // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access

                var handlers = _eventHandlers[eventName];

                if (eventName === "canrecord") {
                  initSize();
                }

                if (handlers && handlers.length > 0) {
                  for (j = 0; j < handlers.length; j++) {
                    handlers[j].apply(inputStream, args);
                  }
                }
              },
              setTopRight: function setTopRight(topRight) {
                _topRight.x = topRight.x;
                _topRight.y = topRight.y;
              },
              getTopRight: function getTopRight() {
                return _topRight;
              },
              setCanvasSize: function setCanvasSize(size) {
                _canvasSize.x = size.x;
                _canvasSize.y = size.y;
              },
              getCanvasSize: function getCanvasSize() {
                return _canvasSize;
              },
              getFrame: function getFrame() {
                return video;
              },
            };
            return inputStream;
          },
          createLiveStream: function createLiveStream(video) {
            console.warn("**** InputStreamBrowser createLiveStream");

            if (video) {
              video.setAttribute("autoplay", "true");
            }

            var that = inputStreamFactory.createVideoStream(video);

            that.ended = function ended() {
              return false;
            };

            return that;
          },
          createImageStream: function createImageStream() {
            // console.warn('**** InputStreamBrowser createImageStream');
            var _config = null;
            var width = 0;
            var height = 0;
            var frameIdx = 0;
            var paused = true;
            var loaded = false;
            var imgArray = null;
            var size = 0;
            var offset = 1;
            var baseUrl = null;
            var _ended = false;
            var calculatedWidth;
            var calculatedHeight;
            var _eventNames = ["canrecord", "ended"];
            var _eventHandlers = {};
            var _topRight = {
              x: 0,
              y: 0,
              type: "Point",
            };
            var _canvasSize = {
              x: 0,
              y: 0,
              type: "XYSize",
            };

            function loadImages() {
              var _config7;

              loaded = false;
              image_loader.load(
                baseUrl,
                function (imgs) {
                  var _config5, _config6;

                  imgArray = imgs; // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access

                  if (imgs[0].tags && imgs[0].tags.orientation) {
                    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
                    switch (imgs[0].tags.orientation) {
                      case 6:
                      case 8:
                        width = imgs[0].img.height;
                        height = imgs[0].img.width;
                        break;

                      default:
                        width = imgs[0].img.width;
                        height = imgs[0].img.height;
                    }
                  } else {
                    width = imgs[0].img.width;
                    height = imgs[0].img.height;
                  } // eslint-disable-next-line no-nested-ternary

                  calculatedWidth =
                    (_config5 = _config) !== null &&
                    _config5 !== void 0 &&
                    _config5.size
                      ? width / height > 1
                        ? _config.size
                        : Math.floor((width / height) * _config.size)
                      : width; // eslint-disable-next-line no-nested-ternary

                  calculatedHeight =
                    (_config6 = _config) !== null &&
                    _config6 !== void 0 &&
                    _config6.size
                      ? width / height > 1
                        ? Math.floor((height / width) * _config.size)
                        : _config.size
                      : height;
                  _canvasSize.x = calculatedWidth;
                  _canvasSize.y = calculatedHeight;
                  loaded = true;
                  frameIdx = 0;
                  setTimeout(function () {
                    // eslint-disable-next-line @typescript-eslint/no-use-before-define
                    publishEvent("canrecord", []);
                  }, 0);
                },
                offset,
                size,
                (_config7 = _config) === null || _config7 === void 0
                  ? void 0
                  : _config7.sequence
              );
            }

            function publishEvent(eventName, args) {
              var j;
              var handlers = _eventHandlers[eventName];

              if (handlers && handlers.length > 0) {
                for (j = 0; j < handlers.length; j++) {
                  // eslint-disable-next-line @typescript-eslint/no-use-before-define
                  handlers[j].apply(inputStream, args); // TODO: typescript complains that any[] is not valid for a second arg for apply?!
                }
              }
            } // TODO: any code shared with the first InputStream above should be shared not copied
            // TODO: publishEvent needs access to inputStream, but inputStream needs access to publishEvent
            // TODO: This is why it's a 'var', so it hoists back.  This is ugly, and should be changed.
            // eslint-disable-next-line no-var,vars-on-top

            var inputStream = {
              trigger: publishEvent,
              getWidth: function getWidth() {
                return calculatedWidth;
              },
              getHeight: function getHeight() {
                return calculatedHeight;
              },
              setWidth: function setWidth(newWidth) {
                calculatedWidth = newWidth;
              },
              setHeight: function setHeight(newHeight) {
                calculatedHeight = newHeight;
              },
              getRealWidth: function getRealWidth() {
                return width;
              },
              getRealHeight: function getRealHeight() {
                return height;
              },
              setInputStream: function setInputStream(stream) {
                // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
                _config = stream; // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access

                if (stream.sequence === false) {
                  // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment,@typescript-eslint/no-unsafe-member-access
                  baseUrl = stream.src;
                  size = 1;
                } else {
                  // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment,@typescript-eslint/no-unsafe-member-access
                  baseUrl = stream.src; // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment,@typescript-eslint/no-unsafe-member-access

                  size = stream.length;
                }

                loadImages();
              },
              ended: function ended() {
                return _ended;
              },
              setAttribute: function setAttribute() {},
              getConfig: function getConfig() {
                return _config;
              },
              pause: function pause() {
                paused = true;
              },
              play: function play() {
                paused = false;
              },
              setCurrentTime: function setCurrentTime(time) {
                frameIdx = time;
              },
              addEventListener: function addEventListener(event, f) {
                if (_eventNames.indexOf(event) !== -1) {
                  if (!_eventHandlers[event]) {
                    _eventHandlers[event] = [];
                  }

                  _eventHandlers[event].push(f);
                }
              },
              clearEventHandlers: function clearEventHandlers() {
                Object.keys(_eventHandlers).forEach(function (ind) {
                  return delete _eventHandlers[ind];
                });
              },
              setTopRight: function setTopRight(topRight) {
                _topRight.x = topRight.x;
                _topRight.y = topRight.y;
              },
              getTopRight: function getTopRight() {
                return _topRight;
              },
              setCanvasSize: function setCanvasSize(canvasSize) {
                _canvasSize.x = canvasSize.x;
                _canvasSize.y = canvasSize.y;
              },
              getCanvasSize: function getCanvasSize() {
                return _canvasSize;
              },
              getFrame: function getFrame() {
                var frame;

                if (!loaded) {
                  return null;
                }

                if (!paused) {
                  var _imgArray;

                  // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
                  frame =
                    (_imgArray = imgArray) === null || _imgArray === void 0
                      ? void 0
                      : _imgArray[frameIdx];

                  if (frameIdx < size - 1) {
                    frameIdx++;
                  } else {
                    setTimeout(function () {
                      _ended = true;
                      publishEvent("ended", []);
                    }, 0);
                  }
                } // eslint-disable-next-line @typescript-eslint/no-unsafe-return

                return frame;
              },
            };
            return inputStream;
          },
        };
        /* harmony default export */ var input_stream_browser =
          inputStreamFactory;
        // EXTERNAL MODULE: ./src/locator/barcode_locator.js
        var barcode_locator = __webpack_require__(23);

        // CONCATENATED MODULE: ./src/QuaggaContext.ts

        var QuaggaContext_QuaggaContext = /*#__PURE__*/ createClass_default()(
          function QuaggaContext() {
            classCallCheck_default()(this, QuaggaContext);

            defineProperty_default()(this, "config", void 0);

            defineProperty_default()(this, "inputStream", void 0);

            defineProperty_default()(this, "framegrabber", void 0);

            defineProperty_default()(this, "inputImageWrapper", void 0);

            defineProperty_default()(this, "stopped", false);

            defineProperty_default()(this, "boxSize", void 0);

            defineProperty_default()(this, "resultCollector", void 0);

            defineProperty_default()(this, "decoder", void 0);

            defineProperty_default()(this, "workerPool", []);

            defineProperty_default()(this, "onUIThread", true);

            defineProperty_default()(
              this,
              "canvasContainer",
              new QuaggaContext_CanvasContainer()
            );
          }
        );
        var QuaggaContext_CanvasInfo = /*#__PURE__*/ createClass_default()(
          function CanvasInfo() {
            classCallCheck_default()(this, CanvasInfo);

            defineProperty_default()(this, "image", void 0);

            defineProperty_default()(this, "overlay", void 0);
          }
        );
        var QuaggaContext_CanvasContainer = /*#__PURE__*/ createClass_default()(
          function CanvasContainer() {
            classCallCheck_default()(this, CanvasContainer);

            defineProperty_default()(this, "ctx", void 0);

            defineProperty_default()(this, "dom", void 0);

            this.ctx = new QuaggaContext_CanvasInfo();
            this.dom = new QuaggaContext_CanvasInfo();
          }
        );
        // CONCATENATED MODULE: ./src/quagga/getViewPort.ts
        function getViewPort_getViewPort(target) {
          if (typeof document === "undefined") {
            return null;
          } // Check if target is already a DOM element

          if (
            target instanceof HTMLElement &&
            target.nodeName &&
            target.nodeType === 1
          ) {
            return target;
          } // Use '#interactive.viewport' as a fallback selector (backwards compatibility)

          var selector =
            typeof target === "string" ? target : "#interactive.viewport";
          return document.querySelector(selector);
        }
        // CONCATENATED MODULE: ./src/quagga/initBuffers.ts

        // TODO: need typescript def for BarcodeLocator
        function initBuffers_initBuffers(inputStream, imageWrapper, locator) {
          var inputImageWrapper =
            imageWrapper ||
            new image_wrapper["a" /* default */]({
              x: inputStream.getWidth(),
              y: inputStream.getHeight(),
              type: "XYSize",
            });

          if (true) {
            console.log("image wrapper size ".concat(inputImageWrapper.size));
          }

          var boxSize = [
            Object(gl_vec2["clone"])([0, 0]),
            Object(gl_vec2["clone"])([0, inputImageWrapper.size.y]),
            Object(gl_vec2["clone"])([
              inputImageWrapper.size.x,
              inputImageWrapper.size.y,
            ]),
            Object(gl_vec2["clone"])([inputImageWrapper.size.x, 0]),
          ];
          barcode_locator["a" /* default */].init(inputImageWrapper, locator);
          return {
            inputImageWrapper: inputImageWrapper,
            boxSize: boxSize,
          };
        }
        // CONCATENATED MODULE: ./src/quagga/initCanvas.ts

        function findOrCreateCanvas(selector, className) {
          var canvas = document.querySelector(selector);

          if (!canvas) {
            canvas = document.createElement("canvas");
            canvas.className = className;
          }

          return canvas;
        }

        function getCanvasAndContext(selector, className) {
          var canvas = findOrCreateCanvas(selector, className);
          var context = canvas.getContext("2d");
          return {
            canvas: canvas,
            context: context,
          };
        }

        function initCanvases(canvasSize) {
          if (typeof document !== "undefined") {
            var image = getCanvasAndContext("canvas.imgBuffer", "imgBuffer");
            var overlay = getCanvasAndContext(
              "canvas.drawingBuffer",
              "drawingBuffer"
            ); // eslint-disable-next-line no-multi-assign

            image.canvas.width = overlay.canvas.width = canvasSize.x; // eslint-disable-next-line no-multi-assign

            image.canvas.height = overlay.canvas.height = canvasSize.y;
            return {
              dom: {
                image: image.canvas,
                overlay: overlay.canvas,
              },
              ctx: {
                image: image.context,
                overlay: overlay.context,
              },
            };
          }

          return null;
        }

        function initCanvas_initCanvas(context) {
          var _context$config,
            _context$config$input,
            _context$config2,
            _context$config2$inpu;

          var viewport = getViewPort_getViewPort(
            context === null || context === void 0
              ? void 0
              : (_context$config = context.config) === null ||
                _context$config === void 0
              ? void 0
              : (_context$config$input = _context$config.inputStream) ===
                  null || _context$config$input === void 0
              ? void 0
              : _context$config$input.target
          );
          var type =
            context === null || context === void 0
              ? void 0
              : (_context$config2 = context.config) === null ||
                _context$config2 === void 0
              ? void 0
              : (_context$config2$inpu = _context$config2.inputStream) ===
                  null || _context$config2$inpu === void 0
              ? void 0
              : _context$config2$inpu.type;
          if (!type) return null;
          var container = initCanvases(context.inputStream.getCanvasSize());
          if (!container)
            return {
              dom: {
                image: null,
                overlay: null,
              },
              ctx: {
                image: null,
                overlay: null,
              },
            };
          var dom = container.dom;

          if (typeof document !== "undefined") {
            if (viewport) {
              if (type === "ImageStream" && !viewport.contains(dom.image)) {
                viewport.appendChild(dom.image);
              }

              if (!viewport.contains(dom.overlay)) {
                viewport.appendChild(dom.overlay);
              }
            }
          }

          return container;
        }
        // CONCATENATED MODULE: ./src/quagga/qworker.ts

        function qworker_ownKeys(object, enumerableOnly) {
          var keys = Object.keys(object);
          if (Object.getOwnPropertySymbols) {
            var symbols = Object.getOwnPropertySymbols(object);
            enumerableOnly &&
              (symbols = symbols.filter(function (sym) {
                return Object.getOwnPropertyDescriptor(object, sym).enumerable;
              })),
              keys.push.apply(keys, symbols);
          }
          return keys;
        }

        function qworker_objectSpread(target) {
          for (var i = 1; i < arguments.length; i++) {
            var source = null != arguments[i] ? arguments[i] : {};
            i % 2
              ? qworker_ownKeys(Object(source), !0).forEach(function (key) {
                  defineProperty_default()(target, key, source[key]);
                })
              : Object.getOwnPropertyDescriptors
              ? Object.defineProperties(
                  target,
                  Object.getOwnPropertyDescriptors(source)
                )
              : qworker_ownKeys(Object(source)).forEach(function (key) {
                  Object.defineProperty(
                    target,
                    key,
                    Object.getOwnPropertyDescriptor(source, key)
                  );
                });
          }
          return target;
        }

        /* Worker functions. These are straight from the original quagga.js file.
         * Not presently used, as worker support is non-functional.  Keeping them around temporarily
         * to refer to until it is re-implemented. We may be able to fix/use some of this.
         */
        // TODO: need a typescript interface for FrameGrabber
        var workerPool = [];
        function updateWorkers(frameGrabber) {
          var availableWorker;

          if (workerPool.length) {
            availableWorker = workerPool.filter(function (workerThread) {
              return !workerThread.busy;
            })[0];

            if (availableWorker) {
              frameGrabber.attachData(availableWorker.imageData);

              if (frameGrabber.grab()) {
                availableWorker.busy = true;
                availableWorker.worker.postMessage(
                  {
                    cmd: "process",
                    imageData: availableWorker.imageData,
                  },
                  [availableWorker.imageData.buffer]
                );
              }

              return true;
            } else {
              return false;
            }
          }

          return null;
        }

        function configForWorker(config) {
          return qworker_objectSpread(
            qworker_objectSpread({}, config),
            {},
            {
              inputStream: qworker_objectSpread(
                qworker_objectSpread({}, config.inputStream),
                {},
                {
                  target: null,
                }
              ),
            }
          );
        } // @ts-ignore

        function workerInterface(factory) {
          if (factory) {
            var Quagga = factory()["default"];

            if (!Quagga) {
              // @ts-ignore
              self.postMessage({
                event: "error",
                message: "Quagga could not be created",
              });
              return;
            }
          } // @ts-ignore

          var imageWrapper; // @ts-ignore

          function onProcessed(result) {
            self.postMessage(
              {
                event: "processed",
                // @ts-ignore
                imageData: imageWrapper.data,
                result: result, // @ts-ignore
              },
              [imageWrapper.data.buffer]
            );
          }

          function workerInterfaceReady() {
            self.postMessage(
              {
                event: "initialized",
                // @ts-ignore
                imageData: imageWrapper.data, // @ts-ignore
              },
              [imageWrapper.data.buffer]
            );
          } // @ts-ignore

          self.onmessage = function (e) {
            if (e.data.cmd === "init") {
              var config = e.data.config;
              config.numOfWorkers = 0;
              imageWrapper = new Quagga.ImageWrapper(
                {
                  x: e.data.size.x,
                  y: e.data.size.y,
                },
                new Uint8Array(e.data.imageData)
              );
              Quagga.init(config, workerInterfaceReady, imageWrapper);
              Quagga.onProcessed(onProcessed);
            } else if (e.data.cmd === "process") {
              // @ts-ignore
              imageWrapper.data = new Uint8Array(e.data.imageData);
              Quagga.start();
            } else if (e.data.cmd === "setReaders") {
              Quagga.setReaders(e.data.readers);
            } else if (e.data.cmd === "registerReader") {
              Quagga.registerReader(e.data.name, e.data.reader);
            }
          };
        }

        function generateWorkerBlob() {
          var blob, factorySource;
          /* jshint ignore:start */
          // @ts-ignore

          if (typeof __factorySource__ !== "undefined") {
            // @ts-ignore
            factorySource = __factorySource__; // eslint-disable-line no-undef
          }
          /* jshint ignore:end */

          blob = new Blob(
            ["(" + workerInterface.toString() + ")(" + factorySource + ");"],
            {
              type: "text/javascript",
            }
          );
          return window.URL.createObjectURL(blob);
        }

        function initWorker(config, inputStream, cb) {
          var blobURL = generateWorkerBlob();
          var worker = new Worker(blobURL);
          var workerThread = {
            worker: worker,
            imageData: new Uint8Array(
              inputStream.getWidth() * inputStream.getHeight()
            ),
            busy: true,
          };

          workerThread.worker.onmessage = function (e) {
            if (e.data.event === "initialized") {
              URL.revokeObjectURL(blobURL);
              workerThread.busy = false;
              workerThread.imageData = new Uint8Array(e.data.imageData);

              if (true) {
                console.log("Worker initialized");
              }

              cb(workerThread);
            } else if (e.data.event === "processed") {
              workerThread.imageData = new Uint8Array(e.data.imageData);
              workerThread.busy = false; // TODO: how to thread publishResult into here?
              // publishResult(e.data.result, workerThread.imageData);
            } else if (e.data.event === "error") {
              if (true) {
                console.log("Worker error: " + e.data.message);
              }
            }
          };

          workerThread.worker.postMessage(
            {
              cmd: "init",
              size: {
                x: inputStream.getWidth(),
                y: inputStream.getHeight(),
              },
              imageData: workerThread.imageData,
              config: configForWorker(config),
            },
            [workerThread.imageData.buffer]
          );
        }
        function adjustWorkerPool(capacity, config, inputStream, cb) {
          var increaseBy = capacity - workerPool.length;

          if (increaseBy === 0 && cb) {
            cb();
          } else if (increaseBy < 0) {
            var workersToTerminate = workerPool.slice(increaseBy);
            workersToTerminate.forEach(function (workerThread) {
              workerThread.worker.terminate();

              if (true) {
                console.log("Worker terminated!");
              }
            });
            workerPool = workerPool.slice(0, increaseBy);

            if (cb) {
              cb();
            }
          } else {
            var workerInitialized = function workerInitialized(workerThread) {
              workerPool.push(workerThread);

              if (workerPool.length >= capacity && cb) {
                cb();
              }
            };

            if (config) {
              for (var i = 0; i < increaseBy; i++) {
                initWorker(config, inputStream, workerInitialized);
              }
            }
          }
        }
        function qworker_setReaders(readers) {
          workerPool.forEach(function (workerThread) {
            return workerThread.worker.postMessage({
              cmd: "setReaders",
              readers: readers,
            });
          });
        }
        function qworker_registerReader(name, reader) {
          workerPool.forEach(function (workerThread) {
            return workerThread.worker.postMessage({
              cmd: "registerReader",
              name: name,
              reader: reader,
            });
          });
        }
        // CONCATENATED MODULE: ./src/quagga/setupInputStream.ts
        // TODO: need to create an InputStream typescript interface, so we don't have an "any" in the next line
        function setupInputStream() {
          var type =
            arguments.length > 0 && arguments[0] !== undefined
              ? arguments[0]
              : "LiveStream";
          var viewport = arguments.length > 1 ? arguments[1] : undefined;
          var inputStreamFactory =
            arguments.length > 2 ? arguments[2] : undefined;

          switch (type) {
            case "VideoStream": {
              var video = document.createElement("video");
              return {
                video: video,
                inputStream: inputStreamFactory.createVideoStream(video),
              };
            }

            case "ImageStream":
              return {
                inputStream: inputStreamFactory.createImageStream(),
              };

            case "LiveStream": {
              var _video = null;

              if (viewport) {
                _video = viewport.querySelector("video");

                if (!_video) {
                  _video = document.createElement("video");
                  viewport.appendChild(_video);
                }
              }

              return {
                video: _video,
                inputStream: inputStreamFactory.createLiveStream(_video),
              };
            }

            default:
              console.error("* setupInputStream invalid type ".concat(type));
              return {
                video: null,
                inputStream: null,
              };
          }
        }
        // CONCATENATED MODULE: ./src/quagga/transform.ts
        /* eslint-disable no-param-reassign */
        function moveBox(box, xOffset, yOffset) {
          var corner = box.length;

          while (corner--) {
            box[corner][0] += xOffset;
            box[corner][1] += yOffset;
          }
        }
        function moveLine(line, xOffset, yOffset) {
          line[0].x += xOffset;
          line[0].y += yOffset;
          line[1].x += xOffset;
          line[1].y += yOffset;
        }
        // CONCATENATED MODULE: ./src/quagga/quagga.ts

        var quagga_Quagga = /*#__PURE__*/ (function () {
          function Quagga() {
            var _this = this;

            classCallCheck_default()(this, Quagga);

            defineProperty_default()(
              this,
              "context",
              new QuaggaContext_QuaggaContext()
            );

            defineProperty_default()(this, "canRecord", function (callback) {
              var _this$context$config;

              if (!_this.context.config) {
                return;
              }

              barcode_locator["a" /* default */].checkImageConstraints(
                _this.context.inputStream,
                (_this$context$config = _this.context.config) === null ||
                  _this$context$config === void 0
                  ? void 0
                  : _this$context$config.locator
              );

              _this.initCanvas();

              _this.context.framegrabber = frame_grabber_browser.create(
                _this.context.inputStream,
                _this.context.canvasContainer.dom.image
              );

              if (_this.context.config.numOfWorkers === undefined) {
                _this.context.config.numOfWorkers = 0;
              }

              adjustWorkerPool(
                _this.context.config.numOfWorkers,
                _this.context.config,
                _this.context.inputStream,
                function () {
                  var _this$context$config2;

                  if (
                    ((_this$context$config2 = _this.context.config) === null ||
                    _this$context$config2 === void 0
                      ? void 0
                      : _this$context$config2.numOfWorkers) === 0
                  ) {
                    _this.initializeData();
                  }

                  _this.ready(callback);
                }
              );
            });

            defineProperty_default()(this, "update", function () {
              if (_this.context.onUIThread) {
                var workersUpdated = updateWorkers(_this.context.framegrabber);

                if (!workersUpdated) {
                  var _this$context$inputIm;

                  _this.context.framegrabber.attachData(
                    (_this$context$inputIm =
                      _this.context.inputImageWrapper) === null ||
                      _this$context$inputIm === void 0
                      ? void 0
                      : _this$context$inputIm.data
                  );

                  if (_this.context.framegrabber.grab()) {
                    if (!workersUpdated) {
                      _this.locateAndDecode();
                    }
                  }
                }
              } else {
                var _this$context$inputIm2;

                _this.context.framegrabber.attachData(
                  (_this$context$inputIm2 = _this.context.inputImageWrapper) ===
                    null || _this$context$inputIm2 === void 0
                    ? void 0
                    : _this$context$inputIm2.data
                );

                _this.context.framegrabber.grab();

                _this.locateAndDecode();
              }
            });
          }

          createClass_default()(Quagga, [
            {
              key: "initBuffers",
              value: function initBuffers(imageWrapper) {
                if (!this.context.config) {
                  return;
                }

                var _initBuffers2 = initBuffers_initBuffers(
                    this.context.inputStream,
                    imageWrapper,
                    this.context.config.locator
                  ),
                  inputImageWrapper = _initBuffers2.inputImageWrapper,
                  boxSize = _initBuffers2.boxSize;

                this.context.inputImageWrapper = inputImageWrapper;
                this.context.boxSize = boxSize;
              },
            },
            {
              key: "initializeData",
              value: function initializeData(imageWrapper) {
                if (!this.context.config) {
                  return;
                }

                this.initBuffers(imageWrapper);
                this.context.decoder = barcode_decoder.create(
                  this.context.config.decoder,
                  this.context.inputImageWrapper
                );
              },
            },
            {
              key: "getViewPort",
              value: function getViewPort() {
                if (!this.context.config || !this.context.config.inputStream) {
                  return null;
                }

                var target = this.context.config.inputStream.target;
                return getViewPort_getViewPort(target);
              },
            },
            {
              key: "ready",
              value: function ready(callback) {
                this.context.inputStream.play();
                callback();
              },
            },
            {
              key: "initCanvas",
              value: function initCanvas() {
                var container = initCanvas_initCanvas(this.context);

                if (!container) {
                  return;
                }

                var ctx = container.ctx,
                  dom = container.dom;
                this.context.canvasContainer.dom.image = dom.image;
                this.context.canvasContainer.dom.overlay = dom.overlay;
                this.context.canvasContainer.ctx.image = ctx.image;
                this.context.canvasContainer.ctx.overlay = ctx.overlay;
              },
            },
            {
              key: "initInputStream",
              value: function initInputStream(callback) {
                if (!this.context.config || !this.context.config.inputStream) {
                  return;
                }

                var _this$context$config$ = this.context.config.inputStream,
                  inputType = _this$context$config$.type,
                  constraints = _this$context$config$.constraints;

                var _setupInputStream = setupInputStream(
                    inputType,
                    this.getViewPort(),
                    input_stream_browser
                  ),
                  video = _setupInputStream.video,
                  inputStream = _setupInputStream.inputStream;

                if (inputType === "LiveStream" && video) {
                  camera_access
                    .request(video, constraints)
                    .then(function () {
                      return inputStream.trigger("canrecord");
                    })
                    ["catch"](function (err) {
                      return callback(err);
                    });
                }

                if (inputStream) {
                  inputStream.setAttribute("preload", "auto");
                  inputStream.setInputStream(this.context.config.inputStream);
                  inputStream.addEventListener(
                    "canrecord",
                    this.canRecord.bind(undefined, callback)
                  );
                }

                this.context.inputStream = inputStream;
              },
            },
            {
              key: "getBoundingBoxes",
              value: function getBoundingBoxes() {
                var _this$context$config3;

                return (_this$context$config3 = this.context.config) !== null &&
                  _this$context$config3 !== void 0 &&
                  _this$context$config3.locate
                  ? barcode_locator["a" /* default */].locate()
                  : [
                      [
                        Object(gl_vec2["clone"])(this.context.boxSize[0]),
                        Object(gl_vec2["clone"])(this.context.boxSize[1]),
                        Object(gl_vec2["clone"])(this.context.boxSize[2]),
                        Object(gl_vec2["clone"])(this.context.boxSize[3]),
                      ],
                    ];
              }, // TODO: need a typescript type for result here.
              // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
            },
            {
              key: "transformResult",
              value: function transformResult(result) {
                var _this2 = this;

                var topRight = this.context.inputStream.getTopRight();
                var xOffset = topRight.x;
                var yOffset = topRight.y;

                if (xOffset === 0 && yOffset === 0) {
                  return;
                }

                if (result.barcodes) {
                  // TODO: BarcodeInfo may not be the right type here.
                  result.barcodes.forEach(function (barcode) {
                    return _this2.transformResult(barcode);
                  });
                }

                if (result.line && result.line.length === 2) {
                  moveLine(result.line, xOffset, yOffset);
                }

                if (result.box) {
                  moveBox(result.box, xOffset, yOffset);
                }

                if (result.boxes && result.boxes.length > 0) {
                  for (var i = 0; i < result.boxes.length; i++) {
                    moveBox(result.boxes[i], xOffset, yOffset);
                  }
                }
              },
            },
            {
              key: "addResult",
              value: function addResult(result, imageData) {
                var _this3 = this;

                if (!imageData || !this.context.resultCollector) {
                  return;
                } // TODO: Figure out what data structure holds a "barcodes" result, if any...

                if (result.barcodes) {
                  result.barcodes
                    .filter(function (barcode) {
                      return barcode.codeResult;
                    })
                    .forEach(function (barcode) {
                      return _this3.addResult(barcode, imageData);
                    });
                } else if (result.codeResult) {
                  this.context.resultCollector.addResult(
                    imageData,
                    this.context.inputStream.getCanvasSize(),
                    result.codeResult
                  );
                }
              }, // eslint-disable-next-line class-methods-use-this
            },
            {
              key: "hasCodeResult",
              value: function hasCodeResult(result) {
                return !!(
                  result &&
                  (result.barcodes
                    ? result.barcodes.some(function (barcode) {
                        return barcode.codeResult;
                      })
                    : result.codeResult)
                );
              }, // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
            },
            {
              key: "publishResult",
              value: function publishResult() {
                var result =
                  arguments.length > 0 && arguments[0] !== undefined
                    ? arguments[0]
                    : null;
                var imageData = arguments.length > 1 ? arguments[1] : undefined;
                var resultToPublish = result;

                if (result && this.context.onUIThread) {
                  this.transformResult(result);
                  this.addResult(result, imageData);
                  resultToPublish = result.barcodes || result;
                }

                events.publish("processed", resultToPublish);

                if (this.hasCodeResult(result)) {
                  events.publish("detected", resultToPublish);
                }
              },
            },
            {
              key: "locateAndDecode",
              value: (function () {
                var _locateAndDecode = asyncToGenerator_default()(
                  /*#__PURE__*/ regenerator_default.a.mark(function _callee() {
                    var boxes,
                      _this$context$inputIm3,
                      decodeResult,
                      imageResult,
                      _this$context$inputIm4;

                    return regenerator_default.a.wrap(
                      function _callee$(_context) {
                        while (1) {
                          switch ((_context.prev = _context.next)) {
                            case 0:
                              boxes = this.getBoundingBoxes();

                              if (!boxes) {
                                _context.next = 12;
                                break;
                              }

                              _context.next = 4;
                              return this.context.decoder.decodeFromBoundingBoxes(
                                boxes
                              );

                            case 4:
                              _context.t0 = _context.sent;

                              if (_context.t0) {
                                _context.next = 7;
                                break;
                              }

                              _context.t0 = {};

                            case 7:
                              decodeResult = _context.t0;
                              decodeResult.boxes = boxes;
                              this.publishResult(
                                decodeResult,
                                (_this$context$inputIm3 =
                                  this.context.inputImageWrapper) === null ||
                                  _this$context$inputIm3 === void 0
                                  ? void 0
                                  : _this$context$inputIm3.data
                              );
                              _context.next = 16;
                              break;

                            case 12:
                              _context.next = 14;
                              return this.context.decoder.decodeFromImage(
                                this.context.inputImageWrapper
                              );

                            case 14:
                              imageResult = _context.sent;

                              if (imageResult) {
                                this.publishResult(
                                  imageResult,
                                  (_this$context$inputIm4 =
                                    this.context.inputImageWrapper) === null ||
                                    _this$context$inputIm4 === void 0
                                    ? void 0
                                    : _this$context$inputIm4.data
                                );
                              } else {
                                this.publishResult();
                              }

                            case 16:
                            case "end":
                              return _context.stop();
                          }
                        }
                      },
                      _callee,
                      this
                    );
                  })
                );

                function locateAndDecode() {
                  return _locateAndDecode.apply(this, arguments);
                }

                return locateAndDecode;
              })(),
            },
            {
              key: "startContinuousUpdate",
              value: function startContinuousUpdate() {
                var _this$context$config4,
                  _this4 = this;

                var next = null;
                var delay =
                  1000 /
                  (((_this$context$config4 = this.context.config) === null ||
                  _this$context$config4 === void 0
                    ? void 0
                    : _this$context$config4.frequency) || 60);
                this.context.stopped = false;
                var context = this.context;

                var newFrame = function newFrame(timestamp) {
                  next = next || timestamp;

                  if (!context.stopped) {
                    if (timestamp >= next) {
                      next += delay;

                      _this4.update();
                    }

                    window.requestAnimationFrame(newFrame);
                  }
                };

                newFrame(performance.now());
              },
            },
            {
              key: "start",
              value: function start() {
                var _this$context$config5, _this$context$config6;

                if (
                  this.context.onUIThread &&
                  ((_this$context$config5 = this.context.config) === null ||
                  _this$context$config5 === void 0
                    ? void 0
                    : (_this$context$config6 =
                        _this$context$config5.inputStream) === null ||
                      _this$context$config6 === void 0
                    ? void 0
                    : _this$context$config6.type) === "LiveStream"
                ) {
                  this.startContinuousUpdate();
                } else {
                  this.update();
                }
              },
            },
            {
              key: "stop",
              value: (function () {
                var _stop = asyncToGenerator_default()(
                  /*#__PURE__*/ regenerator_default.a.mark(function _callee2() {
                    var _this$context$config7;

                    return regenerator_default.a.wrap(
                      function _callee2$(_context2) {
                        while (1) {
                          switch ((_context2.prev = _context2.next)) {
                            case 0:
                              this.context.stopped = true;
                              adjustWorkerPool(0);

                              if (
                                !(
                                  (_this$context$config7 =
                                    this.context.config) !== null &&
                                  _this$context$config7 !== void 0 &&
                                  _this$context$config7.inputStream &&
                                  this.context.config.inputStream.type ===
                                    "LiveStream"
                                )
                              ) {
                                _context2.next = 6;
                                break;
                              }

                              _context2.next = 5;
                              return camera_access.release();

                            case 5:
                              this.context.inputStream.clearEventHandlers();

                            case 6:
                            case "end":
                              return _context2.stop();
                          }
                        }
                      },
                      _callee2,
                      this
                    );
                  })
                );

                function stop() {
                  return _stop.apply(this, arguments);
                }

                return stop;
              })(),
            },
            {
              key: "setReaders",
              value: function setReaders(readers) {
                if (this.context.decoder) {
                  this.context.decoder.setReaders(readers);
                }

                qworker_setReaders(readers);
              },
            },
            {
              key: "registerReader",
              value: function registerReader(name, reader) {
                barcode_decoder.registerReader(name, reader);

                if (this.context.decoder) {
                  this.context.decoder.registerReader(name, reader);
                }

                qworker_registerReader(name, reader);
              },
            },
          ]);

          return Quagga;
        })();

        // CONCATENATED MODULE: ./src/quagga.js

        // eslint-disable-line no-unused-vars

        var instance = new quagga_Quagga();
        var _context = instance.context;
        var QuaggaJSStaticInterface = {
          init: function init(config, cb, imageWrapper) {
            var quaggaInstance =
              arguments.length > 3 && arguments[3] !== undefined
                ? arguments[3]
                : instance;
            var promise;

            if (!cb) {
              promise = new Promise(function (resolve, reject) {
                cb = function cb(err) {
                  err ? reject(err) : resolve();
                };
              });
            }

            quaggaInstance.context.config = merge_default()(
              {},
              config_config,
              config
            ); // TODO #179: pending restructure in Issue #179, we are temp disabling workers

            if (quaggaInstance.context.config.numOfWorkers > 0) {
              quaggaInstance.context.config.numOfWorkers = 0;
            }

            if (imageWrapper) {
              quaggaInstance.context.onUIThread = false;
              quaggaInstance.initializeData(imageWrapper);

              if (cb) {
                cb();
              }
            } else {
              quaggaInstance.initInputStream(cb);
            }

            return promise;
          },
          start: function start() {
            return instance.start();
          },
          stop: function stop() {
            return instance.stop();
          },
          pause: function pause() {
            _context.stopped = true;
          },
          onDetected: function onDetected(callback) {
            if (
              !callback ||
              (typeof callback !== "function" &&
                (typeof_default()(callback) !== "object" || !callback.callback))
            ) {
              console.trace(
                "* warning: Quagga.onDetected called with invalid callback, ignoring"
              );
              return;
            }

            events.subscribe("detected", callback);
          },
          offDetected: function offDetected(callback) {
            events.unsubscribe("detected", callback);
          },
          onProcessed: function onProcessed(callback) {
            if (
              !callback ||
              (typeof callback !== "function" &&
                (typeof_default()(callback) !== "object" || !callback.callback))
            ) {
              console.trace(
                "* warning: Quagga.onProcessed called with invalid callback, ignoring"
              );
              return;
            }

            events.subscribe("processed", callback);
          },
          offProcessed: function offProcessed(callback) {
            events.unsubscribe("processed", callback);
          },
          setReaders: function setReaders(readers) {
            if (!readers) {
              console.trace(
                "* warning: Quagga.setReaders called with no readers, ignoring"
              );
              return;
            }

            instance.setReaders(readers);
          },
          registerReader: function registerReader(name, reader) {
            if (!name) {
              console.trace(
                "* warning: Quagga.registerReader called with no name, ignoring"
              );
              return;
            }

            if (!reader) {
              console.trace(
                "* warning: Quagga.registerReader called with no reader, ignoring"
              );
              return;
            }

            instance.registerReader(name, reader);
          },
          registerResultCollector: function registerResultCollector(
            resultCollector
          ) {
            if (
              resultCollector &&
              typeof resultCollector.addResult === "function"
            ) {
              _context.resultCollector = resultCollector;
            }
          },

          get canvas() {
            return _context.canvasContainer;
          },

          decodeSingle: function decodeSingle(config, resultCallback) {
            var _this = this;

            var quaggaInstance = new quagga_Quagga();
            config = merge_default()(
              {
                inputStream: {
                  type: "ImageStream",
                  sequence: false,
                  size: 800,
                  src: config.src,
                },
                numOfWorkers: true && config.debug ? 0 : 1,
                locator: {
                  halfSample: false,
                },
              },
              config
            ); // TODO #175: restructure worker support so that it will work with typescript using worker-loader
            // https://webpack.js.org/loaders/worker-loader/

            if (config.numOfWorkers > 0) {
              config.numOfWorkers = 0;
            } // workers require Worker and Blob support presently, so if no Blob or Worker then set
            // workers to 0.

            if (
              config.numOfWorkers > 0 &&
              (typeof Blob === "undefined" || typeof Worker === "undefined")
            ) {
              console.warn(
                "* no Worker and/or Blob support - forcing numOfWorkers to 0"
              );
              config.numOfWorkers = 0;
            }

            return new Promise(function (resolve, reject) {
              try {
                _this.init(
                  config,
                  function () {
                    events.once(
                      "processed",
                      function (result) {
                        quaggaInstance.stop();

                        if (resultCallback) {
                          resultCallback.call(null, result);
                        }

                        resolve(result);
                      },
                      true
                    );
                    quaggaInstance.start();
                  },
                  null,
                  quaggaInstance
                );
              } catch (err) {
                reject(err);
              }
            });
          },

          // add the usually expected "default" for use with require, build step won't allow us to
          // write to module.exports so do it here.
          get default() {
            return QuaggaJSStaticInterface;
          },

          Readers: reader_namespaceObject,
          CameraAccess: camera_access,
          ImageDebug: image_debug["a" /* default */],
          ImageWrapper: image_wrapper["a" /* default */],
          ResultCollector: result_collector,
        };
        /* harmony default export */ var quagga = (__webpack_exports__[
          "default"
        ] = QuaggaJSStaticInterface); // export BarcodeReader and other utilities for external plugins

        /***/
      },
      /******/
    ]
  )["default"];
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9RdWFnZ2Evd2VicGFjay91bml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uIiwid2VicGFjazovL1F1YWdnYS93ZWJwYWNrL2Jvb3RzdHJhcCIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9kZWZpbmVQcm9wZXJ0eS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZ2V0UHJvdG90eXBlT2YuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvY2xhc3NDYWxsQ2hlY2suanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvY3JlYXRlQ2xhc3MuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvcG9zc2libGVDb25zdHJ1Y3RvclJldHVybi5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbmhlcml0cy5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZ2wtdmVjMi9pbmRleC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvcmVnZW5lcmF0b3IvaW5kZXguanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vc3JjL2NvbW1vbi9jbHVzdGVyLmpzIiwid2VicGFjazovL1F1YWdnYS8uL3NyYy9jb21tb24vY3ZfdXRpbHMuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vc3JjL2NvbW1vbi9pbWFnZV9kZWJ1Zy50cyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9zcmMvY29tbW9uL2FycmF5X2hlbHBlci50cyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9zcmMvY29tbW9uL2ltYWdlX3dyYXBwZXIudHMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvYXN5bmNUb0dlbmVyYXRvci5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9nZXQuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9pc09iamVjdC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lzQXJyYXkuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvdHlwZW9mLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvbWVyZ2UuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fcm9vdC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lzT2JqZWN0TGlrZS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9zcmMvbG9jYXRvci90cmFjZXIuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUdldFRhZy5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9zcmMvbG9jYXRvci9iYXJjb2RlX2xvY2F0b3IuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fTGlzdENhY2hlLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Fzc29jSW5kZXhPZi5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL2VxLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX1N5bWJvbC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19uYXRpdmVDcmVhdGUuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fZ2V0TWFwRGF0YS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lzQXJndW1lbnRzLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2lzSW5kZXguanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fY2FzdFBhdGguanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvdG9Db25zdW1hYmxlQXJyYXkuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2dsLW1hdDIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fZ2V0TmF0aXZlLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNGdW5jdGlvbi5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlQXNzaWduVmFsdWUuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLyh3ZWJwYWNrKS9idWlsZGluL21vZHVsZS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lzQXJyYXlMaWtlLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNMZW5ndGguanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvc2V0UHJvdG90eXBlT2YuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9pc1N5bWJvbC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL190b0tleS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19NYXAuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fZnJlZUdsb2JhbC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvKHdlYnBhY2spL2J1aWxkaW4vZ2xvYmFsLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX01hcENhY2hlLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Fzc2lnbk1lcmdlVmFsdWUuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fZGVmaW5lUHJvcGVydHkuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fZ2V0UHJvdG90eXBlLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2lzUHJvdG90eXBlLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNCdWZmZXIuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9pc1R5cGVkQXJyYXkuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fc2FmZUdldC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19hc3NpZ25WYWx1ZS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL2tleXNJbi5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lkZW50aXR5LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX292ZXJSZXN0LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3NldFRvU3RyaW5nLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2FycmF5TGlrZVRvQXJyYXkuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzIvZXBzaWxvbi5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZ2wtdmVjMi9jcmVhdGUuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzIvc3VidHJhY3QuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzIvbXVsdGlwbHkuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzIvZGl2aWRlLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC12ZWMyL2Rpc3RhbmNlLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC12ZWMyL3NxdWFyZWREaXN0YW5jZS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZ2wtdmVjMi9sZW5ndGguanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzIvc3F1YXJlZExlbmd0aC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZ2wtdmVjMy9lcHNpbG9uLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC12ZWMzL2NyZWF0ZS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZ2wtdmVjMy9mcm9tVmFsdWVzLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC12ZWMzL25vcm1hbGl6ZS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZ2wtdmVjMy9kb3QuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzMvc3VidHJhY3QuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzMvbXVsdGlwbHkuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzMvZGl2aWRlLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC12ZWMzL2Rpc3RhbmNlLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC12ZWMzL3NxdWFyZWREaXN0YW5jZS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZ2wtdmVjMy9sZW5ndGguanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzMvc3F1YXJlZExlbmd0aC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9zbGljZWRUb0FycmF5LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC12ZWMzL2luZGV4LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvcGljay5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy93cmFwTmF0aXZlU3VwZXIuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vc3JjL2xvY2F0b3IvcmFzdGVyaXplci5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9zcmMvbG9jYXRvci9za2VsZXRvbml6ZXIuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZU1lcmdlLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX1N0YWNrLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2xpc3RDYWNoZUNsZWFyLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2xpc3RDYWNoZURlbGV0ZS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19saXN0Q2FjaGVHZXQuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbGlzdENhY2hlSGFzLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2xpc3RDYWNoZVNldC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19zdGFja0NsZWFyLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3N0YWNrRGVsZXRlLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3N0YWNrR2V0LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3N0YWNrSGFzLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3N0YWNrU2V0LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VJc05hdGl2ZS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19nZXRSYXdUYWcuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fb2JqZWN0VG9TdHJpbmcuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9faXNNYXNrZWQuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fY29yZUpzRGF0YS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL190b1NvdXJjZS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19nZXRWYWx1ZS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19tYXBDYWNoZUNsZWFyLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX0hhc2guanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9faGFzaENsZWFyLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2hhc2hEZWxldGUuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9faGFzaEdldC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19oYXNoSGFzLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2hhc2hTZXQuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbWFwQ2FjaGVEZWxldGUuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9faXNLZXlhYmxlLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX21hcENhY2hlR2V0LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX21hcENhY2hlSGFzLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX21hcENhY2hlU2V0LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VGb3IuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fY3JlYXRlQmFzZUZvci5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlTWVyZ2VEZWVwLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Nsb25lQnVmZmVyLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Nsb25lVHlwZWRBcnJheS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19jbG9uZUFycmF5QnVmZmVyLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX1VpbnQ4QXJyYXkuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fY29weUFycmF5LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2luaXRDbG9uZU9iamVjdC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlQ3JlYXRlLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX292ZXJBcmcuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUlzQXJndW1lbnRzLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNBcnJheUxpa2VPYmplY3QuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9zdHViRmFsc2UuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9pc1BsYWluT2JqZWN0LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VJc1R5cGVkQXJyYXkuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZVVuYXJ5LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX25vZGVVdGlsLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvdG9QbGFpbk9iamVjdC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19jb3B5T2JqZWN0LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2FycmF5TGlrZUtleXMuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZVRpbWVzLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VLZXlzSW4uanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbmF0aXZlS2V5c0luLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2NyZWF0ZUFzc2lnbmVyLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VSZXN0LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2FwcGx5LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VTZXRUb1N0cmluZy5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL2NvbnN0YW50LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3Nob3J0T3V0LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2lzSXRlcmF0ZWVDYWxsLmpzIiwid2VicGFjazovL1F1YWdnYS8uL3NyYy9jb21tb24vdHlwZWRlZnMuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvYXJyYXlXaXRoSG9sZXMuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvaXRlcmFibGVUb0FycmF5TGltaXQuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvbm9uSXRlcmFibGVSZXN0LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC12ZWMyL2Nsb25lLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC12ZWMyL2Zyb21WYWx1ZXMuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzIvY29weS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZ2wtdmVjMi9zZXQuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzIvZXF1YWxzLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC12ZWMyL2V4YWN0RXF1YWxzLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC12ZWMyL2FkZC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZ2wtdmVjMi9zdWIuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzIvbXVsLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC12ZWMyL2Rpdi5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZ2wtdmVjMi9pbnZlcnNlLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC12ZWMyL21pbi5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZ2wtdmVjMi9tYXguanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzIvcm90YXRlLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC12ZWMyL2Zsb29yLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC12ZWMyL2NlaWwuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzIvcm91bmQuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzIvc2NhbGUuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzIvc2NhbGVBbmRBZGQuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzIvZGlzdC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZ2wtdmVjMi9zcXJEaXN0LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC12ZWMyL2xlbi5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZ2wtdmVjMi9zcXJMZW4uanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzIvbmVnYXRlLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC12ZWMyL25vcm1hbGl6ZS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZ2wtdmVjMi9kb3QuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzIvY3Jvc3MuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzIvbGVycC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZ2wtdmVjMi9yYW5kb20uanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzIvdHJhbnNmb3JtTWF0Mi5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZ2wtdmVjMi90cmFuc2Zvcm1NYXQyZC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZ2wtdmVjMi90cmFuc2Zvcm1NYXQzLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC12ZWMyL3RyYW5zZm9ybU1hdDQuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzIvZm9yRWFjaC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZ2wtdmVjMi9saW1pdC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZ2wtdmVjMy9jbG9uZS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZ2wtdmVjMy9hbmdsZS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZ2wtdmVjMy9jb3B5LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC12ZWMzL3NldC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZ2wtdmVjMy9lcXVhbHMuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzMvZXhhY3RFcXVhbHMuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzMvYWRkLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC12ZWMzL3N1Yi5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZ2wtdmVjMy9tdWwuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzMvZGl2LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC12ZWMzL21pbi5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZ2wtdmVjMy9tYXguanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzMvZmxvb3IuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzMvY2VpbC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZ2wtdmVjMy9yb3VuZC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZ2wtdmVjMy9zY2FsZS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZ2wtdmVjMy9zY2FsZUFuZEFkZC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZ2wtdmVjMy9kaXN0LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC12ZWMzL3NxckRpc3QuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzMvbGVuLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC12ZWMzL3Nxckxlbi5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZ2wtdmVjMy9uZWdhdGUuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzMvaW52ZXJzZS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZ2wtdmVjMy9jcm9zcy5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZ2wtdmVjMy9sZXJwLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC12ZWMzL3JhbmRvbS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZ2wtdmVjMy90cmFuc2Zvcm1NYXQ0LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC12ZWMzL3RyYW5zZm9ybU1hdDMuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzMvdHJhbnNmb3JtUXVhdC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZ2wtdmVjMy9yb3RhdGVYLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC12ZWMzL3JvdGF0ZVkuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzMvcm90YXRlWi5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZ2wtdmVjMy9mb3JFYWNoLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL3JlZ2VuZXJhdG9yUnVudGltZS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9zdXBlclByb3BCYXNlLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2FycmF5V2l0aG91dEhvbGVzLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2l0ZXJhYmxlVG9BcnJheS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9ub25JdGVyYWJsZVNwcmVhZC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlUGljay5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlUGlja0J5LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VHZXQuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9faXNLZXkuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fc3RyaW5nVG9QYXRoLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX21lbW9pemVDYXBwZWQuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9tZW1vaXplLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvdG9TdHJpbmcuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZVRvU3RyaW5nLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2FycmF5TWFwLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VTZXQuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9oYXNJbi5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlSGFzSW4uanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9faGFzUGF0aC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19mbGF0UmVzdC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL2ZsYXR0ZW4uanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUZsYXR0ZW4uanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYXJyYXlQdXNoLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2lzRmxhdHRlbmFibGUuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvaXNOYXRpdmVGdW5jdGlvbi5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jb25zdHJ1Y3QuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC1tYXQyL2RldGVybWluYW50LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC1tYXQyL3RyYW5zcG9zZS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZ2wtbWF0Mi9tdWx0aXBseS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZ2wtbWF0Mi9pZGVudGl0eS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZ2wtbWF0Mi9hZGpvaW50LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC1tYXQyL3JvdGF0ZS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZ2wtbWF0Mi9pbnZlcnQuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2dsLW1hdDIvY3JlYXRlLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC1tYXQyL3NjYWxlLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC1tYXQyL2NvcHkuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2dsLW1hdDIvZnJvYi5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZ2wtbWF0Mi9sZHUuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vc3JjL3JlYWRlci9iYXJjb2RlX3JlYWRlci50cyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9zcmMvcmVhZGVyLzJvZjVfcmVhZGVyLnRzIiwid2VicGFjazovL1F1YWdnYS8uL3NyYy9yZWFkZXIvY29kYWJhcl9yZWFkZXIudHMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vc3JjL3JlYWRlci9jb2RlXzEyOF9yZWFkZXIudHMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vc3JjL3JlYWRlci9jb2RlXzM5X3JlYWRlci50cyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9zcmMvcmVhZGVyL2NvZGVfMzJfcmVhZGVyLnRzIiwid2VicGFjazovL1F1YWdnYS8uL3NyYy9yZWFkZXIvY29kZV8zOV92aW5fcmVhZGVyLnRzIiwid2VicGFjazovL1F1YWdnYS8uL3NyYy9yZWFkZXIvY29kZV85M19yZWFkZXIudHMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vc3JjL3JlYWRlci9lYW5fcmVhZGVyLnRzIiwid2VicGFjazovL1F1YWdnYS8uL3NyYy9yZWFkZXIvZWFuXzJfcmVhZGVyLnRzIiwid2VicGFjazovL1F1YWdnYS8uL3NyYy9yZWFkZXIvZWFuXzVfcmVhZGVyLnRzIiwid2VicGFjazovL1F1YWdnYS8uL3NyYy9yZWFkZXIvZWFuXzhfcmVhZGVyLnRzIiwid2VicGFjazovL1F1YWdnYS8uL3NyYy9yZWFkZXIvaTJvZjVfcmVhZGVyLnRzIiwid2VicGFjazovL1F1YWdnYS8uL3NyYy9yZWFkZXIvdXBjX2VfcmVhZGVyLnRzIiwid2VicGFjazovL1F1YWdnYS8uL3NyYy9yZWFkZXIvdXBjX3JlYWRlci50cyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9zcmMvZGVjb2Rlci9icmVzZW5oYW0uanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vc3JjL2RlY29kZXIvYmFyY29kZV9kZWNvZGVyLmpzIiwid2VicGFjazovL1F1YWdnYS8uL3NyYy9yZWFkZXIvaW5kZXgudHMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vc3JjL2NvbW1vbi9ldmVudHMudHMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vc3JjL3F1YWdnYS9FeGNlcHRpb24udHMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vc3JjL2NvbW1vbi9tZWRpYURldmljZXMudHMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vc3JjL2lucHV0L2NhbWVyYV9hY2Nlc3MudHMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vc3JjL2FuYWx5dGljcy9yZXN1bHRfY29sbGVjdG9yLnRzIiwid2VicGFjazovL1F1YWdnYS8uL3NyYy9jb25maWcvY29uZmlnLmRldi50cyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9zcmMvY29uZmlnL2NvbmZpZy5ub2RlLnRzIiwid2VicGFjazovL1F1YWdnYS8uL3NyYy9jb25maWcvY29uZmlnLnByb2QudHMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vc3JjL2NvbmZpZy9jb25maWcudHMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vc3JjL2lucHV0L2ZyYW1lX2dyYWJiZXJfYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9zcmMvaW5wdXQvZXhpZl9oZWxwZXIuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vc3JjL2lucHV0L2ltYWdlX2xvYWRlci5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9zcmMvaW5wdXQvaW5wdXRfc3RyZWFtL2lucHV0X3N0cmVhbV9icm93c2VyLnRzIiwid2VicGFjazovL1F1YWdnYS8uL3NyYy9RdWFnZ2FDb250ZXh0LnRzIiwid2VicGFjazovL1F1YWdnYS8uL3NyYy9xdWFnZ2EvZ2V0Vmlld1BvcnQudHMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vc3JjL3F1YWdnYS9pbml0QnVmZmVycy50cyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9zcmMvcXVhZ2dhL2luaXRDYW52YXMudHMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vc3JjL3F1YWdnYS9xd29ya2VyLnRzIiwid2VicGFjazovL1F1YWdnYS8uL3NyYy9xdWFnZ2Evc2V0dXBJbnB1dFN0cmVhbS50cyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9zcmMvcXVhZ2dhL3RyYW5zZm9ybS50cyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9zcmMvcXVhZ2dhL3F1YWdnYS50cyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9zcmMvcXVhZ2dhLmpzIl0sIm5hbWVzIjpbIl9kZWZpbmVQcm9wZXJ0eSIsIm9iaiIsImtleSIsInZhbHVlIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJlbnVtZXJhYmxlIiwiY29uZmlndXJhYmxlIiwid3JpdGFibGUiLCJtb2R1bGUiLCJleHBvcnRzIiwiX19lc01vZHVsZSIsIl9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQiLCJzZWxmIiwiUmVmZXJlbmNlRXJyb3IiLCJfZ2V0UHJvdG90eXBlT2YiLCJvIiwic2V0UHJvdG90eXBlT2YiLCJnZXRQcm90b3R5cGVPZiIsImJpbmQiLCJfX3Byb3RvX18iLCJfY2xhc3NDYWxsQ2hlY2siLCJpbnN0YW5jZSIsIkNvbnN0cnVjdG9yIiwiVHlwZUVycm9yIiwiX2RlZmluZVByb3BlcnRpZXMiLCJ0YXJnZXQiLCJwcm9wcyIsImkiLCJsZW5ndGgiLCJkZXNjcmlwdG9yIiwiX2NyZWF0ZUNsYXNzIiwicHJvdG9Qcm9wcyIsInN0YXRpY1Byb3BzIiwicHJvdG90eXBlIiwiX3R5cGVvZiIsInJlcXVpcmUiLCJhc3NlcnRUaGlzSW5pdGlhbGl6ZWQiLCJfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybiIsImNhbGwiLCJfaW5oZXJpdHMiLCJzdWJDbGFzcyIsInN1cGVyQ2xhc3MiLCJjcmVhdGUiLCJjb25zdHJ1Y3RvciIsIkVQU0lMT04iLCJjbG9uZSIsImZyb21WYWx1ZXMiLCJjb3B5Iiwic2V0IiwiZXF1YWxzIiwiZXhhY3RFcXVhbHMiLCJhZGQiLCJzdWJ0cmFjdCIsInN1YiIsIm11bHRpcGx5IiwibXVsIiwiZGl2aWRlIiwiZGl2IiwiaW52ZXJzZSIsIm1pbiIsIm1heCIsInJvdGF0ZSIsImZsb29yIiwiY2VpbCIsInJvdW5kIiwic2NhbGUiLCJzY2FsZUFuZEFkZCIsImRpc3RhbmNlIiwiZGlzdCIsInNxdWFyZWREaXN0YW5jZSIsInNxckRpc3QiLCJsZW4iLCJzcXVhcmVkTGVuZ3RoIiwic3FyTGVuIiwibmVnYXRlIiwibm9ybWFsaXplIiwiZG90IiwiY3Jvc3MiLCJsZXJwIiwicmFuZG9tIiwidHJhbnNmb3JtTWF0MiIsInRyYW5zZm9ybU1hdDJkIiwidHJhbnNmb3JtTWF0MyIsInRyYW5zZm9ybU1hdDQiLCJmb3JFYWNoIiwibGltaXQiLCJydW50aW1lIiwicmVnZW5lcmF0b3JSdW50aW1lIiwiYWNjaWRlbnRhbFN0cmljdE1vZGUiLCJnbG9iYWxUaGlzIiwiRnVuY3Rpb24iLCJ2ZWMyIiwicG9pbnQiLCJ0aHJlc2hvbGQiLCJwb2ludHMiLCJjZW50ZXIiLCJyYWQiLCJ2ZWMiLCJwb2ludE1hcCIsInBvaW50VG9BZGQiLCJpZCIsInB1c2giLCJ1cGRhdGVDZW50ZXIiLCJzdW0iLCJNYXRoIiwiY29zIiwic2luIiwiaW5pdCIsImZpdHMiLCJvdGhlclBvaW50Iiwic2ltaWxhcml0eSIsImFicyIsImdldFBvaW50cyIsImdldENlbnRlciIsImNyZWF0ZVBvaW50IiwibmV3UG9pbnQiLCJwcm9wZXJ0eSIsInYyY2xvbmUiLCJ2ZWMzIiwidjNjbG9uZSIsImltYWdlUmVmIiwieCIsInkiLCJ0aGF0IiwidG9WZWMyIiwidG9WZWMzIiwiY29tcHV0ZUludGVncmFsSW1hZ2UyIiwiaW1hZ2VXcmFwcGVyIiwiaW50ZWdyYWxXcmFwcGVyIiwiaW1hZ2VEYXRhIiwiZGF0YSIsIndpZHRoIiwic2l6ZSIsImhlaWdodCIsImludGVncmFsSW1hZ2VEYXRhIiwicG9zQSIsInBvc0IiLCJwb3NDIiwicG9zRCIsImNvbXB1dGVJbnRlZ3JhbEltYWdlIiwidiIsInUiLCJ0aHJlc2hvbGRJbWFnZSIsInRhcmdldFdyYXBwZXIiLCJ0YXJnZXREYXRhIiwiY29tcHV0ZUhpc3RvZ3JhbSIsImJpdHNQZXJQaXhlbCIsImJpdFNoaWZ0IiwiYnVja2V0Q250IiwiaGlzdCIsIkludDMyQXJyYXkiLCJzaGFycGVuTGluZSIsImxpbmUiLCJsZWZ0IiwicmlnaHQiLCJkZXRlcm1pbmVPdHN1VGhyZXNob2xkIiwicHgiLCJlbmQiLCJteCIsImRldGVybWluZVRocmVzaG9sZCIsInZldCIsInAxIiwicDIiLCJwMTIiLCJtMSIsIm0yIiwibTEyIiwiayIsIkFycmF5SGVscGVyIiwibWF4SW5kZXgiLCJvdHN1VGhyZXNob2xkIiwiY29tcHV0ZUJpbmFyeUltYWdlIiwia2VybmVsIiwiQSIsIkIiLCJDIiwiRCIsImF2ZyIsImNsdXN0ZXIiLCJ0aGlzQ2x1c3RlciIsImNsdXN0ZXJzIiwiYWRkVG9DbHVzdGVyIiwiZm91bmQiLCJDbHVzdGVyMiIsIlRyYWNlciIsInRyYWNlIiwiaXRlcmF0aW9uIiwibWF4SXRlcmF0aW9ucyIsInRvcCIsInJlc3VsdCIsImNlbnRlclBvcyIsImN1cnJlbnRQb3MiLCJpZHgiLCJmb3J3YXJkIiwidG8iLCJ0b0lkeCIsInByZWRpY3RlZFBvcyIsInRocmVzaG9sZFgiLCJ0aHJlc2hvbGRZIiwibWF0Y2giLCJwb3MiLCJwcmVkaWN0ZWQiLCJmcm9tIiwiRElMQVRFIiwiRVJPREUiLCJkaWxhdGUiLCJpbkltYWdlV3JhcHBlciIsIm91dEltYWdlV3JhcHBlciIsImluSW1hZ2VEYXRhIiwib3V0SW1hZ2VEYXRhIiwieVN0YXJ0MSIsInlTdGFydDIiLCJ4U3RhcnQxIiwieFN0YXJ0MiIsImVyb2RlIiwiYUltYWdlV3JhcHBlciIsImJJbWFnZVdyYXBwZXIiLCJyZXN1bHRJbWFnZVdyYXBwZXIiLCJhSW1hZ2VEYXRhIiwiYkltYWdlRGF0YSIsImNJbWFnZURhdGEiLCJiaXR3aXNlT3IiLCJjb3VudE5vblplcm8iLCJ0b3BHZW5lcmljIiwibGlzdCIsInNjb3JlRnVuYyIsIm1pbklkeCIsInF1ZXVlIiwic2NvcmUiLCJoaXQiLCJpdGVtIiwiYXBwbHkiLCJOdW1iZXIiLCJNQVhfVkFMVUUiLCJncmF5QXJyYXlGcm9tSW1hZ2UiLCJodG1sSW1hZ2UiLCJvZmZzZXRYIiwiY3R4IiwiYXJyYXkiLCJkcmF3SW1hZ2UiLCJjdHhEYXRhIiwiZ2V0SW1hZ2VEYXRhIiwiY29tcHV0ZUdyYXkiLCJncmF5QXJyYXlGcm9tQ29udGV4dCIsIm9mZnNldCIsImdyYXlBbmRIYWxmU2FtcGxlRnJvbUNhbnZhc0RhdGEiLCJjYW52YXNEYXRhIiwib3V0QXJyYXkiLCJ0b3BSb3dJZHgiLCJib3R0b21Sb3dJZHgiLCJlbmRJZHgiLCJvdXRXaWR0aCIsIm91dEltZ0lkeCIsImluV2lkdGgiLCJjb25maWciLCJsIiwic2luZ2xlQ2hhbm5lbCIsImxvYWRJbWFnZUFycmF5Iiwic3JjIiwiY2FsbGJhY2siLCJjYW52YXMiLCJkb2N1bWVudCIsImNyZWF0ZUVsZW1lbnQiLCJpbWciLCJJbWFnZSIsIm9ubG9hZCIsImdldENvbnRleHQiLCJVaW50OEFycmF5IiwiaGFsZlNhbXBsZSIsImluSW1nV3JhcHBlciIsIm91dEltZ1dyYXBwZXIiLCJpbkltZyIsIm91dEltZyIsImhzdjJyZ2IiLCJoc3YiLCJyZ2IiLCJoIiwicyIsImMiLCJtIiwiciIsImciLCJiIiwiX2NvbXB1dGVEaXZpc29ycyIsIm4iLCJsYXJnZURpdmlzb3JzIiwiZGl2aXNvcnMiLCJzcXJ0IiwidW5zaGlmdCIsImNvbmNhdCIsIl9jb21wdXRlSW50ZXJzZWN0aW9uIiwiYXJyMSIsImFycjIiLCJqIiwiY2FsY3VsYXRlUGF0Y2hTaXplIiwicGF0Y2hTaXplIiwiaW1nU2l6ZSIsImRpdmlzb3JzWCIsImRpdmlzb3JzWSIsIndpZGVTaWRlIiwiY29tbW9uIiwibnJPZlBhdGNoZXNMaXN0IiwibnJPZlBhdGNoZXNNYXAiLCJzbWFsbCIsIm1lZGl1bSIsImxhcmdlIiwibnJPZlBhdGNoZXNJZHgiLCJuck9mUGF0Y2hlcyIsImRlc2lyZWRQYXRjaFNpemUiLCJvcHRpbWFsUGF0Y2hTaXplIiwiZmluZFBhdGNoU2l6ZUZvckRpdmlzb3JzIiwiX3BhcnNlQ1NTRGltZW5zaW9uVmFsdWVzIiwiZGltZW5zaW9uIiwicGFyc2VGbG9hdCIsInVuaXQiLCJpbmRleE9mIiwiX2RpbWVuc2lvbnNDb252ZXJ0ZXJzIiwiY29udGV4dCIsImJvdHRvbSIsImNvbXB1dGVJbWFnZUFyZWEiLCJpbnB1dFdpZHRoIiwiaW5wdXRIZWlnaHQiLCJhcmVhIiwicGFyc2VkQXJlYSIsImtleXMiLCJyZWR1Y2UiLCJwYXJzZWQiLCJjYWxjdWxhdGVkIiwic3giLCJzeSIsInN3Iiwic2giLCJkcmF3UmVjdCIsInN0eWxlIiwic3Ryb2tlU3R5bGUiLCJjb2xvciIsImZpbGxTdHlsZSIsImxpbmVXaWR0aCIsImJlZ2luUGF0aCIsInN0cm9rZVJlY3QiLCJkcmF3UGF0aCIsInBhdGgiLCJkZWYiLCJtb3ZlVG8iLCJsaW5lVG8iLCJjbG9zZVBhdGgiLCJzdHJva2UiLCJjYW52YXNEYXRhUG9zIiwiaW1hZ2VEYXRhUG9zIiwicHV0SW1hZ2VEYXRhIiwiYXJyIiwidmFsIiwiZmlsbCIsInNodWZmbGUiLCJ0b1BvaW50TGlzdCIsInJvd3MiLCJwIiwicm93Iiwiam9pbiIsInByZXYiLCJuZXh0IiwiYXNzZXJ0TnVtYmVyUG9zaXRpdmUiLCJFcnJvciIsIkltYWdlV3JhcHBlciIsIkFycmF5VHlwZSIsImluaXRpYWxpemUiLCJpbWdSZWYiLCJib3JkZXIiLCJzaXplWCIsInNpemVZIiwiaW5kZXhNYXBwaW5nIiwibGFiZWxDb3VudCIsInlzcSIsImxhYmVsU3VtIiwibGFiZWwiLCJtdTExIiwibXUwMiIsIm11MjAiLCJ4XyIsInlfIiwidG1wIiwiUEkiLCJQSV80IiwibTAwIiwibTAxIiwibTEwIiwibTExIiwibTAyIiwibTIwIiwidGhldGEiLCJpc05hTiIsImF0YW4iLCJyZXQiLCJVaW50OENsYW1wZWRBcnJheSIsInBpeGVsIiwiY3VycmVudCIsImdldCIsImZyYW1lIiwiZ2V0QXNSR0JBIiwibmV3RnJhbWUiLCJJbWFnZURhdGEiLCJpblNjYWxlIiwiYWRqdXN0ZWRTY2FsZSIsIndoaXRlUmdiIiwiYmxhY2tSZ2IiLCJhc3luY0dlbmVyYXRvclN0ZXAiLCJnZW4iLCJyZXNvbHZlIiwicmVqZWN0IiwiX25leHQiLCJfdGhyb3ciLCJhcmciLCJpbmZvIiwiZXJyb3IiLCJkb25lIiwiUHJvbWlzZSIsInRoZW4iLCJfYXN5bmNUb0dlbmVyYXRvciIsImZuIiwiYXJncyIsImFyZ3VtZW50cyIsImVyciIsInVuZGVmaW5lZCIsInN1cGVyUHJvcEJhc2UiLCJfZ2V0IiwiUmVmbGVjdCIsInJlY2VpdmVyIiwiYmFzZSIsImRlc2MiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJpc09iamVjdCIsInR5cGUiLCJpc0FycmF5IiwiQXJyYXkiLCJTeW1ib2wiLCJpdGVyYXRvciIsImJhc2VNZXJnZSIsImNyZWF0ZUFzc2lnbmVyIiwibWVyZ2UiLCJvYmplY3QiLCJzb3VyY2UiLCJzcmNJbmRleCIsImZyZWVHbG9iYWwiLCJmcmVlU2VsZiIsInJvb3QiLCJpc09iamVjdExpa2UiLCJzZWFyY2hEaXJlY3Rpb25zIiwibGFiZWxXcmFwcGVyIiwibGFiZWxEYXRhIiwiZWRnZWxhYmVsIiwiY3kiLCJkaXIiLCJjeCIsInZlcnRleDJEIiwiY29udG91clRyYWNpbmciLCJGdiIsIkN2IiwiUCIsImxkaXIiLCJ0b3RhbFBpeGVsQ291bnQiLCJwaXhlbENvdW50ZXIiLCJnZXRSYXdUYWciLCJvYmplY3RUb1N0cmluZyIsIm51bGxUYWciLCJ1bmRlZmluZWRUYWciLCJzeW1Ub1N0cmluZ1RhZyIsInRvU3RyaW5nVGFnIiwiYmFzZUdldFRhZyIsIl9jb25maWciLCJfY3VycmVudEltYWdlV3JhcHBlciIsIl9za2VsSW1hZ2VXcmFwcGVyIiwiX3N1YkltYWdlV3JhcHBlciIsIl9sYWJlbEltYWdlV3JhcHBlciIsIl9wYXRjaEdyaWQiLCJfcGF0Y2hMYWJlbEdyaWQiLCJfaW1hZ2VUb1BhdGNoR3JpZCIsIl9iaW5hcnlJbWFnZVdyYXBwZXIiLCJfcGF0Y2hTaXplIiwiX2NhbnZhc0NvbnRhaW5lciIsImJpbmFyeSIsImRvbSIsIl9udW1QYXRjaGVzIiwiX2lucHV0SW1hZ2VXcmFwcGVyIiwiX3NrZWxldG9uaXplciIsImluaXRCdWZmZXJzIiwic2tlbGV0b25JbWFnZURhdGEiLCJBcnJheUJ1ZmZlciIsInNrZWxldG9uaXplciIsIndpbmRvdyIsImdsb2JhbCIsImluaXRDYW52YXMiLCJ1c2VXb3JrZXIiLCJjbGFzc05hbWUiLCJFTlYiLCJkZWJ1ZyIsInNob3dDYW52YXMiLCJxdWVyeVNlbGVjdG9yIiwiYXBwZW5kQ2hpbGQiLCJib3hGcm9tUGF0Y2hlcyIsInBhdGNoZXMiLCJvdmVyQXZnIiwicGF0Y2giLCJ0cmFuc01hdCIsIm1pbngiLCJtaW55IiwibWF4eCIsIm1heHkiLCJib3giLCJzaG93UGF0Y2hlcyIsIkltYWdlRGVidWciLCJtYXQyIiwic2hvd1RyYW5zZm9ybWVkIiwic2hvd1RyYW5zZm9ybWVkQm94Iiwic2hvd0JCIiwiYmluYXJpemVJbWFnZSIsInplcm9Cb3JkZXIiLCJzaG93IiwiZmluZFBhdGNoZXMiLCJtb21lbnRzIiwicGF0Y2hlc0ZvdW5kIiwicmFzdGVyaXplciIsInJhc3RlclJlc3VsdCIsInNrZWxldG9uaXplIiwiUmFzdGVyaXplciIsInJhc3Rlcml6ZSIsInNob3dMYWJlbHMiLCJvdmVybGF5IiwiY291bnQiLCJkZXNjcmliZVBhdGNoIiwic2hvd0ZvdW5kUGF0Y2hlcyIsImZpbmRCaWdnZXN0Q29ubmVjdGVkQXJlYXMiLCJtYXhMYWJlbCIsImxhYmVsSGlzdCIsInRvcExhYmVscyIsIm1hcCIsInNvcnQiLCJhIiwiZmlsdGVyIiwiZWwiLCJmaW5kQm94ZXMiLCJib3hlcyIsInNob3dSZW1haW5pbmdQYXRjaExhYmVscyIsInNpbWlsYXJNb21lbnRzIiwidG9wQ2x1c3RlciIsImUiLCJzdWJJbWFnZUFzQ29weSIsInNob3dTa2VsZXRvbiIsInBhdGNoUG9zIiwiZWxpZ2libGVNb21lbnRzIiwibWF0Y2hpbmdNb21lbnRzIiwibWluQ29tcG9uZW50V2VpZ2h0IiwiaW5kZXgiLCJyYXN0ZXJpemVBbmd1bGFyU2ltaWxhcml0eSIsImN1cnJJZHgiLCJub3RZZXRQcm9jZXNzZWQiLCJjdXJyZW50SWR4IiwiY3VycmVudFBhdGNoIiwic2hvd1BhdGNoTGFiZWxzIiwiaW5wdXRJbWFnZVdyYXBwZXIiLCJsb2NhdGUiLCJjaGVja0ltYWdlQ29uc3RyYWludHMiLCJpbnB1dFN0cmVhbSIsImdldFdpZHRoIiwiZ2V0SGVpZ2h0IiwidGhpc0hhbGZTYW1wbGUiLCJnZXRDb25maWciLCJzZXRUb3BSaWdodCIsInNldENhbnZhc1NpemUiLCJjb25zb2xlIiwibG9nIiwiSlNPTiIsInN0cmluZ2lmeSIsInNldFdpZHRoIiwic2V0SGVpZ2h0IiwibGlzdENhY2hlQ2xlYXIiLCJsaXN0Q2FjaGVEZWxldGUiLCJsaXN0Q2FjaGVHZXQiLCJsaXN0Q2FjaGVIYXMiLCJsaXN0Q2FjaGVTZXQiLCJMaXN0Q2FjaGUiLCJlbnRyaWVzIiwiY2xlYXIiLCJlbnRyeSIsImhhcyIsImVxIiwiYXNzb2NJbmRleE9mIiwib3RoZXIiLCJnZXROYXRpdmUiLCJuYXRpdmVDcmVhdGUiLCJpc0tleWFibGUiLCJnZXRNYXBEYXRhIiwiX19kYXRhX18iLCJiYXNlSXNBcmd1bWVudHMiLCJvYmplY3RQcm90byIsImhhc093blByb3BlcnR5IiwicHJvcGVydHlJc0VudW1lcmFibGUiLCJpc0FyZ3VtZW50cyIsIk1BWF9TQUZFX0lOVEVHRVIiLCJyZUlzVWludCIsImlzSW5kZXgiLCJ0ZXN0IiwiaXNLZXkiLCJzdHJpbmdUb1BhdGgiLCJ0b1N0cmluZyIsImNhc3RQYXRoIiwiYXJyYXlXaXRob3V0SG9sZXMiLCJpdGVyYWJsZVRvQXJyYXkiLCJ1bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSIsIm5vbkl0ZXJhYmxlU3ByZWFkIiwiX3RvQ29uc3VtYWJsZUFycmF5IiwiZGV0ZXJtaW5hbnQiLCJ0cmFuc3Bvc2UiLCJpZGVudGl0eSIsImFkam9pbnQiLCJpbnZlcnQiLCJmcm9iIiwibGR1IiwiYmFzZUlzTmF0aXZlIiwiZ2V0VmFsdWUiLCJhc3luY1RhZyIsImZ1bmNUYWciLCJnZW5UYWciLCJwcm94eVRhZyIsImlzRnVuY3Rpb24iLCJ0YWciLCJiYXNlQXNzaWduVmFsdWUiLCJ3ZWJwYWNrUG9seWZpbGwiLCJkZXByZWNhdGUiLCJwYXRocyIsImNoaWxkcmVuIiwiaXNMZW5ndGgiLCJpc0FycmF5TGlrZSIsIl9zZXRQcm90b3R5cGVPZiIsInN5bWJvbFRhZyIsImlzU3ltYm9sIiwiSU5GSU5JVFkiLCJ0b0tleSIsIk1hcCIsIm1hcENhY2hlQ2xlYXIiLCJtYXBDYWNoZURlbGV0ZSIsIm1hcENhY2hlR2V0IiwibWFwQ2FjaGVIYXMiLCJtYXBDYWNoZVNldCIsIk1hcENhY2hlIiwiYXNzaWduTWVyZ2VWYWx1ZSIsImZ1bmMiLCJvdmVyQXJnIiwiZ2V0UHJvdG90eXBlIiwiaXNQcm90b3R5cGUiLCJDdG9yIiwicHJvdG8iLCJzdHViRmFsc2UiLCJmcmVlRXhwb3J0cyIsIm5vZGVUeXBlIiwiZnJlZU1vZHVsZSIsIm1vZHVsZUV4cG9ydHMiLCJCdWZmZXIiLCJuYXRpdmVJc0J1ZmZlciIsImlzQnVmZmVyIiwiYmFzZUlzVHlwZWRBcnJheSIsImJhc2VVbmFyeSIsIm5vZGVVdGlsIiwibm9kZUlzVHlwZWRBcnJheSIsImlzVHlwZWRBcnJheSIsInNhZmVHZXQiLCJhc3NpZ25WYWx1ZSIsIm9ialZhbHVlIiwiYXJyYXlMaWtlS2V5cyIsImJhc2VLZXlzSW4iLCJrZXlzSW4iLCJuYXRpdmVNYXgiLCJvdmVyUmVzdCIsInN0YXJ0IiwidHJhbnNmb3JtIiwib3RoZXJBcmdzIiwiYmFzZVNldFRvU3RyaW5nIiwic2hvcnRPdXQiLCJzZXRUb1N0cmluZyIsImFycmF5TGlrZVRvQXJyYXkiLCJfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkiLCJtaW5MZW4iLCJzbGljZSIsIm5hbWUiLCJfYXJyYXlMaWtlVG9BcnJheSIsIm91dCIsIkZsb2F0MzJBcnJheSIsInoiLCJhcnJheVdpdGhIb2xlcyIsIml0ZXJhYmxlVG9BcnJheUxpbWl0Iiwibm9uSXRlcmFibGVSZXN0IiwiX3NsaWNlZFRvQXJyYXkiLCJhbmdsZSIsInRyYW5zZm9ybVF1YXQiLCJyb3RhdGVYIiwicm90YXRlWSIsInJvdGF0ZVoiLCJiYXNlUGljayIsImZsYXRSZXN0IiwicGljayIsImlzTmF0aXZlRnVuY3Rpb24iLCJjb25zdHJ1Y3QiLCJfd3JhcE5hdGl2ZVN1cGVyIiwiQ2xhc3MiLCJfY2FjaGUiLCJXcmFwcGVyIiwiY3JlYXRlQ29udG91cjJEIiwiZmlyc3RWZXJ0ZXgiLCJpbnNpZGVDb250b3VycyIsIm5leHRwZWVyIiwicHJldnBlZXIiLCJDT05UT1VSX0RJUiIsIkNXX0RJUiIsIkNDV19ESVIiLCJVTktOT1dOX0RJUiIsIkRJUiIsIk9VVFNJREVfRURHRSIsIklOU0lERV9FREdFIiwidHJhY2VyIiwiZGVwdGhsYWJlbCIsImJjIiwibGMiLCJsYWJlbGluZGV4IiwiY29sb3JNYXAiLCJ2ZXJ0ZXgiLCJjYyIsInNjIiwiY29ubmVjdGVkQ291bnQiLCJkcmF3Q29udG91ciIsImZpcnN0Q29udG91ciIsInBxIiwiaXEiLCJxIiwiU2tlbGV0b25pemVyIiwic3RkbGliIiwiZm9yZWlnbiIsImJ1ZmZlciIsImltYWdlcyIsImltdWwiLCJpbkltYWdlUHRyIiwib3V0SW1hZ2VQdHIiLCJhSW1hZ2VQdHIiLCJiSW1hZ2VQdHIiLCJpbWFnZVB0ciIsIm1lbWNweSIsInNyY0ltYWdlUHRyIiwiZHN0SW1hZ2VQdHIiLCJzdWJJbWFnZVB0ciIsImVyb2RlZEltYWdlUHRyIiwidGVtcEltYWdlUHRyIiwic2tlbEltYWdlUHRyIiwiU3RhY2siLCJiYXNlRm9yIiwiYmFzZU1lcmdlRGVlcCIsImN1c3RvbWl6ZXIiLCJzdGFjayIsInNyY1ZhbHVlIiwibmV3VmFsdWUiLCJzdGFja0NsZWFyIiwic3RhY2tEZWxldGUiLCJzdGFja0dldCIsInN0YWNrSGFzIiwic3RhY2tTZXQiLCJhcnJheVByb3RvIiwic3BsaWNlIiwibGFzdEluZGV4IiwicG9wIiwiTEFSR0VfQVJSQVlfU0laRSIsInBhaXJzIiwiaXNNYXNrZWQiLCJ0b1NvdXJjZSIsInJlUmVnRXhwQ2hhciIsInJlSXNIb3N0Q3RvciIsImZ1bmNQcm90byIsImZ1bmNUb1N0cmluZyIsInJlSXNOYXRpdmUiLCJSZWdFeHAiLCJyZXBsYWNlIiwicGF0dGVybiIsIm5hdGl2ZU9iamVjdFRvU3RyaW5nIiwiaXNPd24iLCJ1bm1hc2tlZCIsImNvcmVKc0RhdGEiLCJtYXNrU3JjS2V5IiwidWlkIiwiZXhlYyIsIklFX1BST1RPIiwiSGFzaCIsImhhc2hDbGVhciIsImhhc2hEZWxldGUiLCJoYXNoR2V0IiwiaGFzaEhhcyIsImhhc2hTZXQiLCJIQVNIX1VOREVGSU5FRCIsImNyZWF0ZUJhc2VGb3IiLCJmcm9tUmlnaHQiLCJpdGVyYXRlZSIsImtleXNGdW5jIiwiaXRlcmFibGUiLCJjbG9uZUJ1ZmZlciIsImNsb25lVHlwZWRBcnJheSIsImNvcHlBcnJheSIsImluaXRDbG9uZU9iamVjdCIsImlzQXJyYXlMaWtlT2JqZWN0IiwiaXNQbGFpbk9iamVjdCIsInRvUGxhaW5PYmplY3QiLCJtZXJnZUZ1bmMiLCJzdGFja2VkIiwiaXNDb21tb24iLCJpc0FyciIsImlzQnVmZiIsImlzVHlwZWQiLCJhbGxvY1Vuc2FmZSIsImlzRGVlcCIsImNsb25lQXJyYXlCdWZmZXIiLCJ0eXBlZEFycmF5IiwiYnl0ZU9mZnNldCIsImFycmF5QnVmZmVyIiwiYnl0ZUxlbmd0aCIsImJhc2VDcmVhdGUiLCJvYmplY3RDcmVhdGUiLCJhcmdzVGFnIiwib2JqZWN0VGFnIiwib2JqZWN0Q3RvclN0cmluZyIsImFycmF5VGFnIiwiYm9vbFRhZyIsImRhdGVUYWciLCJlcnJvclRhZyIsIm1hcFRhZyIsIm51bWJlclRhZyIsInJlZ2V4cFRhZyIsInNldFRhZyIsInN0cmluZ1RhZyIsIndlYWtNYXBUYWciLCJhcnJheUJ1ZmZlclRhZyIsImRhdGFWaWV3VGFnIiwiZmxvYXQzMlRhZyIsImZsb2F0NjRUYWciLCJpbnQ4VGFnIiwiaW50MTZUYWciLCJpbnQzMlRhZyIsInVpbnQ4VGFnIiwidWludDhDbGFtcGVkVGFnIiwidWludDE2VGFnIiwidWludDMyVGFnIiwidHlwZWRBcnJheVRhZ3MiLCJmcmVlUHJvY2VzcyIsInByb2Nlc3MiLCJ0eXBlcyIsImJpbmRpbmciLCJjb3B5T2JqZWN0IiwiaXNOZXciLCJiYXNlVGltZXMiLCJpbmhlcml0ZWQiLCJpc0FyZyIsImlzVHlwZSIsInNraXBJbmRleGVzIiwiU3RyaW5nIiwibmF0aXZlS2V5c0luIiwiaXNQcm90byIsImJhc2VSZXN0IiwiaXNJdGVyYXRlZUNhbGwiLCJhc3NpZ25lciIsInNvdXJjZXMiLCJndWFyZCIsInRoaXNBcmciLCJjb25zdGFudCIsInN0cmluZyIsIkhPVF9DT1VOVCIsIkhPVF9TUEFOIiwibmF0aXZlTm93IiwiRGF0ZSIsIm5vdyIsImxhc3RDYWxsZWQiLCJzdGFtcCIsInJlbWFpbmluZyIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsIndlYmtpdFJlcXVlc3RBbmltYXRpb25GcmFtZSIsIm1velJlcXVlc3RBbmltYXRpb25GcmFtZSIsIm9SZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJtc1JlcXVlc3RBbmltYXRpb25GcmFtZSIsInNldFRpbWVvdXQiLCJhaCIsImFsIiwiYmgiLCJibCIsImFzc2lnbiIsIm5leHRTb3VyY2UiLCJuZXh0S2V5IiwiX2FycmF5V2l0aEhvbGVzIiwiX2l0ZXJhYmxlVG9BcnJheUxpbWl0IiwiX2kiLCJfYXJyIiwiX24iLCJfZCIsIl9zIiwiX2UiLCJfbm9uSXRlcmFibGVSZXN0IiwiYTAiLCJhMSIsImIwIiwiYjEiLCJ0IiwiYXgiLCJheSIsInN0cmlkZSIsIm1TcSIsInRlbXBBIiwidGVtcEIiLCJjb3NpbmUiLCJhY29zIiwiYTIiLCJiMiIsImF6IiwiYngiLCJieSIsImJ6IiwielNjYWxlIiwidyIsInF4IiwicXkiLCJxeiIsInF3IiwiaXgiLCJpeSIsIml6IiwiaXciLCJweSIsInB6IiwiX3JlZ2VuZXJhdG9yUnVudGltZSIsIk9wIiwiaGFzT3duIiwiJFN5bWJvbCIsIml0ZXJhdG9yU3ltYm9sIiwiYXN5bmNJdGVyYXRvclN5bWJvbCIsImFzeW5jSXRlcmF0b3IiLCJ0b1N0cmluZ1RhZ1N5bWJvbCIsImRlZmluZSIsIndyYXAiLCJpbm5lckZuIiwib3V0ZXJGbiIsInRyeUxvY3NMaXN0IiwicHJvdG9HZW5lcmF0b3IiLCJHZW5lcmF0b3IiLCJnZW5lcmF0b3IiLCJDb250ZXh0IiwiX2ludm9rZSIsInN0YXRlIiwibWV0aG9kIiwiZG9uZVJlc3VsdCIsImRlbGVnYXRlIiwiZGVsZWdhdGVSZXN1bHQiLCJtYXliZUludm9rZURlbGVnYXRlIiwiQ29udGludWVTZW50aW5lbCIsInNlbnQiLCJfc2VudCIsImRpc3BhdGNoRXhjZXB0aW9uIiwiYWJydXB0IiwicmVjb3JkIiwidHJ5Q2F0Y2giLCJHZW5lcmF0b3JGdW5jdGlvbiIsIkdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlIiwiSXRlcmF0b3JQcm90b3R5cGUiLCJnZXRQcm90byIsIk5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlIiwidmFsdWVzIiwiR3AiLCJkZWZpbmVJdGVyYXRvck1ldGhvZHMiLCJBc3luY0l0ZXJhdG9yIiwiUHJvbWlzZUltcGwiLCJpbnZva2UiLCJfX2F3YWl0IiwidW53cmFwcGVkIiwicHJldmlvdXNQcm9taXNlIiwiY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmciLCJyZXN1bHROYW1lIiwibmV4dExvYyIsInB1c2hUcnlFbnRyeSIsImxvY3MiLCJ0cnlMb2MiLCJjYXRjaExvYyIsImZpbmFsbHlMb2MiLCJhZnRlckxvYyIsInRyeUVudHJpZXMiLCJyZXNldFRyeUVudHJ5IiwiY29tcGxldGlvbiIsInJlc2V0IiwiaXRlcmF0b3JNZXRob2QiLCJkaXNwbGF5TmFtZSIsImlzR2VuZXJhdG9yRnVuY3Rpb24iLCJnZW5GdW4iLCJjdG9yIiwibWFyayIsImF3cmFwIiwiYXN5bmMiLCJpdGVyIiwicmV2ZXJzZSIsInNraXBUZW1wUmVzZXQiLCJjaGFyQXQiLCJzdG9wIiwicm9vdFJlY29yZCIsInJ2YWwiLCJleGNlcHRpb24iLCJoYW5kbGUiLCJsb2MiLCJjYXVnaHQiLCJoYXNDYXRjaCIsImhhc0ZpbmFsbHkiLCJmaW5hbGx5RW50cnkiLCJjb21wbGV0ZSIsImZpbmlzaCIsIl9jYXRjaCIsInRocm93biIsImRlbGVnYXRlWWllbGQiLCJfc3VwZXJQcm9wQmFzZSIsIl9hcnJheVdpdGhvdXRIb2xlcyIsIl9pdGVyYWJsZVRvQXJyYXkiLCJfbm9uSXRlcmFibGVTcHJlYWQiLCJiYXNlUGlja0J5IiwiaGFzSW4iLCJiYXNlR2V0IiwiYmFzZVNldCIsInByZWRpY2F0ZSIsInJlSXNEZWVwUHJvcCIsInJlSXNQbGFpblByb3AiLCJtZW1vaXplQ2FwcGVkIiwicmVQcm9wTmFtZSIsInJlRXNjYXBlQ2hhciIsImNoYXJDb2RlQXQiLCJudW1iZXIiLCJxdW90ZSIsInN1YlN0cmluZyIsIm1lbW9pemUiLCJNQVhfTUVNT0laRV9TSVpFIiwiY2FjaGUiLCJGVU5DX0VSUk9SX1RFWFQiLCJyZXNvbHZlciIsIm1lbW9pemVkIiwiQ2FjaGUiLCJiYXNlVG9TdHJpbmciLCJhcnJheU1hcCIsInN5bWJvbFByb3RvIiwic3ltYm9sVG9TdHJpbmciLCJuZXN0ZWQiLCJiYXNlSGFzSW4iLCJoYXNQYXRoIiwiaGFzRnVuYyIsImZsYXR0ZW4iLCJiYXNlRmxhdHRlbiIsImFycmF5UHVzaCIsImlzRmxhdHRlbmFibGUiLCJkZXB0aCIsImlzU3RyaWN0Iiwic3ByZWFkYWJsZVN5bWJvbCIsImlzQ29uY2F0U3ByZWFkYWJsZSIsIl9pc05hdGl2ZUZ1bmN0aW9uIiwiaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0IiwiX2NvbnN0cnVjdCIsIlBhcmVudCIsIl9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QiLCJzaGFtIiwiUHJveHkiLCJCb29sZWFuIiwidmFsdWVPZiIsImEzIiwiYjMiLCJkZXQiLCJ2MCIsInYxIiwicG93IiwiTCIsIlUiLCJCYXJjb2RlRGlyZWN0aW9uIiwiQmFyY29kZVJlYWRlciIsInN1cHBsZW1lbnRzIiwiX3JvdyIsImNvdW50ZXIiLCJjb2RlIiwibWF4U2luZ2xlRXJyb3IiLCJTSU5HTEVfQ09ERV9FUlJPUiIsInNpbmdsZUVycm9yIiwibW9kdWxvIiwiYmFyV2lkdGgiLCJzY2FsZWQiLCJjb3JyZWN0aW9uIiwiaW5kaWNlcyIsImRlY29kZSIsImRpcmVjdGlvbiIsIlJldmVyc2UiLCJGb3J3YXJkIiwiZm9ybWF0IiwiRk9STUFUIiwiX25leHRVbnNldCIsImlzV2hpdGUiLCJjb3VudGVycyIsImNvdW50ZXJQb3MiLCJudW1Db3VudGVycyIsIlN0YXJ0Tm90Rm91bmRFeGNlcHRpb24iLCJDb2RlTm90Rm91bmRFeGNlcHRpb24iLCJQYXR0ZXJuTm90Rm91bmRFeGNlcHRpb24iLCJOIiwiVyIsIlNUQVJUX1BBVFRFUk4iLCJTVE9QX1BBVFRFUk4iLCJDT0RFX1BBVFRFUk4iLCJTVEFSVF9QQVRURVJOX0xFTkdUSCIsIlR3b09mRml2ZVJlYWRlciIsInRyeUhhcmRlciIsImJlc3RNYXRjaCIsImVwc2lsb24iLCJBVkdfQ09ERV9FUlJPUiIsIl9uZXh0U2V0IiwiX21hdGNoUGF0dGVybiIsInN0YXJ0SW5mbyIsIm5hcnJvd0JhcldpZHRoIiwibGVhZGluZ1doaXRlc3BhY2VTdGFydCIsIl9maW5kUGF0dGVybiIsIl9tYXRjaFJhbmdlIiwiZW5kSW5mbyIsInRyYWlsaW5nV2hpdGVzcGFjZUVuZCIsIl92ZXJpZnlUcmFpbGluZ1doaXRlc3BhY2UiLCJkZWNvZGVkQ29kZXMiLCJjb3VudGVyTGVuZ3RoIiwiYmFyU3BhY2VSYXRpbyIsIl9kZWNvZGVDb2RlIiwiX2ZpbmRTdGFydCIsIl9maW5kRW5kIiwiX2ZpbGxDb3VudGVycyIsIl92ZXJpZnlDb3VudGVyTGVuZ3RoIiwiX2RlY29kZVBheWxvYWQiLCJBTFBIQUJFVCIsIkNIQVJBQ1RFUl9FTkNPRElOR1MiLCJTVEFSVF9FTkQiLCJNSU5fRU5DT0RFRF9DSEFSUyIsIk1BWF9BQ0NFUFRBQkxFIiwiUEFERElORyIsIk5ld0NvZGFiYXJSZWFkZXIiLCJfY291bnRlcnMiLCJiYXJUaHJlc2hvbGQiLCJfY29tcHV0ZUFsdGVybmF0aW5nVGhyZXNob2xkIiwic3BhY2VUaHJlc2hvbGQiLCJiaXRtYXNrIiwiX3RvUGF0dGVybiIsIl9pc1N0YXJ0RW5kIiwiX3N1bUNvdW50ZXJzIiwic3RhcnRDb3VudGVyIiwiZW5kQ291bnRlciIsImZyb21DaGFyQ29kZSIsIl9jYWxjdWxhdGVQYXR0ZXJuTGVuZ3RoIiwiY2hhciIsImNoYXJDb2RlIiwiY2F0ZWdvcml6YXRpb24iLCJzcGFjZSIsIm5hcnJvdyIsImNvdW50cyIsIndpZGUiLCJiYXIiLCJfY2hhclRvUGF0dGVybiIsImtpbmQiLCJjYXQiLCJuZXdraW5kIiwidGhyZXNob2xkcyIsIl90aHJlc2hvbGRSZXN1bHRQYXR0ZXJuIiwibmV4dFN0YXJ0IiwiZGVjb2RlZENoYXIiLCJfcGF0dGVyblRvQ2hhciIsIl92ZXJpZnlXaGl0ZXNwYWNlIiwiX3ZhbGlkYXRlUmVzdWx0IiwiQ29kZTEyOFJlYWRlciIsIl9jb3JyZWN0IiwiY2FsY3VsYXRlQ29ycmVjdGlvbiIsIk1PRFVMRV9JTkRJQ0VTIiwiX2NvcnJlY3RCYXJzIiwiU1RBUlRfQ09ERV9BIiwiU1RBUlRfQ09ERV9DIiwiY2hlY2tzdW0iLCJjb2Rlc2V0IiwiQ09ERV9BIiwiU1RBUlRfQ09ERV9CIiwiQ09ERV9CIiwiQ09ERV9DIiwic2hpZnROZXh0IiwicmVtb3ZlTGFzdENoYXJhY3RlciIsIm11bHRpcGxpZXIiLCJyYXdSZXN1bHQiLCJTVE9QX0NPREUiLCJDT0RFX1NISUZUIiwiZXhwZWN0ZWQiLCJub3JtYWxpemVkIiwic3VtTm9ybWFsaXplZCIsInN1bUV4cGVjdGVkIiwiQUxQSEFCRVRIX1NUUklORyIsIlVpbnQxNkFycmF5IiwiQVNURVJJU0siLCJDb2RlMzlSZWFkZXIiLCJwYXR0ZXJuU3RhcnQiLCJ3aGl0ZVNwYWNlTXVzdFN0YXJ0IiwibWF4TmFycm93V2lkdGgiLCJudW1XaWRlQmFycyIsIndpZGVCYXJXaWR0aCIsIl9maW5kTmV4dFdpZHRoIiwibWluV2lkdGgiLCJsYXN0U3RhcnQiLCJwYXR0ZXJuU2l6ZSIsIl90b0NvdW50ZXJzIiwicGF0dGVybnMiLCJBRUlPIiwiQVowOSIsImNvZGUzMnNldCIsIkNvZGUzMlJlYWRlciIsInJlcyIsImNvZGUzMiIsIl9jaGVja0NoZWNrc3VtIiwiX2RlY29kZUNvZGUzMiIsIklPUSIsIkNvZGUzOVZJTlJlYWRlciIsIkNvZGU5M1JlYWRlciIsImNoYXJBcnJheSIsIm5leHRDaGFyIiwibmV4dENoYXJDb2RlIiwid2FybiIsIm1heFdlaWdodCIsImFycmF5VG9DaGVjayIsIndlaWdodGVkU3VtcyIsIndlaWdodCIsImNoZWNrQ2hhciIsIl9tYXRjaENoZWNrQ2hhciIsIl92ZXJpZnlFbmQiLCJfdmVyaWZ5Q2hlY2tzdW1zIiwiX2RlY29kZUV4dGVuZGVkIiwiQ09ERV9HX1NUQVJUIiwiTUlERExFX1BBVFRFUk4iLCJFWFRFTlNJT05fU1RBUlRfUEFUVEVSTiIsIkNPREVfRlJFUVVFTkNZIiwiRUFOUmVhZGVyIiwiY29kZXJhbmdlIiwiY29kZUZyZXF1ZW5jeSIsImluQ29kZSIsIm91dENvZGUiLCJmaXJzdERpZ2l0IiwiX2NhbGN1bGF0ZUZpcnN0RGlnaXQiLCJtaWRkbGVQYXR0ZXJuIiwicmVzdWx0SW5mbyIsIl9jaGVja3N1bSIsInN1cHBsZW1lbnQiLCJfZGVjb2RlRXh0ZW5zaW9ucyIsImxhc3RDb2RlIiwiRUFOMlJlYWRlciIsInBhcnNlSW50IiwiQ0hFQ0tfRElHSVRfRU5DT0RJTkdTIiwiZGV0ZXJtaW5lQ2hlY2tEaWdpdCIsImV4dGVuc2lvbkNoZWNrc3VtIiwiRUFONVJlYWRlciIsIkVBTjhSZWFkZXIiLCJJMm9mNVJlYWRlciIsIm9wdHMiLCJub3JtYWxpemVCYXJTcGFjZVdpZHRoIiwiY291bnRlclN1bSIsImNvZGVTdW0iLCJjb3JyZWN0aW9uUmF0aW8iLCJNQVhfQ09SUkVDVElPTl9GQUNUT1IiLCJjb3JyZWN0aW9uUmF0aW9JbnZlcnNlIiwiY291bnRlclBhaXIiLCJjb2RlcyIsIl9kZWNvZGVQYWlyIiwiVVBDRVJlYWRlciIsIl9kZXRlcm1pbmVQYXJpdHkiLCJuclN5c3RlbSIsInVwY2EiLCJsYXN0RGlnaXQiLCJfY29udmVydFRvVVBDQSIsIlVQQ1JlYWRlciIsInN1YnN0cmluZyIsIkJyZXNlbmhhbSIsIlNsb3BlIiwiVVAiLCJET1dOIiwiZ2V0QmFyY29kZUxpbmUiLCJ4MCIsInkwIiwieDEiLCJ5MSIsInN0ZWVwIiwicmVhZCIsImRlbHRhWCIsImRlbHRhWSIsInlTdGVwIiwidG9CaW5hcnlMaW5lIiwic2xvcGUiLCJzbG9wZTIiLCJleHRyZW1hIiwiY3VycmVudERpciIsInJUaHJlc2hvbGQiLCJwcmludEZyZXF1ZW5jeSIsInByaW50UGF0dGVybiIsImZpbGxDb2xvciIsImZpbGxSZWN0IiwiUkVBREVSUyIsImNvZGVfMTI4X3JlYWRlciIsImVhbl9yZWFkZXIiLCJlYW5fNV9yZWFkZXIiLCJlYW5fMl9yZWFkZXIiLCJlYW5fOF9yZWFkZXIiLCJjb2RlXzM5X3JlYWRlciIsImNvZGVfMzlfdmluX3JlYWRlciIsImNvZGFiYXJfcmVhZGVyIiwiQ29kYWJhclJlYWRlciIsInVwY19yZWFkZXIiLCJ1cGNfZV9yZWFkZXIiLCJpMm9mNV9yZWFkZXIiLCJjb2RlXzkzX3JlYWRlciIsImNvZGVfMzJfcmVhZGVyIiwicmVnaXN0ZXJSZWFkZXIiLCJyZWFkZXIiLCJfY2FudmFzIiwiZnJlcXVlbmN5IiwiX2JhcmNvZGVSZWFkZXJzIiwiaW5pdFJlYWRlcnMiLCJpbml0Q29uZmlnIiwiJGRlYnVnIiwicmVhZGVycyIsInJlYWRlckNvbmZpZyIsImNvbmZpZ3VyYXRpb24iLCJyZWFkZXJPYmoiLCJ2aXMiLCJub2RlIiwicHJvcCIsInNob3dGcmVxdWVuY3kiLCJzaG93UGF0dGVybiIsImRpc3BsYXkiLCJnZXRFeHRlbmRlZExpbmUiLCJleHQiLCJleHRlbmRMaW5lIiwiYW1vdW50IiwiZXh0ZW5zaW9uIiwiaW5JbWFnZVdpdGhCb3JkZXIiLCJnZXRMaW5lIiwidHJ5RGVjb2RlIiwiYmFyY29kZUxpbmUiLCJkZWNvZGVQYXR0ZXJuIiwiY29kZVJlc3VsdCIsInRyeURlY29kZUJydXRlRm9yY2UiLCJsaW5lQW5nbGUiLCJzaWRlTGVuZ3RoIiwic2xpY2VzIiwieGRpciIsInlkaXIiLCJnZXRMaW5lTGVuZ3RoIiwiZGVjb2RlRnJvbUltYWdlIiwiZGVjb2RlSW1hZ2UiLCJkZWNvZGVGcm9tQm91bmRpbmdCb3giLCJkcmF3Qm91bmRpbmdCb3giLCJsaW5lTGVuZ3RoIiwiYXRhbjIiLCJkcmF3U2NhbmxpbmUiLCJkZWNvZGVGcm9tQm91bmRpbmdCb3hlcyIsImJhcmNvZGVzIiwibXVsdGlwbGUiLCJpbWFnZVdyYXBwZXJJbiIsInNldFJlYWRlcnMiLCJFdmVudEludGVyZmFjZSIsImV2ZW50cyIsImdldEV2ZW50IiwiZXZlbnROYW1lIiwic3Vic2NyaWJlcnMiLCJjbGVhckV2ZW50cyIsInB1Ymxpc2hTdWJzY3JpcHRpb24iLCJzdWJzY3JpcHRpb24iLCJfc3Vic2NyaWJlIiwiZXZlbnQiLCJzdWJzY3JpYmUiLCJwdWJsaXNoIiwic3Vic2NyaWJlciIsIm9uY2UiLCJ1bnN1YnNjcmliZSIsIkV4Y2VwdGlvbiIsIkVSUk9SX0RFU0MiLCJlbnVtZXJhdGVEZXZpY2VzIiwibmF2aWdhdG9yIiwibWVkaWFEZXZpY2VzIiwiZ2V0VXNlck1lZGlhIiwiY29uc3RyYWludHMiLCJzdHJlYW1SZWYiLCJ3YWl0Rm9yVmlkZW8iLCJ2aWRlbyIsImF0dGVtcHRzIiwiY2hlY2tWaWRlbyIsInZpZGVvV2lkdGgiLCJ2aWRlb0hlaWdodCIsImluaXRDYW1lcmEiLCJzdHJlYW0iLCJzZXRBdHRyaWJ1dGUiLCJzcmNPYmplY3QiLCJhZGRFdmVudExpc3RlbmVyIiwicGxheSIsImRlcHJlY2F0ZWRDb25zdHJhaW50cyIsInZpZGVvQ29uc3RyYWludHMiLCJtaW5Bc3BlY3RSYXRpbyIsImFzcGVjdFJhdGlvIiwiZmFjaW5nIiwiZmFjaW5nTW9kZSIsInBpY2tDb25zdHJhaW50cyIsImRldmljZUlkIiwiYXVkaW8iLCJlbnVtZXJhdGVWaWRlb0RldmljZXMiLCJkZXZpY2VzIiwiZGV2aWNlIiwiZ2V0QWN0aXZlVHJhY2siLCJ0cmFja3MiLCJnZXRWaWRlb1RyYWNrcyIsIlF1YWdnYUpTQ2FtZXJhQWNjZXNzIiwicmVxdWVzdGVkVmlkZW9FbGVtZW50IiwicmVxdWVzdCIsIm5ld0NvbnN0cmFpbnRzIiwicmVsZWFzZSIsInBhdXNlIiwidHJhY2siLCJnZXRBY3RpdmVTdHJlYW1MYWJlbCIsImRpc2FibGVUb3JjaCIsImFwcGx5Q29uc3RyYWludHMiLCJ0b3JjaCIsImVuYWJsZVRvcmNoIiwiY29udGFpbnMiLCJzb21lIiwiZXZlcnkiLCJwYXNzZXNGaWx0ZXIiLCJyZXN1bHRzIiwiY2FwYWNpdHkiLCJjYXB0dXJlIiwibWF0Y2hlc0NvbnN0cmFpbnRzIiwiYmxhY2tsaXN0IiwiYWRkUmVzdWx0IiwiaW1hZ2VTaXplIiwidG9EYXRhVVJMIiwiZ2V0UmVzdWx0cyIsIkRldkNvbmZpZyIsIm51bU9mV29ya2VycyIsImRlY29kZXIiLCJsb2NhdG9yIiwiTm9kZUNvbmZpZyIsInNlcXVlbmNlIiwiUHJvZENvbmZpZyIsIkV4cG9ydENvbmZpZyIsIlF1YWdnYUNvbmZpZyIsIlRPX1JBRElBTlMiLCJhZGp1c3RDYW52YXNTaXplIiwidGFyZ2V0U2l6ZSIsIkZyYW1lR3JhYmJlciIsIl90aGF0IiwiX3N0cmVhbUNvbmZpZyIsIl92aWRlb1NpemUiLCJnZXRSZWFsV2lkdGgiLCJnZXRSZWFsSGVpZ2h0IiwiX2NhbnZhc1NpemUiLCJnZXRDYW52YXNTaXplIiwiX3NpemUiLCJ0b3BSaWdodCIsImdldFRvcFJpZ2h0IiwiX3N4IiwiX3N5IiwiX2N0eCIsIl9kYXRhIiwidmlkZW9TaXplIiwiY2FudmFzU2l6ZSIsImF0dGFjaERhdGEiLCJnZXREYXRhIiwiZ3JhYiIsImRvSGFsZlNhbXBsZSIsImdldEZyYW1lIiwiZHJhd2FibGUiLCJkcmF3QW5nbGUiLCJ0YWdzIiwib3JpZW50YXRpb24iLCJ0cmFuc2xhdGUiLCJnZXRTaXplIiwiRXhpZlRhZ3MiLCJBdmFpbGFibGVUYWdzIiwiZmluZFRhZ3NJbk9iamVjdFVSTCIsIm9iamVjdFVSTFRvQmxvYiIsInJlYWRUb0J1ZmZlciIsImZpbmRUYWdzSW5CdWZmZXIiLCJiYXNlNjRUb0FycmF5QnVmZmVyIiwiZGF0YVVybCIsImJhc2U2NCIsImF0b2IiLCJ2aWV3IiwiYmxvYiIsImZpbGVSZWFkZXIiLCJGaWxlUmVhZGVyIiwicmVhZEFzQXJyYXlCdWZmZXIiLCJ1cmwiLCJodHRwIiwiWE1MSHR0cFJlcXVlc3QiLCJvcGVuIiwicmVzcG9uc2VUeXBlIiwib25yZWFkeXN0YXRlY2hhbmdlIiwicmVhZHlTdGF0ZSIsIkRPTkUiLCJzdGF0dXMiLCJyZXNwb25zZSIsIm9uZXJyb3IiLCJzZW5kIiwiZmlsZSIsInNlbGVjdGVkVGFncyIsImRhdGFWaWV3IiwiRGF0YVZpZXciLCJleGlmVGFncyIsInNlbGVjdGVkVGFnIiwiZXhpZlRhZyIsIm1hcmtlciIsImdldFVpbnQ4IiwicmVhZEVYSUZEYXRhIiwiZ2V0VWludDE2IiwiZ2V0U3RyaW5nRnJvbUJ1ZmZlciIsInRpZmZPZmZzZXQiLCJiaWdFbmQiLCJmaXJzdElGRE9mZnNldCIsImdldFVpbnQzMiIsInJlYWRUYWdzIiwidGlmZlN0YXJ0IiwiZGlyU3RhcnQiLCJzdHJpbmdzIiwiZW50cnlPZmZzZXQiLCJyZWFkVGFnVmFsdWUiLCJudW1WYWx1ZXMiLCJvdXRzdHIiLCJJbWFnZUxvYWRlciIsImxvYWQiLCJkaXJlY3RvcnkiLCJodG1sSW1hZ2VzU3JjQXJyYXkiLCJodG1sSW1hZ2VzQXJyYXkiLCJudW0iLCJub3RMb2FkZWQiLCJhZGRJbWFnZSIsImltYWdlIiwibG9hZGVkIiwibG9hZGVkSW1nIiwibm90bG9hZGVkSW1ncyIsImltZ05hbWUiLCJzdWJzdHIiLCJsYXN0SW5kZXhPZiIsImFkZE9ubG9hZEhhbmRsZXIiLCJpbnB1dFN0cmVhbUZhY3RvcnkiLCJjcmVhdGVWaWRlb1N0cmVhbSIsIl9ldmVudE5hbWVzIiwiX2V2ZW50SGFuZGxlcnMiLCJfY2FsY3VsYXRlZFdpZHRoIiwiX2NhbGN1bGF0ZWRIZWlnaHQiLCJfdG9wUmlnaHQiLCJpbml0U2l6ZSIsInNldElucHV0U3RyZWFtIiwiZW5kZWQiLCJzZXRDdXJyZW50VGltZSIsInRpbWUiLCJmIiwiYm9vbCIsImNsZWFyRXZlbnRIYW5kbGVycyIsImhhbmRsZXJzIiwiaGFuZGxlciIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJ0cmlnZ2VyIiwiY3JlYXRlTGl2ZVN0cmVhbSIsImNyZWF0ZUltYWdlU3RyZWFtIiwiZnJhbWVJZHgiLCJwYXVzZWQiLCJpbWdBcnJheSIsImJhc2VVcmwiLCJjYWxjdWxhdGVkV2lkdGgiLCJjYWxjdWxhdGVkSGVpZ2h0IiwibG9hZEltYWdlcyIsImltZ3MiLCJwdWJsaXNoRXZlbnQiLCJuZXdXaWR0aCIsIm5ld0hlaWdodCIsImluZCIsIlF1YWdnYUNvbnRleHQiLCJDYW52YXNDb250YWluZXIiLCJDYW52YXNJbmZvIiwiZ2V0Vmlld1BvcnQiLCJIVE1MRWxlbWVudCIsIm5vZGVOYW1lIiwic2VsZWN0b3IiLCJib3hTaXplIiwiQmFyY29kZUxvY2F0b3IiLCJmaW5kT3JDcmVhdGVDYW52YXMiLCJnZXRDYW52YXNBbmRDb250ZXh0IiwiaW5pdENhbnZhc2VzIiwidmlld3BvcnQiLCJjb250YWluZXIiLCJ3b3JrZXJQb29sIiwidXBkYXRlV29ya2VycyIsImZyYW1lR3JhYmJlciIsImF2YWlsYWJsZVdvcmtlciIsIndvcmtlclRocmVhZCIsImJ1c3kiLCJ3b3JrZXIiLCJwb3N0TWVzc2FnZSIsImNtZCIsImNvbmZpZ0ZvcldvcmtlciIsIndvcmtlckludGVyZmFjZSIsImZhY3RvcnkiLCJRdWFnZ2EiLCJtZXNzYWdlIiwib25Qcm9jZXNzZWQiLCJ3b3JrZXJJbnRlcmZhY2VSZWFkeSIsIm9ubWVzc2FnZSIsImdlbmVyYXRlV29ya2VyQmxvYiIsImZhY3RvcnlTb3VyY2UiLCJfX2ZhY3RvcnlTb3VyY2VfXyIsIkJsb2IiLCJVUkwiLCJjcmVhdGVPYmplY3RVUkwiLCJpbml0V29ya2VyIiwiY2IiLCJibG9iVVJMIiwiV29ya2VyIiwicmV2b2tlT2JqZWN0VVJMIiwiYWRqdXN0V29ya2VyUG9vbCIsImluY3JlYXNlQnkiLCJ3b3JrZXJzVG9UZXJtaW5hdGUiLCJ0ZXJtaW5hdGUiLCJ3b3JrZXJJbml0aWFsaXplZCIsInNldHVwSW5wdXRTdHJlYW0iLCJtb3ZlQm94IiwieE9mZnNldCIsInlPZmZzZXQiLCJjb3JuZXIiLCJtb3ZlTGluZSIsImZyYW1lZ3JhYmJlciIsImNhbnZhc0NvbnRhaW5lciIsIlFXb3JrZXJzIiwiaW5pdGlhbGl6ZURhdGEiLCJyZWFkeSIsIm9uVUlUaHJlYWQiLCJ3b3JrZXJzVXBkYXRlZCIsImxvY2F0ZUFuZERlY29kZSIsIl9pbml0QnVmZmVycyIsIkJhcmNvZGVEZWNvZGVyIiwiX2dldFZpZXdQb3J0IiwiX2luaXRDYW52YXMiLCJpbnB1dFR5cGUiLCJJbnB1dFN0cmVhbSIsIkNhbWVyYUFjY2VzcyIsImNhblJlY29yZCIsImJhcmNvZGUiLCJ0cmFuc2Zvcm1SZXN1bHQiLCJyZXN1bHRDb2xsZWN0b3IiLCJyZXN1bHRUb1B1Ymxpc2giLCJFdmVudHMiLCJoYXNDb2RlUmVzdWx0IiwiZ2V0Qm91bmRpbmdCb3hlcyIsImRlY29kZVJlc3VsdCIsInB1Ymxpc2hSZXN1bHQiLCJpbWFnZVJlc3VsdCIsImRlbGF5Iiwic3RvcHBlZCIsInRpbWVzdGFtcCIsInVwZGF0ZSIsInBlcmZvcm1hbmNlIiwic3RhcnRDb250aW51b3VzVXBkYXRlIiwiX2NvbnRleHQiLCJRdWFnZ2FKU1N0YXRpY0ludGVyZmFjZSIsInF1YWdnYUluc3RhbmNlIiwicHJvbWlzZSIsIkNvbmZpZyIsImluaXRJbnB1dFN0cmVhbSIsIm9uRGV0ZWN0ZWQiLCJvZmZEZXRlY3RlZCIsIm9mZlByb2Nlc3NlZCIsInJlZ2lzdGVyUmVzdWx0Q29sbGVjdG9yIiwiZGVjb2RlU2luZ2xlIiwicmVzdWx0Q2FsbGJhY2siLCJkZWZhdWx0IiwiUmVhZGVycyIsIlJlc3VsdENvbGxlY3RvciJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELE87UUNWQTtRQUNBOztRQUVBO1FBQ0E7O1FBRUE7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7O1FBRUE7UUFDQTs7UUFFQTtRQUNBOztRQUVBO1FBQ0E7UUFDQTs7O1FBR0E7UUFDQTs7UUFFQTtRQUNBOztRQUVBO1FBQ0E7UUFDQTtRQUNBLDBDQUEwQyxnQ0FBZ0M7UUFDMUU7UUFDQTs7UUFFQTtRQUNBO1FBQ0E7UUFDQSx3REFBd0Qsa0JBQWtCO1FBQzFFO1FBQ0EsaURBQWlELGNBQWM7UUFDL0Q7O1FBRUE7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBLHlDQUF5QyxpQ0FBaUM7UUFDMUUsZ0hBQWdILG1CQUFtQixFQUFFO1FBQ3JJO1FBQ0E7O1FBRUE7UUFDQTtRQUNBO1FBQ0EsMkJBQTJCLDBCQUEwQixFQUFFO1FBQ3ZELGlDQUFpQyxlQUFlO1FBQ2hEO1FBQ0E7UUFDQTs7UUFFQTtRQUNBLHNEQUFzRCwrREFB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V0UsT0FBT3h0QyxHQUFQLEVBQVk7UUFDVmIsTUFBTSxDQUFDYSxHQUFELENBQU47TUFDSDtJQUNKLENBZk0sQ0FBUDtFQWdCSCxDQXhIMkI7O0VBeUg1QjtFQUNBO0VBQ0EsSUFBSWt1QyxPQUFKLEdBQWM7SUFDVixPQUFPWCx1QkFBUDtFQUNILENBN0gyQjs7RUE4SDVCWSxPQUFPLEVBQVBBLHNCQTlINEI7RUErSDVCL0IsWUFBWSxFQUFaQSxhQS9INEI7RUFnSTVCNW1DLFVBQVUsRUFBVkEsOEJBaEk0QjtFQWlJNUJsSixZQUFZLEVBQVpBLGdDQWpJNEI7RUFrSTVCOHhDLGVBQWUsRUFBZkEsZ0JBQWVBO0FBbElhLENBQWhDO0FBcUllYixtR0FBZixFLENBQ0EiLCJmaWxlIjoicXVhZ2dhLmpzIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIHdlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKVxuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xuXHRlbHNlIGlmKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZClcblx0XHRkZWZpbmUoW10sIGZhY3RvcnkpO1xuXHRlbHNlIGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jylcblx0XHRleHBvcnRzW1wiUXVhZ2dhXCJdID0gZmFjdG9yeSgpO1xuXHRlbHNlXG5cdFx0cm9vdFtcIlF1YWdnYVwiXSA9IGZhY3RvcnkoKTtcbn0pKHdpbmRvdywgZnVuY3Rpb24oKSB7XG5yZXR1cm4gIiwiIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcblxuIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbiBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblxuIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbiBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pIHtcbiBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcbiBcdFx0fVxuIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4gXHRcdFx0aTogbW9kdWxlSWQsXG4gXHRcdFx0bDogZmFsc2UsXG4gXHRcdFx0ZXhwb3J0czoge31cbiBcdFx0fTtcblxuIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbiBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cbiBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuIFx0XHRtb2R1bGUubCA9IHRydWU7XG5cbiBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbiBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuIFx0fVxuXG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcblxuIFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbiBmb3IgaGFybW9ueSBleHBvcnRzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSBmdW5jdGlvbihleHBvcnRzLCBuYW1lLCBnZXR0ZXIpIHtcbiBcdFx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBuYW1lKSkge1xuIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBuYW1lLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZ2V0dGVyIH0pO1xuIFx0XHR9XG4gXHR9O1xuXG4gXHQvLyBkZWZpbmUgX19lc01vZHVsZSBvbiBleHBvcnRzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIgPSBmdW5jdGlvbihleHBvcnRzKSB7XG4gXHRcdGlmKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1N0cmluZ1RhZykge1xuIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuIFx0XHR9XG4gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4gXHR9O1xuXG4gXHQvLyBjcmVhdGUgYSBmYWtlIG5hbWVzcGFjZSBvYmplY3RcbiBcdC8vIG1vZGUgJiAxOiB2YWx1ZSBpcyBhIG1vZHVsZSBpZCwgcmVxdWlyZSBpdFxuIFx0Ly8gbW9kZSAmIDI6IG1lcmdlIGFsbCBwcm9wZXJ0aWVzIG9mIHZhbHVlIGludG8gdGhlIG5zXG4gXHQvLyBtb2RlICYgNDogcmV0dXJuIHZhbHVlIHdoZW4gYWxyZWFkeSBucyBvYmplY3RcbiBcdC8vIG1vZGUgJiA4fDE6IGJlaGF2ZSBsaWtlIHJlcXVpcmVcbiBcdF9fd2VicGFja19yZXF1aXJlX18udCA9IGZ1bmN0aW9uKHZhbHVlLCBtb2RlKSB7XG4gXHRcdGlmKG1vZGUgJiAxKSB2YWx1ZSA9IF9fd2VicGFja19yZXF1aXJlX18odmFsdWUpO1xuIFx0XHRpZihtb2RlICYgOCkgcmV0dXJuIHZhbHVlO1xuIFx0XHRpZigobW9kZSAmIDQpICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgJiYgdmFsdWUuX19lc01vZHVsZSkgcmV0dXJuIHZhbHVlO1xuIFx0XHR2YXIgbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIobnMpO1xuIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobnMsICdkZWZhdWx0JywgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdmFsdWUgfSk7XG4gXHRcdGlmKG1vZGUgJiAyICYmIHR5cGVvZiB2YWx1ZSAhPSAnc3RyaW5nJykgZm9yKHZhciBrZXkgaW4gdmFsdWUpIF9fd2VicGFja19yZXF1aXJlX18uZChucywga2V5LCBmdW5jdGlvbihrZXkpIHsgcmV0dXJuIHZhbHVlW2tleV07IH0uYmluZChudWxsLCBrZXkpKTtcbiBcdFx0cmV0dXJuIG5zO1xuIFx0fTtcblxuIFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuIFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbiBcdFx0XHRmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuIFx0XHRcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcbiBcdFx0cmV0dXJuIGdldHRlcjtcbiBcdH07XG5cbiBcdC8vIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbFxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xuXG4gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCIvXCI7XG5cblxuIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSA4OSk7XG4iLCJmdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7XG4gIGlmIChrZXkgaW4gb2JqKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgd3JpdGFibGU6IHRydWVcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBvYmpba2V5XSA9IHZhbHVlO1xuICB9XG5cbiAgcmV0dXJuIG9iajtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfZGVmaW5lUHJvcGVydHksIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlLCBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0czsiLCJmdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHtcbiAgaWYgKHNlbGYgPT09IHZvaWQgMCkge1xuICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtcbiAgfVxuXG4gIHJldHVybiBzZWxmO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlLCBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0czsiLCJmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xuICBtb2R1bGUuZXhwb3J0cyA9IF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZi5iaW5kKCkgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xuICAgIHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7XG4gIH0sIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlLCBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0cztcbiAgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfZ2V0UHJvdG90eXBlT2YsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlLCBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0czsiLCJmdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7XG4gIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9jbGFzc0NhbGxDaGVjaywgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzOyIsImZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07XG4gICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlO1xuICAgIGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTtcbiAgICBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7XG4gIGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpO1xuICBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb25zdHJ1Y3RvciwgXCJwcm90b3R5cGVcIiwge1xuICAgIHdyaXRhYmxlOiBmYWxzZVxuICB9KTtcbiAgcmV0dXJuIENvbnN0cnVjdG9yO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9jcmVhdGVDbGFzcywgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzOyIsInZhciBfdHlwZW9mID0gcmVxdWlyZShcIi4vdHlwZW9mLmpzXCIpW1wiZGVmYXVsdFwiXTtcblxudmFyIGFzc2VydFRoaXNJbml0aWFsaXplZCA9IHJlcXVpcmUoXCIuL2Fzc2VydFRoaXNJbml0aWFsaXplZC5qc1wiKTtcblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkge1xuICBpZiAoY2FsbCAmJiAoX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkge1xuICAgIHJldHVybiBjYWxsO1xuICB9IGVsc2UgaWYgKGNhbGwgIT09IHZvaWQgMCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJEZXJpdmVkIGNvbnN0cnVjdG9ycyBtYXkgb25seSByZXR1cm4gb2JqZWN0IG9yIHVuZGVmaW5lZFwiKTtcbiAgfVxuXG4gIHJldHVybiBhc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4sIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlLCBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0czsiLCJ2YXIgc2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKFwiLi9zZXRQcm90b3R5cGVPZi5qc1wiKTtcblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7XG4gIGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7XG4gIH1cblxuICBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHtcbiAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgdmFsdWU6IHN1YkNsYXNzLFxuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9XG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoc3ViQ2xhc3MsIFwicHJvdG90eXBlXCIsIHtcbiAgICB3cml0YWJsZTogZmFsc2VcbiAgfSk7XG4gIGlmIChzdXBlckNsYXNzKSBzZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2luaGVyaXRzLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZSwgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHM7IiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gIEVQU0lMT046IHJlcXVpcmUoJy4vZXBzaWxvbicpXG4gICwgY3JlYXRlOiByZXF1aXJlKCcuL2NyZWF0ZScpXG4gICwgY2xvbmU6IHJlcXVpcmUoJy4vY2xvbmUnKVxuICAsIGZyb21WYWx1ZXM6IHJlcXVpcmUoJy4vZnJvbVZhbHVlcycpXG4gICwgY29weTogcmVxdWlyZSgnLi9jb3B5JylcbiAgLCBzZXQ6IHJlcXVpcmUoJy4vc2V0JylcbiAgLCBlcXVhbHM6IHJlcXVpcmUoJy4vZXF1YWxzJylcbiAgLCBleGFjdEVxdWFsczogcmVxdWlyZSgnLi9leGFjdEVxdWFscycpXG4gICwgYWRkOiByZXF1aXJlKCcuL2FkZCcpXG4gICwgc3VidHJhY3Q6IHJlcXVpcmUoJy4vc3VidHJhY3QnKVxuICAsIHN1YjogcmVxdWlyZSgnLi9zdWInKVxuICAsIG11bHRpcGx5OiByZXF1aXJlKCcuL211bHRpcGx5JylcbiAgLCBtdWw6IHJlcXVpcmUoJy4vbXVsJylcbiAgLCBkaXZpZGU6IHJlcXVpcmUoJy4vZGl2aWRlJylcbiAgLCBkaXY6IHJlcXVpcmUoJy4vZGl2JylcbiAgLCBpbnZlcnNlOiByZXF1aXJlKCcuL2ludmVyc2UnKVxuICAsIG1pbjogcmVxdWlyZSgnLi9taW4nKVxuICAsIG1heDogcmVxdWlyZSgnLi9tYXgnKVxuICAsIHJvdGF0ZTogcmVxdWlyZSgnLi9yb3RhdGUnKVxuICAsIGZsb29yOiByZXF1aXJlKCcuL2Zsb29yJylcbiAgLCBjZWlsOiByZXF1aXJlKCcuL2NlaWwnKVxuICAsIHJvdW5kOiByZXF1aXJlKCcuL3JvdW5kJylcbiAgLCBzY2FsZTogcmVxdWlyZSgnLi9zY2FsZScpXG4gICwgc2NhbGVBbmRBZGQ6IHJlcXVpcmUoJy4vc2NhbGVBbmRBZGQnKVxuICAsIGRpc3RhbmNlOiByZXF1aXJlKCcuL2Rpc3RhbmNlJylcbiAgLCBkaXN0OiByZXF1aXJlKCcuL2Rpc3QnKVxuICAsIHNxdWFyZWREaXN0YW5jZTogcmVxdWlyZSgnLi9zcXVhcmVkRGlzdGFuY2UnKVxuICAsIHNxckRpc3Q6IHJlcXVpcmUoJy4vc3FyRGlzdCcpXG4gICwgbGVuZ3RoOiByZXF1aXJlKCcuL2xlbmd0aCcpXG4gICwgbGVuOiByZXF1aXJlKCcuL2xlbicpXG4gICwgc3F1YXJlZExlbmd0aDogcmVxdWlyZSgnLi9zcXVhcmVkTGVuZ3RoJylcbiAgLCBzcXJMZW46IHJlcXVpcmUoJy4vc3FyTGVuJylcbiAgLCBuZWdhdGU6IHJlcXVpcmUoJy4vbmVnYXRlJylcbiAgLCBub3JtYWxpemU6IHJlcXVpcmUoJy4vbm9ybWFsaXplJylcbiAgLCBkb3Q6IHJlcXVpcmUoJy4vZG90JylcbiAgLCBjcm9zczogcmVxdWlyZSgnLi9jcm9zcycpXG4gICwgbGVycDogcmVxdWlyZSgnLi9sZXJwJylcbiAgLCByYW5kb206IHJlcXVpcmUoJy4vcmFuZG9tJylcbiAgLCB0cmFuc2Zvcm1NYXQyOiByZXF1aXJlKCcuL3RyYW5zZm9ybU1hdDInKVxuICAsIHRyYW5zZm9ybU1hdDJkOiByZXF1aXJlKCcuL3RyYW5zZm9ybU1hdDJkJylcbiAgLCB0cmFuc2Zvcm1NYXQzOiByZXF1aXJlKCcuL3RyYW5zZm9ybU1hdDMnKVxuICAsIHRyYW5zZm9ybU1hdDQ6IHJlcXVpcmUoJy4vdHJhbnNmb3JtTWF0NCcpXG4gICwgZm9yRWFjaDogcmVxdWlyZSgnLi9mb3JFYWNoJylcbiAgLCBsaW1pdDogcmVxdWlyZSgnLi9saW1pdCcpXG59XG4iLCIvLyBUT0RPKEJhYmVsIDgpOiBSZW1vdmUgdGhpcyBmaWxlLlxuXG52YXIgcnVudGltZSA9IHJlcXVpcmUoXCIuLi9oZWxwZXJzL3JlZ2VuZXJhdG9yUnVudGltZVwiKSgpO1xubW9kdWxlLmV4cG9ydHMgPSBydW50aW1lO1xuXG4vLyBDb3BpZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVnZW5lcmF0b3IvYmxvYi9tYWluL3BhY2thZ2VzL3J1bnRpbWUvcnVudGltZS5qcyNMNzM2PVxudHJ5IHtcbiAgcmVnZW5lcmF0b3JSdW50aW1lID0gcnVudGltZTtcbn0gY2F0Y2ggKGFjY2lkZW50YWxTdHJpY3RNb2RlKSB7XG4gIGlmICh0eXBlb2YgZ2xvYmFsVGhpcyA9PT0gXCJvYmplY3RcIikge1xuICAgIGdsb2JhbFRoaXMucmVnZW5lcmF0b3JSdW50aW1lID0gcnVudGltZTtcbiAgfSBlbHNlIHtcbiAgICBGdW5jdGlvbihcInJcIiwgXCJyZWdlbmVyYXRvclJ1bnRpbWUgPSByXCIpKHJ1bnRpbWUpO1xuICB9XG59XG4iLCIvLyBUT0RPOiBjbHVzdGVyLmpzIGFuZCBjdl91dGlscy5qcyBhcmUgcHJldHR5IHRpZ2h0bHkgaW50ZXJ0d2luZWQsIG1ha2luZyBmb3IgYSBjb21wbGV4IGNvbnZlcnNpb25cbi8vIGludG8gdHlwZXNjcmlwdC4gYmUgd2FybmVkLiA6LSlcblxuaW1wb3J0IHsgY2xvbmUsIGRvdCB9IGZyb20gJ2dsLXZlYzInO1xuXG5jb25zdCB2ZWMyID0geyBjbG9uZSwgZG90IH07XG5cbi8qKlxuICogQ3JlYXRlcyBhIGNsdXN0ZXIgZm9yIGdyb3VwaW5nIHNpbWlsYXIgb3JpZW50YXRpb25zIG9mIGRhdGFwb2ludHNcbiAqL1xuZXhwb3J0IGRlZmF1bHQge1xuICAgIGNyZWF0ZShwb2ludCwgdGhyZXNob2xkKSB7XG4gICAgICAgIGNvbnN0IHBvaW50cyA9IFtdO1xuICAgICAgICBjb25zdCBjZW50ZXIgPSB7XG4gICAgICAgICAgICByYWQ6IDAsXG4gICAgICAgICAgICB2ZWM6IHZlYzIuY2xvbmUoWzAsIDBdKSxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgcG9pbnRNYXAgPSB7fTtcblxuICAgICAgICBmdW5jdGlvbiBhZGQocG9pbnRUb0FkZCkge1xuICAgICAgICAgICAgcG9pbnRNYXBbcG9pbnRUb0FkZC5pZF0gPSBwb2ludFRvQWRkO1xuICAgICAgICAgICAgcG9pbnRzLnB1c2gocG9pbnRUb0FkZCk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiB1cGRhdGVDZW50ZXIoKSB7XG4gICAgICAgICAgICBsZXQgaTsgbGV0XG4gICAgICAgICAgICAgICAgc3VtID0gMDtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBwb2ludHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBzdW0gKz0gcG9pbnRzW2ldLnJhZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNlbnRlci5yYWQgPSBzdW0gLyBwb2ludHMubGVuZ3RoO1xuICAgICAgICAgICAgY2VudGVyLnZlYyA9IHZlYzIuY2xvbmUoW01hdGguY29zKGNlbnRlci5yYWQpLCBNYXRoLnNpbihjZW50ZXIucmFkKV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gaW5pdCgpIHtcbiAgICAgICAgICAgIGFkZChwb2ludCk7XG4gICAgICAgICAgICB1cGRhdGVDZW50ZXIoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGluaXQoKTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYWRkKHBvaW50VG9BZGQpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXBvaW50TWFwW3BvaW50VG9BZGQuaWRdKSB7XG4gICAgICAgICAgICAgICAgICAgIGFkZChwb2ludFRvQWRkKTtcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlQ2VudGVyKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZpdHMob3RoZXJQb2ludCkge1xuICAgICAgICAgICAgICAgIC8vIGNoZWNrIGNvc2luZSBzaW1pbGFyaXR5IHRvIGNlbnRlci1hbmdsZVxuICAgICAgICAgICAgICAgIGNvbnN0IHNpbWlsYXJpdHkgPSBNYXRoLmFicyh2ZWMyLmRvdChvdGhlclBvaW50LnBvaW50LnZlYywgY2VudGVyLnZlYykpO1xuICAgICAgICAgICAgICAgIGlmIChzaW1pbGFyaXR5ID4gdGhyZXNob2xkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0UG9pbnRzKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwb2ludHM7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0Q2VudGVyKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjZW50ZXI7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgY3JlYXRlUG9pbnQobmV3UG9pbnQsIGlkLCBwcm9wZXJ0eSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcmFkOiBuZXdQb2ludFtwcm9wZXJ0eV0sXG4gICAgICAgICAgICBwb2ludDogbmV3UG9pbnQsXG4gICAgICAgICAgICBpZCxcbiAgICAgICAgfTtcbiAgICB9LFxufTtcbiIsIi8qIGVzbGludC1kaXNhYmxlIG5vLW1peGVkLW9wZXJhdG9ycyAqL1xuLyogZXNsaW50LWRpc2FibGUgbm8tYml0d2lzZSAqL1xuaW1wb3J0IHsgY2xvbmUgYXMgdjJjbG9uZSB9IGZyb20gJ2dsLXZlYzInO1xuaW1wb3J0IHsgY2xvbmUgYXMgdjNjbG9uZSB9IGZyb20gJ2dsLXZlYzMnO1xuaW1wb3J0IENsdXN0ZXIyIGZyb20gJy4vY2x1c3Rlcic7XG5pbXBvcnQgQXJyYXlIZWxwZXIgZnJvbSAnLi9hcnJheV9oZWxwZXInO1xuXG5jb25zdCB2ZWMyID0geyBjbG9uZTogdjJjbG9uZSB9O1xuY29uc3QgdmVjMyA9IHsgY2xvbmU6IHYzY2xvbmUgfTtcblxuLyoqXG4gKiBAcGFyYW0geCB4LWNvb3JkaW5hdGVcbiAqIEBwYXJhbSB5IHktY29vcmRpbmF0ZVxuICogQHJldHVybiBJbWFnZVJlZmVyZW5jZSB7eCx5fSBDb29yZGluYXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbWFnZVJlZih4LCB5KSB7XG4gICAgY29uc3QgdGhhdCA9IHtcbiAgICAgICAgeCxcbiAgICAgICAgeSxcbiAgICAgICAgdG9WZWMyKCkge1xuICAgICAgICAgICAgcmV0dXJuIHZlYzIuY2xvbmUoW3RoaXMueCwgdGhpcy55XSk7XG4gICAgICAgIH0sXG4gICAgICAgIHRvVmVjMygpIHtcbiAgICAgICAgICAgIHJldHVybiB2ZWMzLmNsb25lKFt0aGlzLngsIHRoaXMueSwgMV0pO1xuICAgICAgICB9LFxuICAgICAgICByb3VuZCgpIHtcbiAgICAgICAgICAgIHRoaXMueCA9IHRoaXMueCA+IDAuMCA/IE1hdGguZmxvb3IodGhpcy54ICsgMC41KSA6IE1hdGguZmxvb3IodGhpcy54IC0gMC41KTtcbiAgICAgICAgICAgIHRoaXMueSA9IHRoaXMueSA+IDAuMCA/IE1hdGguZmxvb3IodGhpcy55ICsgMC41KSA6IE1hdGguZmxvb3IodGhpcy55IC0gMC41KTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuICAgIH07XG4gICAgcmV0dXJuIHRoYXQ7XG59XG5cbi8qKlxuICogQ29tcHV0ZXMgYW4gaW50ZWdyYWwgaW1hZ2Ugb2YgYSBnaXZlbiBncmF5c2NhbGUgaW1hZ2UuXG4gKiBAcGFyYW0gaW1hZ2VEYXRhQ29udGFpbmVyIHtJbWFnZURhdGFDb250YWluZXJ9IHRoZSBpbWFnZSB0byBiZSBpbnRlZ3JhdGVkXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb21wdXRlSW50ZWdyYWxJbWFnZTIoaW1hZ2VXcmFwcGVyLCBpbnRlZ3JhbFdyYXBwZXIpIHtcbiAgICBjb25zdCBpbWFnZURhdGEgPSBpbWFnZVdyYXBwZXIuZGF0YTtcbiAgICBjb25zdCB3aWR0aCA9IGltYWdlV3JhcHBlci5zaXplLng7XG4gICAgY29uc3QgaGVpZ2h0ID0gaW1hZ2VXcmFwcGVyLnNpemUueTtcbiAgICBjb25zdCBpbnRlZ3JhbEltYWdlRGF0YSA9IGludGVncmFsV3JhcHBlci5kYXRhO1xuICAgIGxldCBzdW0gPSAwOyBsZXQgcG9zQSA9IDA7IGxldCBwb3NCID0gMDsgbGV0IHBvc0MgPSAwOyBsZXQgcG9zRCA9IDA7IGxldCB4OyBsZXRcbiAgICAgICAgeTtcblxuICAgIC8vIHN1bSB1cCBmaXJzdCBjb2x1bW5cbiAgICBwb3NCID0gd2lkdGg7XG4gICAgc3VtID0gMDtcbiAgICBmb3IgKHkgPSAxOyB5IDwgaGVpZ2h0OyB5KyspIHtcbiAgICAgICAgc3VtICs9IGltYWdlRGF0YVtwb3NBXTtcbiAgICAgICAgaW50ZWdyYWxJbWFnZURhdGFbcG9zQl0gKz0gc3VtO1xuICAgICAgICBwb3NBICs9IHdpZHRoO1xuICAgICAgICBwb3NCICs9IHdpZHRoO1xuICAgIH1cblxuICAgIHBvc0EgPSAwO1xuICAgIHBvc0IgPSAxO1xuICAgIHN1bSA9IDA7XG4gICAgZm9yICh4ID0gMTsgeCA8IHdpZHRoOyB4KyspIHtcbiAgICAgICAgc3VtICs9IGltYWdlRGF0YVtwb3NBXTtcbiAgICAgICAgaW50ZWdyYWxJbWFnZURhdGFbcG9zQl0gKz0gc3VtO1xuICAgICAgICBwb3NBKys7XG4gICAgICAgIHBvc0IrKztcbiAgICB9XG5cbiAgICBmb3IgKHkgPSAxOyB5IDwgaGVpZ2h0OyB5KyspIHtcbiAgICAgICAgcG9zQSA9IHkgKiB3aWR0aCArIDE7XG4gICAgICAgIHBvc0IgPSAoeSAtIDEpICogd2lkdGggKyAxO1xuICAgICAgICBwb3NDID0geSAqIHdpZHRoO1xuICAgICAgICBwb3NEID0gKHkgLSAxKSAqIHdpZHRoO1xuICAgICAgICBmb3IgKHggPSAxOyB4IDwgd2lkdGg7IHgrKykge1xuICAgICAgICAgICAgaW50ZWdyYWxJbWFnZURhdGFbcG9zQV1cbiAgICAgICAgICAgICAgICArPSBpbWFnZURhdGFbcG9zQV0gKyBpbnRlZ3JhbEltYWdlRGF0YVtwb3NCXSArIGludGVncmFsSW1hZ2VEYXRhW3Bvc0NdIC0gaW50ZWdyYWxJbWFnZURhdGFbcG9zRF07XG4gICAgICAgICAgICBwb3NBKys7XG4gICAgICAgICAgICBwb3NCKys7XG4gICAgICAgICAgICBwb3NDKys7XG4gICAgICAgICAgICBwb3NEKys7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjb21wdXRlSW50ZWdyYWxJbWFnZShpbWFnZVdyYXBwZXIsIGludGVncmFsV3JhcHBlcikge1xuICAgIGNvbnN0IGltYWdlRGF0YSA9IGltYWdlV3JhcHBlci5kYXRhO1xuICAgIGNvbnN0IHdpZHRoID0gaW1hZ2VXcmFwcGVyLnNpemUueDtcbiAgICBjb25zdCBoZWlnaHQgPSBpbWFnZVdyYXBwZXIuc2l6ZS55O1xuICAgIGNvbnN0IGludGVncmFsSW1hZ2VEYXRhID0gaW50ZWdyYWxXcmFwcGVyLmRhdGE7XG4gICAgbGV0IHN1bSA9IDA7XG5cbiAgICAvLyBzdW0gdXAgZmlyc3Qgcm93XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB3aWR0aDsgaSsrKSB7XG4gICAgICAgIHN1bSArPSBpbWFnZURhdGFbaV07XG4gICAgICAgIGludGVncmFsSW1hZ2VEYXRhW2ldID0gc3VtO1xuICAgIH1cblxuICAgIGZvciAobGV0IHYgPSAxOyB2IDwgaGVpZ2h0OyB2KyspIHtcbiAgICAgICAgc3VtID0gMDtcbiAgICAgICAgZm9yIChsZXQgdSA9IDA7IHUgPCB3aWR0aDsgdSsrKSB7XG4gICAgICAgICAgICBzdW0gKz0gaW1hZ2VEYXRhW3YgKiB3aWR0aCArIHVdO1xuICAgICAgICAgICAgaW50ZWdyYWxJbWFnZURhdGFbKCh2KSAqIHdpZHRoKSArIHVdID0gc3VtICsgaW50ZWdyYWxJbWFnZURhdGFbKHYgLSAxKSAqIHdpZHRoICsgdV07XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0aHJlc2hvbGRJbWFnZShpbWFnZVdyYXBwZXIsIHRocmVzaG9sZCwgdGFyZ2V0V3JhcHBlcikge1xuICAgIGlmICghdGFyZ2V0V3JhcHBlcikge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgICAgdGFyZ2V0V3JhcHBlciA9IGltYWdlV3JhcHBlcjtcbiAgICB9XG4gICAgY29uc3QgaW1hZ2VEYXRhID0gaW1hZ2VXcmFwcGVyLmRhdGE7IGxldCB7IGxlbmd0aCB9ID0gaW1hZ2VEYXRhOyBjb25zdFxuICAgICAgICB0YXJnZXREYXRhID0gdGFyZ2V0V3JhcHBlci5kYXRhO1xuXG4gICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgIHRhcmdldERhdGFbbGVuZ3RoXSA9IGltYWdlRGF0YVtsZW5ndGhdIDwgdGhyZXNob2xkID8gMSA6IDA7XG4gICAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gY29tcHV0ZUhpc3RvZ3JhbShpbWFnZVdyYXBwZXIsIGJpdHNQZXJQaXhlbCkge1xuICAgIGlmICghYml0c1BlclBpeGVsKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgICBiaXRzUGVyUGl4ZWwgPSA4O1xuICAgIH1cbiAgICBjb25zdCBpbWFnZURhdGEgPSBpbWFnZVdyYXBwZXIuZGF0YTtcbiAgICBsZXQgeyBsZW5ndGggfSA9IGltYWdlRGF0YTtcbiAgICBjb25zdCBiaXRTaGlmdCA9IDggLSBiaXRzUGVyUGl4ZWw7XG4gICAgY29uc3QgYnVja2V0Q250ID0gMSA8PCBiaXRzUGVyUGl4ZWw7XG4gICAgY29uc3QgaGlzdCA9IG5ldyBJbnQzMkFycmF5KGJ1Y2tldENudCk7XG5cbiAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgaGlzdFtpbWFnZURhdGFbbGVuZ3RoXSA+PiBiaXRTaGlmdF0rKztcbiAgICB9XG4gICAgcmV0dXJuIGhpc3Q7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzaGFycGVuTGluZShsaW5lKSB7XG4gICAgbGV0IGk7XG4gICAgY29uc3QgeyBsZW5ndGggfSA9IGxpbmU7XG4gICAgbGV0IGxlZnQgPSBsaW5lWzBdO1xuICAgIGxldCBjZW50ZXIgPSBsaW5lWzFdO1xuICAgIGxldCByaWdodDtcblxuICAgIGZvciAoaSA9IDE7IGkgPCBsZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgcmlnaHQgPSBsaW5lW2kgKyAxXTtcbiAgICAgICAgLy8gIC0xIDQgLTEga2VybmVsXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgICBsaW5lW2kgLSAxXSA9ICgoKGNlbnRlciAqIDIpIC0gbGVmdCAtIHJpZ2h0KSkgJiAyNTU7XG4gICAgICAgIGxlZnQgPSBjZW50ZXI7XG4gICAgICAgIGNlbnRlciA9IHJpZ2h0O1xuICAgIH1cbiAgICByZXR1cm4gbGluZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRldGVybWluZU90c3VUaHJlc2hvbGQoaW1hZ2VXcmFwcGVyLCBiaXRzUGVyUGl4ZWwgPSA4KSB7XG4gICAgbGV0IGhpc3Q7XG4gICAgY29uc3QgYml0U2hpZnQgPSA4IC0gYml0c1BlclBpeGVsO1xuXG4gICAgZnVuY3Rpb24gcHgoaW5pdCwgZW5kKSB7XG4gICAgICAgIGxldCBzdW0gPSAwO1xuICAgICAgICBmb3IgKGxldCBpID0gaW5pdDsgaSA8PSBlbmQ7IGkrKykge1xuICAgICAgICAgICAgc3VtICs9IGhpc3RbaV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN1bTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBteChpbml0LCBlbmQpIHtcbiAgICAgICAgbGV0IHN1bSA9IDA7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IGluaXQ7IGkgPD0gZW5kOyBpKyspIHtcbiAgICAgICAgICAgIHN1bSArPSBpICogaGlzdFtpXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzdW07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGV0ZXJtaW5lVGhyZXNob2xkKCkge1xuICAgICAgICBjb25zdCB2ZXQgPSBbMF07XG4gICAgICAgIGxldCBwMTtcbiAgICAgICAgbGV0IHAyO1xuICAgICAgICBsZXQgcDEyO1xuICAgICAgICBsZXQgbTE7XG4gICAgICAgIGxldCBtMjtcbiAgICAgICAgbGV0IG0xMjtcbiAgICAgICAgY29uc3QgbWF4ID0gKDEgPDwgYml0c1BlclBpeGVsKSAtIDE7XG5cbiAgICAgICAgaGlzdCA9IGNvbXB1dGVIaXN0b2dyYW0oaW1hZ2VXcmFwcGVyLCBiaXRzUGVyUGl4ZWwpO1xuICAgICAgICBmb3IgKGxldCBrID0gMTsgayA8IG1heDsgaysrKSB7XG4gICAgICAgICAgICBwMSA9IHB4KDAsIGspO1xuICAgICAgICAgICAgcDIgPSBweChrICsgMSwgbWF4KTtcbiAgICAgICAgICAgIHAxMiA9IHAxICogcDI7XG4gICAgICAgICAgICBpZiAocDEyID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcDEyID0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG0xID0gbXgoMCwgaykgKiBwMjtcbiAgICAgICAgICAgIG0yID0gbXgoayArIDEsIG1heCkgKiBwMTtcbiAgICAgICAgICAgIG0xMiA9IG0xIC0gbTI7XG4gICAgICAgICAgICB2ZXRba10gPSBtMTIgKiBtMTIgLyBwMTI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEFycmF5SGVscGVyLm1heEluZGV4KHZldCk7XG4gICAgfVxuXG4gICAgY29uc3QgdGhyZXNob2xkID0gZGV0ZXJtaW5lVGhyZXNob2xkKCk7XG4gICAgcmV0dXJuIHRocmVzaG9sZCA8PCBiaXRTaGlmdDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG90c3VUaHJlc2hvbGQoaW1hZ2VXcmFwcGVyLCB0YXJnZXRXcmFwcGVyKSB7XG4gICAgY29uc3QgdGhyZXNob2xkID0gZGV0ZXJtaW5lT3RzdVRocmVzaG9sZChpbWFnZVdyYXBwZXIpO1xuXG4gICAgdGhyZXNob2xkSW1hZ2UoaW1hZ2VXcmFwcGVyLCB0aHJlc2hvbGQsIHRhcmdldFdyYXBwZXIpO1xuICAgIHJldHVybiB0aHJlc2hvbGQ7XG59XG5cbi8vIGxvY2FsIHRocmVzaG9sZGluZ1xuZXhwb3J0IGZ1bmN0aW9uIGNvbXB1dGVCaW5hcnlJbWFnZShpbWFnZVdyYXBwZXIsIGludGVncmFsV3JhcHBlciwgdGFyZ2V0V3JhcHBlcikge1xuICAgIGNvbXB1dGVJbnRlZ3JhbEltYWdlKGltYWdlV3JhcHBlciwgaW50ZWdyYWxXcmFwcGVyKTtcblxuICAgIGlmICghdGFyZ2V0V3JhcHBlcikge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgICAgdGFyZ2V0V3JhcHBlciA9IGltYWdlV3JhcHBlcjtcbiAgICB9XG4gICAgY29uc3QgaW1hZ2VEYXRhID0gaW1hZ2VXcmFwcGVyLmRhdGE7XG4gICAgY29uc3QgdGFyZ2V0RGF0YSA9IHRhcmdldFdyYXBwZXIuZGF0YTtcbiAgICBjb25zdCB3aWR0aCA9IGltYWdlV3JhcHBlci5zaXplLng7XG4gICAgY29uc3QgaGVpZ2h0ID0gaW1hZ2VXcmFwcGVyLnNpemUueTtcbiAgICBjb25zdCBpbnRlZ3JhbEltYWdlRGF0YSA9IGludGVncmFsV3JhcHBlci5kYXRhO1xuICAgIGxldCBzdW0gPSAwOyBsZXQgdjsgbGV0IHU7IGNvbnN0IGtlcm5lbCA9IDM7IGxldCBBOyBsZXQgQjsgbGV0IEM7IGxldCBEOyBsZXQgYXZnOyBjb25zdFxuICAgICAgICBzaXplID0gKGtlcm5lbCAqIDIgKyAxKSAqIChrZXJuZWwgKiAyICsgMSk7XG5cbiAgICAvLyBjbGVhciBvdXQgdG9wICYgYm90dG9tLWJvcmRlclxuICAgIGZvciAodiA9IDA7IHYgPD0ga2VybmVsOyB2KyspIHtcbiAgICAgICAgZm9yICh1ID0gMDsgdSA8IHdpZHRoOyB1KyspIHtcbiAgICAgICAgICAgIHRhcmdldERhdGFbKCh2KSAqIHdpZHRoKSArIHVdID0gMDtcbiAgICAgICAgICAgIHRhcmdldERhdGFbKCgoaGVpZ2h0IC0gMSkgLSB2KSAqIHdpZHRoKSArIHVdID0gMDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIGNsZWFyIG91dCBsZWZ0ICYgcmlnaHQgYm9yZGVyXG4gICAgZm9yICh2ID0ga2VybmVsOyB2IDwgaGVpZ2h0IC0ga2VybmVsOyB2KyspIHtcbiAgICAgICAgZm9yICh1ID0gMDsgdSA8PSBrZXJuZWw7IHUrKykge1xuICAgICAgICAgICAgdGFyZ2V0RGF0YVsoKHYpICogd2lkdGgpICsgdV0gPSAwO1xuICAgICAgICAgICAgdGFyZ2V0RGF0YVsoKHYpICogd2lkdGgpICsgKHdpZHRoIC0gMSAtIHUpXSA9IDA7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKHYgPSBrZXJuZWwgKyAxOyB2IDwgaGVpZ2h0IC0ga2VybmVsIC0gMTsgdisrKSB7XG4gICAgICAgIGZvciAodSA9IGtlcm5lbCArIDE7IHUgPCB3aWR0aCAtIGtlcm5lbDsgdSsrKSB7XG4gICAgICAgICAgICBBID0gaW50ZWdyYWxJbWFnZURhdGFbKHYgLSBrZXJuZWwgLSAxKSAqIHdpZHRoICsgKHUgLSBrZXJuZWwgLSAxKV07XG4gICAgICAgICAgICBCID0gaW50ZWdyYWxJbWFnZURhdGFbKHYgLSBrZXJuZWwgLSAxKSAqIHdpZHRoICsgKHUgKyBrZXJuZWwpXTtcbiAgICAgICAgICAgIEMgPSBpbnRlZ3JhbEltYWdlRGF0YVsodiArIGtlcm5lbCkgKiB3aWR0aCArICh1IC0ga2VybmVsIC0gMSldO1xuICAgICAgICAgICAgRCA9IGludGVncmFsSW1hZ2VEYXRhWyh2ICsga2VybmVsKSAqIHdpZHRoICsgKHUgKyBrZXJuZWwpXTtcbiAgICAgICAgICAgIHN1bSA9IEQgLSBDIC0gQiArIEE7XG4gICAgICAgICAgICBhdmcgPSBzdW0gLyAoc2l6ZSk7XG4gICAgICAgICAgICB0YXJnZXREYXRhW3YgKiB3aWR0aCArIHVdID0gaW1hZ2VEYXRhW3YgKiB3aWR0aCArIHVdID4gKGF2ZyArIDUpID8gMCA6IDE7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjbHVzdGVyKHBvaW50cywgdGhyZXNob2xkLCBwcm9wZXJ0eSkge1xuICAgIGxldCBpOyBsZXQgazsgbGV0IHRoaXNDbHVzdGVyOyBsZXQgcG9pbnQ7IGNvbnN0XG4gICAgICAgIGNsdXN0ZXJzID0gW107XG5cbiAgICBpZiAoIXByb3BlcnR5KSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgICBwcm9wZXJ0eSA9ICdyYWQnO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFkZFRvQ2x1c3RlcihuZXdQb2ludCkge1xuICAgICAgICBsZXQgZm91bmQgPSBmYWxzZTtcbiAgICAgICAgZm9yIChrID0gMDsgayA8IGNsdXN0ZXJzLmxlbmd0aDsgaysrKSB7XG4gICAgICAgICAgICB0aGlzQ2x1c3RlciA9IGNsdXN0ZXJzW2tdO1xuICAgICAgICAgICAgaWYgKHRoaXNDbHVzdGVyLmZpdHMobmV3UG9pbnQpKSB7XG4gICAgICAgICAgICAgICAgdGhpc0NsdXN0ZXIuYWRkKG5ld1BvaW50KTtcbiAgICAgICAgICAgICAgICBmb3VuZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZvdW5kO1xuICAgIH1cblxuICAgIC8vIGl0ZXJhdGUgb3ZlciBlYWNoIGNsb3VkXG4gICAgZm9yIChpID0gMDsgaSA8IHBvaW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBwb2ludCA9IENsdXN0ZXIyLmNyZWF0ZVBvaW50KHBvaW50c1tpXSwgaSwgcHJvcGVydHkpO1xuICAgICAgICBpZiAoIWFkZFRvQ2x1c3Rlcihwb2ludCkpIHtcbiAgICAgICAgICAgIGNsdXN0ZXJzLnB1c2goQ2x1c3RlcjIuY3JlYXRlKHBvaW50LCB0aHJlc2hvbGQpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY2x1c3RlcnM7XG59XG5cbmV4cG9ydCBjb25zdCBUcmFjZXIgPSB7XG4gICAgdHJhY2UocG9pbnRzLCB2ZWMpIHtcbiAgICAgICAgbGV0IGl0ZXJhdGlvbjtcbiAgICAgICAgY29uc3QgbWF4SXRlcmF0aW9ucyA9IDEwO1xuICAgICAgICBsZXQgdG9wID0gW107XG4gICAgICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICAgICAgbGV0IGNlbnRlclBvcyA9IDA7XG4gICAgICAgIGxldCBjdXJyZW50UG9zID0gMDtcblxuICAgICAgICBmdW5jdGlvbiB0cmFjZShpZHgsIGZvcndhcmQpIHtcbiAgICAgICAgICAgIGxldCB0bztcbiAgICAgICAgICAgIGxldCB0b0lkeDtcbiAgICAgICAgICAgIGxldCBwcmVkaWN0ZWRQb3M7XG4gICAgICAgICAgICBjb25zdCB0aHJlc2hvbGRYID0gMTtcbiAgICAgICAgICAgIGNvbnN0IHRocmVzaG9sZFkgPSBNYXRoLmFicyh2ZWNbMV0gLyAxMCk7XG4gICAgICAgICAgICBsZXQgZm91bmQgPSBmYWxzZTtcblxuICAgICAgICAgICAgZnVuY3Rpb24gbWF0Y2gocG9zLCBwcmVkaWN0ZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAocG9zLnggPiAocHJlZGljdGVkLnggLSB0aHJlc2hvbGRYKVxuICAgICAgICAgICAgICAgICAgICAgICAgJiYgcG9zLnggPCAocHJlZGljdGVkLnggKyB0aHJlc2hvbGRYKVxuICAgICAgICAgICAgICAgICAgICAgICAgJiYgcG9zLnkgPiAocHJlZGljdGVkLnkgLSB0aHJlc2hvbGRZKVxuICAgICAgICAgICAgICAgICAgICAgICAgJiYgcG9zLnkgPCAocHJlZGljdGVkLnkgKyB0aHJlc2hvbGRZKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBjaGVjayBpZiB0aGUgbmV4dCBpbmRleCBpcyB3aXRoaW4gdGhlIHZlYyBzcGVjaWZpY2F0aW9uc1xuICAgICAgICAgICAgLy8gaWYgbm90LCBjaGVjayBhcyBsb25nIGFzIHRoZSB0aHJlc2hvbGQgaXMgbWV0XG5cbiAgICAgICAgICAgIGNvbnN0IGZyb20gPSBwb2ludHNbaWR4XTtcbiAgICAgICAgICAgIGlmIChmb3J3YXJkKSB7XG4gICAgICAgICAgICAgICAgcHJlZGljdGVkUG9zID0ge1xuICAgICAgICAgICAgICAgICAgICB4OiBmcm9tLnggKyB2ZWNbMF0sXG4gICAgICAgICAgICAgICAgICAgIHk6IGZyb20ueSArIHZlY1sxXSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwcmVkaWN0ZWRQb3MgPSB7XG4gICAgICAgICAgICAgICAgICAgIHg6IGZyb20ueCAtIHZlY1swXSxcbiAgICAgICAgICAgICAgICAgICAgeTogZnJvbS55IC0gdmVjWzFdLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRvSWR4ID0gZm9yd2FyZCA/IGlkeCArIDEgOiBpZHggLSAxO1xuICAgICAgICAgICAgdG8gPSBwb2ludHNbdG9JZHhdO1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbmQtYXNzaWduXG4gICAgICAgICAgICB3aGlsZSAodG8gJiYgKGZvdW5kID0gbWF0Y2godG8sIHByZWRpY3RlZFBvcykpICE9PSB0cnVlICYmIChNYXRoLmFicyh0by55IC0gZnJvbS55KSA8IHZlY1sxXSkpIHtcbiAgICAgICAgICAgICAgICB0b0lkeCA9IGZvcndhcmQgPyB0b0lkeCArIDEgOiB0b0lkeCAtIDE7XG4gICAgICAgICAgICAgICAgdG8gPSBwb2ludHNbdG9JZHhdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gZm91bmQgPyB0b0lkeCA6IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGl0ZXJhdGlvbiA9IDA7IGl0ZXJhdGlvbiA8IG1heEl0ZXJhdGlvbnM7IGl0ZXJhdGlvbisrKSB7XG4gICAgICAgICAgICAvLyByYW5kb21seSBzZWxlY3QgcG9pbnQgdG8gc3RhcnQgd2l0aFxuICAgICAgICAgICAgY2VudGVyUG9zID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogcG9pbnRzLmxlbmd0aCk7XG5cbiAgICAgICAgICAgIC8vIHRyYWNlIGZvcndhcmRcbiAgICAgICAgICAgIHRvcCA9IFtdO1xuICAgICAgICAgICAgY3VycmVudFBvcyA9IGNlbnRlclBvcztcbiAgICAgICAgICAgIHRvcC5wdXNoKHBvaW50c1tjdXJyZW50UG9zXSk7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uZC1hc3NpZ25cbiAgICAgICAgICAgIHdoaWxlICgoY3VycmVudFBvcyA9IHRyYWNlKGN1cnJlbnRQb3MsIHRydWUpKSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRvcC5wdXNoKHBvaW50c1tjdXJyZW50UG9zXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY2VudGVyUG9zID4gMCkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRQb3MgPSBjZW50ZXJQb3M7XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbmQtYXNzaWduXG4gICAgICAgICAgICAgICAgd2hpbGUgKChjdXJyZW50UG9zID0gdHJhY2UoY3VycmVudFBvcywgZmFsc2UpKSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB0b3AucHVzaChwb2ludHNbY3VycmVudFBvc10pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRvcC5sZW5ndGggPiByZXN1bHQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gdG9wO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcbn07XG5cbmV4cG9ydCBjb25zdCBESUxBVEUgPSAxO1xuZXhwb3J0IGNvbnN0IEVST0RFID0gMjtcblxuZXhwb3J0IGZ1bmN0aW9uIGRpbGF0ZShpbkltYWdlV3JhcHBlciwgb3V0SW1hZ2VXcmFwcGVyKSB7XG4gICAgbGV0IHY7XG4gICAgbGV0IHU7XG4gICAgY29uc3QgaW5JbWFnZURhdGEgPSBpbkltYWdlV3JhcHBlci5kYXRhO1xuICAgIGNvbnN0IG91dEltYWdlRGF0YSA9IG91dEltYWdlV3JhcHBlci5kYXRhO1xuICAgIGNvbnN0IGhlaWdodCA9IGluSW1hZ2VXcmFwcGVyLnNpemUueTtcbiAgICBjb25zdCB3aWR0aCA9IGluSW1hZ2VXcmFwcGVyLnNpemUueDtcbiAgICBsZXQgc3VtO1xuICAgIGxldCB5U3RhcnQxO1xuICAgIGxldCB5U3RhcnQyO1xuICAgIGxldCB4U3RhcnQxO1xuICAgIGxldCB4U3RhcnQyO1xuXG4gICAgZm9yICh2ID0gMTsgdiA8IGhlaWdodCAtIDE7IHYrKykge1xuICAgICAgICBmb3IgKHUgPSAxOyB1IDwgd2lkdGggLSAxOyB1KyspIHtcbiAgICAgICAgICAgIHlTdGFydDEgPSB2IC0gMTtcbiAgICAgICAgICAgIHlTdGFydDIgPSB2ICsgMTtcbiAgICAgICAgICAgIHhTdGFydDEgPSB1IC0gMTtcbiAgICAgICAgICAgIHhTdGFydDIgPSB1ICsgMTtcbiAgICAgICAgICAgIHN1bSA9IGluSW1hZ2VEYXRhW3lTdGFydDEgKiB3aWR0aCArIHhTdGFydDFdICsgaW5JbWFnZURhdGFbeVN0YXJ0MSAqIHdpZHRoICsgeFN0YXJ0Ml1cbiAgICAgICAgICAgICsgaW5JbWFnZURhdGFbdiAqIHdpZHRoICsgdV1cbiAgICAgICAgICAgICsgaW5JbWFnZURhdGFbeVN0YXJ0MiAqIHdpZHRoICsgeFN0YXJ0MV0gKyBpbkltYWdlRGF0YVt5U3RhcnQyICogd2lkdGggKyB4U3RhcnQyXTtcbiAgICAgICAgICAgIG91dEltYWdlRGF0YVt2ICogd2lkdGggKyB1XSA9IHN1bSA+IDAgPyAxIDogMDtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGVyb2RlKGluSW1hZ2VXcmFwcGVyLCBvdXRJbWFnZVdyYXBwZXIpIHtcbiAgICBsZXQgdjtcbiAgICBsZXQgdTtcbiAgICBjb25zdCBpbkltYWdlRGF0YSA9IGluSW1hZ2VXcmFwcGVyLmRhdGE7XG4gICAgY29uc3Qgb3V0SW1hZ2VEYXRhID0gb3V0SW1hZ2VXcmFwcGVyLmRhdGE7XG4gICAgY29uc3QgaGVpZ2h0ID0gaW5JbWFnZVdyYXBwZXIuc2l6ZS55O1xuICAgIGNvbnN0IHdpZHRoID0gaW5JbWFnZVdyYXBwZXIuc2l6ZS54O1xuICAgIGxldCBzdW07XG4gICAgbGV0IHlTdGFydDE7XG4gICAgbGV0IHlTdGFydDI7XG4gICAgbGV0IHhTdGFydDE7XG4gICAgbGV0IHhTdGFydDI7XG5cbiAgICBmb3IgKHYgPSAxOyB2IDwgaGVpZ2h0IC0gMTsgdisrKSB7XG4gICAgICAgIGZvciAodSA9IDE7IHUgPCB3aWR0aCAtIDE7IHUrKykge1xuICAgICAgICAgICAgeVN0YXJ0MSA9IHYgLSAxO1xuICAgICAgICAgICAgeVN0YXJ0MiA9IHYgKyAxO1xuICAgICAgICAgICAgeFN0YXJ0MSA9IHUgLSAxO1xuICAgICAgICAgICAgeFN0YXJ0MiA9IHUgKyAxO1xuICAgICAgICAgICAgc3VtID0gaW5JbWFnZURhdGFbeVN0YXJ0MSAqIHdpZHRoICsgeFN0YXJ0MV0gKyBpbkltYWdlRGF0YVt5U3RhcnQxICogd2lkdGggKyB4U3RhcnQyXVxuICAgICAgICAgICAgKyBpbkltYWdlRGF0YVt2ICogd2lkdGggKyB1XVxuICAgICAgICAgICAgKyBpbkltYWdlRGF0YVt5U3RhcnQyICogd2lkdGggKyB4U3RhcnQxXSArIGluSW1hZ2VEYXRhW3lTdGFydDIgKiB3aWR0aCArIHhTdGFydDJdO1xuICAgICAgICAgICAgb3V0SW1hZ2VEYXRhW3YgKiB3aWR0aCArIHVdID0gc3VtID09PSA1ID8gMSA6IDA7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzdWJ0cmFjdChhSW1hZ2VXcmFwcGVyLCBiSW1hZ2VXcmFwcGVyLCByZXN1bHRJbWFnZVdyYXBwZXIpIHtcbiAgICBpZiAoIXJlc3VsdEltYWdlV3JhcHBlcikge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgICAgcmVzdWx0SW1hZ2VXcmFwcGVyID0gYUltYWdlV3JhcHBlcjtcbiAgICB9XG4gICAgbGV0IHsgbGVuZ3RoIH0gPSBhSW1hZ2VXcmFwcGVyLmRhdGE7XG4gICAgY29uc3QgYUltYWdlRGF0YSA9IGFJbWFnZVdyYXBwZXIuZGF0YTtcbiAgICBjb25zdCBiSW1hZ2VEYXRhID0gYkltYWdlV3JhcHBlci5kYXRhO1xuICAgIGNvbnN0IGNJbWFnZURhdGEgPSByZXN1bHRJbWFnZVdyYXBwZXIuZGF0YTtcblxuICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICBjSW1hZ2VEYXRhW2xlbmd0aF0gPSBhSW1hZ2VEYXRhW2xlbmd0aF0gLSBiSW1hZ2VEYXRhW2xlbmd0aF07XG4gICAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gYml0d2lzZU9yKGFJbWFnZVdyYXBwZXIsIGJJbWFnZVdyYXBwZXIsIHJlc3VsdEltYWdlV3JhcHBlcikge1xuICAgIGlmICghcmVzdWx0SW1hZ2VXcmFwcGVyKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgICByZXN1bHRJbWFnZVdyYXBwZXIgPSBhSW1hZ2VXcmFwcGVyO1xuICAgIH1cbiAgICBsZXQgeyBsZW5ndGggfSA9IGFJbWFnZVdyYXBwZXIuZGF0YTtcbiAgICBjb25zdCBhSW1hZ2VEYXRhID0gYUltYWdlV3JhcHBlci5kYXRhO1xuICAgIGNvbnN0IGJJbWFnZURhdGEgPSBiSW1hZ2VXcmFwcGVyLmRhdGE7XG4gICAgY29uc3QgY0ltYWdlRGF0YSA9IHJlc3VsdEltYWdlV3JhcHBlci5kYXRhO1xuXG4gICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgIGNJbWFnZURhdGFbbGVuZ3RoXSA9IGFJbWFnZURhdGFbbGVuZ3RoXSB8fCBiSW1hZ2VEYXRhW2xlbmd0aF07XG4gICAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gY291bnROb25aZXJvKGltYWdlV3JhcHBlcikge1xuICAgIGxldCB7IGxlbmd0aCB9ID0gaW1hZ2VXcmFwcGVyLmRhdGE7XG4gICAgY29uc3QgeyBkYXRhIH0gPSBpbWFnZVdyYXBwZXI7XG4gICAgbGV0IHN1bSA9IDA7XG5cbiAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgc3VtICs9IGRhdGFbbGVuZ3RoXTtcbiAgICB9XG4gICAgcmV0dXJuIHN1bTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHRvcEdlbmVyaWMobGlzdCwgdG9wLCBzY29yZUZ1bmMpIHtcbiAgICBsZXQgaTsgbGV0IG1pbklkeCA9IDA7IGxldCBtaW4gPSAwOyBjb25zdCBxdWV1ZSA9IFtdOyBsZXQgc2NvcmU7IGxldCBoaXQ7IGxldFxuICAgICAgICBwb3M7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgdG9wOyBpKyspIHtcbiAgICAgICAgcXVldWVbaV0gPSB7XG4gICAgICAgICAgICBzY29yZTogMCxcbiAgICAgICAgICAgIGl0ZW06IG51bGwsXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgc2NvcmUgPSBzY29yZUZ1bmMuYXBwbHkodGhpcywgW2xpc3RbaV1dKTtcbiAgICAgICAgaWYgKHNjb3JlID4gbWluKSB7XG4gICAgICAgICAgICBoaXQgPSBxdWV1ZVttaW5JZHhdO1xuICAgICAgICAgICAgaGl0LnNjb3JlID0gc2NvcmU7XG4gICAgICAgICAgICBoaXQuaXRlbSA9IGxpc3RbaV07XG4gICAgICAgICAgICBtaW4gPSBOdW1iZXIuTUFYX1ZBTFVFO1xuICAgICAgICAgICAgZm9yIChwb3MgPSAwOyBwb3MgPCB0b3A7IHBvcysrKSB7XG4gICAgICAgICAgICAgICAgaWYgKHF1ZXVlW3Bvc10uc2NvcmUgPCBtaW4pIHtcbiAgICAgICAgICAgICAgICAgICAgbWluID0gcXVldWVbcG9zXS5zY29yZTtcbiAgICAgICAgICAgICAgICAgICAgbWluSWR4ID0gcG9zO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBxdWV1ZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdyYXlBcnJheUZyb21JbWFnZShodG1sSW1hZ2UsIG9mZnNldFgsIGN0eCwgYXJyYXkpIHtcbiAgICBjdHguZHJhd0ltYWdlKGh0bWxJbWFnZSwgb2Zmc2V0WCwgMCwgaHRtbEltYWdlLndpZHRoLCBodG1sSW1hZ2UuaGVpZ2h0KTtcbiAgICBjb25zdCBjdHhEYXRhID0gY3R4LmdldEltYWdlRGF0YShvZmZzZXRYLCAwLCBodG1sSW1hZ2Uud2lkdGgsIGh0bWxJbWFnZS5oZWlnaHQpLmRhdGE7XG4gICAgY29tcHV0ZUdyYXkoY3R4RGF0YSwgYXJyYXkpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ3JheUFycmF5RnJvbUNvbnRleHQoY3R4LCBzaXplLCBvZmZzZXQsIGFycmF5KSB7XG4gICAgY29uc3QgY3R4RGF0YSA9IGN0eC5nZXRJbWFnZURhdGEob2Zmc2V0LngsIG9mZnNldC55LCBzaXplLngsIHNpemUueSkuZGF0YTtcbiAgICBjb21wdXRlR3JheShjdHhEYXRhLCBhcnJheSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBncmF5QW5kSGFsZlNhbXBsZUZyb21DYW52YXNEYXRhKGNhbnZhc0RhdGEsIHNpemUsIG91dEFycmF5KSB7XG4gICAgbGV0IHRvcFJvd0lkeCA9IDA7XG4gICAgbGV0IGJvdHRvbVJvd0lkeCA9IHNpemUueDtcbiAgICBjb25zdCBlbmRJZHggPSBNYXRoLmZsb29yKGNhbnZhc0RhdGEubGVuZ3RoIC8gNCk7XG4gICAgY29uc3Qgb3V0V2lkdGggPSBzaXplLnggLyAyO1xuICAgIGxldCBvdXRJbWdJZHggPSAwO1xuICAgIGNvbnN0IGluV2lkdGggPSBzaXplLng7XG4gICAgbGV0IGk7XG5cbiAgICB3aGlsZSAoYm90dG9tUm93SWR4IDwgZW5kSWR4KSB7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBvdXRXaWR0aDsgaSsrKSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgICAgICAgIG91dEFycmF5W291dEltZ0lkeF0gPSAoXG4gICAgICAgICAgICAgICAgKDAuMjk5ICogY2FudmFzRGF0YVt0b3BSb3dJZHggKiA0ICsgMF1cbiAgICAgICAgICAgICAgICAgKyAwLjU4NyAqIGNhbnZhc0RhdGFbdG9wUm93SWR4ICogNCArIDFdXG4gICAgICAgICAgICAgICAgICsgMC4xMTQgKiBjYW52YXNEYXRhW3RvcFJvd0lkeCAqIDQgKyAyXSlcbiAgICAgICAgICAgICAgICArICgwLjI5OSAqIGNhbnZhc0RhdGFbKHRvcFJvd0lkeCArIDEpICogNCArIDBdXG4gICAgICAgICAgICAgICAgICsgMC41ODcgKiBjYW52YXNEYXRhWyh0b3BSb3dJZHggKyAxKSAqIDQgKyAxXVxuICAgICAgICAgICAgICAgICArIDAuMTE0ICogY2FudmFzRGF0YVsodG9wUm93SWR4ICsgMSkgKiA0ICsgMl0pXG4gICAgICAgICAgICAgICAgKyAoMC4yOTkgKiBjYW52YXNEYXRhWyhib3R0b21Sb3dJZHgpICogNCArIDBdXG4gICAgICAgICAgICAgICAgICsgMC41ODcgKiBjYW52YXNEYXRhWyhib3R0b21Sb3dJZHgpICogNCArIDFdXG4gICAgICAgICAgICAgICAgICsgMC4xMTQgKiBjYW52YXNEYXRhWyhib3R0b21Sb3dJZHgpICogNCArIDJdKVxuICAgICAgICAgICAgICAgICsgKDAuMjk5ICogY2FudmFzRGF0YVsoYm90dG9tUm93SWR4ICsgMSkgKiA0ICsgMF1cbiAgICAgICAgICAgICAgICAgKyAwLjU4NyAqIGNhbnZhc0RhdGFbKGJvdHRvbVJvd0lkeCArIDEpICogNCArIDFdXG4gICAgICAgICAgICAgICAgICsgMC4xMTQgKiBjYW52YXNEYXRhWyhib3R0b21Sb3dJZHggKyAxKSAqIDQgKyAyXSkpIC8gNDtcbiAgICAgICAgICAgIG91dEltZ0lkeCsrO1xuICAgICAgICAgICAgdG9wUm93SWR4ICs9IDI7XG4gICAgICAgICAgICBib3R0b21Sb3dJZHggKz0gMjtcbiAgICAgICAgfVxuICAgICAgICB0b3BSb3dJZHggKz0gaW5XaWR0aDtcbiAgICAgICAgYm90dG9tUm93SWR4ICs9IGluV2lkdGg7XG4gICAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gY29tcHV0ZUdyYXkoaW1hZ2VEYXRhLCBvdXRBcnJheSwgY29uZmlnKSB7XG4gICAgY29uc3QgbCA9IChpbWFnZURhdGEubGVuZ3RoIC8gNCkgfCAwO1xuICAgIGNvbnN0IHNpbmdsZUNoYW5uZWwgPSBjb25maWcgJiYgY29uZmlnLnNpbmdsZUNoYW5uZWwgPT09IHRydWU7XG5cbiAgICBpZiAoc2luZ2xlQ2hhbm5lbCkge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICAgICAgICBvdXRBcnJheVtpXSA9IGltYWdlRGF0YVtpICogNCArIDBdO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgICAgICAgb3V0QXJyYXlbaV0gPSAwLjI5OSAqIGltYWdlRGF0YVtpICogNCArIDBdICsgMC41ODcgKiBpbWFnZURhdGFbaSAqIDQgKyAxXSArIDAuMTE0ICogaW1hZ2VEYXRhW2kgKiA0ICsgMl07XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBsb2FkSW1hZ2VBcnJheShzcmMsIGNhbGxiYWNrLCBjYW52YXMgPSBkb2N1bWVudCAmJiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKSkge1xuICAgIGNvbnN0IGltZyA9IG5ldyBJbWFnZSgpO1xuICAgIGltZy5jYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgIGltZy5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgICBjYW52YXMud2lkdGggPSB0aGlzLndpZHRoO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgICAgY2FudmFzLmhlaWdodCA9IHRoaXMuaGVpZ2h0O1xuICAgICAgICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgICAgY3R4LmRyYXdJbWFnZSh0aGlzLCAwLCAwKTtcbiAgICAgICAgY29uc3QgYXJyYXkgPSBuZXcgVWludDhBcnJheSh0aGlzLndpZHRoICogdGhpcy5oZWlnaHQpO1xuICAgICAgICBjdHguZHJhd0ltYWdlKHRoaXMsIDAsIDApO1xuICAgICAgICBjb25zdCB7IGRhdGEgfSA9IGN0eC5nZXRJbWFnZURhdGEoMCwgMCwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xuICAgICAgICBjb21wdXRlR3JheShkYXRhLCBhcnJheSk7XG4gICAgICAgIHRoaXMuY2FsbGJhY2soYXJyYXksIHtcbiAgICAgICAgICAgIHg6IHRoaXMud2lkdGgsXG4gICAgICAgICAgICB5OiB0aGlzLmhlaWdodCxcbiAgICAgICAgfSwgdGhpcyk7XG4gICAgfTtcbiAgICBpbWcuc3JjID0gc3JjO1xufVxuXG4vKipcbiAqIEBwYXJhbSBpbkltZyB7SW1hZ2VXcmFwcGVyfSBpbnB1dCBpbWFnZSB0byBiZSBzYW1wbGVkXG4gKiBAcGFyYW0gb3V0SW1nIHtJbWFnZVdyYXBwZXJ9IHRvIGJlIHN0b3JlZCBpblxuICovXG5leHBvcnQgZnVuY3Rpb24gaGFsZlNhbXBsZShpbkltZ1dyYXBwZXIsIG91dEltZ1dyYXBwZXIpIHtcbiAgICBjb25zdCBpbkltZyA9IGluSW1nV3JhcHBlci5kYXRhO1xuICAgIGNvbnN0IGluV2lkdGggPSBpbkltZ1dyYXBwZXIuc2l6ZS54O1xuICAgIGNvbnN0IG91dEltZyA9IG91dEltZ1dyYXBwZXIuZGF0YTtcbiAgICBsZXQgdG9wUm93SWR4ID0gMDtcbiAgICBsZXQgYm90dG9tUm93SWR4ID0gaW5XaWR0aDtcbiAgICBjb25zdCBlbmRJZHggPSBpbkltZy5sZW5ndGg7XG4gICAgY29uc3Qgb3V0V2lkdGggPSBpbldpZHRoIC8gMjtcbiAgICBsZXQgb3V0SW1nSWR4ID0gMDtcbiAgICB3aGlsZSAoYm90dG9tUm93SWR4IDwgZW5kSWR4KSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb3V0V2lkdGg7IGkrKykge1xuICAgICAgICAgICAgb3V0SW1nW291dEltZ0lkeF0gPSBNYXRoLmZsb29yKFxuICAgICAgICAgICAgICAgIChpbkltZ1t0b3BSb3dJZHhdICsgaW5JbWdbdG9wUm93SWR4ICsgMV0gKyBpbkltZ1tib3R0b21Sb3dJZHhdICsgaW5JbWdbYm90dG9tUm93SWR4ICsgMV0pIC8gNCxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBvdXRJbWdJZHgrKztcbiAgICAgICAgICAgIHRvcFJvd0lkeCArPSAyO1xuICAgICAgICAgICAgYm90dG9tUm93SWR4ICs9IDI7XG4gICAgICAgIH1cbiAgICAgICAgdG9wUm93SWR4ICs9IGluV2lkdGg7XG4gICAgICAgIGJvdHRvbVJvd0lkeCArPSBpbldpZHRoO1xuICAgIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGhzdjJyZ2IoaHN2LCByZ2IgPSBbMCwgMCwgMF0pIHtcbiAgICBjb25zdCBoID0gaHN2WzBdO1xuICAgIGNvbnN0IHMgPSBoc3ZbMV07XG4gICAgY29uc3QgdiA9IGhzdlsyXTtcbiAgICBjb25zdCBjID0gdiAqIHM7XG4gICAgY29uc3QgeCA9IGMgKiAoMSAtIE1hdGguYWJzKChoIC8gNjApICUgMiAtIDEpKTtcbiAgICBjb25zdCBtID0gdiAtIGM7XG4gICAgbGV0IHIgPSAwO1xuICAgIGxldCBnID0gMDtcbiAgICBsZXQgYiA9IDA7XG5cbiAgICBpZiAoaCA8IDYwKSB7XG4gICAgICAgIHIgPSBjO1xuICAgICAgICBnID0geDtcbiAgICB9IGVsc2UgaWYgKGggPCAxMjApIHtcbiAgICAgICAgciA9IHg7XG4gICAgICAgIGcgPSBjO1xuICAgIH0gZWxzZSBpZiAoaCA8IDE4MCkge1xuICAgICAgICBnID0gYztcbiAgICAgICAgYiA9IHg7XG4gICAgfSBlbHNlIGlmIChoIDwgMjQwKSB7XG4gICAgICAgIGcgPSB4O1xuICAgICAgICBiID0gYztcbiAgICB9IGVsc2UgaWYgKGggPCAzMDApIHtcbiAgICAgICAgciA9IHg7XG4gICAgICAgIGIgPSBjO1xuICAgIH0gZWxzZSBpZiAoaCA8IDM2MCkge1xuICAgICAgICByID0gYztcbiAgICAgICAgYiA9IHg7XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgIHJnYlswXSA9ICgociArIG0pICogMjU1KSB8IDA7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgcmdiWzFdID0gKChnICsgbSkgKiAyNTUpIHwgMDtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICByZ2JbMl0gPSAoKGIgKyBtKSAqIDI1NSkgfCAwO1xuICAgIHJldHVybiByZ2I7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfY29tcHV0ZURpdmlzb3JzKG4pIHtcbiAgICBjb25zdCBsYXJnZURpdmlzb3JzID0gW107XG4gICAgY29uc3QgZGl2aXNvcnMgPSBbXTtcblxuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgTWF0aC5zcXJ0KG4pICsgMTsgaSsrKSB7XG4gICAgICAgIGlmIChuICUgaSA9PT0gMCkge1xuICAgICAgICAgICAgZGl2aXNvcnMucHVzaChpKTtcbiAgICAgICAgICAgIGlmIChpICE9PSBuIC8gaSkge1xuICAgICAgICAgICAgICAgIGxhcmdlRGl2aXNvcnMudW5zaGlmdChNYXRoLmZsb29yKG4gLyBpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGRpdmlzb3JzLmNvbmNhdChsYXJnZURpdmlzb3JzKTtcbn1cblxuZnVuY3Rpb24gX2NvbXB1dGVJbnRlcnNlY3Rpb24oYXJyMSwgYXJyMikge1xuICAgIGxldCBpID0gMDtcbiAgICBsZXQgaiA9IDA7XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG5cbiAgICB3aGlsZSAoaSA8IGFycjEubGVuZ3RoICYmIGogPCBhcnIyLmxlbmd0aCkge1xuICAgICAgICBpZiAoYXJyMVtpXSA9PT0gYXJyMltqXSkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goYXJyMVtpXSk7XG4gICAgICAgICAgICBpKys7XG4gICAgICAgICAgICBqKys7XG4gICAgICAgIH0gZWxzZSBpZiAoYXJyMVtpXSA+IGFycjJbal0pIHtcbiAgICAgICAgICAgIGorKztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY2FsY3VsYXRlUGF0Y2hTaXplKHBhdGNoU2l6ZSwgaW1nU2l6ZSkge1xuICAgIGNvbnN0IGRpdmlzb3JzWCA9IF9jb21wdXRlRGl2aXNvcnMoaW1nU2l6ZS54KTtcbiAgICBjb25zdCBkaXZpc29yc1kgPSBfY29tcHV0ZURpdmlzb3JzKGltZ1NpemUueSk7XG4gICAgY29uc3Qgd2lkZVNpZGUgPSBNYXRoLm1heChpbWdTaXplLngsIGltZ1NpemUueSk7XG4gICAgY29uc3QgY29tbW9uID0gX2NvbXB1dGVJbnRlcnNlY3Rpb24oZGl2aXNvcnNYLCBkaXZpc29yc1kpO1xuICAgIGNvbnN0IG5yT2ZQYXRjaGVzTGlzdCA9IFs4LCAxMCwgMTUsIDIwLCAzMiwgNjAsIDgwXTtcbiAgICBjb25zdCBuck9mUGF0Y2hlc01hcCA9IHtcbiAgICAgICAgJ3gtc21hbGwnOiA1LFxuICAgICAgICBzbWFsbDogNCxcbiAgICAgICAgbWVkaXVtOiAzLFxuICAgICAgICBsYXJnZTogMixcbiAgICAgICAgJ3gtbGFyZ2UnOiAxLFxuICAgIH07XG4gICAgY29uc3QgbnJPZlBhdGNoZXNJZHggPSBuck9mUGF0Y2hlc01hcFtwYXRjaFNpemVdIHx8IG5yT2ZQYXRjaGVzTWFwLm1lZGl1bTtcbiAgICBjb25zdCBuck9mUGF0Y2hlcyA9IG5yT2ZQYXRjaGVzTGlzdFtuck9mUGF0Y2hlc0lkeF07XG4gICAgY29uc3QgZGVzaXJlZFBhdGNoU2l6ZSA9IE1hdGguZmxvb3Iod2lkZVNpZGUgLyBuck9mUGF0Y2hlcyk7XG4gICAgbGV0IG9wdGltYWxQYXRjaFNpemU7XG5cbiAgICBmdW5jdGlvbiBmaW5kUGF0Y2hTaXplRm9yRGl2aXNvcnMoZGl2aXNvcnMpIHtcbiAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICBsZXQgZm91bmQgPSBkaXZpc29yc1tNYXRoLmZsb29yKGRpdmlzb3JzLmxlbmd0aCAvIDIpXTtcblxuICAgICAgICB3aGlsZSAoaSA8IChkaXZpc29ycy5sZW5ndGggLSAxKSAmJiBkaXZpc29yc1tpXSA8IGRlc2lyZWRQYXRjaFNpemUpIHtcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuICAgICAgICBpZiAoaSA+IDApIHtcbiAgICAgICAgICAgIGlmIChNYXRoLmFicyhkaXZpc29yc1tpXSAtIGRlc2lyZWRQYXRjaFNpemUpID4gTWF0aC5hYnMoZGl2aXNvcnNbaSAtIDFdIC0gZGVzaXJlZFBhdGNoU2l6ZSkpIHtcbiAgICAgICAgICAgICAgICBmb3VuZCA9IGRpdmlzb3JzW2kgLSAxXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZm91bmQgPSBkaXZpc29yc1tpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZGVzaXJlZFBhdGNoU2l6ZSAvIGZvdW5kIDwgbnJPZlBhdGNoZXNMaXN0W25yT2ZQYXRjaGVzSWR4ICsgMV0gLyBuck9mUGF0Y2hlc0xpc3RbbnJPZlBhdGNoZXNJZHhdXG4gICAgICAgICAgICAmJiBkZXNpcmVkUGF0Y2hTaXplIC8gZm91bmQgPiBuck9mUGF0Y2hlc0xpc3RbbnJPZlBhdGNoZXNJZHggLSAxXSAvIG5yT2ZQYXRjaGVzTGlzdFtuck9mUGF0Y2hlc0lkeF0pIHtcbiAgICAgICAgICAgIHJldHVybiB7IHg6IGZvdW5kLCB5OiBmb3VuZCB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIG9wdGltYWxQYXRjaFNpemUgPSBmaW5kUGF0Y2hTaXplRm9yRGl2aXNvcnMoY29tbW9uKTtcbiAgICBpZiAoIW9wdGltYWxQYXRjaFNpemUpIHtcbiAgICAgICAgb3B0aW1hbFBhdGNoU2l6ZSA9IGZpbmRQYXRjaFNpemVGb3JEaXZpc29ycyhfY29tcHV0ZURpdmlzb3JzKHdpZGVTaWRlKSk7XG4gICAgICAgIGlmICghb3B0aW1hbFBhdGNoU2l6ZSkge1xuICAgICAgICAgICAgb3B0aW1hbFBhdGNoU2l6ZSA9IGZpbmRQYXRjaFNpemVGb3JEaXZpc29ycygoX2NvbXB1dGVEaXZpc29ycyhkZXNpcmVkUGF0Y2hTaXplICogbnJPZlBhdGNoZXMpKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG9wdGltYWxQYXRjaFNpemU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfcGFyc2VDU1NEaW1lbnNpb25WYWx1ZXModmFsdWUpIHtcbiAgICBjb25zdCBkaW1lbnNpb24gPSB7XG4gICAgICAgIHZhbHVlOiBwYXJzZUZsb2F0KHZhbHVlKSxcbiAgICAgICAgdW5pdDogdmFsdWUuaW5kZXhPZignJScpID09PSB2YWx1ZS5sZW5ndGggLSAxID8gJyUnIDogJyUnLFxuICAgIH07XG5cbiAgICByZXR1cm4gZGltZW5zaW9uO1xufVxuXG5leHBvcnQgY29uc3QgX2RpbWVuc2lvbnNDb252ZXJ0ZXJzID0ge1xuICAgIHRvcChkaW1lbnNpb24sIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIGRpbWVuc2lvbi51bml0ID09PSAnJScgPyBNYXRoLmZsb29yKGNvbnRleHQuaGVpZ2h0ICogKGRpbWVuc2lvbi52YWx1ZSAvIDEwMCkpIDogbnVsbDtcbiAgICB9LFxuICAgIHJpZ2h0KGRpbWVuc2lvbiwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gZGltZW5zaW9uLnVuaXQgPT09ICclJyA/IE1hdGguZmxvb3IoY29udGV4dC53aWR0aCAtIChjb250ZXh0LndpZHRoICogKGRpbWVuc2lvbi52YWx1ZSAvIDEwMCkpKSA6IG51bGw7XG4gICAgfSxcbiAgICBib3R0b20oZGltZW5zaW9uLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiBkaW1lbnNpb24udW5pdCA9PT0gJyUnID8gTWF0aC5mbG9vcihjb250ZXh0LmhlaWdodCAtIChjb250ZXh0LmhlaWdodCAqIChkaW1lbnNpb24udmFsdWUgLyAxMDApKSkgOiBudWxsO1xuICAgIH0sXG4gICAgbGVmdChkaW1lbnNpb24sIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIGRpbWVuc2lvbi51bml0ID09PSAnJScgPyBNYXRoLmZsb29yKGNvbnRleHQud2lkdGggKiAoZGltZW5zaW9uLnZhbHVlIC8gMTAwKSkgOiBudWxsO1xuICAgIH0sXG59O1xuXG5leHBvcnQgZnVuY3Rpb24gY29tcHV0ZUltYWdlQXJlYShpbnB1dFdpZHRoLCBpbnB1dEhlaWdodCwgYXJlYSkge1xuICAgIGNvbnN0IGNvbnRleHQgPSB7IHdpZHRoOiBpbnB1dFdpZHRoLCBoZWlnaHQ6IGlucHV0SGVpZ2h0IH07XG5cbiAgICBjb25zdCBwYXJzZWRBcmVhID0gT2JqZWN0LmtleXMoYXJlYSkucmVkdWNlKChyZXN1bHQsIGtleSkgPT4ge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IGFyZWFba2V5XTtcbiAgICAgICAgY29uc3QgcGFyc2VkID0gX3BhcnNlQ1NTRGltZW5zaW9uVmFsdWVzKHZhbHVlKTtcbiAgICAgICAgY29uc3QgY2FsY3VsYXRlZCA9IF9kaW1lbnNpb25zQ29udmVydGVyc1trZXldKHBhcnNlZCwgY29udGV4dCk7XG5cbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICAgIHJlc3VsdFtrZXldID0gY2FsY3VsYXRlZDtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LCB7fSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBzeDogcGFyc2VkQXJlYS5sZWZ0LFxuICAgICAgICBzeTogcGFyc2VkQXJlYS50b3AsXG4gICAgICAgIHN3OiBwYXJzZWRBcmVhLnJpZ2h0IC0gcGFyc2VkQXJlYS5sZWZ0LFxuICAgICAgICBzaDogcGFyc2VkQXJlYS5ib3R0b20gLSBwYXJzZWRBcmVhLnRvcCxcbiAgICB9O1xufVxuIiwiaW1wb3J0IHsgWFlTaXplIH0gZnJvbSAnLi4vLi4vdHlwZS1kZWZpbml0aW9ucy9xdWFnZ2EuZCc7XG5cbi8vIFRPRE86IFhZUG9zaXRpb24gc2hvdWxkIGJlIGFuIFhZT2JqZWN0LCBidXQgdGhhdCBicmVha3MgWFlEZWZpbml0aW9uLCB3aGljaCBicmVha3MgZHJhd1BhdGgoKSBiZWxvdy5cbmRlY2xhcmUgaW50ZXJmYWNlIFhZUG9zaXRpb24ge1xuICAgIHg6IG51bWJlcjtcbiAgICB5OiBudW1iZXI7XG59XG5cbmRlY2xhcmUgaW50ZXJmYWNlIENhbnZhc1N0eWxlIHtcbiAgICBjb2xvcjogc3RyaW5nO1xuICAgIGxpbmVXaWR0aDogbnVtYmVyO1xufVxuXG4vLyBYWURlZmluaXRpb24gdGVsbHMgdXMgd2hpY2ggY29tcG9uZW50IG9mIGEgZ2l2ZW4gYXJyYXkgb3Igb2JqZWN0IGlzIHRoZSBcIlhcIiBhbmQgd2hpY2ggaXMgdGhlIFwiWVwiLlxuLy8gVXN1YWxseSB0aGlzIGlzIDAgZm9yIFggYW5kIDEgZm9yIFksIGJ1dCBtaWdodCBiZSB1c2VkIGFzICd4JyBmb3IgeCBhbmQgJ3knIGZvciBZLlxuZGVjbGFyZSBpbnRlcmZhY2UgWFlEZWZpbml0aW9uIHtcbiAgICB4OiBrZXlvZiBYWVBvc2l0aW9uO1xuICAgIHk6IGtleW9mIFhZUG9zaXRpb247XG59XG5cbmRlY2xhcmUgdHlwZSBQYXRoID0gQXJyYXk8WFlQb3NpdGlvbj47XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgICBkcmF3UmVjdChwb3M6IFhZUG9zaXRpb24sIHNpemU6IFhZU2l6ZSwgY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQsIHN0eWxlOiBDYW52YXNTdHlsZSk6IHZvaWQge1xuICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBzdHlsZS5jb2xvcjtcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IHN0eWxlLmNvbG9yO1xuICAgICAgICBjdHgubGluZVdpZHRoID0gc3R5bGUubGluZVdpZHRoIHx8IDE7XG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgY3R4LnN0cm9rZVJlY3QocG9zLngsIHBvcy55LCBzaXplLngsIHNpemUueSk7XG4gICAgfSxcbiAgICBkcmF3UGF0aChwYXRoOiBQYXRoLCBkZWY6IFhZRGVmaW5pdGlvbiwgY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQsIHN0eWxlOiBDYW52YXNTdHlsZSk6IHZvaWQge1xuICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBzdHlsZS5jb2xvcjtcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IHN0eWxlLmNvbG9yO1xuICAgICAgICBjdHgubGluZVdpZHRoID0gc3R5bGUubGluZVdpZHRoO1xuICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIGN0eC5tb3ZlVG8ocGF0aFswXVtkZWYueF0sIHBhdGhbMF1bZGVmLnldKTtcbiAgICAgICAgZm9yIChsZXQgaiA9IDE7IGogPCBwYXRoLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICBjdHgubGluZVRvKHBhdGhbal1bZGVmLnhdLCBwYXRoW2pdW2RlZi55XSk7XG4gICAgICAgIH1cbiAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgfSxcbiAgICBkcmF3SW1hZ2UoaW1hZ2VEYXRhOiBBcnJheTxudW1iZXI+LCBzaXplOiBYWVNpemUsIGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEKTogYm9vbGVhbiB7XG4gICAgICAgIGNvbnN0IGNhbnZhc0RhdGEgPSBjdHguZ2V0SW1hZ2VEYXRhKDAsIDAsIHNpemUueCwgc2l6ZS55KTtcbiAgICAgICAgY29uc3QgeyBkYXRhIH0gPSBjYW52YXNEYXRhO1xuICAgICAgICBsZXQgY2FudmFzRGF0YVBvcyA9IGRhdGEubGVuZ3RoO1xuICAgICAgICBsZXQgaW1hZ2VEYXRhUG9zID0gaW1hZ2VEYXRhLmxlbmd0aDtcblxuICAgICAgICBpZiAoY2FudmFzRGF0YVBvcyAvIGltYWdlRGF0YVBvcyAhPT0gNCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlIChpbWFnZURhdGFQb3MtLSkge1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBpbWFnZURhdGFbaW1hZ2VEYXRhUG9zXTtcbiAgICAgICAgICAgIGRhdGFbLS1jYW52YXNEYXRhUG9zXSA9IDI1NTtcbiAgICAgICAgICAgIGRhdGFbLS1jYW52YXNEYXRhUG9zXSA9IHZhbHVlO1xuICAgICAgICAgICAgZGF0YVstLWNhbnZhc0RhdGFQb3NdID0gdmFsdWU7XG4gICAgICAgICAgICBkYXRhWy0tY2FudmFzRGF0YVBvc10gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBjdHgucHV0SW1hZ2VEYXRhKGNhbnZhc0RhdGEsIDAsIDApO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxufTtcbiIsIi8qIGVzbGludC1kaXNhYmxlIG5vLXBhcmFtLXJlYXNzaWduICovXG5pbXBvcnQgeyBUeXBlZEFycmF5IH0gZnJvbSAnLi4vLi4vdHlwZS1kZWZpbml0aW9ucy9xdWFnZ2EnO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gICAgaW5pdChhcnI6IFR5cGVkQXJyYXkgfCBBcnJheTxudW1iZXI+LCB2YWw6IG51bWJlcikge1xuICAgICAgICBhcnIuZmlsbCh2YWwpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBJTi1QTEFDRSBTaHVmZmxlcyB0aGUgY29udGVudCBvZiBhbiBhcnJheVxuICAgICAqL1xuICAgIHNodWZmbGUoYXJyOiBBcnJheTxudW1iZXI+KSB7XG4gICAgICAgIC8vIER1cnN0ZW5mZWxkIHNodWZmbGUgYWxnb3JpdGhtXG4gICAgICAgIC8vIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzI0NTA5NTQvaG93LXRvLXJhbmRvbWl6ZS1zaHVmZmxlLWEtamF2YXNjcmlwdC1hcnJheVxuICAgICAgICBmb3IgKGxldCBpID0gYXJyLmxlbmd0aCAtIDE7IGkgPiAwOyBpLS0pIHtcbiAgICAgICAgICAgIGNvbnN0IGogPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAoaSArIDEpKTtcbiAgICAgICAgICAgIFthcnJbaV0sIGFycltqXV0gPSBbYXJyW2pdLCBhcnJbaV1dO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhcnI7XG4gICAgfSxcblxuICAgIHRvUG9pbnRMaXN0KGFycjogQXJyYXk8QXJyYXk8bnVtYmVyPj4pIHtcbiAgICAgICAgY29uc3Qgcm93cyA9IGFyci5yZWR1Y2UoKHAsIG4pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHJvdyA9IGBbJHtuLmpvaW4oJywnKX1dYDtcbiAgICAgICAgICAgIHAucHVzaChyb3cpO1xuICAgICAgICAgICAgcmV0dXJuIHA7XG4gICAgICAgIH0sIFtdIGFzIEFycmF5PHN0cmluZz4pO1xuICAgICAgICByZXR1cm4gYFske3Jvd3Muam9pbignLFxcclxcbicpfV1gO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiByZXR1cm5zIHRoZSBlbGVtZW50cyB3aGljaCdzIHNjb3JlIGlzIGJpZ2dlciB0aGFuIHRoZSB0aHJlc2hvbGRcbiAgICAgKi9cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICB0aHJlc2hvbGQoYXJyOiBBcnJheTxudW1iZXI+LCB0aHJlc2hvbGQ6IG51bWJlciwgc2NvcmVGdW5jOiAoKHNjb3JlOiBudW1iZXIpID0+IG51bWJlcikpIHtcbiAgICAgICAgY29uc3QgcXVldWUgPSBhcnIucmVkdWNlKChwcmV2OiBBcnJheTxudW1iZXI+LCBuZXh0KSA9PiB7XG4gICAgICAgICAgICBpZiAoc2NvcmVGdW5jLmFwcGx5KGFyciwgW25leHRdKSA+PSB0aHJlc2hvbGQpIHtcbiAgICAgICAgICAgICAgICBwcmV2LnB1c2gobmV4dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcHJldjtcbiAgICAgICAgfSwgW10pO1xuICAgICAgICByZXR1cm4gcXVldWU7XG4gICAgfSxcblxuICAgIG1heEluZGV4KGFycjogQXJyYXk8bnVtYmVyPikge1xuICAgICAgICBsZXQgbWF4ID0gMDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChhcnJbaV0gPiBhcnJbbWF4XSkge1xuICAgICAgICAgICAgICAgIG1heCA9IGk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1heDtcbiAgICB9LFxuXG4gICAgbWF4KGFycjogQXJyYXk8bnVtYmVyPikge1xuICAgICAgICBsZXQgbWF4ID0gMDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChhcnJbaV0gPiBtYXgpIHtcbiAgICAgICAgICAgICAgICBtYXggPSBhcnJbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1heDtcbiAgICB9LFxuXG4gICAgc3VtKGFycjogQXJyYXk8bnVtYmVyPiB8IFR5cGVkQXJyYXkpOiBudW1iZXIge1xuICAgICAgICBsZXQgeyBsZW5ndGggfSA9IGFycjtcbiAgICAgICAgbGV0IHN1bSA9IDA7XG5cbiAgICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgICAgICBzdW0gKz0gYXJyW2xlbmd0aF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN1bTtcbiAgICB9LFxufTtcbiIsImltcG9ydCB7IGNsb25lIH0gZnJvbSAnZ2wtdmVjMic7XG5pbXBvcnQge1xuICAgIFhZU2l6ZSxcbiAgICBUeXBlZEFycmF5Q29uc3RydWN0b3IsXG4gICAgVHlwZWRBcnJheSxcbiAgICBXcmFwcGVySW5kZXhNYXBwaW5nLFxuICAgIE1vbWVudCxcbiAgICBTcGFyc2VJbWFnZVdyYXBwZXIsXG59IGZyb20gJy4uLy4uL3R5cGUtZGVmaW5pdGlvbnMvcXVhZ2dhLmQnO1xuaW1wb3J0IEFycmF5SGVscGVyIGZyb20gJy4vYXJyYXlfaGVscGVyJztcbmltcG9ydCB7IGhzdjJyZ2IgfSBmcm9tICcuL2N2X3V0aWxzJztcblxuY29uc3QgdmVjMiA9IHsgY2xvbmUgfTtcblxudHlwZSBQb3NpdGl2ZU51bWJlciA9IG51bWJlcjtcbmZ1bmN0aW9uIGFzc2VydE51bWJlclBvc2l0aXZlKHZhbDogbnVtYmVyKTogYXNzZXJ0cyB2YWwgaXMgUG9zaXRpdmVOdW1iZXIge1xuICAgIGlmICh2YWwgPCAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgZXhwZWN0ZWQgcG9zaXRpdmUgbnVtYmVyLCByZWNlaXZlZCAke3ZhbH1gKTtcbiAgICB9XG59XG5cbmNsYXNzIEltYWdlV3JhcHBlciBpbXBsZW1lbnRzIFNwYXJzZUltYWdlV3JhcHBlciB7XG4gICAgZGF0YTogVHlwZWRBcnJheSB8IEFycmF5PG51bWJlcj47XG5cbiAgICBzaXplOiBYWVNpemU7XG5cbiAgICBpbmRleE1hcHBpbmc/OiBXcmFwcGVySW5kZXhNYXBwaW5nO1xuXG4gICAgLy8gUmVwcmVzZW50cyBhIGJhc2ljIGltYWdlIGNvbWJpbmluZyB0aGUgZGF0YSBhbmQgc2l6ZS4gSW4gYWRkaXRpb24sIHNvbWUgbWV0aG9kcyBmb3JcbiAgICAvLyBtYW5pcHVsYXRpb24gYXJlIGNvbnRhaW5lZCB3aXRoaW4uXG4gICAgY29uc3RydWN0b3IoXG4gICAgICAgIHNpemU6IFhZU2l6ZSxcbiAgICAgICAgZGF0YT86IFR5cGVkQXJyYXkgfCBBcnJheTxudW1iZXI+LFxuICAgICAgICBBcnJheVR5cGU6IFR5cGVkQXJyYXlDb25zdHJ1Y3RvciB8IEFycmF5Q29uc3RydWN0b3IgPSBVaW50OEFycmF5LFxuICAgICAgICBpbml0aWFsaXplPzogYm9vbGVhbixcbiAgICApIHtcbiAgICAgICAgaWYgKCFkYXRhKSB7XG4gICAgICAgICAgICB0aGlzLmRhdGEgPSBuZXcgKEFycmF5VHlwZSkoc2l6ZS54ICogc2l6ZS55KTtcbiAgICAgICAgICAgIGlmIChpbml0aWFsaXplKSB7XG4gICAgICAgICAgICAgICAgQXJyYXlIZWxwZXIuaW5pdCh0aGlzLmRhdGEsIDApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNpemUgPSBzaXplO1xuICAgIH1cblxuICAgIC8vIHRlc3RzIGlmIGEgcG9zaXRpb24gaXMgd2l0aGluIHRoZSBpbWFnZSwgZXh0ZW5kZWQgb3V0IGJ5IGEgYm9yZGVyIG9uIGVhY2ggc2lkZVxuICAgIGluSW1hZ2VXaXRoQm9yZGVyKGltZ1JlZjogWFlTaXplLCBib3JkZXI6IFBvc2l0aXZlTnVtYmVyID0gMCk6IGJvb2xlYW4ge1xuICAgICAgICBhc3NlcnROdW1iZXJQb3NpdGl2ZShib3JkZXIpO1xuICAgICAgICByZXR1cm4gKGltZ1JlZi54ID49IDApXG4gICAgICAgICAgICAmJiAoaW1nUmVmLnkgPj0gMClcbiAgICAgICAgICAgICYmIChpbWdSZWYueCA8ICh0aGlzLnNpemUueCArIChib3JkZXIgKiAyKSkpXG4gICAgICAgICAgICAmJiAoaW1nUmVmLnkgPCAodGhpcy5zaXplLnkgKyAoYm9yZGVyICogMikpKTtcbiAgICB9XG5cbiAgICAvLyBDb3B5IGZyb20gVEhJUyBJbWFnZVdyYXBwZXIgdG8gdGhlIG5ldyBpbWFnZVdyYXBwZXIgcGFyYW1ldGVyLCBzdGFydGluZyBhdCBmcm9tLCBzdG9wcGluZyBhdFxuICAgIC8vIGVuZCBvZiBuZXcgaW1hZ2VXcmFwcGVyIHNpemUuXG4gICAgc3ViSW1hZ2VBc0NvcHkoaW1hZ2VXcmFwcGVyOiBJbWFnZVdyYXBwZXIsIGZyb206IFhZU2l6ZSk6IEltYWdlV3JhcHBlciB7XG4gICAgICAgIGFzc2VydE51bWJlclBvc2l0aXZlKGZyb20ueCk7XG4gICAgICAgIGFzc2VydE51bWJlclBvc2l0aXZlKGZyb20ueSk7XG4gICAgICAgIGNvbnN0IHsgeDogc2l6ZVgsIHk6IHNpemVZIH0gPSBpbWFnZVdyYXBwZXIuc2l6ZTtcbiAgICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCBzaXplWDsgeCsrKSB7XG4gICAgICAgICAgICBmb3IgKGxldCB5ID0gMDsgeSA8IHNpemVZOyB5KyspIHtcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgICAgICAgICAgICBpbWFnZVdyYXBwZXIuZGF0YVt5ICogc2l6ZVggKyB4XSA9IHRoaXMuZGF0YVsoZnJvbS55ICsgeSkgKiB0aGlzLnNpemUueCArIGZyb20ueCArIHhdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbWFnZVdyYXBwZXI7XG4gICAgICAgIC8vIFRPRE86IHRoaXMgZnVuY3Rpb24gcmVhbGx5IHByb2JhYmx5IHNob3VsZCBjYWxsIGludG8gSW1hZ2VXcmFwcGVyIHNvbWV3aGVyZSB0byBtYWtlXG4gICAgICAgIC8vIHN1cmUgdGhhdCBhbGwgb2YgaXQncyBwYXJhbWV0ZXJzIGFyZSBzZXQgcHJvcGVybHksIHNvbWV0aGluZyBsaWtlXG4gICAgICAgIC8vIEltYWdlV3JhcHBlci5VcGRhdGVGcm9tKClcbiAgICAgICAgLy8gdGhhdCBtaWdodCB0YWtlIGEgcHJvdmlkZWQgZGF0YSBhbmQgc2l6ZSwgYW5kIG1ha2Ugc3VyZSB0aGVyZSdzIG5vIGludmFsaWQgaW5kZXhNYXBwaW5nXG4gICAgICAgIC8vIGhhbmdpbmcgYXJvdW5kLCBhbmQgc3VjaC5cbiAgICB9XG5cbiAgICAvLyBSZXRyaWV2ZSBhIGdyYXlzY2FsZSB2YWx1ZSBhdCB0aGUgZ2l2ZW4gcGl4ZWwgcG9zaXRpb24gb2YgdGhlIGltYWdlXG4gICAgZ2V0KHg6IG51bWJlciwgeTogbnVtYmVyKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YVt5ICogdGhpcy5zaXplLnggKyB4XTtcbiAgICB9XG5cbiAgICAvLyBSZXRyaWV2ZSBhIGdyYXlzY2FsZSB2YWx1ZSBhdCB0aGUgZ2l2ZW4gcGl4ZWwgcG9zaXRpb24gb2YgdGhlIGltYWdlIChzYWZlLCB3aGF0ZXZlciB0aGF0XG4gICAgLy8gbWVhbnMpXG4gICAgZ2V0U2FmZSh4OiBudW1iZXIsIHk6IG51bWJlcik6IG51bWJlciB7XG4gICAgICAgIC8vIGNhY2hlIGluZGV4TWFwcGluZyBiZWNhdXNlIGlmIHdlJ3JlIHVzaW5nIGl0IG9uY2UsIHdlJ2xsIHByb2JhYmx5IG5lZWQgaXQgYSBidW5jaCBtb3JlXG4gICAgICAgIC8vIHRvb1xuICAgICAgICBpZiAoIXRoaXMuaW5kZXhNYXBwaW5nKSB7XG4gICAgICAgICAgICB0aGlzLmluZGV4TWFwcGluZyA9IHtcbiAgICAgICAgICAgICAgICB4OiBbXSxcbiAgICAgICAgICAgICAgICB5OiBbXSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuc2l6ZS54OyBpKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLmluZGV4TWFwcGluZy54W2ldID0gaTtcbiAgICAgICAgICAgICAgICB0aGlzLmluZGV4TWFwcGluZy54W2kgKyB0aGlzLnNpemUueF0gPSBpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnNpemUueTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pbmRleE1hcHBpbmcueVtpXSA9IGk7XG4gICAgICAgICAgICAgICAgdGhpcy5pbmRleE1hcHBpbmcueVtpICsgdGhpcy5zaXplLnldID0gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5kYXRhWyh0aGlzLmluZGV4TWFwcGluZy55W3kgKyB0aGlzLnNpemUueV0pICogdGhpcy5zaXplLnggKyB0aGlzLmluZGV4TWFwcGluZy54W3ggKyB0aGlzLnNpemUueF1dO1xuICAgIH1cblxuICAgIC8vIFNldHMgYSBnaXZlbiBwaXhlbCBwb3NpdGlvbiBpbiB0aGUgaW1hZ2UgdG8gdGhlIGdpdmVuIGdyYXlzY2FsZSB2YWx1ZVxuICAgIHNldCh4OiBudW1iZXIsIHk6IG51bWJlciwgdmFsdWU6IG51bWJlcik6IEltYWdlV3JhcHBlciB7XG4gICAgICAgIHRoaXMuZGF0YVt5ICogdGhpcy5zaXplLnggKyB4XSA9IHZhbHVlO1xuICAgICAgICBkZWxldGUgdGhpcy5pbmRleE1hcHBpbmc7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vIFNldHMgdGhlIGJvcmRlciBvZiB0aGUgaW1hZ2UgKDEgcGl4ZWwpIHRvIHplcm9cbiAgICB6ZXJvQm9yZGVyKCk6IEltYWdlV3JhcHBlciB7XG4gICAgICAgIGNvbnN0IHsgeDogd2lkdGgsIHk6IGhlaWdodCB9ID0gdGhpcy5zaXplO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHdpZHRoOyBpKyspIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1tdWx0aS1hc3NpZ25cbiAgICAgICAgICAgIHRoaXMuZGF0YVtpXSA9IHRoaXMuZGF0YVsoaGVpZ2h0IC0gMSkgKiB3aWR0aCArIGldID0gMDtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IGhlaWdodCAtIDE7IGkrKykge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLW11bHRpLWFzc2lnblxuICAgICAgICAgICAgdGhpcy5kYXRhW2kgKiB3aWR0aF0gPSB0aGlzLmRhdGFbaSAqIHdpZHRoICsgKHdpZHRoIC0gMSldID0gMDtcbiAgICAgICAgfVxuICAgICAgICBkZWxldGUgdGhpcy5pbmRleE1hcHBpbmc7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vIFRPRE86IHRoaXMgZnVuY3Rpb24gaXMgZW50aXJlbHkgdG9vIGxhcmdlIGZvciBtZSB0byByZWFzb24gb3V0IHJpZ2h0IGF0IHRoaXMgbW9tZW50IHRoYXQgaSdtIGhhbmRsaW5nXG4gICAgLy8gYWxsIHRoZSByZXN0IG9mIGl0LCBzbyB0aGlzIGlzIGEgdmVyYmF0aW0gY29weSBvZiB0aGUgamF2YXNjcmlwdCBzb3VyY2UsIHdpdGggb25seSB0d2Vha3NcbiAgICAvLyBuZWNlc3NhcnkgdG8gZ2V0IGl0IHRvIHJ1biwgbm8gdGhvdWdodCBwdXQgaW50byBpdCB5ZXQuXG4gICAgbW9tZW50cyhsYWJlbENvdW50OiBudW1iZXIpOiBBcnJheTxNb21lbnQ+IHtcbiAgICAgICAgY29uc3QgeyBkYXRhIH0gPSB0aGlzO1xuICAgICAgICBsZXQgeDtcbiAgICAgICAgbGV0IHk7XG4gICAgICAgIGNvbnN0IGhlaWdodCA9IHRoaXMuc2l6ZS55O1xuICAgICAgICBjb25zdCB3aWR0aCA9IHRoaXMuc2l6ZS54O1xuICAgICAgICBsZXQgdmFsO1xuICAgICAgICBsZXQgeXNxO1xuICAgICAgICBjb25zdCBsYWJlbFN1bTogQXJyYXk8TW9tZW50PiA9IFtdO1xuICAgICAgICBsZXQgaTtcbiAgICAgICAgbGV0IGxhYmVsO1xuICAgICAgICBsZXQgbXUxMTtcbiAgICAgICAgbGV0IG11MDI7XG4gICAgICAgIGxldCBtdTIwO1xuICAgICAgICBsZXQgeF87XG4gICAgICAgIGxldCB5XztcbiAgICAgICAgbGV0IHRtcDtcbiAgICAgICAgY29uc3QgcmVzdWx0OiBBcnJheTxNb21lbnQ+ID0gW107XG4gICAgICAgIGNvbnN0IHsgUEkgfSA9IE1hdGg7XG4gICAgICAgIGNvbnN0IFBJXzQgPSBQSSAvIDQ7XG5cbiAgICAgICAgaWYgKGxhYmVsQ291bnQgPD0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsYWJlbENvdW50OyBpKyspIHtcbiAgICAgICAgICAgIGxhYmVsU3VtW2ldID0ge1xuICAgICAgICAgICAgICAgIG0wMDogMCxcbiAgICAgICAgICAgICAgICBtMDE6IDAsXG4gICAgICAgICAgICAgICAgbTEwOiAwLFxuICAgICAgICAgICAgICAgIG0xMTogMCxcbiAgICAgICAgICAgICAgICBtMDI6IDAsXG4gICAgICAgICAgICAgICAgbTIwOiAwLFxuICAgICAgICAgICAgICAgIHRoZXRhOiAwLFxuICAgICAgICAgICAgICAgIHJhZDogMCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHkgPSAwOyB5IDwgaGVpZ2h0OyB5KyspIHtcbiAgICAgICAgICAgIHlzcSA9IHkgKiB5O1xuICAgICAgICAgICAgZm9yICh4ID0gMDsgeCA8IHdpZHRoOyB4KyspIHtcbiAgICAgICAgICAgICAgICB2YWwgPSBkYXRhW3kgKiB3aWR0aCArIHhdO1xuICAgICAgICAgICAgICAgIGlmICh2YWwgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGxhYmVsID0gbGFiZWxTdW1bdmFsIC0gMV07XG4gICAgICAgICAgICAgICAgICAgIGxhYmVsLm0wMCArPSAxO1xuICAgICAgICAgICAgICAgICAgICBsYWJlbC5tMDEgKz0geTtcbiAgICAgICAgICAgICAgICAgICAgbGFiZWwubTEwICs9IHg7XG4gICAgICAgICAgICAgICAgICAgIGxhYmVsLm0xMSArPSB4ICogeTtcbiAgICAgICAgICAgICAgICAgICAgbGFiZWwubTAyICs9IHlzcTtcbiAgICAgICAgICAgICAgICAgICAgbGFiZWwubTIwICs9IHggKiB4O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsYWJlbENvdW50OyBpKyspIHtcbiAgICAgICAgICAgIGxhYmVsID0gbGFiZWxTdW1baV07XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVzdHJpY3RlZC1nbG9iYWxzXG4gICAgICAgICAgICBpZiAoIWlzTmFOKGxhYmVsLm0wMCkgJiYgbGFiZWwubTAwICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgeF8gPSBsYWJlbC5tMTAgLyBsYWJlbC5tMDA7XG4gICAgICAgICAgICAgICAgeV8gPSBsYWJlbC5tMDEgLyBsYWJlbC5tMDA7XG4gICAgICAgICAgICAgICAgbXUxMSA9IGxhYmVsLm0xMSAvIGxhYmVsLm0wMCAtIHhfICogeV87XG4gICAgICAgICAgICAgICAgbXUwMiA9IGxhYmVsLm0wMiAvIGxhYmVsLm0wMCAtIHlfICogeV87XG4gICAgICAgICAgICAgICAgbXUyMCA9IGxhYmVsLm0yMCAvIGxhYmVsLm0wMCAtIHhfICogeF87XG4gICAgICAgICAgICAgICAgdG1wID0gKG11MDIgLSBtdTIwKSAvICgyICogbXUxMSk7XG4gICAgICAgICAgICAgICAgdG1wID0gMC41ICogTWF0aC5hdGFuKHRtcCkgKyAobXUxMSA+PSAwID8gUElfNCA6IC1QSV80KSArIFBJO1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1taXhlZC1vcGVyYXRvcnNcbiAgICAgICAgICAgICAgICBsYWJlbC50aGV0YSA9ICh0bXAgKiAxODAgLyBQSSArIDkwKSAlIDE4MCAtIDkwO1xuICAgICAgICAgICAgICAgIGlmIChsYWJlbC50aGV0YSA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgbGFiZWwudGhldGEgKz0gMTgwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsYWJlbC5yYWQgPSB0bXAgPiBQSSA/IHRtcCAtIFBJIDogdG1wO1xuICAgICAgICAgICAgICAgIGxhYmVsLnZlYyA9IHZlYzIuY2xvbmUoW01hdGguY29zKHRtcCksIE1hdGguc2luKHRtcCldKTtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChsYWJlbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvLyByZXR1cm4gYSBVaW50OENsYW1wZWRBcnJheSBjb250YWluaW5nIHRoaXMgZ3JheXNjYWxlIGltYWdlIGNvbnZlcnRlZCB0byBSR0JBIGZvcm1cbiAgICBnZXRBc1JHQkEoc2NhbGUgPSAxLjApOiBVaW50OENsYW1wZWRBcnJheSB7XG4gICAgICAgIGNvbnN0IHJldCA9IG5ldyBVaW50OENsYW1wZWRBcnJheSg0ICogdGhpcy5zaXplLnggKiB0aGlzLnNpemUueSk7XG4gICAgICAgIGZvciAobGV0IHkgPSAwOyB5IDwgdGhpcy5zaXplLnk7IHkrKykge1xuICAgICAgICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCB0aGlzLnNpemUueDsgeCsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcGl4ZWwgPSB5ICogdGhpcy5zaXplLnggKyB4O1xuICAgICAgICAgICAgICAgIGNvbnN0IGN1cnJlbnQgPSB0aGlzLmdldCh4LCB5KSAqIHNjYWxlO1xuICAgICAgICAgICAgICAgIHJldFtwaXhlbCAqIDQgKyAwXSA9IGN1cnJlbnQ7XG4gICAgICAgICAgICAgICAgcmV0W3BpeGVsICogNCArIDFdID0gY3VycmVudDtcbiAgICAgICAgICAgICAgICByZXRbcGl4ZWwgKiA0ICsgMl0gPSBjdXJyZW50O1xuICAgICAgICAgICAgICAgIHJldFtwaXhlbCAqIDQgKyAzXSA9IDI1NTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cblxuICAgIC8vIERpc3BsYXkgdGhpcyBJbWFnZVdyYXBwZXIgaW4gYSBnaXZlbiBDYW52YXMgZWxlbWVudCBhdCB0aGUgc3BlY2lmaWVkIHNjYWxlXG4gICAgc2hvdyhjYW52YXM6IEhUTUxDYW52YXNFbGVtZW50LCBzY2FsZSA9IDEuMCk6IHZvaWQge1xuICAgICAgICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgICAgaWYgKCFjdHgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5hYmxlIHRvIGdldCBjYW52YXMgY29udGV4dCcpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZyYW1lID0gY3R4LmdldEltYWdlRGF0YSgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuICAgICAgICBjb25zdCBkYXRhID0gdGhpcy5nZXRBc1JHQkEoc2NhbGUpO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgICAgY2FudmFzLndpZHRoID0gdGhpcy5zaXplLng7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgICBjYW52YXMuaGVpZ2h0ID0gdGhpcy5zaXplLnk7XG4gICAgICAgIGNvbnN0IG5ld0ZyYW1lID0gbmV3IEltYWdlRGF0YShkYXRhLCBmcmFtZS53aWR0aCwgZnJhbWUuaGVpZ2h0KTtcbiAgICAgICAgY3R4LnB1dEltYWdlRGF0YShuZXdGcmFtZSwgMCwgMCk7XG4gICAgfVxuXG4gICAgLy8gRGlzcGxheXMgYSBzcGVjaWZpZWQgU3ViSW1hZ2UgYXJlYSBpbiBhIGdpdmVuIGNhbnZhcy4gVGhpcyBkaWZmZXJzIGRyYXN0aWNhbGx5IGZyb21cbiAgICAvLyBjcmVhdGluZyBhIG5ldyBTdWJJbWFnZSBhbmQgdXNpbmcgaXQncyBzaG93KCkgbWV0aG9kLiBXaHk/IEkgZG9uJ3QgaGF2ZSB0aGUgYW5zd2VyIHRvIHRoYXRcbiAgICAvLyB5ZXQuICBJIHN1c3BlY3QgdGhlIEhTVi9SR0Igb3BlcmF0aW9ucyBpbnZvbHZlZCBoZXJlIGFyZSBtYWtpbmcgaXQgc2lnbmlmaWNhbnRseSBkaWZmZXJlbnQsXG4gICAgLy8gYnV0IHVudGlsIEkgY2FuIHZpc3VhbGl6ZSB0aGVzZSBmdW5jdGlvbnMgc2lkZSBieSBzaWRlLCBJJ20ganVzdCBnb2luZyB0byBjb3B5IHRoZSBleGlzdGluZ1xuICAgIC8vIGltcGxlbWVudGF0aW9uLlxuICAgIG92ZXJsYXkoY2FudmFzOiBIVE1MQ2FudmFzRWxlbWVudCwgaW5TY2FsZTogbnVtYmVyLCBmcm9tOiBYWVNpemUpOiB2b2lkIHtcbiAgICAgICAgY29uc3QgYWRqdXN0ZWRTY2FsZSA9IChpblNjYWxlIDwgMCB8fCBpblNjYWxlID4gMzYwKSA/IDM2MCA6IGluU2NhbGU7XG4gICAgICAgIGNvbnN0IGhzdiA9IFswLCAxLCAxXTtcbiAgICAgICAgY29uc3QgcmdiID0gWzAsIDAsIDBdO1xuICAgICAgICBjb25zdCB3aGl0ZVJnYiA9IFsyNTUsIDI1NSwgMjU1XTtcbiAgICAgICAgY29uc3QgYmxhY2tSZ2IgPSBbMCwgMCwgMF07XG4gICAgICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICAgICAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgIGlmICghY3R4KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuYWJsZSB0byBnZXQgY2FudmFzIGNvbnRleHQnKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmcmFtZSA9IGN0eC5nZXRJbWFnZURhdGEoZnJvbS54LCBmcm9tLnksIHRoaXMuc2l6ZS54LCB0aGlzLnNpemUueSk7XG4gICAgICAgIGNvbnN0IHsgZGF0YSB9ID0gZnJhbWU7XG4gICAgICAgIGxldCB7IGxlbmd0aCB9ID0gdGhpcy5kYXRhO1xuICAgICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgICAgIGhzdlswXSA9IHRoaXMuZGF0YVtsZW5ndGhdICogYWRqdXN0ZWRTY2FsZTtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1uZXN0ZWQtdGVybmFyeVxuICAgICAgICAgICAgcmVzdWx0ID0gaHN2WzBdIDw9IDAgPyB3aGl0ZVJnYiA6IGhzdlswXSA+PSAzNjAgPyBibGFja1JnYiA6IGhzdjJyZ2IoaHN2LCByZ2IpO1xuICAgICAgICAgICAgY29uc3QgcG9zID0gbGVuZ3RoICogNDtcbiAgICAgICAgICAgIFtkYXRhW3Bvc10sIGRhdGFbcG9zICsgMV0sIGRhdGFbcG9zICsgMl1dID0gcmVzdWx0O1xuICAgICAgICAgICAgZGF0YVtwb3MgKyAzXSA9IDI1NTtcbiAgICAgICAgfVxuICAgICAgICBjdHgucHV0SW1hZ2VEYXRhKGZyYW1lLCBmcm9tLngsIGZyb20ueSk7XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBJbWFnZVdyYXBwZXI7XG4iLCJmdW5jdGlvbiBhc3luY0dlbmVyYXRvclN0ZXAoZ2VuLCByZXNvbHZlLCByZWplY3QsIF9uZXh0LCBfdGhyb3csIGtleSwgYXJnKSB7XG4gIHRyeSB7XG4gICAgdmFyIGluZm8gPSBnZW5ba2V5XShhcmcpO1xuICAgIHZhciB2YWx1ZSA9IGluZm8udmFsdWU7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmVqZWN0KGVycm9yKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoaW5mby5kb25lKSB7XG4gICAgcmVzb2x2ZSh2YWx1ZSk7XG4gIH0gZWxzZSB7XG4gICAgUHJvbWlzZS5yZXNvbHZlKHZhbHVlKS50aGVuKF9uZXh0LCBfdGhyb3cpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9hc3luY1RvR2VuZXJhdG9yKGZuKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzLFxuICAgICAgICBhcmdzID0gYXJndW1lbnRzO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICB2YXIgZ2VuID0gZm4uYXBwbHkoc2VsZiwgYXJncyk7XG5cbiAgICAgIGZ1bmN0aW9uIF9uZXh0KHZhbHVlKSB7XG4gICAgICAgIGFzeW5jR2VuZXJhdG9yU3RlcChnZW4sIHJlc29sdmUsIHJlamVjdCwgX25leHQsIF90aHJvdywgXCJuZXh0XCIsIHZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gX3Rocm93KGVycikge1xuICAgICAgICBhc3luY0dlbmVyYXRvclN0ZXAoZ2VuLCByZXNvbHZlLCByZWplY3QsIF9uZXh0LCBfdGhyb3csIFwidGhyb3dcIiwgZXJyKTtcbiAgICAgIH1cblxuICAgICAgX25leHQodW5kZWZpbmVkKTtcbiAgICB9KTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfYXN5bmNUb0dlbmVyYXRvciwgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzOyIsInZhciBzdXBlclByb3BCYXNlID0gcmVxdWlyZShcIi4vc3VwZXJQcm9wQmFzZS5qc1wiKTtcblxuZnVuY3Rpb24gX2dldCgpIHtcbiAgaWYgKHR5cGVvZiBSZWZsZWN0ICE9PSBcInVuZGVmaW5lZFwiICYmIFJlZmxlY3QuZ2V0KSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBfZ2V0ID0gUmVmbGVjdC5nZXQuYmluZCgpLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZSwgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHM7XG4gIH0gZWxzZSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBfZ2V0ID0gZnVuY3Rpb24gX2dldCh0YXJnZXQsIHByb3BlcnR5LCByZWNlaXZlcikge1xuICAgICAgdmFyIGJhc2UgPSBzdXBlclByb3BCYXNlKHRhcmdldCwgcHJvcGVydHkpO1xuICAgICAgaWYgKCFiYXNlKSByZXR1cm47XG4gICAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoYmFzZSwgcHJvcGVydHkpO1xuXG4gICAgICBpZiAoZGVzYy5nZXQpIHtcbiAgICAgICAgcmV0dXJuIGRlc2MuZ2V0LmNhbGwoYXJndW1lbnRzLmxlbmd0aCA8IDMgPyB0YXJnZXQgOiByZWNlaXZlcik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBkZXNjLnZhbHVlO1xuICAgIH0sIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlLCBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0cztcbiAgfVxuXG4gIHJldHVybiBfZ2V0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2dldCwgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzOyIsIi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgdGhlXG4gKiBbbGFuZ3VhZ2UgdHlwZV0oaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLWVjbWFzY3JpcHQtbGFuZ3VhZ2UtdHlwZXMpXG4gKiBvZiBgT2JqZWN0YC4gKGUuZy4gYXJyYXlzLCBmdW5jdGlvbnMsIG9iamVjdHMsIHJlZ2V4ZXMsIGBuZXcgTnVtYmVyKDApYCwgYW5kIGBuZXcgU3RyaW5nKCcnKWApXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNPYmplY3Qoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KF8ubm9vcCk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChudWxsKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiAodHlwZSA9PSAnb2JqZWN0JyB8fCB0eXBlID09ICdmdW5jdGlvbicpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzT2JqZWN0O1xuIiwiLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGFuIGBBcnJheWAgb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGFycmF5LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcnJheShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheShkb2N1bWVudC5ib2R5LmNoaWxkcmVuKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0FycmF5KCdhYmMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0FycmF5KF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXk7XG5cbm1vZHVsZS5leHBvcnRzID0gaXNBcnJheTtcbiIsImZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7XG4gIFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjtcblxuICByZXR1cm4gKG1vZHVsZS5leHBvcnRzID0gX3R5cGVvZiA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIFwic3ltYm9sXCIgPT0gdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA/IGZ1bmN0aW9uIChvYmopIHtcbiAgICByZXR1cm4gdHlwZW9mIG9iajtcbiAgfSA6IGZ1bmN0aW9uIChvYmopIHtcbiAgICByZXR1cm4gb2JqICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqO1xuICB9LCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZSwgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHMpLCBfdHlwZW9mKG9iaik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX3R5cGVvZiwgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzOyIsInZhciBiYXNlTWVyZ2UgPSByZXF1aXJlKCcuL19iYXNlTWVyZ2UnKSxcbiAgICBjcmVhdGVBc3NpZ25lciA9IHJlcXVpcmUoJy4vX2NyZWF0ZUFzc2lnbmVyJyk7XG5cbi8qKlxuICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5hc3NpZ25gIGV4Y2VwdCB0aGF0IGl0IHJlY3Vyc2l2ZWx5IG1lcmdlcyBvd24gYW5kXG4gKiBpbmhlcml0ZWQgZW51bWVyYWJsZSBzdHJpbmcga2V5ZWQgcHJvcGVydGllcyBvZiBzb3VyY2Ugb2JqZWN0cyBpbnRvIHRoZVxuICogZGVzdGluYXRpb24gb2JqZWN0LiBTb3VyY2UgcHJvcGVydGllcyB0aGF0IHJlc29sdmUgdG8gYHVuZGVmaW5lZGAgYXJlXG4gKiBza2lwcGVkIGlmIGEgZGVzdGluYXRpb24gdmFsdWUgZXhpc3RzLiBBcnJheSBhbmQgcGxhaW4gb2JqZWN0IHByb3BlcnRpZXNcbiAqIGFyZSBtZXJnZWQgcmVjdXJzaXZlbHkuIE90aGVyIG9iamVjdHMgYW5kIHZhbHVlIHR5cGVzIGFyZSBvdmVycmlkZGVuIGJ5XG4gKiBhc3NpZ25tZW50LiBTb3VyY2Ugb2JqZWN0cyBhcmUgYXBwbGllZCBmcm9tIGxlZnQgdG8gcmlnaHQuIFN1YnNlcXVlbnRcbiAqIHNvdXJjZXMgb3ZlcndyaXRlIHByb3BlcnR5IGFzc2lnbm1lbnRzIG9mIHByZXZpb3VzIHNvdXJjZXMuXG4gKlxuICogKipOb3RlOioqIFRoaXMgbWV0aG9kIG11dGF0ZXMgYG9iamVjdGAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjUuMFxuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICogQHBhcmFtIHsuLi5PYmplY3R9IFtzb3VyY2VzXSBUaGUgc291cmNlIG9iamVjdHMuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0ge1xuICogICAnYSc6IFt7ICdiJzogMiB9LCB7ICdkJzogNCB9XVxuICogfTtcbiAqXG4gKiB2YXIgb3RoZXIgPSB7XG4gKiAgICdhJzogW3sgJ2MnOiAzIH0sIHsgJ2UnOiA1IH1dXG4gKiB9O1xuICpcbiAqIF8ubWVyZ2Uob2JqZWN0LCBvdGhlcik7XG4gKiAvLyA9PiB7ICdhJzogW3sgJ2InOiAyLCAnYyc6IDMgfSwgeyAnZCc6IDQsICdlJzogNSB9XSB9XG4gKi9cbnZhciBtZXJnZSA9IGNyZWF0ZUFzc2lnbmVyKGZ1bmN0aW9uKG9iamVjdCwgc291cmNlLCBzcmNJbmRleCkge1xuICBiYXNlTWVyZ2Uob2JqZWN0LCBzb3VyY2UsIHNyY0luZGV4KTtcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IG1lcmdlO1xuIiwidmFyIGZyZWVHbG9iYWwgPSByZXF1aXJlKCcuL19mcmVlR2xvYmFsJyk7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgc2VsZmAuICovXG52YXIgZnJlZVNlbGYgPSB0eXBlb2Ygc2VsZiA9PSAnb2JqZWN0JyAmJiBzZWxmICYmIHNlbGYuT2JqZWN0ID09PSBPYmplY3QgJiYgc2VsZjtcblxuLyoqIFVzZWQgYXMgYSByZWZlcmVuY2UgdG8gdGhlIGdsb2JhbCBvYmplY3QuICovXG52YXIgcm9vdCA9IGZyZWVHbG9iYWwgfHwgZnJlZVNlbGYgfHwgRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcblxubW9kdWxlLmV4cG9ydHMgPSByb290O1xuIiwiLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZS4gQSB2YWx1ZSBpcyBvYmplY3QtbGlrZSBpZiBpdCdzIG5vdCBgbnVsbGBcbiAqIGFuZCBoYXMgYSBgdHlwZW9mYCByZXN1bHQgb2YgXCJvYmplY3RcIi5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZSh7fSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdExpa2UoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShudWxsKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0TGlrZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNPYmplY3RMaWtlO1xuIiwiLyoqXG4gKiBodHRwOi8vd3d3LmNvZGVwcm9qZWN0LmNvbS9UaXBzLzQwNzE3Mi9Db25uZWN0ZWQtQ29tcG9uZW50LUxhYmVsaW5nLWFuZC1WZWN0b3JpemF0aW9uXG4gKi9cbmNvbnN0IFRyYWNlciA9IHtcbiAgICBzZWFyY2hEaXJlY3Rpb25zOiBbWzAsIDFdLCBbMSwgMV0sIFsxLCAwXSwgWzEsIC0xXSwgWzAsIC0xXSwgWy0xLCAtMV0sIFstMSwgMF0sIFstMSwgMV1dLFxuICAgIGNyZWF0ZShpbWFnZVdyYXBwZXIsIGxhYmVsV3JhcHBlcikge1xuICAgICAgICBjb25zdCBpbWFnZURhdGEgPSBpbWFnZVdyYXBwZXIuZGF0YTtcbiAgICAgICAgY29uc3QgbGFiZWxEYXRhID0gbGFiZWxXcmFwcGVyLmRhdGE7XG4gICAgICAgIGNvbnN0IHsgc2VhcmNoRGlyZWN0aW9ucyB9ID0gdGhpcztcbiAgICAgICAgY29uc3Qgd2lkdGggPSBpbWFnZVdyYXBwZXIuc2l6ZS54O1xuICAgICAgICBsZXQgcG9zO1xuXG4gICAgICAgIGZ1bmN0aW9uIHRyYWNlKGN1cnJlbnQsIGNvbG9yLCBsYWJlbCwgZWRnZWxhYmVsKSB7XG4gICAgICAgICAgICBsZXQgaTtcbiAgICAgICAgICAgIGxldCB5O1xuICAgICAgICAgICAgbGV0IHg7XG5cbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBzZWFyY2hEaXJlY3Rpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgeSA9IGN1cnJlbnQuY3kgKyBzZWFyY2hEaXJlY3Rpb25zW2N1cnJlbnQuZGlyXVswXTtcbiAgICAgICAgICAgICAgICB4ID0gY3VycmVudC5jeCArIHNlYXJjaERpcmVjdGlvbnNbY3VycmVudC5kaXJdWzFdO1xuICAgICAgICAgICAgICAgIHBvcyA9IHkgKiB3aWR0aCArIHg7XG4gICAgICAgICAgICAgICAgaWYgKChpbWFnZURhdGFbcG9zXSA9PT0gY29sb3IpICYmICgobGFiZWxEYXRhW3Bvc10gPT09IDApIHx8IChsYWJlbERhdGFbcG9zXSA9PT0gbGFiZWwpKSkge1xuICAgICAgICAgICAgICAgICAgICBsYWJlbERhdGFbcG9zXSA9IGxhYmVsO1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50LmN5ID0geTtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudC5jeCA9IHg7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobGFiZWxEYXRhW3Bvc10gPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgbGFiZWxEYXRhW3Bvc10gPSBlZGdlbGFiZWw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGN1cnJlbnQuZGlyID0gKGN1cnJlbnQuZGlyICsgMSkgJSA4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gdmVydGV4MkQoeCwgeSwgZGlyKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGRpcixcbiAgICAgICAgICAgICAgICB4LFxuICAgICAgICAgICAgICAgIHksXG4gICAgICAgICAgICAgICAgbmV4dDogbnVsbCxcbiAgICAgICAgICAgICAgICBwcmV2OiBudWxsLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGNvbnRvdXJUcmFjaW5nKHN5LCBzeCwgbGFiZWwsIGNvbG9yLCBlZGdlbGFiZWwpIHtcbiAgICAgICAgICAgIGxldCBGdiA9IG51bGw7XG4gICAgICAgICAgICBsZXQgQ3Y7XG4gICAgICAgICAgICBsZXQgUDtcbiAgICAgICAgICAgIGxldCBsZGlyO1xuICAgICAgICAgICAgY29uc3QgY3VycmVudCA9IHtcbiAgICAgICAgICAgICAgICBjeDogc3gsXG4gICAgICAgICAgICAgICAgY3k6IHN5LFxuICAgICAgICAgICAgICAgIGRpcjogMCxcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGlmICh0cmFjZShjdXJyZW50LCBjb2xvciwgbGFiZWwsIGVkZ2VsYWJlbCkpIHtcbiAgICAgICAgICAgICAgICBGdiA9IHZlcnRleDJEKHN4LCBzeSwgY3VycmVudC5kaXIpO1xuICAgICAgICAgICAgICAgIEN2ID0gRnY7XG4gICAgICAgICAgICAgICAgbGRpciA9IGN1cnJlbnQuZGlyO1xuICAgICAgICAgICAgICAgIFAgPSB2ZXJ0ZXgyRChjdXJyZW50LmN4LCBjdXJyZW50LmN5LCAwKTtcbiAgICAgICAgICAgICAgICBQLnByZXYgPSBDdjtcbiAgICAgICAgICAgICAgICBDdi5uZXh0ID0gUDtcbiAgICAgICAgICAgICAgICBQLm5leHQgPSBudWxsO1xuICAgICAgICAgICAgICAgIEN2ID0gUDtcblxuICAgICAgICAgICAgICAgIGxldCB0b3RhbFBpeGVsQ291bnQgPSBpbWFnZVdyYXBwZXIuc2l6ZS54ICogaW1hZ2VXcmFwcGVyLnNpemUueTtcbiAgICAgICAgICAgICAgICBsZXQgcGl4ZWxDb3VudGVyID0gMDtcbiAgICAgICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnQuZGlyID0gKGN1cnJlbnQuZGlyICsgNikgJSA4O1xuICAgICAgICAgICAgICAgICAgICB0cmFjZShjdXJyZW50LCBjb2xvciwgbGFiZWwsIGVkZ2VsYWJlbCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsZGlyICE9PSBjdXJyZW50LmRpcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgQ3YuZGlyID0gY3VycmVudC5kaXI7XG4gICAgICAgICAgICAgICAgICAgICAgICBQID0gdmVydGV4MkQoY3VycmVudC5jeCwgY3VycmVudC5jeSwgMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBQLnByZXYgPSBDdjtcbiAgICAgICAgICAgICAgICAgICAgICAgIEN2Lm5leHQgPSBQO1xuICAgICAgICAgICAgICAgICAgICAgICAgUC5uZXh0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIEN2ID0gUDtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIEN2LmRpciA9IGxkaXI7XG4gICAgICAgICAgICAgICAgICAgICAgICBDdi54ID0gY3VycmVudC5jeDtcbiAgICAgICAgICAgICAgICAgICAgICAgIEN2LnkgPSBjdXJyZW50LmN5O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGxkaXIgPSBjdXJyZW50LmRpcjtcbiAgICAgICAgICAgICAgICB9IHdoaWxlICgoY3VycmVudC5jeCAhPT0gc3ggfHwgY3VycmVudC5jeSAhPT0gc3kpICYmICsrcGl4ZWxDb3VudGVyIDwgdG90YWxQaXhlbENvdW50KTtcbiAgICAgICAgICAgICAgICBGdi5wcmV2ID0gQ3YucHJldjtcbiAgICAgICAgICAgICAgICBDdi5wcmV2Lm5leHQgPSBGdjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBGdjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0cmFjZShjdXJyZW50LCBjb2xvciwgbGFiZWwsIGVkZ2VsYWJlbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cmFjZShjdXJyZW50LCBjb2xvciwgbGFiZWwsIGVkZ2VsYWJlbCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY29udG91clRyYWNpbmcoc3ksIHN4LCBsYWJlbCwgY29sb3IsIGVkZ2VsYWJlbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb250b3VyVHJhY2luZyhzeSwgc3gsIGxhYmVsLCBjb2xvciwgZWRnZWxhYmVsKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfSxcbn07XG5cbmV4cG9ydCBkZWZhdWx0IChUcmFjZXIpO1xuIiwidmFyIFN5bWJvbCA9IHJlcXVpcmUoJy4vX1N5bWJvbCcpLFxuICAgIGdldFJhd1RhZyA9IHJlcXVpcmUoJy4vX2dldFJhd1RhZycpLFxuICAgIG9iamVjdFRvU3RyaW5nID0gcmVxdWlyZSgnLi9fb2JqZWN0VG9TdHJpbmcnKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIG51bGxUYWcgPSAnW29iamVjdCBOdWxsXScsXG4gICAgdW5kZWZpbmVkVGFnID0gJ1tvYmplY3QgVW5kZWZpbmVkXSc7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHN5bVRvU3RyaW5nVGFnID0gU3ltYm9sID8gU3ltYm9sLnRvU3RyaW5nVGFnIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBnZXRUYWdgIHdpdGhvdXQgZmFsbGJhY2tzIGZvciBidWdneSBlbnZpcm9ubWVudHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgYHRvU3RyaW5nVGFnYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUdldFRhZyh2YWx1ZSkge1xuICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkVGFnIDogbnVsbFRhZztcbiAgfVxuICByZXR1cm4gKHN5bVRvU3RyaW5nVGFnICYmIHN5bVRvU3RyaW5nVGFnIGluIE9iamVjdCh2YWx1ZSkpXG4gICAgPyBnZXRSYXdUYWcodmFsdWUpXG4gICAgOiBvYmplY3RUb1N0cmluZyh2YWx1ZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUdldFRhZztcbiIsImltcG9ydCAqIGFzIHZlYzIgZnJvbSAnZ2wtdmVjMic7XG5pbXBvcnQgKiBhcyBtYXQyIGZyb20gJ2dsLW1hdDInO1xuaW1wb3J0IEltYWdlV3JhcHBlciBmcm9tICcuLi9jb21tb24vaW1hZ2Vfd3JhcHBlcic7XG5pbXBvcnQge1xuICAgIGNhbGN1bGF0ZVBhdGNoU2l6ZSxcbiAgICBvdHN1VGhyZXNob2xkLFxuICAgIGhzdjJyZ2IsXG4gICAgY2x1c3RlcixcbiAgICB0b3BHZW5lcmljLFxuICAgIGltYWdlUmVmLFxuICAgIGhhbGZTYW1wbGUsXG4gICAgY29tcHV0ZUltYWdlQXJlYSxcbn0gZnJvbSAnLi4vY29tbW9uL2N2X3V0aWxzJztcbmltcG9ydCBBcnJheUhlbHBlciBmcm9tICcuLi9jb21tb24vYXJyYXlfaGVscGVyJztcbmltcG9ydCBJbWFnZURlYnVnIGZyb20gJy4uL2NvbW1vbi9pbWFnZV9kZWJ1Zyc7XG5pbXBvcnQgUmFzdGVyaXplciBmcm9tICcuL3Jhc3Rlcml6ZXInO1xuaW1wb3J0IFRyYWNlciBmcm9tICcuL3RyYWNlcic7XG5pbXBvcnQgc2tlbGV0b25pemVyIGZyb20gJy4vc2tlbGV0b25pemVyJztcblxuXG5sZXQgX2NvbmZpZztcbmxldCBfY3VycmVudEltYWdlV3JhcHBlcjtcbmxldCBfc2tlbEltYWdlV3JhcHBlcjtcbmxldCBfc3ViSW1hZ2VXcmFwcGVyO1xubGV0IF9sYWJlbEltYWdlV3JhcHBlcjtcbmxldCBfcGF0Y2hHcmlkO1xubGV0IF9wYXRjaExhYmVsR3JpZDtcbmxldCBfaW1hZ2VUb1BhdGNoR3JpZDtcbmxldCBfYmluYXJ5SW1hZ2VXcmFwcGVyO1xubGV0IF9wYXRjaFNpemU7XG5jb25zdCBfY2FudmFzQ29udGFpbmVyID0ge1xuICAgIGN0eDoge1xuICAgICAgICBiaW5hcnk6IG51bGwsXG4gICAgfSxcbiAgICBkb206IHtcbiAgICAgICAgYmluYXJ5OiBudWxsLFxuICAgIH0sXG59O1xuY29uc3QgX251bVBhdGNoZXMgPSB7IHg6IDAsIHk6IDAgfTtcbmxldCBfaW5wdXRJbWFnZVdyYXBwZXI7XG5sZXQgX3NrZWxldG9uaXplcjtcblxuZnVuY3Rpb24gaW5pdEJ1ZmZlcnMoKSB7XG4gICAgaWYgKF9jb25maWcuaGFsZlNhbXBsZSkge1xuICAgICAgICBfY3VycmVudEltYWdlV3JhcHBlciA9IG5ldyBJbWFnZVdyYXBwZXIoe1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWJpdHdpc2VcbiAgICAgICAgICAgIHg6IF9pbnB1dEltYWdlV3JhcHBlci5zaXplLnggLyAyIHwgMCxcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1iaXR3aXNlXG4gICAgICAgICAgICB5OiBfaW5wdXRJbWFnZVdyYXBwZXIuc2l6ZS55IC8gMiB8IDAsXG4gICAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIF9jdXJyZW50SW1hZ2VXcmFwcGVyID0gX2lucHV0SW1hZ2VXcmFwcGVyO1xuICAgIH1cblxuICAgIF9wYXRjaFNpemUgPSBjYWxjdWxhdGVQYXRjaFNpemUoX2NvbmZpZy5wYXRjaFNpemUsIF9jdXJyZW50SW1hZ2VXcmFwcGVyLnNpemUpO1xuXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWJpdHdpc2VcbiAgICBfbnVtUGF0Y2hlcy54ID0gX2N1cnJlbnRJbWFnZVdyYXBwZXIuc2l6ZS54IC8gX3BhdGNoU2l6ZS54IHwgMDtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tYml0d2lzZVxuICAgIF9udW1QYXRjaGVzLnkgPSBfY3VycmVudEltYWdlV3JhcHBlci5zaXplLnkgLyBfcGF0Y2hTaXplLnkgfCAwO1xuXG4gICAgX2JpbmFyeUltYWdlV3JhcHBlciA9IG5ldyBJbWFnZVdyYXBwZXIoX2N1cnJlbnRJbWFnZVdyYXBwZXIuc2l6ZSwgdW5kZWZpbmVkLCBVaW50OEFycmF5LCBmYWxzZSk7XG5cbiAgICBfbGFiZWxJbWFnZVdyYXBwZXIgPSBuZXcgSW1hZ2VXcmFwcGVyKF9wYXRjaFNpemUsIHVuZGVmaW5lZCwgQXJyYXksIHRydWUpO1xuXG4gICAgY29uc3Qgc2tlbGV0b25JbWFnZURhdGEgPSBuZXcgQXJyYXlCdWZmZXIoNjQgKiAxMDI0KTtcbiAgICBfc3ViSW1hZ2VXcmFwcGVyID0gbmV3IEltYWdlV3JhcHBlcihfcGF0Y2hTaXplLFxuICAgICAgICBuZXcgVWludDhBcnJheShza2VsZXRvbkltYWdlRGF0YSwgMCwgX3BhdGNoU2l6ZS54ICogX3BhdGNoU2l6ZS55KSk7XG4gICAgX3NrZWxJbWFnZVdyYXBwZXIgPSBuZXcgSW1hZ2VXcmFwcGVyKF9wYXRjaFNpemUsXG4gICAgICAgIG5ldyBVaW50OEFycmF5KHNrZWxldG9uSW1hZ2VEYXRhLCBfcGF0Y2hTaXplLnggKiBfcGF0Y2hTaXplLnkgKiAzLCBfcGF0Y2hTaXplLnggKiBfcGF0Y2hTaXplLnkpLFxuICAgICAgICB1bmRlZmluZWQsIHRydWUpO1xuICAgIF9za2VsZXRvbml6ZXIgPSBza2VsZXRvbml6ZXIoXG4gICAgICAgICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykgPyB3aW5kb3cgOiAodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnKSA/IHNlbGYgOiBnbG9iYWwsXG4gICAgICAgIHsgc2l6ZTogX3BhdGNoU2l6ZS54IH0sXG4gICAgICAgIHNrZWxldG9uSW1hZ2VEYXRhLFxuICAgICk7XG5cbiAgICBfaW1hZ2VUb1BhdGNoR3JpZCA9IG5ldyBJbWFnZVdyYXBwZXIoe1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tYml0d2lzZVxuICAgICAgICB4OiAoX2N1cnJlbnRJbWFnZVdyYXBwZXIuc2l6ZS54IC8gX3N1YkltYWdlV3JhcHBlci5zaXplLngpIHwgMCxcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWJpdHdpc2VcbiAgICAgICAgeTogKF9jdXJyZW50SW1hZ2VXcmFwcGVyLnNpemUueSAvIF9zdWJJbWFnZVdyYXBwZXIuc2l6ZS55KSB8IDAsXG4gICAgfSwgdW5kZWZpbmVkLCBBcnJheSwgdHJ1ZSk7XG4gICAgX3BhdGNoR3JpZCA9IG5ldyBJbWFnZVdyYXBwZXIoX2ltYWdlVG9QYXRjaEdyaWQuc2l6ZSwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHRydWUpO1xuICAgIF9wYXRjaExhYmVsR3JpZCA9IG5ldyBJbWFnZVdyYXBwZXIoX2ltYWdlVG9QYXRjaEdyaWQuc2l6ZSwgdW5kZWZpbmVkLCBJbnQzMkFycmF5LCB0cnVlKTtcbn1cblxuZnVuY3Rpb24gaW5pdENhbnZhcygpIHtcbiAgICBpZiAoX2NvbmZpZy51c2VXb3JrZXIgfHwgdHlwZW9mIGRvY3VtZW50ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIF9jYW52YXNDb250YWluZXIuZG9tLmJpbmFyeSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgIF9jYW52YXNDb250YWluZXIuZG9tLmJpbmFyeS5jbGFzc05hbWUgPSAnYmluYXJ5QnVmZmVyJztcbiAgICBpZiAoRU5WLmRldmVsb3BtZW50ICYmIF9jb25maWcuZGVidWcuc2hvd0NhbnZhcyA9PT0gdHJ1ZSkge1xuICAgICAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjZGVidWcnKS5hcHBlbmRDaGlsZChfY2FudmFzQ29udGFpbmVyLmRvbS5iaW5hcnkpO1xuICAgIH1cbiAgICBfY2FudmFzQ29udGFpbmVyLmN0eC5iaW5hcnkgPSBfY2FudmFzQ29udGFpbmVyLmRvbS5iaW5hcnkuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICBfY2FudmFzQ29udGFpbmVyLmRvbS5iaW5hcnkud2lkdGggPSBfYmluYXJ5SW1hZ2VXcmFwcGVyLnNpemUueDtcbiAgICBfY2FudmFzQ29udGFpbmVyLmRvbS5iaW5hcnkuaGVpZ2h0ID0gX2JpbmFyeUltYWdlV3JhcHBlci5zaXplLnk7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIGJvdW5kaW5nIGJveCB3aGljaCBlbmNsb3NlcyBhbGwgdGhlIGdpdmVuIHBhdGNoZXNcbiAqIEByZXR1cm5zIHtBcnJheX0gVGhlIG1pbmltYWwgYm91bmRpbmcgYm94XG4gKi9cbmZ1bmN0aW9uIGJveEZyb21QYXRjaGVzKHBhdGNoZXMpIHtcbiAgICBsZXQgb3ZlckF2ZztcbiAgICBsZXQgaTtcbiAgICBsZXQgajtcbiAgICBsZXQgcGF0Y2g7XG4gICAgbGV0IHRyYW5zTWF0O1xuICAgIGxldCBtaW54ID0gX2JpbmFyeUltYWdlV3JhcHBlci5zaXplLng7XG4gICAgbGV0IG1pbnkgPSBfYmluYXJ5SW1hZ2VXcmFwcGVyLnNpemUueTtcbiAgICBsZXQgbWF4eCA9IC1fYmluYXJ5SW1hZ2VXcmFwcGVyLnNpemUueDtcbiAgICBsZXQgbWF4eSA9IC1fYmluYXJ5SW1hZ2VXcmFwcGVyLnNpemUueTtcbiAgICBsZXQgYm94O1xuICAgIGxldCBzY2FsZTtcblxuICAgIC8vIGRyYXcgYWxsIHBhdGNoZXMgd2hpY2ggYXJlIHRvIGJlIHRha2VuIGludG8gY29uc2lkZXJhdGlvblxuICAgIG92ZXJBdmcgPSAwO1xuICAgIGZvciAoaSA9IDA7IGkgPCBwYXRjaGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHBhdGNoID0gcGF0Y2hlc1tpXTtcbiAgICAgICAgb3ZlckF2ZyArPSBwYXRjaC5yYWQ7XG4gICAgICAgIGlmIChFTlYuZGV2ZWxvcG1lbnQgJiYgX2NvbmZpZy5kZWJ1Zy5zaG93UGF0Y2hlcykge1xuICAgICAgICAgICAgSW1hZ2VEZWJ1Zy5kcmF3UmVjdChwYXRjaC5wb3MsIF9zdWJJbWFnZVdyYXBwZXIuc2l6ZSwgX2NhbnZhc0NvbnRhaW5lci5jdHguYmluYXJ5LCB7IGNvbG9yOiAncmVkJyB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIG92ZXJBdmcgLz0gcGF0Y2hlcy5sZW5ndGg7XG4gICAgb3ZlckF2ZyA9IChvdmVyQXZnICogMTgwIC8gTWF0aC5QSSArIDkwKSAlIDE4MCAtIDkwO1xuICAgIGlmIChvdmVyQXZnIDwgMCkge1xuICAgICAgICBvdmVyQXZnICs9IDE4MDtcbiAgICB9XG5cbiAgICBvdmVyQXZnID0gKDE4MCAtIG92ZXJBdmcpICogTWF0aC5QSSAvIDE4MDtcbiAgICB0cmFuc01hdCA9IG1hdDIuY29weShtYXQyLmNyZWF0ZSgpLCBbTWF0aC5jb3Mob3ZlckF2ZyksIE1hdGguc2luKG92ZXJBdmcpLCAtTWF0aC5zaW4ob3ZlckF2ZyksIE1hdGguY29zKG92ZXJBdmcpXSk7XG5cbiAgICAvLyBpdGVyYXRlIG92ZXIgcGF0Y2hlcyBhbmQgcm90YXRlIGJ5IGFuZ2xlXG4gICAgZm9yIChpID0gMDsgaSA8IHBhdGNoZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcGF0Y2ggPSBwYXRjaGVzW2ldO1xuICAgICAgICBmb3IgKGogPSAwOyBqIDwgNDsgaisrKSB7XG4gICAgICAgICAgICB2ZWMyLnRyYW5zZm9ybU1hdDIocGF0Y2guYm94W2pdLCBwYXRjaC5ib3hbal0sIHRyYW5zTWF0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChFTlYuZGV2ZWxvcG1lbnQgJiYgX2NvbmZpZy5kZWJ1Zy5ib3hGcm9tUGF0Y2hlcy5zaG93VHJhbnNmb3JtZWQpIHtcbiAgICAgICAgICAgIEltYWdlRGVidWcuZHJhd1BhdGgocGF0Y2guYm94LCB7IHg6IDAsIHk6IDEgfSwgX2NhbnZhc0NvbnRhaW5lci5jdHguYmluYXJ5LCB7IGNvbG9yOiAnIzk5ZmYwMCcsIGxpbmVXaWR0aDogMiB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIGZpbmQgYm91bmRpbmcgYm94XG4gICAgZm9yIChpID0gMDsgaSA8IHBhdGNoZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcGF0Y2ggPSBwYXRjaGVzW2ldO1xuICAgICAgICBmb3IgKGogPSAwOyBqIDwgNDsgaisrKSB7XG4gICAgICAgICAgICBpZiAocGF0Y2guYm94W2pdWzBdIDwgbWlueCkge1xuICAgICAgICAgICAgICAgIG1pbnggPSBwYXRjaC5ib3hbal1bMF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocGF0Y2guYm94W2pdWzBdID4gbWF4eCkge1xuICAgICAgICAgICAgICAgIG1heHggPSBwYXRjaC5ib3hbal1bMF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocGF0Y2guYm94W2pdWzFdIDwgbWlueSkge1xuICAgICAgICAgICAgICAgIG1pbnkgPSBwYXRjaC5ib3hbal1bMV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocGF0Y2guYm94W2pdWzFdID4gbWF4eSkge1xuICAgICAgICAgICAgICAgIG1heHkgPSBwYXRjaC5ib3hbal1bMV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBib3ggPSBbW21pbngsIG1pbnldLCBbbWF4eCwgbWlueV0sIFttYXh4LCBtYXh5XSwgW21pbngsIG1heHldXTtcblxuICAgIGlmIChFTlYuZGV2ZWxvcG1lbnQgJiYgX2NvbmZpZy5kZWJ1Zy5ib3hGcm9tUGF0Y2hlcy5zaG93VHJhbnNmb3JtZWRCb3gpIHtcbiAgICAgICAgSW1hZ2VEZWJ1Zy5kcmF3UGF0aChib3gsIHsgeDogMCwgeTogMSB9LCBfY2FudmFzQ29udGFpbmVyLmN0eC5iaW5hcnksIHsgY29sb3I6ICcjZmYwMDAwJywgbGluZVdpZHRoOiAyIH0pO1xuICAgIH1cblxuICAgIHNjYWxlID0gX2NvbmZpZy5oYWxmU2FtcGxlID8gMiA6IDE7XG4gICAgLy8gcmV2ZXJzZSByb3RhdGlvbjtcbiAgICB0cmFuc01hdCA9IG1hdDIuaW52ZXJ0KHRyYW5zTWF0LCB0cmFuc01hdCk7XG4gICAgZm9yIChqID0gMDsgaiA8IDQ7IGorKykge1xuICAgICAgICB2ZWMyLnRyYW5zZm9ybU1hdDIoYm94W2pdLCBib3hbal0sIHRyYW5zTWF0KTtcbiAgICB9XG5cbiAgICBpZiAoRU5WLmRldmVsb3BtZW50ICYmIF9jb25maWcuZGVidWcuYm94RnJvbVBhdGNoZXMuc2hvd0JCKSB7XG4gICAgICAgIEltYWdlRGVidWcuZHJhd1BhdGgoYm94LCB7IHg6IDAsIHk6IDEgfSwgX2NhbnZhc0NvbnRhaW5lci5jdHguYmluYXJ5LCB7IGNvbG9yOiAnI2ZmMDAwMCcsIGxpbmVXaWR0aDogMiB9KTtcbiAgICB9XG5cbiAgICBmb3IgKGogPSAwOyBqIDwgNDsgaisrKSB7XG4gICAgICAgIHZlYzIuc2NhbGUoYm94W2pdLCBib3hbal0sIHNjYWxlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYm94O1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBiaW5hcnkgaW1hZ2Ugb2YgdGhlIGN1cnJlbnQgaW1hZ2VcbiAqL1xuZnVuY3Rpb24gYmluYXJpemVJbWFnZSgpIHtcbiAgICBvdHN1VGhyZXNob2xkKF9jdXJyZW50SW1hZ2VXcmFwcGVyLCBfYmluYXJ5SW1hZ2VXcmFwcGVyKTtcbiAgICBfYmluYXJ5SW1hZ2VXcmFwcGVyLnplcm9Cb3JkZXIoKTtcbiAgICBpZiAoRU5WLmRldmVsb3BtZW50ICYmIF9jb25maWcuZGVidWcuc2hvd0NhbnZhcykge1xuICAgICAgICBfYmluYXJ5SW1hZ2VXcmFwcGVyLnNob3coX2NhbnZhc0NvbnRhaW5lci5kb20uYmluYXJ5LCAyNTUpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBJdGVyYXRlIG92ZXIgdGhlIGVudGlyZSBpbWFnZVxuICogZXh0cmFjdCBwYXRjaGVzXG4gKi9cbmZ1bmN0aW9uIGZpbmRQYXRjaGVzKCkge1xuICAgIGxldCBpO1xuICAgIGxldCBqO1xuICAgIGxldCB4O1xuICAgIGxldCB5O1xuICAgIGxldCBtb21lbnRzO1xuICAgIGxldCBwYXRjaGVzRm91bmQgPSBbXTtcbiAgICBsZXQgcmFzdGVyaXplcjtcbiAgICBsZXQgcmFzdGVyUmVzdWx0O1xuICAgIGxldCBwYXRjaDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgX251bVBhdGNoZXMueDsgaSsrKSB7XG4gICAgICAgIGZvciAoaiA9IDA7IGogPCBfbnVtUGF0Y2hlcy55OyBqKyspIHtcbiAgICAgICAgICAgIHggPSBfc3ViSW1hZ2VXcmFwcGVyLnNpemUueCAqIGk7XG4gICAgICAgICAgICB5ID0gX3N1YkltYWdlV3JhcHBlci5zaXplLnkgKiBqO1xuXG4gICAgICAgICAgICAvLyBzZXBlcmF0ZSBwYXJ0c1xuICAgICAgICAgICAgc2tlbGV0b25pemUoeCwgeSk7XG5cbiAgICAgICAgICAgIC8vIFJhc3Rlcml6ZSwgZmluZCBpbmRpdmlkdWFsIGJhcnNcbiAgICAgICAgICAgIF9za2VsSW1hZ2VXcmFwcGVyLnplcm9Cb3JkZXIoKTtcbiAgICAgICAgICAgIEFycmF5SGVscGVyLmluaXQoX2xhYmVsSW1hZ2VXcmFwcGVyLmRhdGEsIDApO1xuICAgICAgICAgICAgcmFzdGVyaXplciA9IFJhc3Rlcml6ZXIuY3JlYXRlKF9za2VsSW1hZ2VXcmFwcGVyLCBfbGFiZWxJbWFnZVdyYXBwZXIpO1xuICAgICAgICAgICAgcmFzdGVyUmVzdWx0ID0gcmFzdGVyaXplci5yYXN0ZXJpemUoMCk7XG5cbiAgICAgICAgICAgIGlmIChFTlYuZGV2ZWxvcG1lbnQgJiYgX2NvbmZpZy5kZWJ1Zy5zaG93TGFiZWxzKSB7XG4gICAgICAgICAgICAgICAgX2xhYmVsSW1hZ2VXcmFwcGVyLm92ZXJsYXkoX2NhbnZhc0NvbnRhaW5lci5kb20uYmluYXJ5LCBNYXRoLmZsb29yKDM2MCAvIHJhc3RlclJlc3VsdC5jb3VudCksXG4gICAgICAgICAgICAgICAgICAgIHsgeCwgeSB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gY2FsY3VsYXRlIG1vbWVudHMgZnJvbSB0aGUgc2tlbGV0b25pemVkIHBhdGNoXG4gICAgICAgICAgICBtb21lbnRzID0gX2xhYmVsSW1hZ2VXcmFwcGVyLm1vbWVudHMocmFzdGVyUmVzdWx0LmNvdW50KTtcblxuICAgICAgICAgICAgLy8gZXh0cmFjdCBlbGlnaWJsZSBwYXRjaGVzXG4gICAgICAgICAgICBwYXRjaGVzRm91bmQgPSBwYXRjaGVzRm91bmQuY29uY2F0KGRlc2NyaWJlUGF0Y2gobW9tZW50cywgW2ksIGpdLCB4LCB5KSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoRU5WLmRldmVsb3BtZW50ICYmIF9jb25maWcuZGVidWcuc2hvd0ZvdW5kUGF0Y2hlcykge1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcGF0Y2hlc0ZvdW5kLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBwYXRjaCA9IHBhdGNoZXNGb3VuZFtpXTtcbiAgICAgICAgICAgIEltYWdlRGVidWcuZHJhd1JlY3QocGF0Y2gucG9zLCBfc3ViSW1hZ2VXcmFwcGVyLnNpemUsIF9jYW52YXNDb250YWluZXIuY3R4LmJpbmFyeSxcbiAgICAgICAgICAgICAgICB7IGNvbG9yOiAnIzk5ZmYwMCcsIGxpbmVXaWR0aDogMiB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBwYXRjaGVzRm91bmQ7XG59XG5cbi8qKlxuICogRmluZHMgdGhvc2UgY29ubmVjdGVkIGFyZWFzIHdoaWNoIGNvbnRhaW4gYXQgbGVhc3QgNiBwYXRjaGVzXG4gKiBhbmQgcmV0dXJucyB0aGVtIG9yZGVyZWQgREVTQyBieSB0aGUgbnVtYmVyIG9mIGNvbnRhaW5lZCBwYXRjaGVzXG4gKiBAcGFyYW0ge051bWJlcn0gbWF4TGFiZWxcbiAqL1xuZnVuY3Rpb24gZmluZEJpZ2dlc3RDb25uZWN0ZWRBcmVhcyhtYXhMYWJlbCkge1xuICAgIGxldCBpO1xuICAgIGxldCBzdW07XG4gICAgbGV0IGxhYmVsSGlzdCA9IFtdO1xuICAgIGxldCB0b3BMYWJlbHMgPSBbXTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBtYXhMYWJlbDsgaSsrKSB7XG4gICAgICAgIGxhYmVsSGlzdC5wdXNoKDApO1xuICAgIH1cbiAgICBzdW0gPSBfcGF0Y2hMYWJlbEdyaWQuZGF0YS5sZW5ndGg7XG4gICAgd2hpbGUgKHN1bS0tKSB7XG4gICAgICAgIGlmIChfcGF0Y2hMYWJlbEdyaWQuZGF0YVtzdW1dID4gMCkge1xuICAgICAgICAgICAgbGFiZWxIaXN0W19wYXRjaExhYmVsR3JpZC5kYXRhW3N1bV0gLSAxXSsrO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgbGFiZWxIaXN0ID0gbGFiZWxIaXN0Lm1hcCgodmFsLCBpZHgpID0+ICh7XG4gICAgICAgIHZhbCxcbiAgICAgICAgbGFiZWw6IGlkeCArIDEsXG4gICAgfSkpO1xuXG4gICAgbGFiZWxIaXN0LnNvcnQoKGEsIGIpID0+IGIudmFsIC0gYS52YWwpO1xuXG4gICAgLy8gZXh0cmFjdCB0b3AgYXJlYXMgd2l0aCBhdCBsZWFzdCA2IHBhdGNoZXMgcHJlc2VudFxuICAgIHRvcExhYmVscyA9IGxhYmVsSGlzdC5maWx0ZXIoKGVsKSA9PiBlbC52YWwgPj0gNSk7XG5cbiAgICByZXR1cm4gdG9wTGFiZWxzO1xufVxuXG4vKipcbiAqXG4gKi9cbmZ1bmN0aW9uIGZpbmRCb3hlcyh0b3BMYWJlbHMsIG1heExhYmVsKSB7XG4gICAgbGV0IGk7XG4gICAgbGV0IGo7XG4gICAgbGV0IHN1bTtcbiAgICBjb25zdCBwYXRjaGVzID0gW107XG4gICAgbGV0IHBhdGNoO1xuICAgIGxldCBib3g7XG4gICAgY29uc3QgYm94ZXMgPSBbXTtcbiAgICBjb25zdCBoc3YgPSBbMCwgMSwgMV07XG4gICAgY29uc3QgcmdiID0gWzAsIDAsIDBdO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IHRvcExhYmVscy5sZW5ndGg7IGkrKykge1xuICAgICAgICBzdW0gPSBfcGF0Y2hMYWJlbEdyaWQuZGF0YS5sZW5ndGg7XG4gICAgICAgIHBhdGNoZXMubGVuZ3RoID0gMDtcbiAgICAgICAgd2hpbGUgKHN1bS0tKSB7XG4gICAgICAgICAgICBpZiAoX3BhdGNoTGFiZWxHcmlkLmRhdGFbc3VtXSA9PT0gdG9wTGFiZWxzW2ldLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgcGF0Y2ggPSBfaW1hZ2VUb1BhdGNoR3JpZC5kYXRhW3N1bV07XG4gICAgICAgICAgICAgICAgcGF0Y2hlcy5wdXNoKHBhdGNoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBib3ggPSBib3hGcm9tUGF0Y2hlcyhwYXRjaGVzKTtcbiAgICAgICAgaWYgKGJveCkge1xuICAgICAgICAgICAgYm94ZXMucHVzaChib3gpO1xuXG4gICAgICAgICAgICAvLyBkcmF3IHBhdGNoLWxhYmVscyBpZiByZXF1ZXN0ZWRcbiAgICAgICAgICAgIGlmIChFTlYuZGV2ZWxvcG1lbnQgJiYgX2NvbmZpZy5kZWJ1Zy5zaG93UmVtYWluaW5nUGF0Y2hMYWJlbHMpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgcGF0Y2hlcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICBwYXRjaCA9IHBhdGNoZXNbal07XG4gICAgICAgICAgICAgICAgICAgIGhzdlswXSA9ICh0b3BMYWJlbHNbaV0ubGFiZWwgLyAobWF4TGFiZWwgKyAxKSkgKiAzNjA7XG4gICAgICAgICAgICAgICAgICAgIGhzdjJyZ2IoaHN2LCByZ2IpO1xuICAgICAgICAgICAgICAgICAgICBJbWFnZURlYnVnLmRyYXdSZWN0KHBhdGNoLnBvcywgX3N1YkltYWdlV3JhcHBlci5zaXplLCBfY2FudmFzQ29udGFpbmVyLmN0eC5iaW5hcnksXG4gICAgICAgICAgICAgICAgICAgICAgICB7IGNvbG9yOiBgcmdiKCR7cmdiLmpvaW4oJywnKX0pYCwgbGluZVdpZHRoOiAyIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYm94ZXM7XG59XG5cbi8qKlxuICogRmluZCBzaW1pbGFyIG1vbWVudHMgKHZpYSBjbHVzdGVyKVxuICogQHBhcmFtIHtPYmplY3R9IG1vbWVudHNcbiAqL1xuZnVuY3Rpb24gc2ltaWxhck1vbWVudHMobW9tZW50cykge1xuICAgIGNvbnN0IGNsdXN0ZXJzID0gY2x1c3Rlcihtb21lbnRzLCAwLjkwKTtcbiAgICBjb25zdCB0b3BDbHVzdGVyID0gdG9wR2VuZXJpYyhjbHVzdGVycywgMSwgKGUpID0+IGUuZ2V0UG9pbnRzKCkubGVuZ3RoKTtcbiAgICBsZXQgcG9pbnRzID0gW107IGNvbnN0XG4gICAgICAgIHJlc3VsdCA9IFtdO1xuICAgIGlmICh0b3BDbHVzdGVyLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICBwb2ludHMgPSB0b3BDbHVzdGVyWzBdLml0ZW0uZ2V0UG9pbnRzKCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcG9pbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChwb2ludHNbaV0ucG9pbnQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIHNrZWxldG9uaXplKHgsIHkpIHtcbiAgICBfYmluYXJ5SW1hZ2VXcmFwcGVyLnN1YkltYWdlQXNDb3B5KF9zdWJJbWFnZVdyYXBwZXIsIGltYWdlUmVmKHgsIHkpKTtcbiAgICBfc2tlbGV0b25pemVyLnNrZWxldG9uaXplKCk7XG5cbiAgICAvLyBTaG93IHNrZWxldG9uIGlmIHJlcXVlc3RlZFxuICAgIGlmIChFTlYuZGV2ZWxvcG1lbnQgJiYgX2NvbmZpZy5kZWJ1Zy5zaG93U2tlbGV0b24pIHtcbiAgICAgICAgX3NrZWxJbWFnZVdyYXBwZXIub3ZlcmxheShfY2FudmFzQ29udGFpbmVyLmRvbS5iaW5hcnksIDM2MCwgaW1hZ2VSZWYoeCwgeSkpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBFeHRyYWN0cyBhbmQgZGVzY3JpYmVzIHRob3NlIHBhdGNoZXMgd2hpY2ggc2VlbSB0byBjb250YWluIGEgYmFyY29kZSBwYXR0ZXJuXG4gKiBAcGFyYW0ge0FycmF5fSBtb21lbnRzXG4gKiBAcGFyYW0ge09iamVjdH0gcGF0Y2hQb3MsXG4gKiBAcGFyYW0ge051bWJlcn0geFxuICogQHBhcmFtIHtOdW1iZXJ9IHlcbiAqIEByZXR1cm5zIHtBcnJheX0gbGlzdCBvZiBwYXRjaGVzXG4gKi9cbmZ1bmN0aW9uIGRlc2NyaWJlUGF0Y2gobW9tZW50cywgcGF0Y2hQb3MsIHgsIHkpIHtcbiAgICBsZXQgaztcbiAgICBsZXQgYXZnO1xuICAgIGNvbnN0IGVsaWdpYmxlTW9tZW50cyA9IFtdO1xuICAgIGxldCBtYXRjaGluZ01vbWVudHM7XG4gICAgbGV0IHBhdGNoO1xuICAgIGNvbnN0IHBhdGNoZXNGb3VuZCA9IFtdO1xuICAgIGNvbnN0IG1pbkNvbXBvbmVudFdlaWdodCA9IE1hdGguY2VpbChfcGF0Y2hTaXplLnggLyAzKTtcblxuICAgIGlmIChtb21lbnRzLmxlbmd0aCA+PSAyKSB7XG4gICAgICAgIC8vIG9ubHkgY29sbGVjdCBtb21lbnRzIHdoaWNoJ3MgYXJlYSBjb3ZlcnMgYXQgbGVhc3QgbWluQ29tcG9uZW50V2VpZ2h0IHBpeGVscy5cbiAgICAgICAgZm9yIChrID0gMDsgayA8IG1vbWVudHMubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgICAgIGlmIChtb21lbnRzW2tdLm0wMCA+IG1pbkNvbXBvbmVudFdlaWdodCkge1xuICAgICAgICAgICAgICAgIGVsaWdpYmxlTW9tZW50cy5wdXNoKG1vbWVudHNba10pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gaWYgYXQgbGVhc3QgMiBtb21lbnRzIGFyZSBmb3VuZCB3aGljaCBoYXZlIGF0IGxlYXN0IG1pbkNvbXBvbmVudFdlaWdodHMgY292ZXJlZFxuICAgICAgICBpZiAoZWxpZ2libGVNb21lbnRzLmxlbmd0aCA+PSAyKSB7XG4gICAgICAgICAgICBtYXRjaGluZ01vbWVudHMgPSBzaW1pbGFyTW9tZW50cyhlbGlnaWJsZU1vbWVudHMpO1xuICAgICAgICAgICAgYXZnID0gMDtcbiAgICAgICAgICAgIC8vIGRldGVybWluZSB0aGUgc2ltaWxhcml0eSBvZiB0aGUgbW9tZW50c1xuICAgICAgICAgICAgZm9yIChrID0gMDsgayA8IG1hdGNoaW5nTW9tZW50cy5sZW5ndGg7IGsrKykge1xuICAgICAgICAgICAgICAgIGF2ZyArPSBtYXRjaGluZ01vbWVudHNba10/LnJhZCA/PyAwO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBPbmx5IHR3byBvZiB0aGUgbW9tZW50cyBhcmUgYWxsb3dlZCBub3QgdG8gZml0IGludG8gdGhlIGVxdWF0aW9uXG4gICAgICAgICAgICAvLyBhZGQgdGhlIHBhdGNoIHRvIHRoZSBzZXRcbiAgICAgICAgICAgIGlmIChtYXRjaGluZ01vbWVudHMubGVuZ3RoID4gMVxuICAgICAgICAgICAgICAgICAgICAmJiBtYXRjaGluZ01vbWVudHMubGVuZ3RoID49IChlbGlnaWJsZU1vbWVudHMubGVuZ3RoIC8gNCkgKiAzXG4gICAgICAgICAgICAgICAgICAgICYmIG1hdGNoaW5nTW9tZW50cy5sZW5ndGggPiBtb21lbnRzLmxlbmd0aCAvIDQpIHtcbiAgICAgICAgICAgICAgICBhdmcgLz0gbWF0Y2hpbmdNb21lbnRzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBwYXRjaCA9IHtcbiAgICAgICAgICAgICAgICAgICAgaW5kZXg6IHBhdGNoUG9zWzFdICogX251bVBhdGNoZXMueCArIHBhdGNoUG9zWzBdLFxuICAgICAgICAgICAgICAgICAgICBwb3M6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHgsXG4gICAgICAgICAgICAgICAgICAgICAgICB5LFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBib3g6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZlYzIuY2xvbmUoW3gsIHldKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZlYzIuY2xvbmUoW3ggKyBfc3ViSW1hZ2VXcmFwcGVyLnNpemUueCwgeV0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmVjMi5jbG9uZShbeCArIF9zdWJJbWFnZVdyYXBwZXIuc2l6ZS54LCB5ICsgX3N1YkltYWdlV3JhcHBlci5zaXplLnldKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZlYzIuY2xvbmUoW3gsIHkgKyBfc3ViSW1hZ2VXcmFwcGVyLnNpemUueV0pLFxuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgICAgICBtb21lbnRzOiBtYXRjaGluZ01vbWVudHMsXG4gICAgICAgICAgICAgICAgICAgIHJhZDogYXZnLFxuICAgICAgICAgICAgICAgICAgICB2ZWM6IHZlYzIuY2xvbmUoW01hdGguY29zKGF2ZyksIE1hdGguc2luKGF2ZyldKSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHBhdGNoZXNGb3VuZC5wdXNoKHBhdGNoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcGF0Y2hlc0ZvdW5kO1xufVxuXG4vKipcbiAqIGZpbmRzIHBhdGNoZXMgd2hpY2ggYXJlIGNvbm5lY3RlZCBhbmQgc2hhcmUgdGhlIHNhbWUgb3JpZW50YXRpb25cbiAqIEBwYXJhbSB7T2JqZWN0fSBwYXRjaGVzRm91bmRcbiAqL1xuZnVuY3Rpb24gcmFzdGVyaXplQW5ndWxhclNpbWlsYXJpdHkocGF0Y2hlc0ZvdW5kKSB7XG4gICAgbGV0IGxhYmVsID0gMDtcbiAgICBjb25zdCB0aHJlc2hvbGQgPSAwLjk1O1xuICAgIGxldCBjdXJySWR4ID0gMDtcbiAgICBsZXQgajtcbiAgICBsZXQgcGF0Y2g7XG4gICAgY29uc3QgaHN2ID0gWzAsIDEsIDFdO1xuICAgIGNvbnN0IHJnYiA9IFswLCAwLCAwXTtcblxuICAgIGZ1bmN0aW9uIG5vdFlldFByb2Nlc3NlZCgpIHtcbiAgICAgICAgbGV0IGk7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBfcGF0Y2hMYWJlbEdyaWQuZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKF9wYXRjaExhYmVsR3JpZC5kYXRhW2ldID09PSAwICYmIF9wYXRjaEdyaWQuZGF0YVtpXSA9PT0gMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfcGF0Y2hMYWJlbEdyaWQuZGF0YS5sZW5ndGg7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdHJhY2UoY3VycmVudElkeCkge1xuICAgICAgICBsZXQgeDtcbiAgICAgICAgbGV0IHk7XG4gICAgICAgIGxldCBjdXJyZW50UGF0Y2g7XG4gICAgICAgIGxldCBpZHg7XG4gICAgICAgIGxldCBkaXI7XG4gICAgICAgIGNvbnN0IGN1cnJlbnQgPSB7XG4gICAgICAgICAgICB4OiBjdXJyZW50SWR4ICUgX3BhdGNoTGFiZWxHcmlkLnNpemUueCxcbiAgICAgICAgICAgIHk6IChjdXJyZW50SWR4IC8gX3BhdGNoTGFiZWxHcmlkLnNpemUueCkgfCAwLFxuICAgICAgICB9O1xuICAgICAgICBsZXQgc2ltaWxhcml0eTtcblxuICAgICAgICBpZiAoY3VycmVudElkeCA8IF9wYXRjaExhYmVsR3JpZC5kYXRhLmxlbmd0aCkge1xuICAgICAgICAgICAgY3VycmVudFBhdGNoID0gX2ltYWdlVG9QYXRjaEdyaWQuZGF0YVtjdXJyZW50SWR4XTtcbiAgICAgICAgICAgIC8vIGFzc2lnbiBsYWJlbFxuICAgICAgICAgICAgX3BhdGNoTGFiZWxHcmlkLmRhdGFbY3VycmVudElkeF0gPSBsYWJlbDtcbiAgICAgICAgICAgIGZvciAoZGlyID0gMDsgZGlyIDwgVHJhY2VyLnNlYXJjaERpcmVjdGlvbnMubGVuZ3RoOyBkaXIrKykge1xuICAgICAgICAgICAgICAgIHkgPSBjdXJyZW50LnkgKyBUcmFjZXIuc2VhcmNoRGlyZWN0aW9uc1tkaXJdWzBdO1xuICAgICAgICAgICAgICAgIHggPSBjdXJyZW50LnggKyBUcmFjZXIuc2VhcmNoRGlyZWN0aW9uc1tkaXJdWzFdO1xuICAgICAgICAgICAgICAgIGlkeCA9IHkgKiBfcGF0Y2hMYWJlbEdyaWQuc2l6ZS54ICsgeDtcblxuICAgICAgICAgICAgICAgIC8vIGNvbnRpbnVlIGlmIHBhdGNoIGVtcHR5XG4gICAgICAgICAgICAgICAgaWYgKF9wYXRjaEdyaWQuZGF0YVtpZHhdID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIF9wYXRjaExhYmVsR3JpZC5kYXRhW2lkeF0gPSBOdW1iZXIuTUFYX1ZBTFVFO1xuICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29udGludWVcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKF9wYXRjaExhYmVsR3JpZC5kYXRhW2lkeF0gPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgc2ltaWxhcml0eSA9IE1hdGguYWJzKHZlYzIuZG90KF9pbWFnZVRvUGF0Y2hHcmlkLmRhdGFbaWR4XS52ZWMsIGN1cnJlbnRQYXRjaC52ZWMpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNpbWlsYXJpdHkgPiB0aHJlc2hvbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYWNlKGlkeCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBwcmVwYXJlIGZvciBmaW5kaW5nIHRoZSByaWdodCBwYXRjaGVzXG4gICAgQXJyYXlIZWxwZXIuaW5pdChfcGF0Y2hHcmlkLmRhdGEsIDApO1xuICAgIEFycmF5SGVscGVyLmluaXQoX3BhdGNoTGFiZWxHcmlkLmRhdGEsIDApO1xuICAgIEFycmF5SGVscGVyLmluaXQoX2ltYWdlVG9QYXRjaEdyaWQuZGF0YSwgbnVsbCk7XG5cbiAgICBmb3IgKGogPSAwOyBqIDwgcGF0Y2hlc0ZvdW5kLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIHBhdGNoID0gcGF0Y2hlc0ZvdW5kW2pdO1xuICAgICAgICBfaW1hZ2VUb1BhdGNoR3JpZC5kYXRhW3BhdGNoLmluZGV4XSA9IHBhdGNoO1xuICAgICAgICBfcGF0Y2hHcmlkLmRhdGFbcGF0Y2guaW5kZXhdID0gMTtcbiAgICB9XG5cbiAgICAvLyByYXN0ZXJpemUgdGhlIHBhdGNoZXMgZm91bmQgdG8gZGV0ZXJtaW5lIGFyZWFcbiAgICBfcGF0Y2hHcmlkLnplcm9Cb3JkZXIoKTtcblxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25kLWFzc2lnblxuICAgIHdoaWxlICgoY3VycklkeCA9IG5vdFlldFByb2Nlc3NlZCgpKSA8IF9wYXRjaExhYmVsR3JpZC5kYXRhLmxlbmd0aCkge1xuICAgICAgICBsYWJlbCsrO1xuICAgICAgICB0cmFjZShjdXJySWR4KTtcbiAgICB9XG5cbiAgICAvLyBkcmF3IHBhdGNoLWxhYmVscyBpZiByZXF1ZXN0ZWRcbiAgICBpZiAoRU5WLmRldmVsb3BtZW50ICYmIF9jb25maWcuZGVidWcuc2hvd1BhdGNoTGFiZWxzKSB7XG4gICAgICAgIGZvciAoaiA9IDA7IGogPCBfcGF0Y2hMYWJlbEdyaWQuZGF0YS5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgaWYgKF9wYXRjaExhYmVsR3JpZC5kYXRhW2pdID4gMCAmJiBfcGF0Y2hMYWJlbEdyaWQuZGF0YVtqXSA8PSBsYWJlbCkge1xuICAgICAgICAgICAgICAgIHBhdGNoID0gX2ltYWdlVG9QYXRjaEdyaWQuZGF0YVtqXTtcbiAgICAgICAgICAgICAgICBoc3ZbMF0gPSAoX3BhdGNoTGFiZWxHcmlkLmRhdGFbal0gLyAobGFiZWwgKyAxKSkgKiAzNjA7XG4gICAgICAgICAgICAgICAgaHN2MnJnYihoc3YsIHJnYik7XG4gICAgICAgICAgICAgICAgSW1hZ2VEZWJ1Zy5kcmF3UmVjdChwYXRjaC5wb3MsIF9zdWJJbWFnZVdyYXBwZXIuc2l6ZSwgX2NhbnZhc0NvbnRhaW5lci5jdHguYmluYXJ5LFxuICAgICAgICAgICAgICAgICAgICB7IGNvbG9yOiBgcmdiKCR7cmdiLmpvaW4oJywnKX0pYCwgbGluZVdpZHRoOiAyIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGxhYmVsO1xufVxuXG5leHBvcnQgZGVmYXVsdCB7XG4gICAgaW5pdChpbnB1dEltYWdlV3JhcHBlciwgY29uZmlnKSB7XG4gICAgICAgIF9jb25maWcgPSBjb25maWc7XG4gICAgICAgIF9pbnB1dEltYWdlV3JhcHBlciA9IGlucHV0SW1hZ2VXcmFwcGVyO1xuXG4gICAgICAgIGluaXRCdWZmZXJzKCk7XG4gICAgICAgIGluaXRDYW52YXMoKTtcbiAgICB9LFxuXG4gICAgbG9jYXRlKCkge1xuICAgICAgICBpZiAoX2NvbmZpZy5oYWxmU2FtcGxlKSB7XG4gICAgICAgICAgICBoYWxmU2FtcGxlKF9pbnB1dEltYWdlV3JhcHBlciwgX2N1cnJlbnRJbWFnZVdyYXBwZXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgYmluYXJpemVJbWFnZSgpO1xuICAgICAgICBjb25zdCBwYXRjaGVzRm91bmQgPSBmaW5kUGF0Y2hlcygpO1xuICAgICAgICAvLyByZXR1cm4gdW5sZXNzIDUlIG9yIG1vcmUgcGF0Y2hlcyBhcmUgZm91bmRcbiAgICAgICAgaWYgKHBhdGNoZXNGb3VuZC5sZW5ndGggPCBfbnVtUGF0Y2hlcy54ICogX251bVBhdGNoZXMueSAqIDAuMDUpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcmFzdGVycml6ZSBhcmVhIGJ5IGNvbXBhcmluZyBhbmd1bGFyIHNpbWlsYXJpdHk7XG4gICAgICAgIGNvbnN0IG1heExhYmVsID0gcmFzdGVyaXplQW5ndWxhclNpbWlsYXJpdHkocGF0Y2hlc0ZvdW5kKTtcbiAgICAgICAgaWYgKG1heExhYmVsIDwgMSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBzZWFyY2ggZm9yIGFyZWEgd2l0aCB0aGUgbW9zdCBwYXRjaGVzIChiaWdnZXN0IGNvbm5lY3RlZCBhcmVhKVxuICAgICAgICBjb25zdCB0b3BMYWJlbHMgPSBmaW5kQmlnZ2VzdENvbm5lY3RlZEFyZWFzKG1heExhYmVsKTtcbiAgICAgICAgaWYgKHRvcExhYmVscy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgYm94ZXMgPSBmaW5kQm94ZXModG9wTGFiZWxzLCBtYXhMYWJlbCk7XG4gICAgICAgIHJldHVybiBib3hlcztcbiAgICB9LFxuXG4gICAgY2hlY2tJbWFnZUNvbnN0cmFpbnRzKGlucHV0U3RyZWFtLCBjb25maWcpIHtcbiAgICAgICAgbGV0IHBhdGNoU2l6ZTtcbiAgICAgICAgbGV0IHdpZHRoID0gaW5wdXRTdHJlYW0uZ2V0V2lkdGgoKTtcbiAgICAgICAgbGV0IGhlaWdodCA9IGlucHV0U3RyZWFtLmdldEhlaWdodCgpO1xuICAgICAgICBjb25zdCB0aGlzSGFsZlNhbXBsZSA9IGNvbmZpZy5oYWxmU2FtcGxlID8gMC41IDogMTtcbiAgICAgICAgbGV0IGFyZWE7XG5cbiAgICAgICAgLy8gY2FsY3VsYXRlIHdpZHRoIGFuZCBoZWlnaHQgYmFzZWQgb24gYXJlYVxuICAgICAgICBpZiAoaW5wdXRTdHJlYW0uZ2V0Q29uZmlnKCkuYXJlYSkge1xuICAgICAgICAgICAgYXJlYSA9IGNvbXB1dGVJbWFnZUFyZWEod2lkdGgsIGhlaWdodCwgaW5wdXRTdHJlYW0uZ2V0Q29uZmlnKCkuYXJlYSk7XG4gICAgICAgICAgICBpbnB1dFN0cmVhbS5zZXRUb3BSaWdodCh7IHg6IGFyZWEuc3gsIHk6IGFyZWEuc3kgfSk7XG4gICAgICAgICAgICBpbnB1dFN0cmVhbS5zZXRDYW52YXNTaXplKHsgeDogd2lkdGgsIHk6IGhlaWdodCB9KTtcbiAgICAgICAgICAgIHdpZHRoID0gYXJlYS5zdztcbiAgICAgICAgICAgIGhlaWdodCA9IGFyZWEuc2g7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBzaXplID0ge1xuICAgICAgICAgICAgeDogTWF0aC5mbG9vcih3aWR0aCAqIHRoaXNIYWxmU2FtcGxlKSxcbiAgICAgICAgICAgIHk6IE1hdGguZmxvb3IoaGVpZ2h0ICogdGhpc0hhbGZTYW1wbGUpLFxuICAgICAgICB9O1xuXG4gICAgICAgIHBhdGNoU2l6ZSA9IGNhbGN1bGF0ZVBhdGNoU2l6ZShjb25maWcucGF0Y2hTaXplLCBzaXplKTtcbiAgICAgICAgaWYgKEVOVi5kZXZlbG9wbWVudCkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coYFBhdGNoLVNpemU6ICR7SlNPTi5zdHJpbmdpZnkocGF0Y2hTaXplKX1gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlucHV0U3RyZWFtLnNldFdpZHRoKE1hdGguZmxvb3IoTWF0aC5mbG9vcihzaXplLnggLyBwYXRjaFNpemUueCkgKiAoMSAvIHRoaXNIYWxmU2FtcGxlKSAqIHBhdGNoU2l6ZS54KSk7XG4gICAgICAgIGlucHV0U3RyZWFtLnNldEhlaWdodChNYXRoLmZsb29yKE1hdGguZmxvb3Ioc2l6ZS55IC8gcGF0Y2hTaXplLnkpICogKDEgLyB0aGlzSGFsZlNhbXBsZSkgKiBwYXRjaFNpemUueSkpO1xuXG4gICAgICAgIGlmICgoaW5wdXRTdHJlYW0uZ2V0V2lkdGgoKSAlIHBhdGNoU2l6ZS54KSA9PT0gMCAmJiAoaW5wdXRTdHJlYW0uZ2V0SGVpZ2h0KCkgJSBwYXRjaFNpemUueSkgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbWFnZSBkaW1lbnNpb25zIGRvIG5vdCBjb21wbHkgd2l0aCB0aGUgY3VycmVudCBzZXR0aW5nczogV2lkdGggKCR7XG4gICAgICAgICAgICB3aWR0aH0gKWFuZCBoZWlnaHQgKCR7aGVpZ2h0XG4gICAgICAgIH0pIG11c3QgYSBtdWx0aXBsZSBvZiAke3BhdGNoU2l6ZS54fWApO1xuICAgIH0sXG59O1xuIiwidmFyIGxpc3RDYWNoZUNsZWFyID0gcmVxdWlyZSgnLi9fbGlzdENhY2hlQ2xlYXInKSxcbiAgICBsaXN0Q2FjaGVEZWxldGUgPSByZXF1aXJlKCcuL19saXN0Q2FjaGVEZWxldGUnKSxcbiAgICBsaXN0Q2FjaGVHZXQgPSByZXF1aXJlKCcuL19saXN0Q2FjaGVHZXQnKSxcbiAgICBsaXN0Q2FjaGVIYXMgPSByZXF1aXJlKCcuL19saXN0Q2FjaGVIYXMnKSxcbiAgICBsaXN0Q2FjaGVTZXQgPSByZXF1aXJlKCcuL19saXN0Q2FjaGVTZXQnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGxpc3QgY2FjaGUgb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBMaXN0Q2FjaGUoZW50cmllcykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGVudHJpZXMgPT0gbnVsbCA/IDAgOiBlbnRyaWVzLmxlbmd0aDtcblxuICB0aGlzLmNsZWFyKCk7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGVudHJ5ID0gZW50cmllc1tpbmRleF07XG4gICAgdGhpcy5zZXQoZW50cnlbMF0sIGVudHJ5WzFdKTtcbiAgfVxufVxuXG4vLyBBZGQgbWV0aG9kcyB0byBgTGlzdENhY2hlYC5cbkxpc3RDYWNoZS5wcm90b3R5cGUuY2xlYXIgPSBsaXN0Q2FjaGVDbGVhcjtcbkxpc3RDYWNoZS5wcm90b3R5cGVbJ2RlbGV0ZSddID0gbGlzdENhY2hlRGVsZXRlO1xuTGlzdENhY2hlLnByb3RvdHlwZS5nZXQgPSBsaXN0Q2FjaGVHZXQ7XG5MaXN0Q2FjaGUucHJvdG90eXBlLmhhcyA9IGxpc3RDYWNoZUhhcztcbkxpc3RDYWNoZS5wcm90b3R5cGUuc2V0ID0gbGlzdENhY2hlU2V0O1xuXG5tb2R1bGUuZXhwb3J0cyA9IExpc3RDYWNoZTtcbiIsInZhciBlcSA9IHJlcXVpcmUoJy4vZXEnKTtcblxuLyoqXG4gKiBHZXRzIHRoZSBpbmRleCBhdCB3aGljaCB0aGUgYGtleWAgaXMgZm91bmQgaW4gYGFycmF5YCBvZiBrZXktdmFsdWUgcGFpcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICogQHBhcmFtIHsqfSBrZXkgVGhlIGtleSB0byBzZWFyY2ggZm9yLlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUsIGVsc2UgYC0xYC5cbiAqL1xuZnVuY3Rpb24gYXNzb2NJbmRleE9mKGFycmF5LCBrZXkpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcbiAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgaWYgKGVxKGFycmF5W2xlbmd0aF1bMF0sIGtleSkpIHtcbiAgICAgIHJldHVybiBsZW5ndGg7XG4gICAgfVxuICB9XG4gIHJldHVybiAtMTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhc3NvY0luZGV4T2Y7XG4iLCIvKipcbiAqIFBlcmZvcm1zIGFcbiAqIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG4gKiBjb21wYXJpc29uIGJldHdlZW4gdHdvIHZhbHVlcyB0byBkZXRlcm1pbmUgaWYgdGhleSBhcmUgZXF1aXZhbGVudC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZhbHVlcyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEgfTtcbiAqIHZhciBvdGhlciA9IHsgJ2EnOiAxIH07XG4gKlxuICogXy5lcShvYmplY3QsIG9iamVjdCk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5lcShvYmplY3QsIG90aGVyKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5lcSgnYScsICdhJyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5lcSgnYScsIE9iamVjdCgnYScpKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5lcShOYU4sIE5hTik7XG4gKiAvLyA9PiB0cnVlXG4gKi9cbmZ1bmN0aW9uIGVxKHZhbHVlLCBvdGhlcikge1xuICByZXR1cm4gdmFsdWUgPT09IG90aGVyIHx8ICh2YWx1ZSAhPT0gdmFsdWUgJiYgb3RoZXIgIT09IG90aGVyKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBlcTtcbiIsInZhciByb290ID0gcmVxdWlyZSgnLi9fcm9vdCcpO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBTeW1ib2wgPSByb290LlN5bWJvbDtcblxubW9kdWxlLmV4cG9ydHMgPSBTeW1ib2w7XG4iLCJ2YXIgZ2V0TmF0aXZlID0gcmVxdWlyZSgnLi9fZ2V0TmF0aXZlJyk7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHRoYXQgYXJlIHZlcmlmaWVkIHRvIGJlIG5hdGl2ZS4gKi9cbnZhciBuYXRpdmVDcmVhdGUgPSBnZXROYXRpdmUoT2JqZWN0LCAnY3JlYXRlJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gbmF0aXZlQ3JlYXRlO1xuIiwidmFyIGlzS2V5YWJsZSA9IHJlcXVpcmUoJy4vX2lzS2V5YWJsZScpO1xuXG4vKipcbiAqIEdldHMgdGhlIGRhdGEgZm9yIGBtYXBgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gbWFwIFRoZSBtYXAgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSByZWZlcmVuY2Uga2V5LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIG1hcCBkYXRhLlxuICovXG5mdW5jdGlvbiBnZXRNYXBEYXRhKG1hcCwga2V5KSB7XG4gIHZhciBkYXRhID0gbWFwLl9fZGF0YV9fO1xuICByZXR1cm4gaXNLZXlhYmxlKGtleSlcbiAgICA/IGRhdGFbdHlwZW9mIGtleSA9PSAnc3RyaW5nJyA/ICdzdHJpbmcnIDogJ2hhc2gnXVxuICAgIDogZGF0YS5tYXA7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0TWFwRGF0YTtcbiIsInZhciBiYXNlSXNBcmd1bWVudHMgPSByZXF1aXJlKCcuL19iYXNlSXNBcmd1bWVudHMnKSxcbiAgICBpc09iamVjdExpa2UgPSByZXF1aXJlKCcuL2lzT2JqZWN0TGlrZScpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBwcm9wZXJ0eUlzRW51bWVyYWJsZSA9IG9iamVjdFByb3RvLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGxpa2VseSBhbiBgYXJndW1lbnRzYCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LFxuICogIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FyZ3VtZW50cyhmdW5jdGlvbigpIHsgcmV0dXJuIGFyZ3VtZW50czsgfSgpKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJndW1lbnRzKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNBcmd1bWVudHMgPSBiYXNlSXNBcmd1bWVudHMoZnVuY3Rpb24oKSB7IHJldHVybiBhcmd1bWVudHM7IH0oKSkgPyBiYXNlSXNBcmd1bWVudHMgOiBmdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCAnY2FsbGVlJykgJiZcbiAgICAhcHJvcGVydHlJc0VudW1lcmFibGUuY2FsbCh2YWx1ZSwgJ2NhbGxlZScpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBpc0FyZ3VtZW50cztcbiIsIi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIE1BWF9TQUZFX0lOVEVHRVIgPSA5MDA3MTk5MjU0NzQwOTkxO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgdW5zaWduZWQgaW50ZWdlciB2YWx1ZXMuICovXG52YXIgcmVJc1VpbnQgPSAvXig/OjB8WzEtOV1cXGQqKSQvO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgYXJyYXktbGlrZSBpbmRleC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcGFyYW0ge251bWJlcn0gW2xlbmd0aD1NQVhfU0FGRV9JTlRFR0VSXSBUaGUgdXBwZXIgYm91bmRzIG9mIGEgdmFsaWQgaW5kZXguXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGluZGV4LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzSW5kZXgodmFsdWUsIGxlbmd0aCkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgbGVuZ3RoID0gbGVuZ3RoID09IG51bGwgPyBNQVhfU0FGRV9JTlRFR0VSIDogbGVuZ3RoO1xuXG4gIHJldHVybiAhIWxlbmd0aCAmJlxuICAgICh0eXBlID09ICdudW1iZXInIHx8XG4gICAgICAodHlwZSAhPSAnc3ltYm9sJyAmJiByZUlzVWludC50ZXN0KHZhbHVlKSkpICYmXG4gICAgICAgICh2YWx1ZSA+IC0xICYmIHZhbHVlICUgMSA9PSAwICYmIHZhbHVlIDwgbGVuZ3RoKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0luZGV4O1xuIiwidmFyIGlzQXJyYXkgPSByZXF1aXJlKCcuL2lzQXJyYXknKSxcbiAgICBpc0tleSA9IHJlcXVpcmUoJy4vX2lzS2V5JyksXG4gICAgc3RyaW5nVG9QYXRoID0gcmVxdWlyZSgnLi9fc3RyaW5nVG9QYXRoJyksXG4gICAgdG9TdHJpbmcgPSByZXF1aXJlKCcuL3RvU3RyaW5nJyk7XG5cbi8qKlxuICogQ2FzdHMgYHZhbHVlYCB0byBhIHBhdGggYXJyYXkgaWYgaXQncyBub3Qgb25lLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBpbnNwZWN0LlxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBvYmplY3QgdG8gcXVlcnkga2V5cyBvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgY2FzdCBwcm9wZXJ0eSBwYXRoIGFycmF5LlxuICovXG5mdW5jdGlvbiBjYXN0UGF0aCh2YWx1ZSwgb2JqZWN0KSB7XG4gIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICByZXR1cm4gaXNLZXkodmFsdWUsIG9iamVjdCkgPyBbdmFsdWVdIDogc3RyaW5nVG9QYXRoKHRvU3RyaW5nKHZhbHVlKSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2FzdFBhdGg7XG4iLCJ2YXIgYXJyYXlXaXRob3V0SG9sZXMgPSByZXF1aXJlKFwiLi9hcnJheVdpdGhvdXRIb2xlcy5qc1wiKTtcblxudmFyIGl0ZXJhYmxlVG9BcnJheSA9IHJlcXVpcmUoXCIuL2l0ZXJhYmxlVG9BcnJheS5qc1wiKTtcblxudmFyIHVuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5ID0gcmVxdWlyZShcIi4vdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkuanNcIik7XG5cbnZhciBub25JdGVyYWJsZVNwcmVhZCA9IHJlcXVpcmUoXCIuL25vbkl0ZXJhYmxlU3ByZWFkLmpzXCIpO1xuXG5mdW5jdGlvbiBfdG9Db25zdW1hYmxlQXJyYXkoYXJyKSB7XG4gIHJldHVybiBhcnJheVdpdGhvdXRIb2xlcyhhcnIpIHx8IGl0ZXJhYmxlVG9BcnJheShhcnIpIHx8IHVuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KGFycikgfHwgbm9uSXRlcmFibGVTcHJlYWQoKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfdG9Db25zdW1hYmxlQXJyYXksIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlLCBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0czsiLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBkZXRlcm1pbmFudDogcmVxdWlyZSgnLi9kZXRlcm1pbmFudCcpXG4gICwgdHJhbnNwb3NlOiByZXF1aXJlKCcuL3RyYW5zcG9zZScpXG4gICwgbXVsdGlwbHk6IHJlcXVpcmUoJy4vbXVsdGlwbHknKVxuICAsIGlkZW50aXR5OiByZXF1aXJlKCcuL2lkZW50aXR5JylcbiAgLCBhZGpvaW50OiByZXF1aXJlKCcuL2Fkam9pbnQnKVxuICAsIHJvdGF0ZTogcmVxdWlyZSgnLi9yb3RhdGUnKVxuICAsIGludmVydDogcmVxdWlyZSgnLi9pbnZlcnQnKVxuICAsIGNyZWF0ZTogcmVxdWlyZSgnLi9jcmVhdGUnKVxuICAsIHNjYWxlOiByZXF1aXJlKCcuL3NjYWxlJylcbiAgLCBjb3B5OiByZXF1aXJlKCcuL2NvcHknKVxuICAsIGZyb2I6IHJlcXVpcmUoJy4vZnJvYicpXG4gICwgbGR1OiByZXF1aXJlKCcuL2xkdScpXG59XG4iLCJ2YXIgYmFzZUlzTmF0aXZlID0gcmVxdWlyZSgnLi9fYmFzZUlzTmF0aXZlJyksXG4gICAgZ2V0VmFsdWUgPSByZXF1aXJlKCcuL19nZXRWYWx1ZScpO1xuXG4vKipcbiAqIEdldHMgdGhlIG5hdGl2ZSBmdW5jdGlvbiBhdCBga2V5YCBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBtZXRob2QgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGZ1bmN0aW9uIGlmIGl0J3MgbmF0aXZlLCBlbHNlIGB1bmRlZmluZWRgLlxuICovXG5mdW5jdGlvbiBnZXROYXRpdmUob2JqZWN0LCBrZXkpIHtcbiAgdmFyIHZhbHVlID0gZ2V0VmFsdWUob2JqZWN0LCBrZXkpO1xuICByZXR1cm4gYmFzZUlzTmF0aXZlKHZhbHVlKSA/IHZhbHVlIDogdW5kZWZpbmVkO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldE5hdGl2ZTtcbiIsInZhciBiYXNlR2V0VGFnID0gcmVxdWlyZSgnLi9fYmFzZUdldFRhZycpLFxuICAgIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9pc09iamVjdCcpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYXN5bmNUYWcgPSAnW29iamVjdCBBc3luY0Z1bmN0aW9uXScsXG4gICAgZnVuY1RhZyA9ICdbb2JqZWN0IEZ1bmN0aW9uXScsXG4gICAgZ2VuVGFnID0gJ1tvYmplY3QgR2VuZXJhdG9yRnVuY3Rpb25dJyxcbiAgICBwcm94eVRhZyA9ICdbb2JqZWN0IFByb3h5XSc7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBGdW5jdGlvbmAgb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgZnVuY3Rpb24sIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0Z1bmN0aW9uKF8pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNGdW5jdGlvbigvYWJjLyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbHVlKSB7XG4gIGlmICghaXNPYmplY3QodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8vIFRoZSB1c2Ugb2YgYE9iamVjdCN0b1N0cmluZ2AgYXZvaWRzIGlzc3VlcyB3aXRoIHRoZSBgdHlwZW9mYCBvcGVyYXRvclxuICAvLyBpbiBTYWZhcmkgOSB3aGljaCByZXR1cm5zICdvYmplY3QnIGZvciB0eXBlZCBhcnJheXMgYW5kIG90aGVyIGNvbnN0cnVjdG9ycy5cbiAgdmFyIHRhZyA9IGJhc2VHZXRUYWcodmFsdWUpO1xuICByZXR1cm4gdGFnID09IGZ1bmNUYWcgfHwgdGFnID09IGdlblRhZyB8fCB0YWcgPT0gYXN5bmNUYWcgfHwgdGFnID09IHByb3h5VGFnO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzRnVuY3Rpb247XG4iLCJ2YXIgZGVmaW5lUHJvcGVydHkgPSByZXF1aXJlKCcuL19kZWZpbmVQcm9wZXJ0eScpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBhc3NpZ25WYWx1ZWAgYW5kIGBhc3NpZ25NZXJnZVZhbHVlYCB3aXRob3V0XG4gKiB2YWx1ZSBjaGVja3MuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGFzc2lnbi5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGFzc2lnbi5cbiAqL1xuZnVuY3Rpb24gYmFzZUFzc2lnblZhbHVlKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICBpZiAoa2V5ID09ICdfX3Byb3RvX18nICYmIGRlZmluZVByb3BlcnR5KSB7XG4gICAgZGVmaW5lUHJvcGVydHkob2JqZWN0LCBrZXksIHtcbiAgICAgICdjb25maWd1cmFibGUnOiB0cnVlLFxuICAgICAgJ2VudW1lcmFibGUnOiB0cnVlLFxuICAgICAgJ3ZhbHVlJzogdmFsdWUsXG4gICAgICAnd3JpdGFibGUnOiB0cnVlXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0W2tleV0gPSB2YWx1ZTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VBc3NpZ25WYWx1ZTtcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obW9kdWxlKSB7XG5cdGlmICghbW9kdWxlLndlYnBhY2tQb2x5ZmlsbCkge1xuXHRcdG1vZHVsZS5kZXByZWNhdGUgPSBmdW5jdGlvbigpIHt9O1xuXHRcdG1vZHVsZS5wYXRocyA9IFtdO1xuXHRcdC8vIG1vZHVsZS5wYXJlbnQgPSB1bmRlZmluZWQgYnkgZGVmYXVsdFxuXHRcdGlmICghbW9kdWxlLmNoaWxkcmVuKSBtb2R1bGUuY2hpbGRyZW4gPSBbXTtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobW9kdWxlLCBcImxvYWRlZFwiLCB7XG5cdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0Z2V0OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIG1vZHVsZS5sO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtb2R1bGUsIFwiaWRcIiwge1xuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdGdldDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiBtb2R1bGUuaTtcblx0XHRcdH1cblx0XHR9KTtcblx0XHRtb2R1bGUud2VicGFja1BvbHlmaWxsID0gMTtcblx0fVxuXHRyZXR1cm4gbW9kdWxlO1xufTtcbiIsInZhciBpc0Z1bmN0aW9uID0gcmVxdWlyZSgnLi9pc0Z1bmN0aW9uJyksXG4gICAgaXNMZW5ndGggPSByZXF1aXJlKCcuL2lzTGVuZ3RoJyk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYXJyYXktbGlrZS4gQSB2YWx1ZSBpcyBjb25zaWRlcmVkIGFycmF5LWxpa2UgaWYgaXQnc1xuICogbm90IGEgZnVuY3Rpb24gYW5kIGhhcyBhIGB2YWx1ZS5sZW5ndGhgIHRoYXQncyBhbiBpbnRlZ2VyIGdyZWF0ZXIgdGhhbiBvclxuICogZXF1YWwgdG8gYDBgIGFuZCBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gYE51bWJlci5NQVhfU0FGRV9JTlRFR0VSYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhcnJheS1saWtlLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKGRvY3VtZW50LmJvZHkuY2hpbGRyZW4pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoJ2FiYycpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzQXJyYXlMaWtlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmIGlzTGVuZ3RoKHZhbHVlLmxlbmd0aCkgJiYgIWlzRnVuY3Rpb24odmFsdWUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzQXJyYXlMaWtlO1xuIiwiLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG52YXIgTUFYX1NBRkVfSU5URUdFUiA9IDkwMDcxOTkyNTQ3NDA5OTE7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBhcnJheS1saWtlIGxlbmd0aC5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgbG9vc2VseSBiYXNlZCBvblxuICogW2BUb0xlbmd0aGBdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXRvbGVuZ3RoKS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGxlbmd0aCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzTGVuZ3RoKDMpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNMZW5ndGgoTnVtYmVyLk1JTl9WQUxVRSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNMZW5ndGgoSW5maW5pdHkpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzTGVuZ3RoKCczJyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0xlbmd0aCh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdudW1iZXInICYmXG4gICAgdmFsdWUgPiAtMSAmJiB2YWx1ZSAlIDEgPT0gMCAmJiB2YWx1ZSA8PSBNQVhfU0FGRV9JTlRFR0VSO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzTGVuZ3RoO1xuIiwiZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2YuYmluZCgpIDogZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgICBvLl9fcHJvdG9fXyA9IHA7XG4gICAgcmV0dXJuIG87XG4gIH0sIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlLCBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0cztcbiAgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfc2V0UHJvdG90eXBlT2YsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlLCBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0czsiLCJ2YXIgYmFzZUdldFRhZyA9IHJlcXVpcmUoJy4vX2Jhc2VHZXRUYWcnKSxcbiAgICBpc09iamVjdExpa2UgPSByZXF1aXJlKCcuL2lzT2JqZWN0TGlrZScpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgc3ltYm9sVGFnID0gJ1tvYmplY3QgU3ltYm9sXSc7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBTeW1ib2xgIHByaW1pdGl2ZSBvciBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBzeW1ib2wsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc1N5bWJvbChTeW1ib2wuaXRlcmF0b3IpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNTeW1ib2woJ2FiYycpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNTeW1ib2wodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnc3ltYm9sJyB8fFxuICAgIChpc09iamVjdExpa2UodmFsdWUpICYmIGJhc2VHZXRUYWcodmFsdWUpID09IHN5bWJvbFRhZyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNTeW1ib2w7XG4iLCJ2YXIgaXNTeW1ib2wgPSByZXF1aXJlKCcuL2lzU3ltYm9sJyk7XG5cbi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIElORklOSVRZID0gMSAvIDA7XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIHN0cmluZyBrZXkgaWYgaXQncyBub3QgYSBzdHJpbmcgb3Igc3ltYm9sLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBpbnNwZWN0LlxuICogQHJldHVybnMge3N0cmluZ3xzeW1ib2x9IFJldHVybnMgdGhlIGtleS5cbiAqL1xuZnVuY3Rpb24gdG9LZXkodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJyB8fCBpc1N5bWJvbCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgdmFyIHJlc3VsdCA9ICh2YWx1ZSArICcnKTtcbiAgcmV0dXJuIChyZXN1bHQgPT0gJzAnICYmICgxIC8gdmFsdWUpID09IC1JTkZJTklUWSkgPyAnLTAnIDogcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHRvS2V5O1xuIiwidmFyIGdldE5hdGl2ZSA9IHJlcXVpcmUoJy4vX2dldE5hdGl2ZScpLFxuICAgIHJvb3QgPSByZXF1aXJlKCcuL19yb290Jyk7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHRoYXQgYXJlIHZlcmlmaWVkIHRvIGJlIG5hdGl2ZS4gKi9cbnZhciBNYXAgPSBnZXROYXRpdmUocm9vdCwgJ01hcCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IE1hcDtcbiIsIi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZ2xvYmFsYCBmcm9tIE5vZGUuanMuICovXG52YXIgZnJlZUdsb2JhbCA9IHR5cGVvZiBnbG9iYWwgPT0gJ29iamVjdCcgJiYgZ2xvYmFsICYmIGdsb2JhbC5PYmplY3QgPT09IE9iamVjdCAmJiBnbG9iYWw7XG5cbm1vZHVsZS5leHBvcnRzID0gZnJlZUdsb2JhbDtcbiIsInZhciBnO1xuXG4vLyBUaGlzIHdvcmtzIGluIG5vbi1zdHJpY3QgbW9kZVxuZyA9IChmdW5jdGlvbigpIHtcblx0cmV0dXJuIHRoaXM7XG59KSgpO1xuXG50cnkge1xuXHQvLyBUaGlzIHdvcmtzIGlmIGV2YWwgaXMgYWxsb3dlZCAoc2VlIENTUClcblx0ZyA9IGcgfHwgbmV3IEZ1bmN0aW9uKFwicmV0dXJuIHRoaXNcIikoKTtcbn0gY2F0Y2ggKGUpIHtcblx0Ly8gVGhpcyB3b3JrcyBpZiB0aGUgd2luZG93IHJlZmVyZW5jZSBpcyBhdmFpbGFibGVcblx0aWYgKHR5cGVvZiB3aW5kb3cgPT09IFwib2JqZWN0XCIpIGcgPSB3aW5kb3c7XG59XG5cbi8vIGcgY2FuIHN0aWxsIGJlIHVuZGVmaW5lZCwgYnV0IG5vdGhpbmcgdG8gZG8gYWJvdXQgaXQuLi5cbi8vIFdlIHJldHVybiB1bmRlZmluZWQsIGluc3RlYWQgb2Ygbm90aGluZyBoZXJlLCBzbyBpdCdzXG4vLyBlYXNpZXIgdG8gaGFuZGxlIHRoaXMgY2FzZS4gaWYoIWdsb2JhbCkgeyAuLi59XG5cbm1vZHVsZS5leHBvcnRzID0gZztcbiIsInZhciBtYXBDYWNoZUNsZWFyID0gcmVxdWlyZSgnLi9fbWFwQ2FjaGVDbGVhcicpLFxuICAgIG1hcENhY2hlRGVsZXRlID0gcmVxdWlyZSgnLi9fbWFwQ2FjaGVEZWxldGUnKSxcbiAgICBtYXBDYWNoZUdldCA9IHJlcXVpcmUoJy4vX21hcENhY2hlR2V0JyksXG4gICAgbWFwQ2FjaGVIYXMgPSByZXF1aXJlKCcuL19tYXBDYWNoZUhhcycpLFxuICAgIG1hcENhY2hlU2V0ID0gcmVxdWlyZSgnLi9fbWFwQ2FjaGVTZXQnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbWFwIGNhY2hlIG9iamVjdCB0byBzdG9yZSBrZXktdmFsdWUgcGFpcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIE1hcENhY2hlKGVudHJpZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBlbnRyaWVzID09IG51bGwgPyAwIDogZW50cmllcy5sZW5ndGg7XG5cbiAgdGhpcy5jbGVhcigpO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaW5kZXhdO1xuICAgIHRoaXMuc2V0KGVudHJ5WzBdLCBlbnRyeVsxXSk7XG4gIH1cbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYE1hcENhY2hlYC5cbk1hcENhY2hlLnByb3RvdHlwZS5jbGVhciA9IG1hcENhY2hlQ2xlYXI7XG5NYXBDYWNoZS5wcm90b3R5cGVbJ2RlbGV0ZSddID0gbWFwQ2FjaGVEZWxldGU7XG5NYXBDYWNoZS5wcm90b3R5cGUuZ2V0ID0gbWFwQ2FjaGVHZXQ7XG5NYXBDYWNoZS5wcm90b3R5cGUuaGFzID0gbWFwQ2FjaGVIYXM7XG5NYXBDYWNoZS5wcm90b3R5cGUuc2V0ID0gbWFwQ2FjaGVTZXQ7XG5cbm1vZHVsZS5leHBvcnRzID0gTWFwQ2FjaGU7XG4iLCJ2YXIgYmFzZUFzc2lnblZhbHVlID0gcmVxdWlyZSgnLi9fYmFzZUFzc2lnblZhbHVlJyksXG4gICAgZXEgPSByZXF1aXJlKCcuL2VxJyk7XG5cbi8qKlxuICogVGhpcyBmdW5jdGlvbiBpcyBsaWtlIGBhc3NpZ25WYWx1ZWAgZXhjZXB0IHRoYXQgaXQgZG9lc24ndCBhc3NpZ25cbiAqIGB1bmRlZmluZWRgIHZhbHVlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gYXNzaWduLlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gYXNzaWduLlxuICovXG5mdW5jdGlvbiBhc3NpZ25NZXJnZVZhbHVlKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICBpZiAoKHZhbHVlICE9PSB1bmRlZmluZWQgJiYgIWVxKG9iamVjdFtrZXldLCB2YWx1ZSkpIHx8XG4gICAgICAodmFsdWUgPT09IHVuZGVmaW5lZCAmJiAhKGtleSBpbiBvYmplY3QpKSkge1xuICAgIGJhc2VBc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgdmFsdWUpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXNzaWduTWVyZ2VWYWx1ZTtcbiIsInZhciBnZXROYXRpdmUgPSByZXF1aXJlKCcuL19nZXROYXRpdmUnKTtcblxudmFyIGRlZmluZVByb3BlcnR5ID0gKGZ1bmN0aW9uKCkge1xuICB0cnkge1xuICAgIHZhciBmdW5jID0gZ2V0TmF0aXZlKE9iamVjdCwgJ2RlZmluZVByb3BlcnR5Jyk7XG4gICAgZnVuYyh7fSwgJycsIHt9KTtcbiAgICByZXR1cm4gZnVuYztcbiAgfSBjYXRjaCAoZSkge31cbn0oKSk7XG5cbm1vZHVsZS5leHBvcnRzID0gZGVmaW5lUHJvcGVydHk7XG4iLCJ2YXIgb3ZlckFyZyA9IHJlcXVpcmUoJy4vX292ZXJBcmcnKTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgZ2V0UHJvdG90eXBlID0gb3ZlckFyZyhPYmplY3QuZ2V0UHJvdG90eXBlT2YsIE9iamVjdCk7XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0UHJvdG90eXBlO1xuIiwiLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBsaWtlbHkgYSBwcm90b3R5cGUgb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgcHJvdG90eXBlLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzUHJvdG90eXBlKHZhbHVlKSB7XG4gIHZhciBDdG9yID0gdmFsdWUgJiYgdmFsdWUuY29uc3RydWN0b3IsXG4gICAgICBwcm90byA9ICh0eXBlb2YgQ3RvciA9PSAnZnVuY3Rpb24nICYmIEN0b3IucHJvdG90eXBlKSB8fCBvYmplY3RQcm90bztcblxuICByZXR1cm4gdmFsdWUgPT09IHByb3RvO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzUHJvdG90eXBlO1xuIiwidmFyIHJvb3QgPSByZXF1aXJlKCcuL19yb290JyksXG4gICAgc3R1YkZhbHNlID0gcmVxdWlyZSgnLi9zdHViRmFsc2UnKTtcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBleHBvcnRzYC4gKi9cbnZhciBmcmVlRXhwb3J0cyA9IHR5cGVvZiBleHBvcnRzID09ICdvYmplY3QnICYmIGV4cG9ydHMgJiYgIWV4cG9ydHMubm9kZVR5cGUgJiYgZXhwb3J0cztcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBtb2R1bGVgLiAqL1xudmFyIGZyZWVNb2R1bGUgPSBmcmVlRXhwb3J0cyAmJiB0eXBlb2YgbW9kdWxlID09ICdvYmplY3QnICYmIG1vZHVsZSAmJiAhbW9kdWxlLm5vZGVUeXBlICYmIG1vZHVsZTtcblxuLyoqIERldGVjdCB0aGUgcG9wdWxhciBDb21tb25KUyBleHRlbnNpb24gYG1vZHVsZS5leHBvcnRzYC4gKi9cbnZhciBtb2R1bGVFeHBvcnRzID0gZnJlZU1vZHVsZSAmJiBmcmVlTW9kdWxlLmV4cG9ydHMgPT09IGZyZWVFeHBvcnRzO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBCdWZmZXIgPSBtb2R1bGVFeHBvcnRzID8gcm9vdC5CdWZmZXIgOiB1bmRlZmluZWQ7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVJc0J1ZmZlciA9IEJ1ZmZlciA/IEJ1ZmZlci5pc0J1ZmZlciA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIGJ1ZmZlci5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMy4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIGJ1ZmZlciwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQnVmZmVyKG5ldyBCdWZmZXIoMikpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNCdWZmZXIobmV3IFVpbnQ4QXJyYXkoMikpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzQnVmZmVyID0gbmF0aXZlSXNCdWZmZXIgfHwgc3R1YkZhbHNlO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGlzQnVmZmVyO1xuIiwidmFyIGJhc2VJc1R5cGVkQXJyYXkgPSByZXF1aXJlKCcuL19iYXNlSXNUeXBlZEFycmF5JyksXG4gICAgYmFzZVVuYXJ5ID0gcmVxdWlyZSgnLi9fYmFzZVVuYXJ5JyksXG4gICAgbm9kZVV0aWwgPSByZXF1aXJlKCcuL19ub2RlVXRpbCcpO1xuXG4vKiBOb2RlLmpzIGhlbHBlciByZWZlcmVuY2VzLiAqL1xudmFyIG5vZGVJc1R5cGVkQXJyYXkgPSBub2RlVXRpbCAmJiBub2RlVXRpbC5pc1R5cGVkQXJyYXk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIHR5cGVkIGFycmF5LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMy4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdHlwZWQgYXJyYXksIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc1R5cGVkQXJyYXkobmV3IFVpbnQ4QXJyYXkpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNUeXBlZEFycmF5KFtdKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc1R5cGVkQXJyYXkgPSBub2RlSXNUeXBlZEFycmF5ID8gYmFzZVVuYXJ5KG5vZGVJc1R5cGVkQXJyYXkpIDogYmFzZUlzVHlwZWRBcnJheTtcblxubW9kdWxlLmV4cG9ydHMgPSBpc1R5cGVkQXJyYXk7XG4iLCIvKipcbiAqIEdldHMgdGhlIHZhbHVlIGF0IGBrZXlgLCB1bmxlc3MgYGtleWAgaXMgXCJfX3Byb3RvX19cIiBvciBcImNvbnN0cnVjdG9yXCIuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHByb3BlcnR5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBzYWZlR2V0KG9iamVjdCwga2V5KSB7XG4gIGlmIChrZXkgPT09ICdjb25zdHJ1Y3RvcicgJiYgdHlwZW9mIG9iamVjdFtrZXldID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKGtleSA9PSAnX19wcm90b19fJykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHJldHVybiBvYmplY3Rba2V5XTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzYWZlR2V0O1xuIiwidmFyIGJhc2VBc3NpZ25WYWx1ZSA9IHJlcXVpcmUoJy4vX2Jhc2VBc3NpZ25WYWx1ZScpLFxuICAgIGVxID0gcmVxdWlyZSgnLi9lcScpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIEFzc2lnbnMgYHZhbHVlYCB0byBga2V5YCBvZiBgb2JqZWN0YCBpZiB0aGUgZXhpc3RpbmcgdmFsdWUgaXMgbm90IGVxdWl2YWxlbnRcbiAqIHVzaW5nIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG4gKiBmb3IgZXF1YWxpdHkgY29tcGFyaXNvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGFzc2lnbi5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGFzc2lnbi5cbiAqL1xuZnVuY3Rpb24gYXNzaWduVmFsdWUob2JqZWN0LCBrZXksIHZhbHVlKSB7XG4gIHZhciBvYmpWYWx1ZSA9IG9iamVjdFtrZXldO1xuICBpZiAoIShoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSAmJiBlcShvYmpWYWx1ZSwgdmFsdWUpKSB8fFxuICAgICAgKHZhbHVlID09PSB1bmRlZmluZWQgJiYgIShrZXkgaW4gb2JqZWN0KSkpIHtcbiAgICBiYXNlQXNzaWduVmFsdWUob2JqZWN0LCBrZXksIHZhbHVlKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFzc2lnblZhbHVlO1xuIiwidmFyIGFycmF5TGlrZUtleXMgPSByZXF1aXJlKCcuL19hcnJheUxpa2VLZXlzJyksXG4gICAgYmFzZUtleXNJbiA9IHJlcXVpcmUoJy4vX2Jhc2VLZXlzSW4nKSxcbiAgICBpc0FycmF5TGlrZSA9IHJlcXVpcmUoJy4vaXNBcnJheUxpa2UnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gYW5kIGluaGVyaXRlZCBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIGBvYmplY3RgLlxuICpcbiAqICoqTm90ZToqKiBOb24tb2JqZWN0IHZhbHVlcyBhcmUgY29lcmNlZCB0byBvYmplY3RzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMy4wLjBcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKiBAZXhhbXBsZVxuICpcbiAqIGZ1bmN0aW9uIEZvbygpIHtcbiAqICAgdGhpcy5hID0gMTtcbiAqICAgdGhpcy5iID0gMjtcbiAqIH1cbiAqXG4gKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICpcbiAqIF8ua2V5c0luKG5ldyBGb28pO1xuICogLy8gPT4gWydhJywgJ2InLCAnYyddIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gKi9cbmZ1bmN0aW9uIGtleXNJbihvYmplY3QpIHtcbiAgcmV0dXJuIGlzQXJyYXlMaWtlKG9iamVjdCkgPyBhcnJheUxpa2VLZXlzKG9iamVjdCwgdHJ1ZSkgOiBiYXNlS2V5c0luKG9iamVjdCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ga2V5c0luO1xuIiwiLyoqXG4gKiBUaGlzIG1ldGhvZCByZXR1cm5zIHRoZSBmaXJzdCBhcmd1bWVudCBpdCByZWNlaXZlcy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHBhcmFtIHsqfSB2YWx1ZSBBbnkgdmFsdWUuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyBgdmFsdWVgLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEgfTtcbiAqXG4gKiBjb25zb2xlLmxvZyhfLmlkZW50aXR5KG9iamVjdCkgPT09IG9iamVjdCk7XG4gKiAvLyA9PiB0cnVlXG4gKi9cbmZ1bmN0aW9uIGlkZW50aXR5KHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpZGVudGl0eTtcbiIsInZhciBhcHBseSA9IHJlcXVpcmUoJy4vX2FwcGx5Jyk7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVNYXggPSBNYXRoLm1heDtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VSZXN0YCB3aGljaCB0cmFuc2Zvcm1zIHRoZSByZXN0IGFycmF5LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBhcHBseSBhIHJlc3QgcGFyYW1ldGVyIHRvLlxuICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydD1mdW5jLmxlbmd0aC0xXSBUaGUgc3RhcnQgcG9zaXRpb24gb2YgdGhlIHJlc3QgcGFyYW1ldGVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gdHJhbnNmb3JtIFRoZSByZXN0IGFycmF5IHRyYW5zZm9ybS5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBvdmVyUmVzdChmdW5jLCBzdGFydCwgdHJhbnNmb3JtKSB7XG4gIHN0YXJ0ID0gbmF0aXZlTWF4KHN0YXJ0ID09PSB1bmRlZmluZWQgPyAoZnVuYy5sZW5ndGggLSAxKSA6IHN0YXJ0LCAwKTtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciBhcmdzID0gYXJndW1lbnRzLFxuICAgICAgICBpbmRleCA9IC0xLFxuICAgICAgICBsZW5ndGggPSBuYXRpdmVNYXgoYXJncy5sZW5ndGggLSBzdGFydCwgMCksXG4gICAgICAgIGFycmF5ID0gQXJyYXkobGVuZ3RoKTtcblxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICBhcnJheVtpbmRleF0gPSBhcmdzW3N0YXJ0ICsgaW5kZXhdO1xuICAgIH1cbiAgICBpbmRleCA9IC0xO1xuICAgIHZhciBvdGhlckFyZ3MgPSBBcnJheShzdGFydCArIDEpO1xuICAgIHdoaWxlICgrK2luZGV4IDwgc3RhcnQpIHtcbiAgICAgIG90aGVyQXJnc1tpbmRleF0gPSBhcmdzW2luZGV4XTtcbiAgICB9XG4gICAgb3RoZXJBcmdzW3N0YXJ0XSA9IHRyYW5zZm9ybShhcnJheSk7XG4gICAgcmV0dXJuIGFwcGx5KGZ1bmMsIHRoaXMsIG90aGVyQXJncyk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gb3ZlclJlc3Q7XG4iLCJ2YXIgYmFzZVNldFRvU3RyaW5nID0gcmVxdWlyZSgnLi9fYmFzZVNldFRvU3RyaW5nJyksXG4gICAgc2hvcnRPdXQgPSByZXF1aXJlKCcuL19zaG9ydE91dCcpO1xuXG4vKipcbiAqIFNldHMgdGhlIGB0b1N0cmluZ2AgbWV0aG9kIG9mIGBmdW5jYCB0byByZXR1cm4gYHN0cmluZ2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHN0cmluZyBUaGUgYHRvU3RyaW5nYCByZXN1bHQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgYGZ1bmNgLlxuICovXG52YXIgc2V0VG9TdHJpbmcgPSBzaG9ydE91dChiYXNlU2V0VG9TdHJpbmcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHNldFRvU3RyaW5nO1xuIiwidmFyIGFycmF5TGlrZVRvQXJyYXkgPSByZXF1aXJlKFwiLi9hcnJheUxpa2VUb0FycmF5LmpzXCIpO1xuXG5mdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobywgbWluTGVuKSB7XG4gIGlmICghbykgcmV0dXJuO1xuICBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBhcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7XG4gIHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTtcbiAgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTtcbiAgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7XG4gIGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSwgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzOyIsImZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7XG4gIGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoO1xuXG4gIGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykge1xuICAgIGFycjJbaV0gPSBhcnJbaV07XG4gIH1cblxuICByZXR1cm4gYXJyMjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfYXJyYXlMaWtlVG9BcnJheSwgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzOyIsIm1vZHVsZS5leHBvcnRzID0gMC4wMDAwMDFcbiIsIm1vZHVsZS5leHBvcnRzID0gY3JlYXRlXG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldywgZW1wdHkgdmVjMlxuICpcbiAqIEByZXR1cm5zIHt2ZWMyfSBhIG5ldyAyRCB2ZWN0b3JcbiAqL1xuZnVuY3Rpb24gY3JlYXRlKCkge1xuICAgIHZhciBvdXQgPSBuZXcgRmxvYXQzMkFycmF5KDIpXG4gICAgb3V0WzBdID0gMFxuICAgIG91dFsxXSA9IDBcbiAgICByZXR1cm4gb3V0XG59IiwibW9kdWxlLmV4cG9ydHMgPSBzdWJ0cmFjdFxuXG4vKipcbiAqIFN1YnRyYWN0cyB2ZWN0b3IgYiBmcm9tIHZlY3RvciBhXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjMn0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG5mdW5jdGlvbiBzdWJ0cmFjdChvdXQsIGEsIGIpIHtcbiAgICBvdXRbMF0gPSBhWzBdIC0gYlswXVxuICAgIG91dFsxXSA9IGFbMV0gLSBiWzFdXG4gICAgcmV0dXJuIG91dFxufSIsIm1vZHVsZS5leHBvcnRzID0gbXVsdGlwbHlcblxuLyoqXG4gKiBNdWx0aXBsaWVzIHR3byB2ZWMyJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbmZ1bmN0aW9uIG11bHRpcGx5KG91dCwgYSwgYikge1xuICAgIG91dFswXSA9IGFbMF0gKiBiWzBdXG4gICAgb3V0WzFdID0gYVsxXSAqIGJbMV1cbiAgICByZXR1cm4gb3V0XG59IiwibW9kdWxlLmV4cG9ydHMgPSBkaXZpZGVcblxuLyoqXG4gKiBEaXZpZGVzIHR3byB2ZWMyJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbmZ1bmN0aW9uIGRpdmlkZShvdXQsIGEsIGIpIHtcbiAgICBvdXRbMF0gPSBhWzBdIC8gYlswXVxuICAgIG91dFsxXSA9IGFbMV0gLyBiWzFdXG4gICAgcmV0dXJuIG91dFxufSIsIm1vZHVsZS5leHBvcnRzID0gZGlzdGFuY2VcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBldWNsaWRpYW4gZGlzdGFuY2UgYmV0d2VlbiB0d28gdmVjMidzXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBkaXN0YW5jZSBiZXR3ZWVuIGEgYW5kIGJcbiAqL1xuZnVuY3Rpb24gZGlzdGFuY2UoYSwgYikge1xuICAgIHZhciB4ID0gYlswXSAtIGFbMF0sXG4gICAgICAgIHkgPSBiWzFdIC0gYVsxXVxuICAgIHJldHVybiBNYXRoLnNxcnQoeCp4ICsgeSp5KVxufSIsIm1vZHVsZS5leHBvcnRzID0gc3F1YXJlZERpc3RhbmNlXG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgc3F1YXJlZCBldWNsaWRpYW4gZGlzdGFuY2UgYmV0d2VlbiB0d28gdmVjMidzXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBzcXVhcmVkIGRpc3RhbmNlIGJldHdlZW4gYSBhbmQgYlxuICovXG5mdW5jdGlvbiBzcXVhcmVkRGlzdGFuY2UoYSwgYikge1xuICAgIHZhciB4ID0gYlswXSAtIGFbMF0sXG4gICAgICAgIHkgPSBiWzFdIC0gYVsxXVxuICAgIHJldHVybiB4KnggKyB5Knlcbn0iLCJtb2R1bGUuZXhwb3J0cyA9IGxlbmd0aFxuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGxlbmd0aCBvZiBhIHZlYzJcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdmVjdG9yIHRvIGNhbGN1bGF0ZSBsZW5ndGggb2ZcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGxlbmd0aCBvZiBhXG4gKi9cbmZ1bmN0aW9uIGxlbmd0aChhKSB7XG4gICAgdmFyIHggPSBhWzBdLFxuICAgICAgICB5ID0gYVsxXVxuICAgIHJldHVybiBNYXRoLnNxcnQoeCp4ICsgeSp5KVxufSIsIm1vZHVsZS5leHBvcnRzID0gc3F1YXJlZExlbmd0aFxuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIHNxdWFyZWQgbGVuZ3RoIG9mIGEgdmVjMlxuICpcbiAqIEBwYXJhbSB7dmVjMn0gYSB2ZWN0b3IgdG8gY2FsY3VsYXRlIHNxdWFyZWQgbGVuZ3RoIG9mXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBzcXVhcmVkIGxlbmd0aCBvZiBhXG4gKi9cbmZ1bmN0aW9uIHNxdWFyZWRMZW5ndGgoYSkge1xuICAgIHZhciB4ID0gYVswXSxcbiAgICAgICAgeSA9IGFbMV1cbiAgICByZXR1cm4geCp4ICsgeSp5XG59IiwibW9kdWxlLmV4cG9ydHMgPSAwLjAwMDAwMVxuIiwibW9kdWxlLmV4cG9ydHMgPSBjcmVhdGU7XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldywgZW1wdHkgdmVjM1xuICpcbiAqIEByZXR1cm5zIHt2ZWMzfSBhIG5ldyAzRCB2ZWN0b3JcbiAqL1xuZnVuY3Rpb24gY3JlYXRlKCkge1xuICAgIHZhciBvdXQgPSBuZXcgRmxvYXQzMkFycmF5KDMpXG4gICAgb3V0WzBdID0gMFxuICAgIG91dFsxXSA9IDBcbiAgICBvdXRbMl0gPSAwXG4gICAgcmV0dXJuIG91dFxufSIsIm1vZHVsZS5leHBvcnRzID0gZnJvbVZhbHVlcztcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IHZlYzMgaW5pdGlhbGl6ZWQgd2l0aCB0aGUgZ2l2ZW4gdmFsdWVzXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IHggWCBjb21wb25lbnRcbiAqIEBwYXJhbSB7TnVtYmVyfSB5IFkgY29tcG9uZW50XG4gKiBAcGFyYW0ge051bWJlcn0geiBaIGNvbXBvbmVudFxuICogQHJldHVybnMge3ZlYzN9IGEgbmV3IDNEIHZlY3RvclxuICovXG5mdW5jdGlvbiBmcm9tVmFsdWVzKHgsIHksIHopIHtcbiAgICB2YXIgb3V0ID0gbmV3IEZsb2F0MzJBcnJheSgzKVxuICAgIG91dFswXSA9IHhcbiAgICBvdXRbMV0gPSB5XG4gICAgb3V0WzJdID0gelxuICAgIHJldHVybiBvdXRcbn0iLCJtb2R1bGUuZXhwb3J0cyA9IG5vcm1hbGl6ZTtcblxuLyoqXG4gKiBOb3JtYWxpemUgYSB2ZWMzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB2ZWN0b3IgdG8gbm9ybWFsaXplXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbmZ1bmN0aW9uIG5vcm1hbGl6ZShvdXQsIGEpIHtcbiAgICB2YXIgeCA9IGFbMF0sXG4gICAgICAgIHkgPSBhWzFdLFxuICAgICAgICB6ID0gYVsyXVxuICAgIHZhciBsZW4gPSB4KnggKyB5KnkgKyB6KnpcbiAgICBpZiAobGVuID4gMCkge1xuICAgICAgICAvL1RPRE86IGV2YWx1YXRlIHVzZSBvZiBnbG1faW52c3FydCBoZXJlP1xuICAgICAgICBsZW4gPSAxIC8gTWF0aC5zcXJ0KGxlbilcbiAgICAgICAgb3V0WzBdID0gYVswXSAqIGxlblxuICAgICAgICBvdXRbMV0gPSBhWzFdICogbGVuXG4gICAgICAgIG91dFsyXSA9IGFbMl0gKiBsZW5cbiAgICB9XG4gICAgcmV0dXJuIG91dFxufSIsIm1vZHVsZS5leHBvcnRzID0gZG90O1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGRvdCBwcm9kdWN0IG9mIHR3byB2ZWMzJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGRvdCBwcm9kdWN0IG9mIGEgYW5kIGJcbiAqL1xuZnVuY3Rpb24gZG90KGEsIGIpIHtcbiAgICByZXR1cm4gYVswXSAqIGJbMF0gKyBhWzFdICogYlsxXSArIGFbMl0gKiBiWzJdXG59IiwibW9kdWxlLmV4cG9ydHMgPSBzdWJ0cmFjdDtcblxuLyoqXG4gKiBTdWJ0cmFjdHMgdmVjdG9yIGIgZnJvbSB2ZWN0b3IgYVxuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuZnVuY3Rpb24gc3VidHJhY3Qob3V0LCBhLCBiKSB7XG4gICAgb3V0WzBdID0gYVswXSAtIGJbMF1cbiAgICBvdXRbMV0gPSBhWzFdIC0gYlsxXVxuICAgIG91dFsyXSA9IGFbMl0gLSBiWzJdXG4gICAgcmV0dXJuIG91dFxufSIsIm1vZHVsZS5leHBvcnRzID0gbXVsdGlwbHk7XG5cbi8qKlxuICogTXVsdGlwbGllcyB0d28gdmVjMydzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG5mdW5jdGlvbiBtdWx0aXBseShvdXQsIGEsIGIpIHtcbiAgICBvdXRbMF0gPSBhWzBdICogYlswXVxuICAgIG91dFsxXSA9IGFbMV0gKiBiWzFdXG4gICAgb3V0WzJdID0gYVsyXSAqIGJbMl1cbiAgICByZXR1cm4gb3V0XG59IiwibW9kdWxlLmV4cG9ydHMgPSBkaXZpZGU7XG5cbi8qKlxuICogRGl2aWRlcyB0d28gdmVjMydzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG5mdW5jdGlvbiBkaXZpZGUob3V0LCBhLCBiKSB7XG4gICAgb3V0WzBdID0gYVswXSAvIGJbMF1cbiAgICBvdXRbMV0gPSBhWzFdIC8gYlsxXVxuICAgIG91dFsyXSA9IGFbMl0gLyBiWzJdXG4gICAgcmV0dXJuIG91dFxufSIsIm1vZHVsZS5leHBvcnRzID0gZGlzdGFuY2U7XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgZXVjbGlkaWFuIGRpc3RhbmNlIGJldHdlZW4gdHdvIHZlYzMnc1xuICpcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge051bWJlcn0gZGlzdGFuY2UgYmV0d2VlbiBhIGFuZCBiXG4gKi9cbmZ1bmN0aW9uIGRpc3RhbmNlKGEsIGIpIHtcbiAgICB2YXIgeCA9IGJbMF0gLSBhWzBdLFxuICAgICAgICB5ID0gYlsxXSAtIGFbMV0sXG4gICAgICAgIHogPSBiWzJdIC0gYVsyXVxuICAgIHJldHVybiBNYXRoLnNxcnQoeCp4ICsgeSp5ICsgeip6KVxufSIsIm1vZHVsZS5leHBvcnRzID0gc3F1YXJlZERpc3RhbmNlO1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIHNxdWFyZWQgZXVjbGlkaWFuIGRpc3RhbmNlIGJldHdlZW4gdHdvIHZlYzMnc1xuICpcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge051bWJlcn0gc3F1YXJlZCBkaXN0YW5jZSBiZXR3ZWVuIGEgYW5kIGJcbiAqL1xuZnVuY3Rpb24gc3F1YXJlZERpc3RhbmNlKGEsIGIpIHtcbiAgICB2YXIgeCA9IGJbMF0gLSBhWzBdLFxuICAgICAgICB5ID0gYlsxXSAtIGFbMV0sXG4gICAgICAgIHogPSBiWzJdIC0gYVsyXVxuICAgIHJldHVybiB4KnggKyB5KnkgKyB6Knpcbn0iLCJtb2R1bGUuZXhwb3J0cyA9IGxlbmd0aDtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBsZW5ndGggb2YgYSB2ZWMzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBhIHZlY3RvciB0byBjYWxjdWxhdGUgbGVuZ3RoIG9mXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBsZW5ndGggb2YgYVxuICovXG5mdW5jdGlvbiBsZW5ndGgoYSkge1xuICAgIHZhciB4ID0gYVswXSxcbiAgICAgICAgeSA9IGFbMV0sXG4gICAgICAgIHogPSBhWzJdXG4gICAgcmV0dXJuIE1hdGguc3FydCh4KnggKyB5KnkgKyB6KnopXG59IiwibW9kdWxlLmV4cG9ydHMgPSBzcXVhcmVkTGVuZ3RoO1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIHNxdWFyZWQgbGVuZ3RoIG9mIGEgdmVjM1xuICpcbiAqIEBwYXJhbSB7dmVjM30gYSB2ZWN0b3IgdG8gY2FsY3VsYXRlIHNxdWFyZWQgbGVuZ3RoIG9mXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBzcXVhcmVkIGxlbmd0aCBvZiBhXG4gKi9cbmZ1bmN0aW9uIHNxdWFyZWRMZW5ndGgoYSkge1xuICAgIHZhciB4ID0gYVswXSxcbiAgICAgICAgeSA9IGFbMV0sXG4gICAgICAgIHogPSBhWzJdXG4gICAgcmV0dXJuIHgqeCArIHkqeSArIHoqelxufSIsInZhciBhcnJheVdpdGhIb2xlcyA9IHJlcXVpcmUoXCIuL2FycmF5V2l0aEhvbGVzLmpzXCIpO1xuXG52YXIgaXRlcmFibGVUb0FycmF5TGltaXQgPSByZXF1aXJlKFwiLi9pdGVyYWJsZVRvQXJyYXlMaW1pdC5qc1wiKTtcblxudmFyIHVuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5ID0gcmVxdWlyZShcIi4vdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkuanNcIik7XG5cbnZhciBub25JdGVyYWJsZVJlc3QgPSByZXF1aXJlKFwiLi9ub25JdGVyYWJsZVJlc3QuanNcIik7XG5cbmZ1bmN0aW9uIF9zbGljZWRUb0FycmF5KGFyciwgaSkge1xuICByZXR1cm4gYXJyYXlXaXRoSG9sZXMoYXJyKSB8fCBpdGVyYWJsZVRvQXJyYXlMaW1pdChhcnIsIGkpIHx8IHVuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KGFyciwgaSkgfHwgbm9uSXRlcmFibGVSZXN0KCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX3NsaWNlZFRvQXJyYXksIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlLCBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0czsiLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgRVBTSUxPTjogcmVxdWlyZSgnLi9lcHNpbG9uJylcbiAgLCBjcmVhdGU6IHJlcXVpcmUoJy4vY3JlYXRlJylcbiAgLCBjbG9uZTogcmVxdWlyZSgnLi9jbG9uZScpXG4gICwgYW5nbGU6IHJlcXVpcmUoJy4vYW5nbGUnKVxuICAsIGZyb21WYWx1ZXM6IHJlcXVpcmUoJy4vZnJvbVZhbHVlcycpXG4gICwgY29weTogcmVxdWlyZSgnLi9jb3B5JylcbiAgLCBzZXQ6IHJlcXVpcmUoJy4vc2V0JylcbiAgLCBlcXVhbHM6IHJlcXVpcmUoJy4vZXF1YWxzJylcbiAgLCBleGFjdEVxdWFsczogcmVxdWlyZSgnLi9leGFjdEVxdWFscycpXG4gICwgYWRkOiByZXF1aXJlKCcuL2FkZCcpXG4gICwgc3VidHJhY3Q6IHJlcXVpcmUoJy4vc3VidHJhY3QnKVxuICAsIHN1YjogcmVxdWlyZSgnLi9zdWInKVxuICAsIG11bHRpcGx5OiByZXF1aXJlKCcuL211bHRpcGx5JylcbiAgLCBtdWw6IHJlcXVpcmUoJy4vbXVsJylcbiAgLCBkaXZpZGU6IHJlcXVpcmUoJy4vZGl2aWRlJylcbiAgLCBkaXY6IHJlcXVpcmUoJy4vZGl2JylcbiAgLCBtaW46IHJlcXVpcmUoJy4vbWluJylcbiAgLCBtYXg6IHJlcXVpcmUoJy4vbWF4JylcbiAgLCBmbG9vcjogcmVxdWlyZSgnLi9mbG9vcicpXG4gICwgY2VpbDogcmVxdWlyZSgnLi9jZWlsJylcbiAgLCByb3VuZDogcmVxdWlyZSgnLi9yb3VuZCcpXG4gICwgc2NhbGU6IHJlcXVpcmUoJy4vc2NhbGUnKVxuICAsIHNjYWxlQW5kQWRkOiByZXF1aXJlKCcuL3NjYWxlQW5kQWRkJylcbiAgLCBkaXN0YW5jZTogcmVxdWlyZSgnLi9kaXN0YW5jZScpXG4gICwgZGlzdDogcmVxdWlyZSgnLi9kaXN0JylcbiAgLCBzcXVhcmVkRGlzdGFuY2U6IHJlcXVpcmUoJy4vc3F1YXJlZERpc3RhbmNlJylcbiAgLCBzcXJEaXN0OiByZXF1aXJlKCcuL3NxckRpc3QnKVxuICAsIGxlbmd0aDogcmVxdWlyZSgnLi9sZW5ndGgnKVxuICAsIGxlbjogcmVxdWlyZSgnLi9sZW4nKVxuICAsIHNxdWFyZWRMZW5ndGg6IHJlcXVpcmUoJy4vc3F1YXJlZExlbmd0aCcpXG4gICwgc3FyTGVuOiByZXF1aXJlKCcuL3NxckxlbicpXG4gICwgbmVnYXRlOiByZXF1aXJlKCcuL25lZ2F0ZScpXG4gICwgaW52ZXJzZTogcmVxdWlyZSgnLi9pbnZlcnNlJylcbiAgLCBub3JtYWxpemU6IHJlcXVpcmUoJy4vbm9ybWFsaXplJylcbiAgLCBkb3Q6IHJlcXVpcmUoJy4vZG90JylcbiAgLCBjcm9zczogcmVxdWlyZSgnLi9jcm9zcycpXG4gICwgbGVycDogcmVxdWlyZSgnLi9sZXJwJylcbiAgLCByYW5kb206IHJlcXVpcmUoJy4vcmFuZG9tJylcbiAgLCB0cmFuc2Zvcm1NYXQ0OiByZXF1aXJlKCcuL3RyYW5zZm9ybU1hdDQnKVxuICAsIHRyYW5zZm9ybU1hdDM6IHJlcXVpcmUoJy4vdHJhbnNmb3JtTWF0MycpXG4gICwgdHJhbnNmb3JtUXVhdDogcmVxdWlyZSgnLi90cmFuc2Zvcm1RdWF0JylcbiAgLCByb3RhdGVYOiByZXF1aXJlKCcuL3JvdGF0ZVgnKVxuICAsIHJvdGF0ZVk6IHJlcXVpcmUoJy4vcm90YXRlWScpXG4gICwgcm90YXRlWjogcmVxdWlyZSgnLi9yb3RhdGVaJylcbiAgLCBmb3JFYWNoOiByZXF1aXJlKCcuL2ZvckVhY2gnKVxufVxuIiwidmFyIGJhc2VQaWNrID0gcmVxdWlyZSgnLi9fYmFzZVBpY2snKSxcbiAgICBmbGF0UmVzdCA9IHJlcXVpcmUoJy4vX2ZsYXRSZXN0Jyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBvYmplY3QgY29tcG9zZWQgb2YgdGhlIHBpY2tlZCBgb2JqZWN0YCBwcm9wZXJ0aWVzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBzaW5jZSAwLjEuMFxuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIHNvdXJjZSBvYmplY3QuXG4gKiBAcGFyYW0gey4uLihzdHJpbmd8c3RyaW5nW10pfSBbcGF0aHNdIFRoZSBwcm9wZXJ0eSBwYXRocyB0byBwaWNrLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxLCAnYic6ICcyJywgJ2MnOiAzIH07XG4gKlxuICogXy5waWNrKG9iamVjdCwgWydhJywgJ2MnXSk7XG4gKiAvLyA9PiB7ICdhJzogMSwgJ2MnOiAzIH1cbiAqL1xudmFyIHBpY2sgPSBmbGF0UmVzdChmdW5jdGlvbihvYmplY3QsIHBhdGhzKSB7XG4gIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IHt9IDogYmFzZVBpY2sob2JqZWN0LCBwYXRocyk7XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBwaWNrO1xuIiwidmFyIGdldFByb3RvdHlwZU9mID0gcmVxdWlyZShcIi4vZ2V0UHJvdG90eXBlT2YuanNcIik7XG5cbnZhciBzZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoXCIuL3NldFByb3RvdHlwZU9mLmpzXCIpO1xuXG52YXIgaXNOYXRpdmVGdW5jdGlvbiA9IHJlcXVpcmUoXCIuL2lzTmF0aXZlRnVuY3Rpb24uanNcIik7XG5cbnZhciBjb25zdHJ1Y3QgPSByZXF1aXJlKFwiLi9jb25zdHJ1Y3QuanNcIik7XG5cbmZ1bmN0aW9uIF93cmFwTmF0aXZlU3VwZXIoQ2xhc3MpIHtcbiAgdmFyIF9jYWNoZSA9IHR5cGVvZiBNYXAgPT09IFwiZnVuY3Rpb25cIiA/IG5ldyBNYXAoKSA6IHVuZGVmaW5lZDtcblxuICBtb2R1bGUuZXhwb3J0cyA9IF93cmFwTmF0aXZlU3VwZXIgPSBmdW5jdGlvbiBfd3JhcE5hdGl2ZVN1cGVyKENsYXNzKSB7XG4gICAgaWYgKENsYXNzID09PSBudWxsIHx8ICFpc05hdGl2ZUZ1bmN0aW9uKENsYXNzKSkgcmV0dXJuIENsYXNzO1xuXG4gICAgaWYgKHR5cGVvZiBDbGFzcyAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBfY2FjaGUgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIGlmIChfY2FjaGUuaGFzKENsYXNzKSkgcmV0dXJuIF9jYWNoZS5nZXQoQ2xhc3MpO1xuXG4gICAgICBfY2FjaGUuc2V0KENsYXNzLCBXcmFwcGVyKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBXcmFwcGVyKCkge1xuICAgICAgcmV0dXJuIGNvbnN0cnVjdChDbGFzcywgYXJndW1lbnRzLCBnZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3Rvcik7XG4gICAgfVxuXG4gICAgV3JhcHBlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKENsYXNzLnByb3RvdHlwZSwge1xuICAgICAgY29uc3RydWN0b3I6IHtcbiAgICAgICAgdmFsdWU6IFdyYXBwZXIsXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHNldFByb3RvdHlwZU9mKFdyYXBwZXIsIENsYXNzKTtcbiAgfSwgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzO1xuICByZXR1cm4gX3dyYXBOYXRpdmVTdXBlcihDbGFzcyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX3dyYXBOYXRpdmVTdXBlciwgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzOyIsImltcG9ydCBUcmFjZXIgZnJvbSAnLi90cmFjZXInO1xuXG4vKipcbiAqIGh0dHA6Ly93d3cuY29kZXByb2plY3QuY29tL1RpcHMvNDA3MTcyL0Nvbm5lY3RlZC1Db21wb25lbnQtTGFiZWxpbmctYW5kLVZlY3Rvcml6YXRpb25cbiAqL1xuY29uc3QgUmFzdGVyaXplciA9IHtcbiAgICBjcmVhdGVDb250b3VyMkQoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkaXI6IG51bGwsXG4gICAgICAgICAgICBpbmRleDogbnVsbCxcbiAgICAgICAgICAgIGZpcnN0VmVydGV4OiBudWxsLFxuICAgICAgICAgICAgaW5zaWRlQ29udG91cnM6IG51bGwsXG4gICAgICAgICAgICBuZXh0cGVlcjogbnVsbCxcbiAgICAgICAgICAgIHByZXZwZWVyOiBudWxsLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgQ09OVE9VUl9ESVI6IHtcbiAgICAgICAgQ1dfRElSOiAwLFxuICAgICAgICBDQ1dfRElSOiAxLFxuICAgICAgICBVTktOT1dOX0RJUjogMixcbiAgICB9LFxuICAgIERJUjoge1xuICAgICAgICBPVVRTSURFX0VER0U6IC0zMjc2NyxcbiAgICAgICAgSU5TSURFX0VER0U6IC0zMjc2NixcbiAgICB9LFxuICAgIGNyZWF0ZShpbWFnZVdyYXBwZXIsIGxhYmVsV3JhcHBlcikge1xuICAgICAgICBjb25zdCBpbWFnZURhdGEgPSBpbWFnZVdyYXBwZXIuZGF0YTtcbiAgICAgICAgY29uc3QgbGFiZWxEYXRhID0gbGFiZWxXcmFwcGVyLmRhdGE7XG4gICAgICAgIGNvbnN0IHdpZHRoID0gaW1hZ2VXcmFwcGVyLnNpemUueDtcbiAgICAgICAgY29uc3QgaGVpZ2h0ID0gaW1hZ2VXcmFwcGVyLnNpemUueTtcbiAgICAgICAgY29uc3QgdHJhY2VyID0gVHJhY2VyLmNyZWF0ZShpbWFnZVdyYXBwZXIsIGxhYmVsV3JhcHBlcik7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJhc3Rlcml6ZShkZXB0aGxhYmVsKSB7XG4gICAgICAgICAgICAgICAgbGV0IGNvbG9yO1xuICAgICAgICAgICAgICAgIGxldCBiYztcbiAgICAgICAgICAgICAgICBsZXQgbGM7XG4gICAgICAgICAgICAgICAgbGV0IGxhYmVsaW5kZXg7XG4gICAgICAgICAgICAgICAgbGV0IGN4O1xuICAgICAgICAgICAgICAgIGxldCBjeTtcbiAgICAgICAgICAgICAgICBjb25zdCBjb2xvck1hcCA9IFtdO1xuICAgICAgICAgICAgICAgIGxldCB2ZXJ0ZXg7XG4gICAgICAgICAgICAgICAgbGV0IHA7XG4gICAgICAgICAgICAgICAgbGV0IGNjO1xuICAgICAgICAgICAgICAgIGxldCBzYztcbiAgICAgICAgICAgICAgICBsZXQgcG9zO1xuICAgICAgICAgICAgICAgIGxldCBjb25uZWN0ZWRDb3VudCA9IDA7XG4gICAgICAgICAgICAgICAgbGV0IGk7XG5cbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgNDAwOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgY29sb3JNYXBbaV0gPSAwO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGNvbG9yTWFwWzBdID0gaW1hZ2VEYXRhWzBdO1xuICAgICAgICAgICAgICAgIGNjID0gbnVsbDtcbiAgICAgICAgICAgICAgICBmb3IgKGN5ID0gMTsgY3kgPCBoZWlnaHQgLSAxOyBjeSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGxhYmVsaW5kZXggPSAwO1xuICAgICAgICAgICAgICAgICAgICBiYyA9IGNvbG9yTWFwWzBdO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGN4ID0gMTsgY3ggPCB3aWR0aCAtIDE7IGN4KyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvcyA9IGN5ICogd2lkdGggKyBjeDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsYWJlbERhdGFbcG9zXSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yID0gaW1hZ2VEYXRhW3Bvc107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbG9yICE9PSBiYykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobGFiZWxpbmRleCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGMgPSBjb25uZWN0ZWRDb3VudCArIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xvck1hcFtsY10gPSBjb2xvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJjID0gY29sb3I7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2ZXJ0ZXggPSB0cmFjZXIuY29udG91clRyYWNpbmcoY3ksIGN4LCBsYywgY29sb3IsIFJhc3Rlcml6ZXIuRElSLk9VVFNJREVfRURHRSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodmVydGV4ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29ubmVjdGVkQ291bnQrKztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYWJlbGluZGV4ID0gbGM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcCA9IFJhc3Rlcml6ZXIuY3JlYXRlQ29udG91cjJEKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcC5kaXIgPSBSYXN0ZXJpemVyLkNPTlRPVVJfRElSLkNXX0RJUjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwLmluZGV4ID0gbGFiZWxpbmRleDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwLmZpcnN0VmVydGV4ID0gdmVydGV4O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHAubmV4dHBlZXIgPSBjYztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwLmluc2lkZUNvbnRvdXJzID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2MgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2MucHJldnBlZXIgPSBwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYyA9IHA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2ZXJ0ZXggPSB0cmFjZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuY29udG91clRyYWNpbmcoY3ksIGN4LCBSYXN0ZXJpemVyLkRJUi5JTlNJREVfRURHRSwgY29sb3IsIGxhYmVsaW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZlcnRleCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHAgPSBSYXN0ZXJpemVyLmNyZWF0ZUNvbnRvdXIyRCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHAuZmlyc3RWZXJ0ZXggPSB2ZXJ0ZXg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcC5pbnNpZGVDb250b3VycyA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRlcHRobGFiZWwgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcC5kaXIgPSBSYXN0ZXJpemVyLkNPTlRPVVJfRElSLkNDV19ESVI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcC5kaXIgPSBSYXN0ZXJpemVyLkNPTlRPVVJfRElSLkNXX0RJUjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcC5pbmRleCA9IGRlcHRobGFiZWw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2MgPSBjYztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoKHNjICE9PSBudWxsKSAmJiBzYy5pbmRleCAhPT0gbGFiZWxpbmRleCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzYyA9IHNjLm5leHRwZWVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2MgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcC5uZXh0cGVlciA9IHNjLmluc2lkZUNvbnRvdXJzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2MuaW5zaWRlQ29udG91cnMgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjLmluc2lkZUNvbnRvdXJzLnByZXZwZWVyID0gcDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzYy5pbnNpZGVDb250b3VycyA9IHA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWxEYXRhW3Bvc10gPSBsYWJlbGluZGV4O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobGFiZWxEYXRhW3Bvc10gPT09IFJhc3Rlcml6ZXIuRElSLk9VVFNJREVfRURHRVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8fCBsYWJlbERhdGFbcG9zXSA9PT0gUmFzdGVyaXplci5ESVIuSU5TSURFX0VER0UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYWJlbGluZGV4ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobGFiZWxEYXRhW3Bvc10gPT09IFJhc3Rlcml6ZXIuRElSLklOU0lERV9FREdFKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJjID0gaW1hZ2VEYXRhW3Bvc107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmMgPSBjb2xvck1hcFswXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsaW5kZXggPSBsYWJlbERhdGFbcG9zXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiYyA9IGNvbG9yTWFwW2xhYmVsaW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNjID0gY2M7XG4gICAgICAgICAgICAgICAgd2hpbGUgKHNjICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHNjLmluZGV4ID0gZGVwdGhsYWJlbDtcbiAgICAgICAgICAgICAgICAgICAgc2MgPSBzYy5uZXh0cGVlcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgY2MsXG4gICAgICAgICAgICAgICAgICAgIGNvdW50OiBjb25uZWN0ZWRDb3VudCxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGRlYnVnOiB7XG4gICAgICAgICAgICAgICAgZHJhd0NvbnRvdXIoY2FudmFzLCBmaXJzdENvbnRvdXIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBwcSA9IGZpcnN0Q29udG91cjtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGlxO1xuICAgICAgICAgICAgICAgICAgICBsZXQgcTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHA7XG5cbiAgICAgICAgICAgICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gJ3JlZCc7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSAncmVkJztcbiAgICAgICAgICAgICAgICAgICAgY3R4LmxpbmVXaWR0aCA9IDE7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHBxICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpcSA9IHBxLmluc2lkZUNvbnRvdXJzO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXEgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHBxICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXEgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBxID0gaXE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXEgPSBpcS5uZXh0cGVlcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcSA9IHBxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBxID0gcHEubmV4dHBlZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBxICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlxID0gcHEuaW5zaWRlQ29udG91cnM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXEgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChxLmRpcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgUmFzdGVyaXplci5DT05UT1VSX0RJUi5DV19ESVI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9ICdyZWQnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFJhc3Rlcml6ZXIuQ09OVE9VUl9ESVIuQ0NXX0RJUjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gJ2JsdWUnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFJhc3Rlcml6ZXIuQ09OVE9VUl9ESVIuVU5LTk9XTl9ESVI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9ICdncmVlbic7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBwID0gcS5maXJzdFZlcnRleDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5tb3ZlVG8ocC54LCBwLnkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHAgPSBwLm5leHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmxpbmVUbyhwLngsIHAueSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IHdoaWxlIChwICE9PSBxLmZpcnN0VmVydGV4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgIH0sXG59O1xuXG5leHBvcnQgZGVmYXVsdCBSYXN0ZXJpemVyO1xuIiwiLyogZXNsaW50LWRpc2FibGUgbm8tcGFyYW0tcmVhc3NpZ24gKi9cbi8qIGVzbGludC1kaXNhYmxlIG5vLWJpdHdpc2UgKi9cbi8qIGVzbGludC1kaXNhYmxlIGVxZXFlcSAqL1xuXG4vKiBAcHJlc2VydmUgQVNNIEJFR0lOICovXG5mdW5jdGlvbiBTa2VsZXRvbml6ZXIoc3RkbGliLCBmb3JlaWduLCBidWZmZXIpIHtcbiAgICAndXNlIGFzbSc7XG5cbiAgICBjb25zdCBpbWFnZXMgPSBuZXcgc3RkbGliLlVpbnQ4QXJyYXkoYnVmZmVyKTtcbiAgICBjb25zdCBzaXplID0gZm9yZWlnbi5zaXplIHwgMDtcbiAgICBjb25zdCB7IGltdWwgfSA9IHN0ZGxpYi5NYXRoO1xuXG4gICAgZnVuY3Rpb24gZXJvZGUoaW5JbWFnZVB0ciwgb3V0SW1hZ2VQdHIpIHtcbiAgICAgICAgaW5JbWFnZVB0ciB8PSAwO1xuICAgICAgICBvdXRJbWFnZVB0ciB8PSAwO1xuXG4gICAgICAgIGxldCB2ID0gMDtcbiAgICAgICAgbGV0IHUgPSAwO1xuICAgICAgICBsZXQgc3VtID0gMDtcbiAgICAgICAgbGV0IHlTdGFydDEgPSAwO1xuICAgICAgICBsZXQgeVN0YXJ0MiA9IDA7XG4gICAgICAgIGxldCB4U3RhcnQxID0gMDtcbiAgICAgICAgbGV0IHhTdGFydDIgPSAwO1xuICAgICAgICBsZXQgb2Zmc2V0ID0gMDtcblxuICAgICAgICBmb3IgKHYgPSAxOyAodiB8IDApIDwgKChzaXplIC0gMSkgfCAwKTsgdiA9ICh2ICsgMSkgfCAwKSB7XG4gICAgICAgICAgICBvZmZzZXQgPSAob2Zmc2V0ICsgc2l6ZSkgfCAwO1xuICAgICAgICAgICAgZm9yICh1ID0gMTsgKHUgfCAwKSA8ICgoc2l6ZSAtIDEpIHwgMCk7IHUgPSAodSArIDEpIHwgMCkge1xuICAgICAgICAgICAgICAgIHlTdGFydDEgPSAob2Zmc2V0IC0gc2l6ZSkgfCAwO1xuICAgICAgICAgICAgICAgIHlTdGFydDIgPSAob2Zmc2V0ICsgc2l6ZSkgfCAwO1xuICAgICAgICAgICAgICAgIHhTdGFydDEgPSAodSAtIDEpIHwgMDtcbiAgICAgICAgICAgICAgICB4U3RhcnQyID0gKHUgKyAxKSB8IDA7XG4gICAgICAgICAgICAgICAgc3VtID0gKChpbWFnZXNbKGluSW1hZ2VQdHIgKyB5U3RhcnQxICsgeFN0YXJ0MSkgfCAwXSB8IDApXG4gICAgICAgICAgICAgICAgICAgICsgKGltYWdlc1soaW5JbWFnZVB0ciArIHlTdGFydDEgKyB4U3RhcnQyKSB8IDBdIHwgMClcbiAgICAgICAgICAgICAgICAgICAgKyAoaW1hZ2VzWyhpbkltYWdlUHRyICsgb2Zmc2V0ICsgdSkgfCAwXSB8IDApXG4gICAgICAgICAgICAgICAgICAgICsgKGltYWdlc1soaW5JbWFnZVB0ciArIHlTdGFydDIgKyB4U3RhcnQxKSB8IDBdIHwgMClcbiAgICAgICAgICAgICAgICAgICAgKyAoaW1hZ2VzWyhpbkltYWdlUHRyICsgeVN0YXJ0MiArIHhTdGFydDIpIHwgMF0gfCAwKSkgfCAwO1xuICAgICAgICAgICAgICAgIGlmICgoc3VtIHwgMCkgPT0gKDUgfCAwKSkge1xuICAgICAgICAgICAgICAgICAgICBpbWFnZXNbKG91dEltYWdlUHRyICsgb2Zmc2V0ICsgdSkgfCAwXSA9IDE7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaW1hZ2VzWyhvdXRJbWFnZVB0ciArIG9mZnNldCArIHUpIHwgMF0gPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHN1YnRyYWN0KGFJbWFnZVB0ciwgYkltYWdlUHRyLCBvdXRJbWFnZVB0cikge1xuICAgICAgICBhSW1hZ2VQdHIgfD0gMDtcbiAgICAgICAgYkltYWdlUHRyIHw9IDA7XG4gICAgICAgIG91dEltYWdlUHRyIHw9IDA7XG5cbiAgICAgICAgbGV0IGxlbmd0aCA9IDA7XG5cbiAgICAgICAgbGVuZ3RoID0gaW11bChzaXplLCBzaXplKSB8IDA7XG5cbiAgICAgICAgd2hpbGUgKChsZW5ndGggfCAwKSA+IDApIHtcbiAgICAgICAgICAgIGxlbmd0aCA9IChsZW5ndGggLSAxKSB8IDA7XG4gICAgICAgICAgICBpbWFnZXNbKG91dEltYWdlUHRyICsgbGVuZ3RoKSB8IDBdID0gKChpbWFnZXNbKGFJbWFnZVB0ciArIGxlbmd0aCkgfCAwXSB8IDApIC0gKGltYWdlc1soYkltYWdlUHRyICsgbGVuZ3RoKSB8IDBdIHwgMCkpIHwgMDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGJpdHdpc2VPcihhSW1hZ2VQdHIsIGJJbWFnZVB0ciwgb3V0SW1hZ2VQdHIpIHtcbiAgICAgICAgYUltYWdlUHRyIHw9IDA7XG4gICAgICAgIGJJbWFnZVB0ciB8PSAwO1xuICAgICAgICBvdXRJbWFnZVB0ciB8PSAwO1xuXG4gICAgICAgIGxldCBsZW5ndGggPSAwO1xuXG4gICAgICAgIGxlbmd0aCA9IGltdWwoc2l6ZSwgc2l6ZSkgfCAwO1xuXG4gICAgICAgIHdoaWxlICgobGVuZ3RoIHwgMCkgPiAwKSB7XG4gICAgICAgICAgICBsZW5ndGggPSAobGVuZ3RoIC0gMSkgfCAwO1xuICAgICAgICAgICAgaW1hZ2VzWyhvdXRJbWFnZVB0ciArIGxlbmd0aCkgfCAwXSA9ICgoaW1hZ2VzWyhhSW1hZ2VQdHIgKyBsZW5ndGgpIHwgMF0gfCAwKSB8IChpbWFnZXNbKGJJbWFnZVB0ciArIGxlbmd0aCkgfCAwXSB8IDApKSB8IDA7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjb3VudE5vblplcm8oaW1hZ2VQdHIpIHtcbiAgICAgICAgaW1hZ2VQdHIgfD0gMDtcblxuICAgICAgICBsZXQgc3VtID0gMDtcbiAgICAgICAgbGV0IGxlbmd0aCA9IDA7XG5cbiAgICAgICAgbGVuZ3RoID0gaW11bChzaXplLCBzaXplKSB8IDA7XG5cbiAgICAgICAgd2hpbGUgKChsZW5ndGggfCAwKSA+IDApIHtcbiAgICAgICAgICAgIGxlbmd0aCA9IChsZW5ndGggLSAxKSB8IDA7XG4gICAgICAgICAgICBzdW0gPSAoKHN1bSB8IDApICsgKGltYWdlc1soaW1hZ2VQdHIgKyBsZW5ndGgpIHwgMF0gfCAwKSkgfCAwO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIChzdW0gfCAwKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbml0KGltYWdlUHRyLCB2YWx1ZSkge1xuICAgICAgICBpbWFnZVB0ciB8PSAwO1xuICAgICAgICB2YWx1ZSB8PSAwO1xuXG4gICAgICAgIGxldCBsZW5ndGggPSAwO1xuXG4gICAgICAgIGxlbmd0aCA9IGltdWwoc2l6ZSwgc2l6ZSkgfCAwO1xuXG4gICAgICAgIHdoaWxlICgobGVuZ3RoIHwgMCkgPiAwKSB7XG4gICAgICAgICAgICBsZW5ndGggPSAobGVuZ3RoIC0gMSkgfCAwO1xuICAgICAgICAgICAgaW1hZ2VzWyhpbWFnZVB0ciArIGxlbmd0aCkgfCAwXSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGlsYXRlKGluSW1hZ2VQdHIsIG91dEltYWdlUHRyKSB7XG4gICAgICAgIGluSW1hZ2VQdHIgfD0gMDtcbiAgICAgICAgb3V0SW1hZ2VQdHIgfD0gMDtcblxuICAgICAgICBsZXQgdiA9IDA7XG4gICAgICAgIGxldCB1ID0gMDtcbiAgICAgICAgbGV0IHN1bSA9IDA7XG4gICAgICAgIGxldCB5U3RhcnQxID0gMDtcbiAgICAgICAgbGV0IHlTdGFydDIgPSAwO1xuICAgICAgICBsZXQgeFN0YXJ0MSA9IDA7XG4gICAgICAgIGxldCB4U3RhcnQyID0gMDtcbiAgICAgICAgbGV0IG9mZnNldCA9IDA7XG5cbiAgICAgICAgZm9yICh2ID0gMTsgKHYgfCAwKSA8ICgoc2l6ZSAtIDEpIHwgMCk7IHYgPSAodiArIDEpIHwgMCkge1xuICAgICAgICAgICAgb2Zmc2V0ID0gKG9mZnNldCArIHNpemUpIHwgMDtcbiAgICAgICAgICAgIGZvciAodSA9IDE7ICh1IHwgMCkgPCAoKHNpemUgLSAxKSB8IDApOyB1ID0gKHUgKyAxKSB8IDApIHtcbiAgICAgICAgICAgICAgICB5U3RhcnQxID0gKG9mZnNldCAtIHNpemUpIHwgMDtcbiAgICAgICAgICAgICAgICB5U3RhcnQyID0gKG9mZnNldCArIHNpemUpIHwgMDtcbiAgICAgICAgICAgICAgICB4U3RhcnQxID0gKHUgLSAxKSB8IDA7XG4gICAgICAgICAgICAgICAgeFN0YXJ0MiA9ICh1ICsgMSkgfCAwO1xuICAgICAgICAgICAgICAgIHN1bSA9ICgoaW1hZ2VzWyhpbkltYWdlUHRyICsgeVN0YXJ0MSArIHhTdGFydDEpIHwgMF0gfCAwKVxuICAgICAgICAgICAgICAgICAgICArIChpbWFnZXNbKGluSW1hZ2VQdHIgKyB5U3RhcnQxICsgeFN0YXJ0MikgfCAwXSB8IDApXG4gICAgICAgICAgICAgICAgICAgICsgKGltYWdlc1soaW5JbWFnZVB0ciArIG9mZnNldCArIHUpIHwgMF0gfCAwKVxuICAgICAgICAgICAgICAgICAgICArIChpbWFnZXNbKGluSW1hZ2VQdHIgKyB5U3RhcnQyICsgeFN0YXJ0MSkgfCAwXSB8IDApXG4gICAgICAgICAgICAgICAgICAgICsgKGltYWdlc1soaW5JbWFnZVB0ciArIHlTdGFydDIgKyB4U3RhcnQyKSB8IDBdIHwgMCkpIHwgMDtcbiAgICAgICAgICAgICAgICBpZiAoKHN1bSB8IDApID4gKDAgfCAwKSkge1xuICAgICAgICAgICAgICAgICAgICBpbWFnZXNbKG91dEltYWdlUHRyICsgb2Zmc2V0ICsgdSkgfCAwXSA9IDE7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaW1hZ2VzWyhvdXRJbWFnZVB0ciArIG9mZnNldCArIHUpIHwgMF0gPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1lbWNweShzcmNJbWFnZVB0ciwgZHN0SW1hZ2VQdHIpIHtcbiAgICAgICAgc3JjSW1hZ2VQdHIgfD0gMDtcbiAgICAgICAgZHN0SW1hZ2VQdHIgfD0gMDtcblxuICAgICAgICBsZXQgbGVuZ3RoID0gMDtcblxuICAgICAgICBsZW5ndGggPSBpbXVsKHNpemUsIHNpemUpIHwgMDtcblxuICAgICAgICB3aGlsZSAoKGxlbmd0aCB8IDApID4gMCkge1xuICAgICAgICAgICAgbGVuZ3RoID0gKGxlbmd0aCAtIDEpIHwgMDtcbiAgICAgICAgICAgIGltYWdlc1soZHN0SW1hZ2VQdHIgKyBsZW5ndGgpIHwgMF0gPSAoaW1hZ2VzWyhzcmNJbWFnZVB0ciArIGxlbmd0aCkgfCAwXSB8IDApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gemVyb0JvcmRlcihpbWFnZVB0cikge1xuICAgICAgICBpbWFnZVB0ciB8PSAwO1xuXG4gICAgICAgIGxldCB4ID0gMDtcbiAgICAgICAgbGV0IHkgPSAwO1xuXG4gICAgICAgIGZvciAoeCA9IDA7ICh4IHwgMCkgPCAoKHNpemUgLSAxKSB8IDApOyB4ID0gKHggKyAxKSB8IDApIHtcbiAgICAgICAgICAgIGltYWdlc1soaW1hZ2VQdHIgKyB4KSB8IDBdID0gMDtcbiAgICAgICAgICAgIGltYWdlc1soaW1hZ2VQdHIgKyB5KSB8IDBdID0gMDtcbiAgICAgICAgICAgIHkgPSAoKHkgKyBzaXplKSAtIDEpIHwgMDtcbiAgICAgICAgICAgIGltYWdlc1soaW1hZ2VQdHIgKyB5KSB8IDBdID0gMDtcbiAgICAgICAgICAgIHkgPSAoeSArIDEpIHwgMDtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHggPSAwOyAoeCB8IDApIDwgKHNpemUgfCAwKTsgeCA9ICh4ICsgMSkgfCAwKSB7XG4gICAgICAgICAgICBpbWFnZXNbKGltYWdlUHRyICsgeSkgfCAwXSA9IDA7XG4gICAgICAgICAgICB5ID0gKHkgKyAxKSB8IDA7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBza2VsZXRvbml6ZSgpIHtcbiAgICAgICAgY29uc3Qgc3ViSW1hZ2VQdHIgPSAwO1xuICAgICAgICBsZXQgZXJvZGVkSW1hZ2VQdHIgPSAwO1xuICAgICAgICBsZXQgdGVtcEltYWdlUHRyID0gMDtcbiAgICAgICAgbGV0IHNrZWxJbWFnZVB0ciA9IDA7XG4gICAgICAgIGxldCBzdW0gPSAwO1xuICAgICAgICBsZXQgZG9uZSA9IDA7XG5cbiAgICAgICAgZXJvZGVkSW1hZ2VQdHIgPSBpbXVsKHNpemUsIHNpemUpIHwgMDtcbiAgICAgICAgdGVtcEltYWdlUHRyID0gKGVyb2RlZEltYWdlUHRyICsgZXJvZGVkSW1hZ2VQdHIpIHwgMDtcbiAgICAgICAgc2tlbEltYWdlUHRyID0gKHRlbXBJbWFnZVB0ciArIGVyb2RlZEltYWdlUHRyKSB8IDA7XG5cbiAgICAgICAgLy8gaW5pdCBza2VsLWltYWdlXG4gICAgICAgIGluaXQoc2tlbEltYWdlUHRyLCAwKTtcbiAgICAgICAgemVyb0JvcmRlcihzdWJJbWFnZVB0cik7XG5cbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgZXJvZGUoc3ViSW1hZ2VQdHIsIGVyb2RlZEltYWdlUHRyKTtcbiAgICAgICAgICAgIGRpbGF0ZShlcm9kZWRJbWFnZVB0ciwgdGVtcEltYWdlUHRyKTtcbiAgICAgICAgICAgIHN1YnRyYWN0KHN1YkltYWdlUHRyLCB0ZW1wSW1hZ2VQdHIsIHRlbXBJbWFnZVB0cik7XG4gICAgICAgICAgICBiaXR3aXNlT3Ioc2tlbEltYWdlUHRyLCB0ZW1wSW1hZ2VQdHIsIHNrZWxJbWFnZVB0cik7XG4gICAgICAgICAgICBtZW1jcHkoZXJvZGVkSW1hZ2VQdHIsIHN1YkltYWdlUHRyKTtcbiAgICAgICAgICAgIHN1bSA9IGNvdW50Tm9uWmVybyhzdWJJbWFnZVB0cikgfCAwO1xuICAgICAgICAgICAgZG9uZSA9ICgoc3VtIHwgMCkgPT0gMCB8IDApO1xuICAgICAgICB9IHdoaWxlICghZG9uZSk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIHNrZWxldG9uaXplLFxuICAgIH07XG59XG4vKiBAcHJlc2VydmUgQVNNIEVORCAqL1xuZXhwb3J0IGRlZmF1bHQgU2tlbGV0b25pemVyO1xuLyogZXNsaW50LWVuYWJsZSBlcWVxZXEgKi9cbiIsInZhciBTdGFjayA9IHJlcXVpcmUoJy4vX1N0YWNrJyksXG4gICAgYXNzaWduTWVyZ2VWYWx1ZSA9IHJlcXVpcmUoJy4vX2Fzc2lnbk1lcmdlVmFsdWUnKSxcbiAgICBiYXNlRm9yID0gcmVxdWlyZSgnLi9fYmFzZUZvcicpLFxuICAgIGJhc2VNZXJnZURlZXAgPSByZXF1aXJlKCcuL19iYXNlTWVyZ2VEZWVwJyksXG4gICAgaXNPYmplY3QgPSByZXF1aXJlKCcuL2lzT2JqZWN0JyksXG4gICAga2V5c0luID0gcmVxdWlyZSgnLi9rZXlzSW4nKSxcbiAgICBzYWZlR2V0ID0gcmVxdWlyZSgnLi9fc2FmZUdldCcpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLm1lcmdlYCB3aXRob3V0IHN1cHBvcnQgZm9yIG11bHRpcGxlIHNvdXJjZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIHNvdXJjZSBvYmplY3QuXG4gKiBAcGFyYW0ge251bWJlcn0gc3JjSW5kZXggVGhlIGluZGV4IG9mIGBzb3VyY2VgLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgbWVyZ2VkIHZhbHVlcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbc3RhY2tdIFRyYWNrcyB0cmF2ZXJzZWQgc291cmNlIHZhbHVlcyBhbmQgdGhlaXIgbWVyZ2VkXG4gKiAgY291bnRlcnBhcnRzLlxuICovXG5mdW5jdGlvbiBiYXNlTWVyZ2Uob2JqZWN0LCBzb3VyY2UsIHNyY0luZGV4LCBjdXN0b21pemVyLCBzdGFjaykge1xuICBpZiAob2JqZWN0ID09PSBzb3VyY2UpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgYmFzZUZvcihzb3VyY2UsIGZ1bmN0aW9uKHNyY1ZhbHVlLCBrZXkpIHtcbiAgICBzdGFjayB8fCAoc3RhY2sgPSBuZXcgU3RhY2spO1xuICAgIGlmIChpc09iamVjdChzcmNWYWx1ZSkpIHtcbiAgICAgIGJhc2VNZXJnZURlZXAob2JqZWN0LCBzb3VyY2UsIGtleSwgc3JjSW5kZXgsIGJhc2VNZXJnZSwgY3VzdG9taXplciwgc3RhY2spO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHZhciBuZXdWYWx1ZSA9IGN1c3RvbWl6ZXJcbiAgICAgICAgPyBjdXN0b21pemVyKHNhZmVHZXQob2JqZWN0LCBrZXkpLCBzcmNWYWx1ZSwgKGtleSArICcnKSwgb2JqZWN0LCBzb3VyY2UsIHN0YWNrKVxuICAgICAgICA6IHVuZGVmaW5lZDtcblxuICAgICAgaWYgKG5ld1ZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbmV3VmFsdWUgPSBzcmNWYWx1ZTtcbiAgICAgIH1cbiAgICAgIGFzc2lnbk1lcmdlVmFsdWUob2JqZWN0LCBrZXksIG5ld1ZhbHVlKTtcbiAgICB9XG4gIH0sIGtleXNJbik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZU1lcmdlO1xuIiwidmFyIExpc3RDYWNoZSA9IHJlcXVpcmUoJy4vX0xpc3RDYWNoZScpLFxuICAgIHN0YWNrQ2xlYXIgPSByZXF1aXJlKCcuL19zdGFja0NsZWFyJyksXG4gICAgc3RhY2tEZWxldGUgPSByZXF1aXJlKCcuL19zdGFja0RlbGV0ZScpLFxuICAgIHN0YWNrR2V0ID0gcmVxdWlyZSgnLi9fc3RhY2tHZXQnKSxcbiAgICBzdGFja0hhcyA9IHJlcXVpcmUoJy4vX3N0YWNrSGFzJyksXG4gICAgc3RhY2tTZXQgPSByZXF1aXJlKCcuL19zdGFja1NldCcpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBzdGFjayBjYWNoZSBvYmplY3QgdG8gc3RvcmUga2V5LXZhbHVlIHBhaXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBTdGFjayhlbnRyaWVzKSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyA9IG5ldyBMaXN0Q2FjaGUoZW50cmllcyk7XG4gIHRoaXMuc2l6ZSA9IGRhdGEuc2l6ZTtcbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYFN0YWNrYC5cblN0YWNrLnByb3RvdHlwZS5jbGVhciA9IHN0YWNrQ2xlYXI7XG5TdGFjay5wcm90b3R5cGVbJ2RlbGV0ZSddID0gc3RhY2tEZWxldGU7XG5TdGFjay5wcm90b3R5cGUuZ2V0ID0gc3RhY2tHZXQ7XG5TdGFjay5wcm90b3R5cGUuaGFzID0gc3RhY2tIYXM7XG5TdGFjay5wcm90b3R5cGUuc2V0ID0gc3RhY2tTZXQ7XG5cbm1vZHVsZS5leHBvcnRzID0gU3RhY2s7XG4iLCIvKipcbiAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIGxpc3QgY2FjaGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGNsZWFyXG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZUNsZWFyKCkge1xuICB0aGlzLl9fZGF0YV9fID0gW107XG4gIHRoaXMuc2l6ZSA9IDA7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbGlzdENhY2hlQ2xlYXI7XG4iLCJ2YXIgYXNzb2NJbmRleE9mID0gcmVxdWlyZSgnLi9fYXNzb2NJbmRleE9mJyk7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBhcnJheVByb3RvID0gQXJyYXkucHJvdG90eXBlO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBzcGxpY2UgPSBhcnJheVByb3RvLnNwbGljZTtcblxuLyoqXG4gKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgbGlzdCBjYWNoZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZGVsZXRlXG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlRGVsZXRlKGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICBpbmRleCA9IGFzc29jSW5kZXhPZihkYXRhLCBrZXkpO1xuXG4gIGlmIChpbmRleCA8IDApIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIGxhc3RJbmRleCA9IGRhdGEubGVuZ3RoIC0gMTtcbiAgaWYgKGluZGV4ID09IGxhc3RJbmRleCkge1xuICAgIGRhdGEucG9wKCk7XG4gIH0gZWxzZSB7XG4gICAgc3BsaWNlLmNhbGwoZGF0YSwgaW5kZXgsIDEpO1xuICB9XG4gIC0tdGhpcy5zaXplO1xuICByZXR1cm4gdHJ1ZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBsaXN0Q2FjaGVEZWxldGU7XG4iLCJ2YXIgYXNzb2NJbmRleE9mID0gcmVxdWlyZSgnLi9fYXNzb2NJbmRleE9mJyk7XG5cbi8qKlxuICogR2V0cyB0aGUgbGlzdCBjYWNoZSB2YWx1ZSBmb3IgYGtleWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGdldFxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZUdldChrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgaW5kZXggPSBhc3NvY0luZGV4T2YoZGF0YSwga2V5KTtcblxuICByZXR1cm4gaW5kZXggPCAwID8gdW5kZWZpbmVkIDogZGF0YVtpbmRleF1bMV07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbGlzdENhY2hlR2V0O1xuIiwidmFyIGFzc29jSW5kZXhPZiA9IHJlcXVpcmUoJy4vX2Fzc29jSW5kZXhPZicpO1xuXG4vKipcbiAqIENoZWNrcyBpZiBhIGxpc3QgY2FjaGUgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlSGFzKGtleSkge1xuICByZXR1cm4gYXNzb2NJbmRleE9mKHRoaXMuX19kYXRhX18sIGtleSkgPiAtMTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBsaXN0Q2FjaGVIYXM7XG4iLCJ2YXIgYXNzb2NJbmRleE9mID0gcmVxdWlyZSgnLi9fYXNzb2NJbmRleE9mJyk7XG5cbi8qKlxuICogU2V0cyB0aGUgbGlzdCBjYWNoZSBga2V5YCB0byBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBzZXRcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbGlzdCBjYWNoZSBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlU2V0KGtleSwgdmFsdWUpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgaW5kZXggPSBhc3NvY0luZGV4T2YoZGF0YSwga2V5KTtcblxuICBpZiAoaW5kZXggPCAwKSB7XG4gICAgKyt0aGlzLnNpemU7XG4gICAgZGF0YS5wdXNoKFtrZXksIHZhbHVlXSk7XG4gIH0gZWxzZSB7XG4gICAgZGF0YVtpbmRleF1bMV0gPSB2YWx1ZTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBsaXN0Q2FjaGVTZXQ7XG4iLCJ2YXIgTGlzdENhY2hlID0gcmVxdWlyZSgnLi9fTGlzdENhY2hlJyk7XG5cbi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgc3RhY2suXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGNsZWFyXG4gKiBAbWVtYmVyT2YgU3RhY2tcbiAqL1xuZnVuY3Rpb24gc3RhY2tDbGVhcigpIHtcbiAgdGhpcy5fX2RhdGFfXyA9IG5ldyBMaXN0Q2FjaGU7XG4gIHRoaXMuc2l6ZSA9IDA7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3RhY2tDbGVhcjtcbiIsIi8qKlxuICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIHN0YWNrLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBkZWxldGVcbiAqIEBtZW1iZXJPZiBTdGFja1xuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIHN0YWNrRGVsZXRlKGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICByZXN1bHQgPSBkYXRhWydkZWxldGUnXShrZXkpO1xuXG4gIHRoaXMuc2l6ZSA9IGRhdGEuc2l6ZTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdGFja0RlbGV0ZTtcbiIsIi8qKlxuICogR2V0cyB0aGUgc3RhY2sgdmFsdWUgZm9yIGBrZXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBnZXRcbiAqIEBtZW1iZXJPZiBTdGFja1xuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIHN0YWNrR2V0KGtleSkge1xuICByZXR1cm4gdGhpcy5fX2RhdGFfXy5nZXQoa2V5KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdGFja0dldDtcbiIsIi8qKlxuICogQ2hlY2tzIGlmIGEgc3RhY2sgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgU3RhY2tcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBzdGFja0hhcyhrZXkpIHtcbiAgcmV0dXJuIHRoaXMuX19kYXRhX18uaGFzKGtleSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3RhY2tIYXM7XG4iLCJ2YXIgTGlzdENhY2hlID0gcmVxdWlyZSgnLi9fTGlzdENhY2hlJyksXG4gICAgTWFwID0gcmVxdWlyZSgnLi9fTWFwJyksXG4gICAgTWFwQ2FjaGUgPSByZXF1aXJlKCcuL19NYXBDYWNoZScpO1xuXG4vKiogVXNlZCBhcyB0aGUgc2l6ZSB0byBlbmFibGUgbGFyZ2UgYXJyYXkgb3B0aW1pemF0aW9ucy4gKi9cbnZhciBMQVJHRV9BUlJBWV9TSVpFID0gMjAwO1xuXG4vKipcbiAqIFNldHMgdGhlIHN0YWNrIGBrZXlgIHRvIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIHNldFxuICogQG1lbWJlck9mIFN0YWNrXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIHN0YWNrIGNhY2hlIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBzdGFja1NldChrZXksIHZhbHVlKSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgaWYgKGRhdGEgaW5zdGFuY2VvZiBMaXN0Q2FjaGUpIHtcbiAgICB2YXIgcGFpcnMgPSBkYXRhLl9fZGF0YV9fO1xuICAgIGlmICghTWFwIHx8IChwYWlycy5sZW5ndGggPCBMQVJHRV9BUlJBWV9TSVpFIC0gMSkpIHtcbiAgICAgIHBhaXJzLnB1c2goW2tleSwgdmFsdWVdKTtcbiAgICAgIHRoaXMuc2l6ZSA9ICsrZGF0YS5zaXplO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGRhdGEgPSB0aGlzLl9fZGF0YV9fID0gbmV3IE1hcENhY2hlKHBhaXJzKTtcbiAgfVxuICBkYXRhLnNldChrZXksIHZhbHVlKTtcbiAgdGhpcy5zaXplID0gZGF0YS5zaXplO1xuICByZXR1cm4gdGhpcztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdGFja1NldDtcbiIsInZhciBpc0Z1bmN0aW9uID0gcmVxdWlyZSgnLi9pc0Z1bmN0aW9uJyksXG4gICAgaXNNYXNrZWQgPSByZXF1aXJlKCcuL19pc01hc2tlZCcpLFxuICAgIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9pc09iamVjdCcpLFxuICAgIHRvU291cmNlID0gcmVxdWlyZSgnLi9fdG9Tb3VyY2UnKTtcblxuLyoqXG4gKiBVc2VkIHRvIG1hdGNoIGBSZWdFeHBgXG4gKiBbc3ludGF4IGNoYXJhY3RlcnNdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXBhdHRlcm5zKS5cbiAqL1xudmFyIHJlUmVnRXhwQ2hhciA9IC9bXFxcXF4kLiorPygpW1xcXXt9fF0vZztcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IGhvc3QgY29uc3RydWN0b3JzIChTYWZhcmkpLiAqL1xudmFyIHJlSXNIb3N0Q3RvciA9IC9eXFxbb2JqZWN0IC4rP0NvbnN0cnVjdG9yXFxdJC87XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBmdW5jUHJvdG8gPSBGdW5jdGlvbi5wcm90b3R5cGUsXG4gICAgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byByZXNvbHZlIHRoZSBkZWNvbXBpbGVkIHNvdXJjZSBvZiBmdW5jdGlvbnMuICovXG52YXIgZnVuY1RvU3RyaW5nID0gZnVuY1Byb3RvLnRvU3RyaW5nO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKiogVXNlZCB0byBkZXRlY3QgaWYgYSBtZXRob2QgaXMgbmF0aXZlLiAqL1xudmFyIHJlSXNOYXRpdmUgPSBSZWdFeHAoJ14nICtcbiAgZnVuY1RvU3RyaW5nLmNhbGwoaGFzT3duUHJvcGVydHkpLnJlcGxhY2UocmVSZWdFeHBDaGFyLCAnXFxcXCQmJylcbiAgLnJlcGxhY2UoL2hhc093blByb3BlcnR5fChmdW5jdGlvbikuKj8oPz1cXFxcXFwoKXwgZm9yIC4rPyg/PVxcXFxcXF0pL2csICckMS4qPycpICsgJyQnXG4pO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzTmF0aXZlYCB3aXRob3V0IGJhZCBzaGltIGNoZWNrcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIG5hdGl2ZSBmdW5jdGlvbixcbiAqICBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc05hdGl2ZSh2YWx1ZSkge1xuICBpZiAoIWlzT2JqZWN0KHZhbHVlKSB8fCBpc01hc2tlZCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIHBhdHRlcm4gPSBpc0Z1bmN0aW9uKHZhbHVlKSA/IHJlSXNOYXRpdmUgOiByZUlzSG9zdEN0b3I7XG4gIHJldHVybiBwYXR0ZXJuLnRlc3QodG9Tb3VyY2UodmFsdWUpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlSXNOYXRpdmU7XG4iLCJ2YXIgU3ltYm9sID0gcmVxdWlyZSgnLi9fU3ltYm9sJyk7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogVXNlZCB0byByZXNvbHZlIHRoZVxuICogW2B0b1N0cmluZ1RhZ2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXG4gKiBvZiB2YWx1ZXMuXG4gKi9cbnZhciBuYXRpdmVPYmplY3RUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBzeW1Ub1N0cmluZ1RhZyA9IFN5bWJvbCA/IFN5bWJvbC50b1N0cmluZ1RhZyA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VHZXRUYWdgIHdoaWNoIGlnbm9yZXMgYFN5bWJvbC50b1N0cmluZ1RhZ2AgdmFsdWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHJhdyBgdG9TdHJpbmdUYWdgLlxuICovXG5mdW5jdGlvbiBnZXRSYXdUYWcodmFsdWUpIHtcbiAgdmFyIGlzT3duID0gaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgc3ltVG9TdHJpbmdUYWcpLFxuICAgICAgdGFnID0gdmFsdWVbc3ltVG9TdHJpbmdUYWddO1xuXG4gIHRyeSB7XG4gICAgdmFsdWVbc3ltVG9TdHJpbmdUYWddID0gdW5kZWZpbmVkO1xuICAgIHZhciB1bm1hc2tlZCA9IHRydWU7XG4gIH0gY2F0Y2ggKGUpIHt9XG5cbiAgdmFyIHJlc3VsdCA9IG5hdGl2ZU9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpO1xuICBpZiAodW5tYXNrZWQpIHtcbiAgICBpZiAoaXNPd24pIHtcbiAgICAgIHZhbHVlW3N5bVRvU3RyaW5nVGFnXSA9IHRhZztcbiAgICB9IGVsc2Uge1xuICAgICAgZGVsZXRlIHZhbHVlW3N5bVRvU3RyaW5nVGFnXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRSYXdUYWc7XG4iLCIvKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKipcbiAqIFVzZWQgdG8gcmVzb2x2ZSB0aGVcbiAqIFtgdG9TdHJpbmdUYWdgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nKVxuICogb2YgdmFsdWVzLlxuICovXG52YXIgbmF0aXZlT2JqZWN0VG9TdHJpbmcgPSBvYmplY3RQcm90by50b1N0cmluZztcblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgc3RyaW5nIHVzaW5nIGBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIG9iamVjdFRvU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiBuYXRpdmVPYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBvYmplY3RUb1N0cmluZztcbiIsInZhciBjb3JlSnNEYXRhID0gcmVxdWlyZSgnLi9fY29yZUpzRGF0YScpO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgbWV0aG9kcyBtYXNxdWVyYWRpbmcgYXMgbmF0aXZlLiAqL1xudmFyIG1hc2tTcmNLZXkgPSAoZnVuY3Rpb24oKSB7XG4gIHZhciB1aWQgPSAvW14uXSskLy5leGVjKGNvcmVKc0RhdGEgJiYgY29yZUpzRGF0YS5rZXlzICYmIGNvcmVKc0RhdGEua2V5cy5JRV9QUk9UTyB8fCAnJyk7XG4gIHJldHVybiB1aWQgPyAoJ1N5bWJvbChzcmMpXzEuJyArIHVpZCkgOiAnJztcbn0oKSk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGBmdW5jYCBoYXMgaXRzIHNvdXJjZSBtYXNrZWQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBmdW5jYCBpcyBtYXNrZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNNYXNrZWQoZnVuYykge1xuICByZXR1cm4gISFtYXNrU3JjS2V5ICYmIChtYXNrU3JjS2V5IGluIGZ1bmMpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzTWFza2VkO1xuIiwidmFyIHJvb3QgPSByZXF1aXJlKCcuL19yb290Jyk7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBvdmVycmVhY2hpbmcgY29yZS1qcyBzaGltcy4gKi9cbnZhciBjb3JlSnNEYXRhID0gcm9vdFsnX19jb3JlLWpzX3NoYXJlZF9fJ107XG5cbm1vZHVsZS5leHBvcnRzID0gY29yZUpzRGF0YTtcbiIsIi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBmdW5jUHJvdG8gPSBGdW5jdGlvbi5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIHJlc29sdmUgdGhlIGRlY29tcGlsZWQgc291cmNlIG9mIGZ1bmN0aW9ucy4gKi9cbnZhciBmdW5jVG9TdHJpbmcgPSBmdW5jUHJvdG8udG9TdHJpbmc7XG5cbi8qKlxuICogQ29udmVydHMgYGZ1bmNgIHRvIGl0cyBzb3VyY2UgY29kZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHNvdXJjZSBjb2RlLlxuICovXG5mdW5jdGlvbiB0b1NvdXJjZShmdW5jKSB7XG4gIGlmIChmdW5jICE9IG51bGwpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGZ1bmNUb1N0cmluZy5jYWxsKGZ1bmMpO1xuICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiAoZnVuYyArICcnKTtcbiAgICB9IGNhdGNoIChlKSB7fVxuICB9XG4gIHJldHVybiAnJztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB0b1NvdXJjZTtcbiIsIi8qKlxuICogR2V0cyB0aGUgdmFsdWUgYXQgYGtleWAgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcHJvcGVydHkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGdldFZhbHVlKG9iamVjdCwga2V5KSB7XG4gIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IG9iamVjdFtrZXldO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldFZhbHVlO1xuIiwidmFyIEhhc2ggPSByZXF1aXJlKCcuL19IYXNoJyksXG4gICAgTGlzdENhY2hlID0gcmVxdWlyZSgnLi9fTGlzdENhY2hlJyksXG4gICAgTWFwID0gcmVxdWlyZSgnLi9fTWFwJyk7XG5cbi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgbWFwLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBjbGVhclxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlQ2xlYXIoKSB7XG4gIHRoaXMuc2l6ZSA9IDA7XG4gIHRoaXMuX19kYXRhX18gPSB7XG4gICAgJ2hhc2gnOiBuZXcgSGFzaCxcbiAgICAnbWFwJzogbmV3IChNYXAgfHwgTGlzdENhY2hlKSxcbiAgICAnc3RyaW5nJzogbmV3IEhhc2hcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtYXBDYWNoZUNsZWFyO1xuIiwidmFyIGhhc2hDbGVhciA9IHJlcXVpcmUoJy4vX2hhc2hDbGVhcicpLFxuICAgIGhhc2hEZWxldGUgPSByZXF1aXJlKCcuL19oYXNoRGVsZXRlJyksXG4gICAgaGFzaEdldCA9IHJlcXVpcmUoJy4vX2hhc2hHZXQnKSxcbiAgICBoYXNoSGFzID0gcmVxdWlyZSgnLi9faGFzaEhhcycpLFxuICAgIGhhc2hTZXQgPSByZXF1aXJlKCcuL19oYXNoU2V0Jyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGhhc2ggb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBIYXNoKGVudHJpZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBlbnRyaWVzID09IG51bGwgPyAwIDogZW50cmllcy5sZW5ndGg7XG5cbiAgdGhpcy5jbGVhcigpO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaW5kZXhdO1xuICAgIHRoaXMuc2V0KGVudHJ5WzBdLCBlbnRyeVsxXSk7XG4gIH1cbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYEhhc2hgLlxuSGFzaC5wcm90b3R5cGUuY2xlYXIgPSBoYXNoQ2xlYXI7XG5IYXNoLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBoYXNoRGVsZXRlO1xuSGFzaC5wcm90b3R5cGUuZ2V0ID0gaGFzaEdldDtcbkhhc2gucHJvdG90eXBlLmhhcyA9IGhhc2hIYXM7XG5IYXNoLnByb3RvdHlwZS5zZXQgPSBoYXNoU2V0O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEhhc2g7XG4iLCJ2YXIgbmF0aXZlQ3JlYXRlID0gcmVxdWlyZSgnLi9fbmF0aXZlQ3JlYXRlJyk7XG5cbi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgaGFzaC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgY2xlYXJcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKi9cbmZ1bmN0aW9uIGhhc2hDbGVhcigpIHtcbiAgdGhpcy5fX2RhdGFfXyA9IG5hdGl2ZUNyZWF0ZSA/IG5hdGl2ZUNyZWF0ZShudWxsKSA6IHt9O1xuICB0aGlzLnNpemUgPSAwO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGhhc2hDbGVhcjtcbiIsIi8qKlxuICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIGhhc2guXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGRlbGV0ZVxuICogQG1lbWJlck9mIEhhc2hcbiAqIEBwYXJhbSB7T2JqZWN0fSBoYXNoIFRoZSBoYXNoIHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBoYXNoRGVsZXRlKGtleSkge1xuICB2YXIgcmVzdWx0ID0gdGhpcy5oYXMoa2V5KSAmJiBkZWxldGUgdGhpcy5fX2RhdGFfX1trZXldO1xuICB0aGlzLnNpemUgLT0gcmVzdWx0ID8gMSA6IDA7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaGFzaERlbGV0ZTtcbiIsInZhciBuYXRpdmVDcmVhdGUgPSByZXF1aXJlKCcuL19uYXRpdmVDcmVhdGUnKTtcblxuLyoqIFVzZWQgdG8gc3RhbmQtaW4gZm9yIGB1bmRlZmluZWRgIGhhc2ggdmFsdWVzLiAqL1xudmFyIEhBU0hfVU5ERUZJTkVEID0gJ19fbG9kYXNoX2hhc2hfdW5kZWZpbmVkX18nO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIEdldHMgdGhlIGhhc2ggdmFsdWUgZm9yIGBrZXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBnZXRcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gaGFzaEdldChrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICBpZiAobmF0aXZlQ3JlYXRlKSB7XG4gICAgdmFyIHJlc3VsdCA9IGRhdGFba2V5XTtcbiAgICByZXR1cm4gcmVzdWx0ID09PSBIQVNIX1VOREVGSU5FRCA/IHVuZGVmaW5lZCA6IHJlc3VsdDtcbiAgfVxuICByZXR1cm4gaGFzT3duUHJvcGVydHkuY2FsbChkYXRhLCBrZXkpID8gZGF0YVtrZXldIDogdW5kZWZpbmVkO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGhhc2hHZXQ7XG4iLCJ2YXIgbmF0aXZlQ3JlYXRlID0gcmVxdWlyZSgnLi9fbmF0aXZlQ3JlYXRlJyk7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgaGFzaCB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaGFzaEhhcyhrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICByZXR1cm4gbmF0aXZlQ3JlYXRlID8gKGRhdGFba2V5XSAhPT0gdW5kZWZpbmVkKSA6IGhhc093blByb3BlcnR5LmNhbGwoZGF0YSwga2V5KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBoYXNoSGFzO1xuIiwidmFyIG5hdGl2ZUNyZWF0ZSA9IHJlcXVpcmUoJy4vX25hdGl2ZUNyZWF0ZScpO1xuXG4vKiogVXNlZCB0byBzdGFuZC1pbiBmb3IgYHVuZGVmaW5lZGAgaGFzaCB2YWx1ZXMuICovXG52YXIgSEFTSF9VTkRFRklORUQgPSAnX19sb2Rhc2hfaGFzaF91bmRlZmluZWRfXyc7XG5cbi8qKlxuICogU2V0cyB0aGUgaGFzaCBga2V5YCB0byBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBzZXRcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGhhc2ggaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIGhhc2hTZXQoa2V5LCB2YWx1ZSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gIHRoaXMuc2l6ZSArPSB0aGlzLmhhcyhrZXkpID8gMCA6IDE7XG4gIGRhdGFba2V5XSA9IChuYXRpdmVDcmVhdGUgJiYgdmFsdWUgPT09IHVuZGVmaW5lZCkgPyBIQVNIX1VOREVGSU5FRCA6IHZhbHVlO1xuICByZXR1cm4gdGhpcztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBoYXNoU2V0O1xuIiwidmFyIGdldE1hcERhdGEgPSByZXF1aXJlKCcuL19nZXRNYXBEYXRhJyk7XG5cbi8qKlxuICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIG1hcC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZGVsZXRlXG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBtYXBDYWNoZURlbGV0ZShrZXkpIHtcbiAgdmFyIHJlc3VsdCA9IGdldE1hcERhdGEodGhpcywga2V5KVsnZGVsZXRlJ10oa2V5KTtcbiAgdGhpcy5zaXplIC09IHJlc3VsdCA/IDEgOiAwO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG1hcENhY2hlRGVsZXRlO1xuIiwiLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBzdWl0YWJsZSBmb3IgdXNlIGFzIHVuaXF1ZSBvYmplY3Qga2V5LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIHN1aXRhYmxlLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzS2V5YWJsZSh2YWx1ZSkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgcmV0dXJuICh0eXBlID09ICdzdHJpbmcnIHx8IHR5cGUgPT0gJ251bWJlcicgfHwgdHlwZSA9PSAnc3ltYm9sJyB8fCB0eXBlID09ICdib29sZWFuJylcbiAgICA/ICh2YWx1ZSAhPT0gJ19fcHJvdG9fXycpXG4gICAgOiAodmFsdWUgPT09IG51bGwpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzS2V5YWJsZTtcbiIsInZhciBnZXRNYXBEYXRhID0gcmVxdWlyZSgnLi9fZ2V0TWFwRGF0YScpO1xuXG4vKipcbiAqIEdldHMgdGhlIG1hcCB2YWx1ZSBmb3IgYGtleWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGdldFxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVHZXQoa2V5KSB7XG4gIHJldHVybiBnZXRNYXBEYXRhKHRoaXMsIGtleSkuZ2V0KGtleSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWFwQ2FjaGVHZXQ7XG4iLCJ2YXIgZ2V0TWFwRGF0YSA9IHJlcXVpcmUoJy4vX2dldE1hcERhdGEnKTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYSBtYXAgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBtYXBDYWNoZUhhcyhrZXkpIHtcbiAgcmV0dXJuIGdldE1hcERhdGEodGhpcywga2V5KS5oYXMoa2V5KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtYXBDYWNoZUhhcztcbiIsInZhciBnZXRNYXBEYXRhID0gcmVxdWlyZSgnLi9fZ2V0TWFwRGF0YScpO1xuXG4vKipcbiAqIFNldHMgdGhlIG1hcCBga2V5YCB0byBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBzZXRcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBtYXAgY2FjaGUgaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlU2V0KGtleSwgdmFsdWUpIHtcbiAgdmFyIGRhdGEgPSBnZXRNYXBEYXRhKHRoaXMsIGtleSksXG4gICAgICBzaXplID0gZGF0YS5zaXplO1xuXG4gIGRhdGEuc2V0KGtleSwgdmFsdWUpO1xuICB0aGlzLnNpemUgKz0gZGF0YS5zaXplID09IHNpemUgPyAwIDogMTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWFwQ2FjaGVTZXQ7XG4iLCJ2YXIgY3JlYXRlQmFzZUZvciA9IHJlcXVpcmUoJy4vX2NyZWF0ZUJhc2VGb3InKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgYmFzZUZvck93bmAgd2hpY2ggaXRlcmF0ZXMgb3ZlciBgb2JqZWN0YFxuICogcHJvcGVydGllcyByZXR1cm5lZCBieSBga2V5c0Z1bmNgIGFuZCBpbnZva2VzIGBpdGVyYXRlZWAgZm9yIGVhY2ggcHJvcGVydHkuXG4gKiBJdGVyYXRlZSBmdW5jdGlvbnMgbWF5IGV4aXQgaXRlcmF0aW9uIGVhcmx5IGJ5IGV4cGxpY2l0bHkgcmV0dXJuaW5nIGBmYWxzZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHBhcmFtIHtGdW5jdGlvbn0ga2V5c0Z1bmMgVGhlIGZ1bmN0aW9uIHRvIGdldCB0aGUga2V5cyBvZiBgb2JqZWN0YC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKi9cbnZhciBiYXNlRm9yID0gY3JlYXRlQmFzZUZvcigpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VGb3I7XG4iLCIvKipcbiAqIENyZWF0ZXMgYSBiYXNlIGZ1bmN0aW9uIGZvciBtZXRob2RzIGxpa2UgYF8uZm9ySW5gIGFuZCBgXy5mb3JPd25gLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtmcm9tUmlnaHRdIFNwZWNpZnkgaXRlcmF0aW5nIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGJhc2UgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUJhc2VGb3IoZnJvbVJpZ2h0KSB7XG4gIHJldHVybiBmdW5jdGlvbihvYmplY3QsIGl0ZXJhdGVlLCBrZXlzRnVuYykge1xuICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICBpdGVyYWJsZSA9IE9iamVjdChvYmplY3QpLFxuICAgICAgICBwcm9wcyA9IGtleXNGdW5jKG9iamVjdCksXG4gICAgICAgIGxlbmd0aCA9IHByb3BzLmxlbmd0aDtcblxuICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgdmFyIGtleSA9IHByb3BzW2Zyb21SaWdodCA/IGxlbmd0aCA6ICsraW5kZXhdO1xuICAgICAgaWYgKGl0ZXJhdGVlKGl0ZXJhYmxlW2tleV0sIGtleSwgaXRlcmFibGUpID09PSBmYWxzZSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG9iamVjdDtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVCYXNlRm9yO1xuIiwidmFyIGFzc2lnbk1lcmdlVmFsdWUgPSByZXF1aXJlKCcuL19hc3NpZ25NZXJnZVZhbHVlJyksXG4gICAgY2xvbmVCdWZmZXIgPSByZXF1aXJlKCcuL19jbG9uZUJ1ZmZlcicpLFxuICAgIGNsb25lVHlwZWRBcnJheSA9IHJlcXVpcmUoJy4vX2Nsb25lVHlwZWRBcnJheScpLFxuICAgIGNvcHlBcnJheSA9IHJlcXVpcmUoJy4vX2NvcHlBcnJheScpLFxuICAgIGluaXRDbG9uZU9iamVjdCA9IHJlcXVpcmUoJy4vX2luaXRDbG9uZU9iamVjdCcpLFxuICAgIGlzQXJndW1lbnRzID0gcmVxdWlyZSgnLi9pc0FyZ3VtZW50cycpLFxuICAgIGlzQXJyYXkgPSByZXF1aXJlKCcuL2lzQXJyYXknKSxcbiAgICBpc0FycmF5TGlrZU9iamVjdCA9IHJlcXVpcmUoJy4vaXNBcnJheUxpa2VPYmplY3QnKSxcbiAgICBpc0J1ZmZlciA9IHJlcXVpcmUoJy4vaXNCdWZmZXInKSxcbiAgICBpc0Z1bmN0aW9uID0gcmVxdWlyZSgnLi9pc0Z1bmN0aW9uJyksXG4gICAgaXNPYmplY3QgPSByZXF1aXJlKCcuL2lzT2JqZWN0JyksXG4gICAgaXNQbGFpbk9iamVjdCA9IHJlcXVpcmUoJy4vaXNQbGFpbk9iamVjdCcpLFxuICAgIGlzVHlwZWRBcnJheSA9IHJlcXVpcmUoJy4vaXNUeXBlZEFycmF5JyksXG4gICAgc2FmZUdldCA9IHJlcXVpcmUoJy4vX3NhZmVHZXQnKSxcbiAgICB0b1BsYWluT2JqZWN0ID0gcmVxdWlyZSgnLi90b1BsYWluT2JqZWN0Jyk7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlTWVyZ2VgIGZvciBhcnJheXMgYW5kIG9iamVjdHMgd2hpY2ggcGVyZm9ybXNcbiAqIGRlZXAgbWVyZ2VzIGFuZCB0cmFja3MgdHJhdmVyc2VkIG9iamVjdHMgZW5hYmxpbmcgb2JqZWN0cyB3aXRoIGNpcmN1bGFyXG4gKiByZWZlcmVuY2VzIHRvIGJlIG1lcmdlZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgc291cmNlIG9iamVjdC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gbWVyZ2UuXG4gKiBAcGFyYW0ge251bWJlcn0gc3JjSW5kZXggVGhlIGluZGV4IG9mIGBzb3VyY2VgLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gbWVyZ2VGdW5jIFRoZSBmdW5jdGlvbiB0byBtZXJnZSB2YWx1ZXMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBhc3NpZ25lZCB2YWx1ZXMuXG4gKiBAcGFyYW0ge09iamVjdH0gW3N0YWNrXSBUcmFja3MgdHJhdmVyc2VkIHNvdXJjZSB2YWx1ZXMgYW5kIHRoZWlyIG1lcmdlZFxuICogIGNvdW50ZXJwYXJ0cy5cbiAqL1xuZnVuY3Rpb24gYmFzZU1lcmdlRGVlcChvYmplY3QsIHNvdXJjZSwga2V5LCBzcmNJbmRleCwgbWVyZ2VGdW5jLCBjdXN0b21pemVyLCBzdGFjaykge1xuICB2YXIgb2JqVmFsdWUgPSBzYWZlR2V0KG9iamVjdCwga2V5KSxcbiAgICAgIHNyY1ZhbHVlID0gc2FmZUdldChzb3VyY2UsIGtleSksXG4gICAgICBzdGFja2VkID0gc3RhY2suZ2V0KHNyY1ZhbHVlKTtcblxuICBpZiAoc3RhY2tlZCkge1xuICAgIGFzc2lnbk1lcmdlVmFsdWUob2JqZWN0LCBrZXksIHN0YWNrZWQpO1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgbmV3VmFsdWUgPSBjdXN0b21pemVyXG4gICAgPyBjdXN0b21pemVyKG9ialZhbHVlLCBzcmNWYWx1ZSwgKGtleSArICcnKSwgb2JqZWN0LCBzb3VyY2UsIHN0YWNrKVxuICAgIDogdW5kZWZpbmVkO1xuXG4gIHZhciBpc0NvbW1vbiA9IG5ld1ZhbHVlID09PSB1bmRlZmluZWQ7XG5cbiAgaWYgKGlzQ29tbW9uKSB7XG4gICAgdmFyIGlzQXJyID0gaXNBcnJheShzcmNWYWx1ZSksXG4gICAgICAgIGlzQnVmZiA9ICFpc0FyciAmJiBpc0J1ZmZlcihzcmNWYWx1ZSksXG4gICAgICAgIGlzVHlwZWQgPSAhaXNBcnIgJiYgIWlzQnVmZiAmJiBpc1R5cGVkQXJyYXkoc3JjVmFsdWUpO1xuXG4gICAgbmV3VmFsdWUgPSBzcmNWYWx1ZTtcbiAgICBpZiAoaXNBcnIgfHwgaXNCdWZmIHx8IGlzVHlwZWQpIHtcbiAgICAgIGlmIChpc0FycmF5KG9ialZhbHVlKSkge1xuICAgICAgICBuZXdWYWx1ZSA9IG9ialZhbHVlO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoaXNBcnJheUxpa2VPYmplY3Qob2JqVmFsdWUpKSB7XG4gICAgICAgIG5ld1ZhbHVlID0gY29weUFycmF5KG9ialZhbHVlKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGlzQnVmZikge1xuICAgICAgICBpc0NvbW1vbiA9IGZhbHNlO1xuICAgICAgICBuZXdWYWx1ZSA9IGNsb25lQnVmZmVyKHNyY1ZhbHVlLCB0cnVlKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGlzVHlwZWQpIHtcbiAgICAgICAgaXNDb21tb24gPSBmYWxzZTtcbiAgICAgICAgbmV3VmFsdWUgPSBjbG9uZVR5cGVkQXJyYXkoc3JjVmFsdWUsIHRydWUpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIG5ld1ZhbHVlID0gW107XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzUGxhaW5PYmplY3Qoc3JjVmFsdWUpIHx8IGlzQXJndW1lbnRzKHNyY1ZhbHVlKSkge1xuICAgICAgbmV3VmFsdWUgPSBvYmpWYWx1ZTtcbiAgICAgIGlmIChpc0FyZ3VtZW50cyhvYmpWYWx1ZSkpIHtcbiAgICAgICAgbmV3VmFsdWUgPSB0b1BsYWluT2JqZWN0KG9ialZhbHVlKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKCFpc09iamVjdChvYmpWYWx1ZSkgfHwgaXNGdW5jdGlvbihvYmpWYWx1ZSkpIHtcbiAgICAgICAgbmV3VmFsdWUgPSBpbml0Q2xvbmVPYmplY3Qoc3JjVmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGlzQ29tbW9uID0gZmFsc2U7XG4gICAgfVxuICB9XG4gIGlmIChpc0NvbW1vbikge1xuICAgIC8vIFJlY3Vyc2l2ZWx5IG1lcmdlIG9iamVjdHMgYW5kIGFycmF5cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgIHN0YWNrLnNldChzcmNWYWx1ZSwgbmV3VmFsdWUpO1xuICAgIG1lcmdlRnVuYyhuZXdWYWx1ZSwgc3JjVmFsdWUsIHNyY0luZGV4LCBjdXN0b21pemVyLCBzdGFjayk7XG4gICAgc3RhY2tbJ2RlbGV0ZSddKHNyY1ZhbHVlKTtcbiAgfVxuICBhc3NpZ25NZXJnZVZhbHVlKG9iamVjdCwga2V5LCBuZXdWYWx1ZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZU1lcmdlRGVlcDtcbiIsInZhciByb290ID0gcmVxdWlyZSgnLi9fcm9vdCcpO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGV4cG9ydHNgLiAqL1xudmFyIGZyZWVFeHBvcnRzID0gdHlwZW9mIGV4cG9ydHMgPT0gJ29iamVjdCcgJiYgZXhwb3J0cyAmJiAhZXhwb3J0cy5ub2RlVHlwZSAmJiBleHBvcnRzO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYG1vZHVsZWAuICovXG52YXIgZnJlZU1vZHVsZSA9IGZyZWVFeHBvcnRzICYmIHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlICYmICFtb2R1bGUubm9kZVR5cGUgJiYgbW9kdWxlO1xuXG4vKiogRGV0ZWN0IHRoZSBwb3B1bGFyIENvbW1vbkpTIGV4dGVuc2lvbiBgbW9kdWxlLmV4cG9ydHNgLiAqL1xudmFyIG1vZHVsZUV4cG9ydHMgPSBmcmVlTW9kdWxlICYmIGZyZWVNb2R1bGUuZXhwb3J0cyA9PT0gZnJlZUV4cG9ydHM7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIEJ1ZmZlciA9IG1vZHVsZUV4cG9ydHMgPyByb290LkJ1ZmZlciA6IHVuZGVmaW5lZCxcbiAgICBhbGxvY1Vuc2FmZSA9IEJ1ZmZlciA/IEJ1ZmZlci5hbGxvY1Vuc2FmZSA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBDcmVhdGVzIGEgY2xvbmUgb2YgIGBidWZmZXJgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0J1ZmZlcn0gYnVmZmVyIFRoZSBidWZmZXIgdG8gY2xvbmUuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0RlZXBdIFNwZWNpZnkgYSBkZWVwIGNsb25lLlxuICogQHJldHVybnMge0J1ZmZlcn0gUmV0dXJucyB0aGUgY2xvbmVkIGJ1ZmZlci5cbiAqL1xuZnVuY3Rpb24gY2xvbmVCdWZmZXIoYnVmZmVyLCBpc0RlZXApIHtcbiAgaWYgKGlzRGVlcCkge1xuICAgIHJldHVybiBidWZmZXIuc2xpY2UoKTtcbiAgfVxuICB2YXIgbGVuZ3RoID0gYnVmZmVyLmxlbmd0aCxcbiAgICAgIHJlc3VsdCA9IGFsbG9jVW5zYWZlID8gYWxsb2NVbnNhZmUobGVuZ3RoKSA6IG5ldyBidWZmZXIuY29uc3RydWN0b3IobGVuZ3RoKTtcblxuICBidWZmZXIuY29weShyZXN1bHQpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsb25lQnVmZmVyO1xuIiwidmFyIGNsb25lQXJyYXlCdWZmZXIgPSByZXF1aXJlKCcuL19jbG9uZUFycmF5QnVmZmVyJyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGNsb25lIG9mIGB0eXBlZEFycmF5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHR5cGVkQXJyYXkgVGhlIHR5cGVkIGFycmF5IHRvIGNsb25lLlxuICogQHBhcmFtIHtib29sZWFufSBbaXNEZWVwXSBTcGVjaWZ5IGEgZGVlcCBjbG9uZS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNsb25lZCB0eXBlZCBhcnJheS5cbiAqL1xuZnVuY3Rpb24gY2xvbmVUeXBlZEFycmF5KHR5cGVkQXJyYXksIGlzRGVlcCkge1xuICB2YXIgYnVmZmVyID0gaXNEZWVwID8gY2xvbmVBcnJheUJ1ZmZlcih0eXBlZEFycmF5LmJ1ZmZlcikgOiB0eXBlZEFycmF5LmJ1ZmZlcjtcbiAgcmV0dXJuIG5ldyB0eXBlZEFycmF5LmNvbnN0cnVjdG9yKGJ1ZmZlciwgdHlwZWRBcnJheS5ieXRlT2Zmc2V0LCB0eXBlZEFycmF5Lmxlbmd0aCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2xvbmVUeXBlZEFycmF5O1xuIiwidmFyIFVpbnQ4QXJyYXkgPSByZXF1aXJlKCcuL19VaW50OEFycmF5Jyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGNsb25lIG9mIGBhcnJheUJ1ZmZlcmAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXlCdWZmZXJ9IGFycmF5QnVmZmVyIFRoZSBhcnJheSBidWZmZXIgdG8gY2xvbmUuXG4gKiBAcmV0dXJucyB7QXJyYXlCdWZmZXJ9IFJldHVybnMgdGhlIGNsb25lZCBhcnJheSBidWZmZXIuXG4gKi9cbmZ1bmN0aW9uIGNsb25lQXJyYXlCdWZmZXIoYXJyYXlCdWZmZXIpIHtcbiAgdmFyIHJlc3VsdCA9IG5ldyBhcnJheUJ1ZmZlci5jb25zdHJ1Y3RvcihhcnJheUJ1ZmZlci5ieXRlTGVuZ3RoKTtcbiAgbmV3IFVpbnQ4QXJyYXkocmVzdWx0KS5zZXQobmV3IFVpbnQ4QXJyYXkoYXJyYXlCdWZmZXIpKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjbG9uZUFycmF5QnVmZmVyO1xuIiwidmFyIHJvb3QgPSByZXF1aXJlKCcuL19yb290Jyk7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIFVpbnQ4QXJyYXkgPSByb290LlVpbnQ4QXJyYXk7XG5cbm1vZHVsZS5leHBvcnRzID0gVWludDhBcnJheTtcbiIsIi8qKlxuICogQ29waWVzIHRoZSB2YWx1ZXMgb2YgYHNvdXJjZWAgdG8gYGFycmF5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gc291cmNlIFRoZSBhcnJheSB0byBjb3B5IHZhbHVlcyBmcm9tLlxuICogQHBhcmFtIHtBcnJheX0gW2FycmF5PVtdXSBUaGUgYXJyYXkgdG8gY29weSB2YWx1ZXMgdG8uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAqL1xuZnVuY3Rpb24gY29weUFycmF5KHNvdXJjZSwgYXJyYXkpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBzb3VyY2UubGVuZ3RoO1xuXG4gIGFycmF5IHx8IChhcnJheSA9IEFycmF5KGxlbmd0aCkpO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGFycmF5W2luZGV4XSA9IHNvdXJjZVtpbmRleF07XG4gIH1cbiAgcmV0dXJuIGFycmF5O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNvcHlBcnJheTtcbiIsInZhciBiYXNlQ3JlYXRlID0gcmVxdWlyZSgnLi9fYmFzZUNyZWF0ZScpLFxuICAgIGdldFByb3RvdHlwZSA9IHJlcXVpcmUoJy4vX2dldFByb3RvdHlwZScpLFxuICAgIGlzUHJvdG90eXBlID0gcmVxdWlyZSgnLi9faXNQcm90b3R5cGUnKTtcblxuLyoqXG4gKiBJbml0aWFsaXplcyBhbiBvYmplY3QgY2xvbmUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjbG9uZS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGluaXRpYWxpemVkIGNsb25lLlxuICovXG5mdW5jdGlvbiBpbml0Q2xvbmVPYmplY3Qob2JqZWN0KSB7XG4gIHJldHVybiAodHlwZW9mIG9iamVjdC5jb25zdHJ1Y3RvciA9PSAnZnVuY3Rpb24nICYmICFpc1Byb3RvdHlwZShvYmplY3QpKVxuICAgID8gYmFzZUNyZWF0ZShnZXRQcm90b3R5cGUob2JqZWN0KSlcbiAgICA6IHt9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGluaXRDbG9uZU9iamVjdDtcbiIsInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vaXNPYmplY3QnKTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0Q3JlYXRlID0gT2JqZWN0LmNyZWF0ZTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5jcmVhdGVgIHdpdGhvdXQgc3VwcG9ydCBmb3IgYXNzaWduaW5nXG4gKiBwcm9wZXJ0aWVzIHRvIHRoZSBjcmVhdGVkIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHByb3RvIFRoZSBvYmplY3QgdG8gaW5oZXJpdCBmcm9tLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cbiAqL1xudmFyIGJhc2VDcmVhdGUgPSAoZnVuY3Rpb24oKSB7XG4gIGZ1bmN0aW9uIG9iamVjdCgpIHt9XG4gIHJldHVybiBmdW5jdGlvbihwcm90bykge1xuICAgIGlmICghaXNPYmplY3QocHJvdG8pKSB7XG4gICAgICByZXR1cm4ge307XG4gICAgfVxuICAgIGlmIChvYmplY3RDcmVhdGUpIHtcbiAgICAgIHJldHVybiBvYmplY3RDcmVhdGUocHJvdG8pO1xuICAgIH1cbiAgICBvYmplY3QucHJvdG90eXBlID0gcHJvdG87XG4gICAgdmFyIHJlc3VsdCA9IG5ldyBvYmplY3Q7XG4gICAgb2JqZWN0LnByb3RvdHlwZSA9IHVuZGVmaW5lZDtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xufSgpKTtcblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlQ3JlYXRlO1xuIiwiLyoqXG4gKiBDcmVhdGVzIGEgdW5hcnkgZnVuY3Rpb24gdGhhdCBpbnZva2VzIGBmdW5jYCB3aXRoIGl0cyBhcmd1bWVudCB0cmFuc2Zvcm1lZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gd3JhcC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHRyYW5zZm9ybSBUaGUgYXJndW1lbnQgdHJhbnNmb3JtLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIG92ZXJBcmcoZnVuYywgdHJhbnNmb3JtKSB7XG4gIHJldHVybiBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4gZnVuYyh0cmFuc2Zvcm0oYXJnKSk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gb3ZlckFyZztcbiIsInZhciBiYXNlR2V0VGFnID0gcmVxdWlyZSgnLi9fYmFzZUdldFRhZycpLFxuICAgIGlzT2JqZWN0TGlrZSA9IHJlcXVpcmUoJy4vaXNPYmplY3RMaWtlJyk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBhcmdzVGFnID0gJ1tvYmplY3QgQXJndW1lbnRzXSc7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNBcmd1bWVudHNgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGBhcmd1bWVudHNgIG9iamVjdCxcbiAqL1xuZnVuY3Rpb24gYmFzZUlzQXJndW1lbnRzKHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGJhc2VHZXRUYWcodmFsdWUpID09IGFyZ3NUYWc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUlzQXJndW1lbnRzO1xuIiwidmFyIGlzQXJyYXlMaWtlID0gcmVxdWlyZSgnLi9pc0FycmF5TGlrZScpLFxuICAgIGlzT2JqZWN0TGlrZSA9IHJlcXVpcmUoJy4vaXNPYmplY3RMaWtlJyk7XG5cbi8qKlxuICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5pc0FycmF5TGlrZWAgZXhjZXB0IHRoYXQgaXQgYWxzbyBjaGVja3MgaWYgYHZhbHVlYFxuICogaXMgYW4gb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGFycmF5LWxpa2Ugb2JqZWN0LFxuICogIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FycmF5TGlrZU9iamVjdChbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2VPYmplY3QoZG9jdW1lbnQuYm9keS5jaGlsZHJlbik7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZU9iamVjdCgnYWJjJyk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNBcnJheUxpa2VPYmplY3QoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzQXJyYXlMaWtlT2JqZWN0KHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGlzQXJyYXlMaWtlKHZhbHVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0FycmF5TGlrZU9iamVjdDtcbiIsIi8qKlxuICogVGhpcyBtZXRob2QgcmV0dXJucyBgZmFsc2VgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4xMy4wXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy50aW1lcygyLCBfLnN0dWJGYWxzZSk7XG4gKiAvLyA9PiBbZmFsc2UsIGZhbHNlXVxuICovXG5mdW5jdGlvbiBzdHViRmFsc2UoKSB7XG4gIHJldHVybiBmYWxzZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdHViRmFsc2U7XG4iLCJ2YXIgYmFzZUdldFRhZyA9IHJlcXVpcmUoJy4vX2Jhc2VHZXRUYWcnKSxcbiAgICBnZXRQcm90b3R5cGUgPSByZXF1aXJlKCcuL19nZXRQcm90b3R5cGUnKSxcbiAgICBpc09iamVjdExpa2UgPSByZXF1aXJlKCcuL2lzT2JqZWN0TGlrZScpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0VGFnID0gJ1tvYmplY3QgT2JqZWN0XSc7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBmdW5jUHJvdG8gPSBGdW5jdGlvbi5wcm90b3R5cGUsXG4gICAgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byByZXNvbHZlIHRoZSBkZWNvbXBpbGVkIHNvdXJjZSBvZiBmdW5jdGlvbnMuICovXG52YXIgZnVuY1RvU3RyaW5nID0gZnVuY1Byb3RvLnRvU3RyaW5nO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKiogVXNlZCB0byBpbmZlciB0aGUgYE9iamVjdGAgY29uc3RydWN0b3IuICovXG52YXIgb2JqZWN0Q3RvclN0cmluZyA9IGZ1bmNUb1N0cmluZy5jYWxsKE9iamVjdCk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBwbGFpbiBvYmplY3QsIHRoYXQgaXMsIGFuIG9iamVjdCBjcmVhdGVkIGJ5IHRoZVxuICogYE9iamVjdGAgY29uc3RydWN0b3Igb3Igb25lIHdpdGggYSBgW1tQcm90b3R5cGVdXWAgb2YgYG51bGxgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC44LjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgcGxhaW4gb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIGZ1bmN0aW9uIEZvbygpIHtcbiAqICAgdGhpcy5hID0gMTtcbiAqIH1cbiAqXG4gKiBfLmlzUGxhaW5PYmplY3QobmV3IEZvbyk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNQbGFpbk9iamVjdChbMSwgMiwgM10pO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzUGxhaW5PYmplY3QoeyAneCc6IDAsICd5JzogMCB9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzUGxhaW5PYmplY3QoT2JqZWN0LmNyZWF0ZShudWxsKSk7XG4gKiAvLyA9PiB0cnVlXG4gKi9cbmZ1bmN0aW9uIGlzUGxhaW5PYmplY3QodmFsdWUpIHtcbiAgaWYgKCFpc09iamVjdExpa2UodmFsdWUpIHx8IGJhc2VHZXRUYWcodmFsdWUpICE9IG9iamVjdFRhZykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgcHJvdG8gPSBnZXRQcm90b3R5cGUodmFsdWUpO1xuICBpZiAocHJvdG8gPT09IG51bGwpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICB2YXIgQ3RvciA9IGhhc093blByb3BlcnR5LmNhbGwocHJvdG8sICdjb25zdHJ1Y3RvcicpICYmIHByb3RvLmNvbnN0cnVjdG9yO1xuICByZXR1cm4gdHlwZW9mIEN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBDdG9yIGluc3RhbmNlb2YgQ3RvciAmJlxuICAgIGZ1bmNUb1N0cmluZy5jYWxsKEN0b3IpID09IG9iamVjdEN0b3JTdHJpbmc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNQbGFpbk9iamVjdDtcbiIsInZhciBiYXNlR2V0VGFnID0gcmVxdWlyZSgnLi9fYmFzZUdldFRhZycpLFxuICAgIGlzTGVuZ3RoID0gcmVxdWlyZSgnLi9pc0xlbmd0aCcpLFxuICAgIGlzT2JqZWN0TGlrZSA9IHJlcXVpcmUoJy4vaXNPYmplY3RMaWtlJyk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBhcmdzVGFnID0gJ1tvYmplY3QgQXJndW1lbnRzXScsXG4gICAgYXJyYXlUYWcgPSAnW29iamVjdCBBcnJheV0nLFxuICAgIGJvb2xUYWcgPSAnW29iamVjdCBCb29sZWFuXScsXG4gICAgZGF0ZVRhZyA9ICdbb2JqZWN0IERhdGVdJyxcbiAgICBlcnJvclRhZyA9ICdbb2JqZWN0IEVycm9yXScsXG4gICAgZnVuY1RhZyA9ICdbb2JqZWN0IEZ1bmN0aW9uXScsXG4gICAgbWFwVGFnID0gJ1tvYmplY3QgTWFwXScsXG4gICAgbnVtYmVyVGFnID0gJ1tvYmplY3QgTnVtYmVyXScsXG4gICAgb2JqZWN0VGFnID0gJ1tvYmplY3QgT2JqZWN0XScsXG4gICAgcmVnZXhwVGFnID0gJ1tvYmplY3QgUmVnRXhwXScsXG4gICAgc2V0VGFnID0gJ1tvYmplY3QgU2V0XScsXG4gICAgc3RyaW5nVGFnID0gJ1tvYmplY3QgU3RyaW5nXScsXG4gICAgd2Vha01hcFRhZyA9ICdbb2JqZWN0IFdlYWtNYXBdJztcblxudmFyIGFycmF5QnVmZmVyVGFnID0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJyxcbiAgICBkYXRhVmlld1RhZyA9ICdbb2JqZWN0IERhdGFWaWV3XScsXG4gICAgZmxvYXQzMlRhZyA9ICdbb2JqZWN0IEZsb2F0MzJBcnJheV0nLFxuICAgIGZsb2F0NjRUYWcgPSAnW29iamVjdCBGbG9hdDY0QXJyYXldJyxcbiAgICBpbnQ4VGFnID0gJ1tvYmplY3QgSW50OEFycmF5XScsXG4gICAgaW50MTZUYWcgPSAnW29iamVjdCBJbnQxNkFycmF5XScsXG4gICAgaW50MzJUYWcgPSAnW29iamVjdCBJbnQzMkFycmF5XScsXG4gICAgdWludDhUYWcgPSAnW29iamVjdCBVaW50OEFycmF5XScsXG4gICAgdWludDhDbGFtcGVkVGFnID0gJ1tvYmplY3QgVWludDhDbGFtcGVkQXJyYXldJyxcbiAgICB1aW50MTZUYWcgPSAnW29iamVjdCBVaW50MTZBcnJheV0nLFxuICAgIHVpbnQzMlRhZyA9ICdbb2JqZWN0IFVpbnQzMkFycmF5XSc7XG5cbi8qKiBVc2VkIHRvIGlkZW50aWZ5IGB0b1N0cmluZ1RhZ2AgdmFsdWVzIG9mIHR5cGVkIGFycmF5cy4gKi9cbnZhciB0eXBlZEFycmF5VGFncyA9IHt9O1xudHlwZWRBcnJheVRhZ3NbZmxvYXQzMlRhZ10gPSB0eXBlZEFycmF5VGFnc1tmbG9hdDY0VGFnXSA9XG50eXBlZEFycmF5VGFnc1tpbnQ4VGFnXSA9IHR5cGVkQXJyYXlUYWdzW2ludDE2VGFnXSA9XG50eXBlZEFycmF5VGFnc1tpbnQzMlRhZ10gPSB0eXBlZEFycmF5VGFnc1t1aW50OFRhZ10gPVxudHlwZWRBcnJheVRhZ3NbdWludDhDbGFtcGVkVGFnXSA9IHR5cGVkQXJyYXlUYWdzW3VpbnQxNlRhZ10gPVxudHlwZWRBcnJheVRhZ3NbdWludDMyVGFnXSA9IHRydWU7XG50eXBlZEFycmF5VGFnc1thcmdzVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2FycmF5VGFnXSA9XG50eXBlZEFycmF5VGFnc1thcnJheUJ1ZmZlclRhZ10gPSB0eXBlZEFycmF5VGFnc1tib29sVGFnXSA9XG50eXBlZEFycmF5VGFnc1tkYXRhVmlld1RhZ10gPSB0eXBlZEFycmF5VGFnc1tkYXRlVGFnXSA9XG50eXBlZEFycmF5VGFnc1tlcnJvclRhZ10gPSB0eXBlZEFycmF5VGFnc1tmdW5jVGFnXSA9XG50eXBlZEFycmF5VGFnc1ttYXBUYWddID0gdHlwZWRBcnJheVRhZ3NbbnVtYmVyVGFnXSA9XG50eXBlZEFycmF5VGFnc1tvYmplY3RUYWddID0gdHlwZWRBcnJheVRhZ3NbcmVnZXhwVGFnXSA9XG50eXBlZEFycmF5VGFnc1tzZXRUYWddID0gdHlwZWRBcnJheVRhZ3Nbc3RyaW5nVGFnXSA9XG50eXBlZEFycmF5VGFnc1t3ZWFrTWFwVGFnXSA9IGZhbHNlO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzVHlwZWRBcnJheWAgd2l0aG91dCBOb2RlLmpzIG9wdGltaXphdGlvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB0eXBlZCBhcnJheSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNUeXBlZEFycmF5KHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmXG4gICAgaXNMZW5ndGgodmFsdWUubGVuZ3RoKSAmJiAhIXR5cGVkQXJyYXlUYWdzW2Jhc2VHZXRUYWcodmFsdWUpXTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlSXNUeXBlZEFycmF5O1xuIiwiLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy51bmFyeWAgd2l0aG91dCBzdXBwb3J0IGZvciBzdG9yaW5nIG1ldGFkYXRhLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjYXAgYXJndW1lbnRzIGZvci5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGNhcHBlZCBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gYmFzZVVuYXJ5KGZ1bmMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgcmV0dXJuIGZ1bmModmFsdWUpO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VVbmFyeTtcbiIsInZhciBmcmVlR2xvYmFsID0gcmVxdWlyZSgnLi9fZnJlZUdsb2JhbCcpO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGV4cG9ydHNgLiAqL1xudmFyIGZyZWVFeHBvcnRzID0gdHlwZW9mIGV4cG9ydHMgPT0gJ29iamVjdCcgJiYgZXhwb3J0cyAmJiAhZXhwb3J0cy5ub2RlVHlwZSAmJiBleHBvcnRzO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYG1vZHVsZWAuICovXG52YXIgZnJlZU1vZHVsZSA9IGZyZWVFeHBvcnRzICYmIHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlICYmICFtb2R1bGUubm9kZVR5cGUgJiYgbW9kdWxlO1xuXG4vKiogRGV0ZWN0IHRoZSBwb3B1bGFyIENvbW1vbkpTIGV4dGVuc2lvbiBgbW9kdWxlLmV4cG9ydHNgLiAqL1xudmFyIG1vZHVsZUV4cG9ydHMgPSBmcmVlTW9kdWxlICYmIGZyZWVNb2R1bGUuZXhwb3J0cyA9PT0gZnJlZUV4cG9ydHM7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgcHJvY2Vzc2AgZnJvbSBOb2RlLmpzLiAqL1xudmFyIGZyZWVQcm9jZXNzID0gbW9kdWxlRXhwb3J0cyAmJiBmcmVlR2xvYmFsLnByb2Nlc3M7XG5cbi8qKiBVc2VkIHRvIGFjY2VzcyBmYXN0ZXIgTm9kZS5qcyBoZWxwZXJzLiAqL1xudmFyIG5vZGVVdGlsID0gKGZ1bmN0aW9uKCkge1xuICB0cnkge1xuICAgIC8vIFVzZSBgdXRpbC50eXBlc2AgZm9yIE5vZGUuanMgMTArLlxuICAgIHZhciB0eXBlcyA9IGZyZWVNb2R1bGUgJiYgZnJlZU1vZHVsZS5yZXF1aXJlICYmIGZyZWVNb2R1bGUucmVxdWlyZSgndXRpbCcpLnR5cGVzO1xuXG4gICAgaWYgKHR5cGVzKSB7XG4gICAgICByZXR1cm4gdHlwZXM7XG4gICAgfVxuXG4gICAgLy8gTGVnYWN5IGBwcm9jZXNzLmJpbmRpbmcoJ3V0aWwnKWAgZm9yIE5vZGUuanMgPCAxMC5cbiAgICByZXR1cm4gZnJlZVByb2Nlc3MgJiYgZnJlZVByb2Nlc3MuYmluZGluZyAmJiBmcmVlUHJvY2Vzcy5iaW5kaW5nKCd1dGlsJyk7XG4gIH0gY2F0Y2ggKGUpIHt9XG59KCkpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IG5vZGVVdGlsO1xuIiwidmFyIGNvcHlPYmplY3QgPSByZXF1aXJlKCcuL19jb3B5T2JqZWN0JyksXG4gICAga2V5c0luID0gcmVxdWlyZSgnLi9rZXlzSW4nKTtcblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgcGxhaW4gb2JqZWN0IGZsYXR0ZW5pbmcgaW5oZXJpdGVkIGVudW1lcmFibGUgc3RyaW5nXG4gKiBrZXllZCBwcm9wZXJ0aWVzIG9mIGB2YWx1ZWAgdG8gb3duIHByb3BlcnRpZXMgb2YgdGhlIHBsYWluIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDMuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBwbGFpbiBvYmplY3QuXG4gKiBAZXhhbXBsZVxuICpcbiAqIGZ1bmN0aW9uIEZvbygpIHtcbiAqICAgdGhpcy5iID0gMjtcbiAqIH1cbiAqXG4gKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICpcbiAqIF8uYXNzaWduKHsgJ2EnOiAxIH0sIG5ldyBGb28pO1xuICogLy8gPT4geyAnYSc6IDEsICdiJzogMiB9XG4gKlxuICogXy5hc3NpZ24oeyAnYSc6IDEgfSwgXy50b1BsYWluT2JqZWN0KG5ldyBGb28pKTtcbiAqIC8vID0+IHsgJ2EnOiAxLCAnYic6IDIsICdjJzogMyB9XG4gKi9cbmZ1bmN0aW9uIHRvUGxhaW5PYmplY3QodmFsdWUpIHtcbiAgcmV0dXJuIGNvcHlPYmplY3QodmFsdWUsIGtleXNJbih2YWx1ZSkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHRvUGxhaW5PYmplY3Q7XG4iLCJ2YXIgYXNzaWduVmFsdWUgPSByZXF1aXJlKCcuL19hc3NpZ25WYWx1ZScpLFxuICAgIGJhc2VBc3NpZ25WYWx1ZSA9IHJlcXVpcmUoJy4vX2Jhc2VBc3NpZ25WYWx1ZScpO1xuXG4vKipcbiAqIENvcGllcyBwcm9wZXJ0aWVzIG9mIGBzb3VyY2VgIHRvIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3QgdG8gY29weSBwcm9wZXJ0aWVzIGZyb20uXG4gKiBAcGFyYW0ge0FycmF5fSBwcm9wcyBUaGUgcHJvcGVydHkgaWRlbnRpZmllcnMgdG8gY29weS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0PXt9XSBUaGUgb2JqZWN0IHRvIGNvcHkgcHJvcGVydGllcyB0by5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvcGllZCB2YWx1ZXMuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICovXG5mdW5jdGlvbiBjb3B5T2JqZWN0KHNvdXJjZSwgcHJvcHMsIG9iamVjdCwgY3VzdG9taXplcikge1xuICB2YXIgaXNOZXcgPSAhb2JqZWN0O1xuICBvYmplY3QgfHwgKG9iamVjdCA9IHt9KTtcblxuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IHByb3BzLmxlbmd0aDtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBrZXkgPSBwcm9wc1tpbmRleF07XG5cbiAgICB2YXIgbmV3VmFsdWUgPSBjdXN0b21pemVyXG4gICAgICA/IGN1c3RvbWl6ZXIob2JqZWN0W2tleV0sIHNvdXJjZVtrZXldLCBrZXksIG9iamVjdCwgc291cmNlKVxuICAgICAgOiB1bmRlZmluZWQ7XG5cbiAgICBpZiAobmV3VmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgbmV3VmFsdWUgPSBzb3VyY2Vba2V5XTtcbiAgICB9XG4gICAgaWYgKGlzTmV3KSB7XG4gICAgICBiYXNlQXNzaWduVmFsdWUob2JqZWN0LCBrZXksIG5ld1ZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYXNzaWduVmFsdWUob2JqZWN0LCBrZXksIG5ld1ZhbHVlKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG9iamVjdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjb3B5T2JqZWN0O1xuIiwidmFyIGJhc2VUaW1lcyA9IHJlcXVpcmUoJy4vX2Jhc2VUaW1lcycpLFxuICAgIGlzQXJndW1lbnRzID0gcmVxdWlyZSgnLi9pc0FyZ3VtZW50cycpLFxuICAgIGlzQXJyYXkgPSByZXF1aXJlKCcuL2lzQXJyYXknKSxcbiAgICBpc0J1ZmZlciA9IHJlcXVpcmUoJy4vaXNCdWZmZXInKSxcbiAgICBpc0luZGV4ID0gcmVxdWlyZSgnLi9faXNJbmRleCcpLFxuICAgIGlzVHlwZWRBcnJheSA9IHJlcXVpcmUoJy4vaXNUeXBlZEFycmF5Jyk7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBvZiB0aGUgYXJyYXktbGlrZSBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaW5oZXJpdGVkIFNwZWNpZnkgcmV0dXJuaW5nIGluaGVyaXRlZCBwcm9wZXJ0eSBuYW1lcy5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKi9cbmZ1bmN0aW9uIGFycmF5TGlrZUtleXModmFsdWUsIGluaGVyaXRlZCkge1xuICB2YXIgaXNBcnIgPSBpc0FycmF5KHZhbHVlKSxcbiAgICAgIGlzQXJnID0gIWlzQXJyICYmIGlzQXJndW1lbnRzKHZhbHVlKSxcbiAgICAgIGlzQnVmZiA9ICFpc0FyciAmJiAhaXNBcmcgJiYgaXNCdWZmZXIodmFsdWUpLFxuICAgICAgaXNUeXBlID0gIWlzQXJyICYmICFpc0FyZyAmJiAhaXNCdWZmICYmIGlzVHlwZWRBcnJheSh2YWx1ZSksXG4gICAgICBza2lwSW5kZXhlcyA9IGlzQXJyIHx8IGlzQXJnIHx8IGlzQnVmZiB8fCBpc1R5cGUsXG4gICAgICByZXN1bHQgPSBza2lwSW5kZXhlcyA/IGJhc2VUaW1lcyh2YWx1ZS5sZW5ndGgsIFN0cmluZykgOiBbXSxcbiAgICAgIGxlbmd0aCA9IHJlc3VsdC5sZW5ndGg7XG5cbiAgZm9yICh2YXIga2V5IGluIHZhbHVlKSB7XG4gICAgaWYgKChpbmhlcml0ZWQgfHwgaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwga2V5KSkgJiZcbiAgICAgICAgIShza2lwSW5kZXhlcyAmJiAoXG4gICAgICAgICAgIC8vIFNhZmFyaSA5IGhhcyBlbnVtZXJhYmxlIGBhcmd1bWVudHMubGVuZ3RoYCBpbiBzdHJpY3QgbW9kZS5cbiAgICAgICAgICAga2V5ID09ICdsZW5ndGgnIHx8XG4gICAgICAgICAgIC8vIE5vZGUuanMgMC4xMCBoYXMgZW51bWVyYWJsZSBub24taW5kZXggcHJvcGVydGllcyBvbiBidWZmZXJzLlxuICAgICAgICAgICAoaXNCdWZmICYmIChrZXkgPT0gJ29mZnNldCcgfHwga2V5ID09ICdwYXJlbnQnKSkgfHxcbiAgICAgICAgICAgLy8gUGhhbnRvbUpTIDIgaGFzIGVudW1lcmFibGUgbm9uLWluZGV4IHByb3BlcnRpZXMgb24gdHlwZWQgYXJyYXlzLlxuICAgICAgICAgICAoaXNUeXBlICYmIChrZXkgPT0gJ2J1ZmZlcicgfHwga2V5ID09ICdieXRlTGVuZ3RoJyB8fCBrZXkgPT0gJ2J5dGVPZmZzZXQnKSkgfHxcbiAgICAgICAgICAgLy8gU2tpcCBpbmRleCBwcm9wZXJ0aWVzLlxuICAgICAgICAgICBpc0luZGV4KGtleSwgbGVuZ3RoKVxuICAgICAgICApKSkge1xuICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhcnJheUxpa2VLZXlzO1xuIiwiLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy50aW1lc2Agd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzXG4gKiBvciBtYXggYXJyYXkgbGVuZ3RoIGNoZWNrcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtudW1iZXJ9IG4gVGhlIG51bWJlciBvZiB0aW1lcyB0byBpbnZva2UgYGl0ZXJhdGVlYC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHJlc3VsdHMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VUaW1lcyhuLCBpdGVyYXRlZSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIHJlc3VsdCA9IEFycmF5KG4pO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbikge1xuICAgIHJlc3VsdFtpbmRleF0gPSBpdGVyYXRlZShpbmRleCk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlVGltZXM7XG4iLCJ2YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL2lzT2JqZWN0JyksXG4gICAgaXNQcm90b3R5cGUgPSByZXF1aXJlKCcuL19pc1Byb3RvdHlwZScpLFxuICAgIG5hdGl2ZUtleXNJbiA9IHJlcXVpcmUoJy4vX25hdGl2ZUtleXNJbicpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmtleXNJbmAgd2hpY2ggZG9lc24ndCB0cmVhdCBzcGFyc2UgYXJyYXlzIGFzIGRlbnNlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICovXG5mdW5jdGlvbiBiYXNlS2V5c0luKG9iamVjdCkge1xuICBpZiAoIWlzT2JqZWN0KG9iamVjdCkpIHtcbiAgICByZXR1cm4gbmF0aXZlS2V5c0luKG9iamVjdCk7XG4gIH1cbiAgdmFyIGlzUHJvdG8gPSBpc1Byb3RvdHlwZShvYmplY3QpLFxuICAgICAgcmVzdWx0ID0gW107XG5cbiAgZm9yICh2YXIga2V5IGluIG9iamVjdCkge1xuICAgIGlmICghKGtleSA9PSAnY29uc3RydWN0b3InICYmIChpc1Byb3RvIHx8ICFoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSkpKSB7XG4gICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VLZXlzSW47XG4iLCIvKipcbiAqIFRoaXMgZnVuY3Rpb24gaXMgbGlrZVxuICogW2BPYmplY3Qua2V5c2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5rZXlzKVxuICogZXhjZXB0IHRoYXQgaXQgaW5jbHVkZXMgaW5oZXJpdGVkIGVudW1lcmFibGUgcHJvcGVydGllcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqL1xuZnVuY3Rpb24gbmF0aXZlS2V5c0luKG9iamVjdCkge1xuICB2YXIgcmVzdWx0ID0gW107XG4gIGlmIChvYmplY3QgIT0gbnVsbCkge1xuICAgIGZvciAodmFyIGtleSBpbiBPYmplY3Qob2JqZWN0KSkge1xuICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBuYXRpdmVLZXlzSW47XG4iLCJ2YXIgYmFzZVJlc3QgPSByZXF1aXJlKCcuL19iYXNlUmVzdCcpLFxuICAgIGlzSXRlcmF0ZWVDYWxsID0gcmVxdWlyZSgnLi9faXNJdGVyYXRlZUNhbGwnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gbGlrZSBgXy5hc3NpZ25gLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBhc3NpZ25lciBUaGUgZnVuY3Rpb24gdG8gYXNzaWduIHZhbHVlcy5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGFzc2lnbmVyIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBjcmVhdGVBc3NpZ25lcihhc3NpZ25lcikge1xuICByZXR1cm4gYmFzZVJlc3QoZnVuY3Rpb24ob2JqZWN0LCBzb3VyY2VzKSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIGxlbmd0aCA9IHNvdXJjZXMubGVuZ3RoLFxuICAgICAgICBjdXN0b21pemVyID0gbGVuZ3RoID4gMSA/IHNvdXJjZXNbbGVuZ3RoIC0gMV0gOiB1bmRlZmluZWQsXG4gICAgICAgIGd1YXJkID0gbGVuZ3RoID4gMiA/IHNvdXJjZXNbMl0gOiB1bmRlZmluZWQ7XG5cbiAgICBjdXN0b21pemVyID0gKGFzc2lnbmVyLmxlbmd0aCA+IDMgJiYgdHlwZW9mIGN1c3RvbWl6ZXIgPT0gJ2Z1bmN0aW9uJylcbiAgICAgID8gKGxlbmd0aC0tLCBjdXN0b21pemVyKVxuICAgICAgOiB1bmRlZmluZWQ7XG5cbiAgICBpZiAoZ3VhcmQgJiYgaXNJdGVyYXRlZUNhbGwoc291cmNlc1swXSwgc291cmNlc1sxXSwgZ3VhcmQpKSB7XG4gICAgICBjdXN0b21pemVyID0gbGVuZ3RoIDwgMyA/IHVuZGVmaW5lZCA6IGN1c3RvbWl6ZXI7XG4gICAgICBsZW5ndGggPSAxO1xuICAgIH1cbiAgICBvYmplY3QgPSBPYmplY3Qob2JqZWN0KTtcbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgdmFyIHNvdXJjZSA9IHNvdXJjZXNbaW5kZXhdO1xuICAgICAgaWYgKHNvdXJjZSkge1xuICAgICAgICBhc3NpZ25lcihvYmplY3QsIHNvdXJjZSwgaW5kZXgsIGN1c3RvbWl6ZXIpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb2JqZWN0O1xuICB9KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVBc3NpZ25lcjtcbiIsInZhciBpZGVudGl0eSA9IHJlcXVpcmUoJy4vaWRlbnRpdHknKSxcbiAgICBvdmVyUmVzdCA9IHJlcXVpcmUoJy4vX292ZXJSZXN0JyksXG4gICAgc2V0VG9TdHJpbmcgPSByZXF1aXJlKCcuL19zZXRUb1N0cmluZycpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnJlc3RgIHdoaWNoIGRvZXNuJ3QgdmFsaWRhdGUgb3IgY29lcmNlIGFyZ3VtZW50cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gYXBwbHkgYSByZXN0IHBhcmFtZXRlciB0by5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnQ9ZnVuYy5sZW5ndGgtMV0gVGhlIHN0YXJ0IHBvc2l0aW9uIG9mIHRoZSByZXN0IHBhcmFtZXRlci5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBiYXNlUmVzdChmdW5jLCBzdGFydCkge1xuICByZXR1cm4gc2V0VG9TdHJpbmcob3ZlclJlc3QoZnVuYywgc3RhcnQsIGlkZW50aXR5KSwgZnVuYyArICcnKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlUmVzdDtcbiIsIi8qKlxuICogQSBmYXN0ZXIgYWx0ZXJuYXRpdmUgdG8gYEZ1bmN0aW9uI2FwcGx5YCwgdGhpcyBmdW5jdGlvbiBpbnZva2VzIGBmdW5jYFxuICogd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgb2YgYHRoaXNBcmdgIGFuZCB0aGUgYXJndW1lbnRzIG9mIGBhcmdzYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gaW52b2tlLlxuICogQHBhcmFtIHsqfSB0aGlzQXJnIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgZnVuY2AuXG4gKiBAcGFyYW0ge0FycmF5fSBhcmdzIFRoZSBhcmd1bWVudHMgdG8gaW52b2tlIGBmdW5jYCB3aXRoLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc3VsdCBvZiBgZnVuY2AuXG4gKi9cbmZ1bmN0aW9uIGFwcGx5KGZ1bmMsIHRoaXNBcmcsIGFyZ3MpIHtcbiAgc3dpdGNoIChhcmdzLmxlbmd0aCkge1xuICAgIGNhc2UgMDogcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnKTtcbiAgICBjYXNlIDE6IHJldHVybiBmdW5jLmNhbGwodGhpc0FyZywgYXJnc1swXSk7XG4gICAgY2FzZSAyOiByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcsIGFyZ3NbMF0sIGFyZ3NbMV0pO1xuICAgIGNhc2UgMzogcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnLCBhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdKTtcbiAgfVxuICByZXR1cm4gZnVuYy5hcHBseSh0aGlzQXJnLCBhcmdzKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhcHBseTtcbiIsInZhciBjb25zdGFudCA9IHJlcXVpcmUoJy4vY29uc3RhbnQnKSxcbiAgICBkZWZpbmVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vX2RlZmluZVByb3BlcnR5JyksXG4gICAgaWRlbnRpdHkgPSByZXF1aXJlKCcuL2lkZW50aXR5Jyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYHNldFRvU3RyaW5nYCB3aXRob3V0IHN1cHBvcnQgZm9yIGhvdCBsb29wIHNob3J0aW5nLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBzdHJpbmcgVGhlIGB0b1N0cmluZ2AgcmVzdWx0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIGBmdW5jYC5cbiAqL1xudmFyIGJhc2VTZXRUb1N0cmluZyA9ICFkZWZpbmVQcm9wZXJ0eSA/IGlkZW50aXR5IDogZnVuY3Rpb24oZnVuYywgc3RyaW5nKSB7XG4gIHJldHVybiBkZWZpbmVQcm9wZXJ0eShmdW5jLCAndG9TdHJpbmcnLCB7XG4gICAgJ2NvbmZpZ3VyYWJsZSc6IHRydWUsXG4gICAgJ2VudW1lcmFibGUnOiBmYWxzZSxcbiAgICAndmFsdWUnOiBjb25zdGFudChzdHJpbmcpLFxuICAgICd3cml0YWJsZSc6IHRydWVcbiAgfSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VTZXRUb1N0cmluZztcbiIsIi8qKlxuICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBgdmFsdWVgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMi40LjBcbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byByZXR1cm4gZnJvbSB0aGUgbmV3IGZ1bmN0aW9uLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgY29uc3RhbnQgZnVuY3Rpb24uXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3RzID0gXy50aW1lcygyLCBfLmNvbnN0YW50KHsgJ2EnOiAxIH0pKTtcbiAqXG4gKiBjb25zb2xlLmxvZyhvYmplY3RzKTtcbiAqIC8vID0+IFt7ICdhJzogMSB9LCB7ICdhJzogMSB9XVxuICpcbiAqIGNvbnNvbGUubG9nKG9iamVjdHNbMF0gPT09IG9iamVjdHNbMV0pO1xuICogLy8gPT4gdHJ1ZVxuICovXG5mdW5jdGlvbiBjb25zdGFudCh2YWx1ZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNvbnN0YW50O1xuIiwiLyoqIFVzZWQgdG8gZGV0ZWN0IGhvdCBmdW5jdGlvbnMgYnkgbnVtYmVyIG9mIGNhbGxzIHdpdGhpbiBhIHNwYW4gb2YgbWlsbGlzZWNvbmRzLiAqL1xudmFyIEhPVF9DT1VOVCA9IDgwMCxcbiAgICBIT1RfU1BBTiA9IDE2O1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlTm93ID0gRGF0ZS5ub3c7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQnbGwgc2hvcnQgb3V0IGFuZCBpbnZva2UgYGlkZW50aXR5YCBpbnN0ZWFkXG4gKiBvZiBgZnVuY2Agd2hlbiBpdCdzIGNhbGxlZCBgSE9UX0NPVU5UYCBvciBtb3JlIHRpbWVzIGluIGBIT1RfU1BBTmBcbiAqIG1pbGxpc2Vjb25kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gcmVzdHJpY3QuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBzaG9ydGFibGUgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIHNob3J0T3V0KGZ1bmMpIHtcbiAgdmFyIGNvdW50ID0gMCxcbiAgICAgIGxhc3RDYWxsZWQgPSAwO1xuXG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgc3RhbXAgPSBuYXRpdmVOb3coKSxcbiAgICAgICAgcmVtYWluaW5nID0gSE9UX1NQQU4gLSAoc3RhbXAgLSBsYXN0Q2FsbGVkKTtcblxuICAgIGxhc3RDYWxsZWQgPSBzdGFtcDtcbiAgICBpZiAocmVtYWluaW5nID4gMCkge1xuICAgICAgaWYgKCsrY291bnQgPj0gSE9UX0NPVU5UKSB7XG4gICAgICAgIHJldHVybiBhcmd1bWVudHNbMF07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvdW50ID0gMDtcbiAgICB9XG4gICAgcmV0dXJuIGZ1bmMuYXBwbHkodW5kZWZpbmVkLCBhcmd1bWVudHMpO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNob3J0T3V0O1xuIiwidmFyIGVxID0gcmVxdWlyZSgnLi9lcScpLFxuICAgIGlzQXJyYXlMaWtlID0gcmVxdWlyZSgnLi9pc0FycmF5TGlrZScpLFxuICAgIGlzSW5kZXggPSByZXF1aXJlKCcuL19pc0luZGV4JyksXG4gICAgaXNPYmplY3QgPSByZXF1aXJlKCcuL2lzT2JqZWN0Jyk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIHRoZSBnaXZlbiBhcmd1bWVudHMgYXJlIGZyb20gYW4gaXRlcmF0ZWUgY2FsbC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgcG90ZW50aWFsIGl0ZXJhdGVlIHZhbHVlIGFyZ3VtZW50LlxuICogQHBhcmFtIHsqfSBpbmRleCBUaGUgcG90ZW50aWFsIGl0ZXJhdGVlIGluZGV4IG9yIGtleSBhcmd1bWVudC5cbiAqIEBwYXJhbSB7Kn0gb2JqZWN0IFRoZSBwb3RlbnRpYWwgaXRlcmF0ZWUgb2JqZWN0IGFyZ3VtZW50LlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBhcmd1bWVudHMgYXJlIGZyb20gYW4gaXRlcmF0ZWUgY2FsbCxcbiAqICBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzSXRlcmF0ZWVDYWxsKHZhbHVlLCBpbmRleCwgb2JqZWN0KSB7XG4gIGlmICghaXNPYmplY3Qob2JqZWN0KSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgdHlwZSA9IHR5cGVvZiBpbmRleDtcbiAgaWYgKHR5cGUgPT0gJ251bWJlcidcbiAgICAgICAgPyAoaXNBcnJheUxpa2Uob2JqZWN0KSAmJiBpc0luZGV4KGluZGV4LCBvYmplY3QubGVuZ3RoKSlcbiAgICAgICAgOiAodHlwZSA9PSAnc3RyaW5nJyAmJiBpbmRleCBpbiBvYmplY3QpXG4gICAgICApIHtcbiAgICByZXR1cm4gZXEob2JqZWN0W2luZGV4XSwgdmFsdWUpO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0l0ZXJhdGVlQ2FsbDtcbiIsIi8qXG4gKiB0eXBlZGVmcy5qc1xuICogTm9ybWFsaXplcyBicm93c2VyLXNwZWNpZmljIHByZWZpeGVzIGFuZCBwcm92aWRlIHNvbWUgYmFzaWMgcG9seWZpbGxzXG4gKi9cblxuaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgaWYgKCF3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKSB7XG4gICAgICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHdpbmRvdy53ZWJraXRSZXF1ZXN0QW5pbWF0aW9uRnJhbWVcbiAgICAgICAgICAgICAgICB8fCB3aW5kb3cubW96UmVxdWVzdEFuaW1hdGlvbkZyYW1lXG4gICAgICAgICAgICAgICAgfHwgd2luZG93Lm9SZXF1ZXN0QW5pbWF0aW9uRnJhbWVcbiAgICAgICAgICAgICAgICB8fCB3aW5kb3cubXNSZXF1ZXN0QW5pbWF0aW9uRnJhbWVcbiAgICAgICAgICAgICAgICB8fCBmdW5jdGlvbiAoLyogZnVuY3Rpb24gRnJhbWVSZXF1ZXN0Q2FsbGJhY2sgKi8gY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgd2luZG93LnNldFRpbWVvdXQoY2FsbGJhY2ssIDEwMDAgLyA2MCk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgfSgpKTtcbiAgICB9XG59XG5cbmlmICh0eXBlb2YgTWF0aC5pbXVsICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgLyogZXNsaW50LWRpc2FibGUgbm8tYml0d2lzZSAqL1xuICAgIE1hdGguaW11bCA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIGNvbnN0IGFoID0gKGEgPj4+IDE2KSAmIDB4ZmZmZjtcbiAgICAgICAgY29uc3QgYWwgPSBhICYgMHhmZmZmO1xuICAgICAgICBjb25zdCBiaCA9IChiID4+PiAxNikgJiAweGZmZmY7XG4gICAgICAgIGNvbnN0IGJsID0gYiAmIDB4ZmZmZjtcbiAgICAgICAgLy8gdGhlIHNoaWZ0IGJ5IDAgZml4ZXMgdGhlIHNpZ24gb24gdGhlIGhpZ2ggcGFydFxuICAgICAgICAvLyB0aGUgZmluYWwgfDAgY29udmVydHMgdGhlIHVuc2lnbmVkIHZhbHVlIGludG8gYSBzaWduZWQgdmFsdWVcbiAgICAgICAgcmV0dXJuICgoYWwgKiBibCkgKyAoKChhaCAqIGJsICsgYWwgKiBiaCkgPDwgMTYpID4+PiAwKSB8IDApO1xuICAgIH07XG4gICAgLyogZXNsaW50LWVuYWJsZSBuby1iaXR3aXNlICovXG59XG5cbmlmICh0eXBlb2YgT2JqZWN0LmFzc2lnbiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIE9iamVjdC5hc3NpZ24gPSBmdW5jdGlvbiAodGFyZ2V0KSB7IC8vIC5sZW5ndGggb2YgZnVuY3Rpb24gaXMgMlxuXG4ndXNlIHN0cmljdCc7XG5cbiAgICAgICAgaWYgKHRhcmdldCA9PT0gbnVsbCkgeyAvLyBUeXBlRXJyb3IgaWYgdW5kZWZpbmVkIG9yIG51bGxcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBjb252ZXJ0IHVuZGVmaW5lZCBvciBudWxsIHRvIG9iamVjdCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgdG8gPSBPYmplY3QodGFyZ2V0KTtcblxuICAgICAgICBmb3IgKGxldCBpbmRleCA9IDE7IGluZGV4IDwgYXJndW1lbnRzLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHByZWZlci1yZXN0LXBhcmFtc1xuICAgICAgICAgICAgY29uc3QgbmV4dFNvdXJjZSA9IGFyZ3VtZW50c1tpbmRleF07XG5cbiAgICAgICAgICAgIGlmIChuZXh0U291cmNlICE9PSBudWxsKSB7IC8vIFNraXAgb3ZlciBpZiB1bmRlZmluZWQgb3IgbnVsbFxuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZXN0cmljdGVkLXN5bnRheFxuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgbmV4dEtleSBpbiBuZXh0U291cmNlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEF2b2lkIGJ1Z3Mgd2hlbiBoYXNPd25Qcm9wZXJ0eSBpcyBzaGFkb3dlZFxuICAgICAgICAgICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG5leHRTb3VyY2UsIG5leHRLZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0b1tuZXh0S2V5XSA9IG5leHRTb3VyY2VbbmV4dEtleV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRvO1xuICAgIH07XG59XG4iLCJmdW5jdGlvbiBfYXJyYXlXaXRoSG9sZXMoYXJyKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGFycikpIHJldHVybiBhcnI7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2FycmF5V2l0aEhvbGVzLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZSwgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHM7IiwiZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheUxpbWl0KGFyciwgaSkge1xuICB2YXIgX2kgPSBhcnIgPT0gbnVsbCA/IG51bGwgOiB0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIGFycltTeW1ib2wuaXRlcmF0b3JdIHx8IGFycltcIkBAaXRlcmF0b3JcIl07XG5cbiAgaWYgKF9pID09IG51bGwpIHJldHVybjtcbiAgdmFyIF9hcnIgPSBbXTtcbiAgdmFyIF9uID0gdHJ1ZTtcbiAgdmFyIF9kID0gZmFsc2U7XG5cbiAgdmFyIF9zLCBfZTtcblxuICB0cnkge1xuICAgIGZvciAoX2kgPSBfaS5jYWxsKGFycik7ICEoX24gPSAoX3MgPSBfaS5uZXh0KCkpLmRvbmUpOyBfbiA9IHRydWUpIHtcbiAgICAgIF9hcnIucHVzaChfcy52YWx1ZSk7XG5cbiAgICAgIGlmIChpICYmIF9hcnIubGVuZ3RoID09PSBpKSBicmVhaztcbiAgICB9XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIF9kID0gdHJ1ZTtcbiAgICBfZSA9IGVycjtcbiAgfSBmaW5hbGx5IHtcbiAgICB0cnkge1xuICAgICAgaWYgKCFfbiAmJiBfaVtcInJldHVyblwiXSAhPSBudWxsKSBfaVtcInJldHVyblwiXSgpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBpZiAoX2QpIHRocm93IF9lO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBfYXJyO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9pdGVyYWJsZVRvQXJyYXlMaW1pdCwgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzOyIsImZ1bmN0aW9uIF9ub25JdGVyYWJsZVJlc3QoKSB7XG4gIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX25vbkl0ZXJhYmxlUmVzdCwgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzOyIsIm1vZHVsZS5leHBvcnRzID0gY2xvbmVcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IHZlYzIgaW5pdGlhbGl6ZWQgd2l0aCB2YWx1ZXMgZnJvbSBhbiBleGlzdGluZyB2ZWN0b3JcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdmVjdG9yIHRvIGNsb25lXG4gKiBAcmV0dXJucyB7dmVjMn0gYSBuZXcgMkQgdmVjdG9yXG4gKi9cbmZ1bmN0aW9uIGNsb25lKGEpIHtcbiAgICB2YXIgb3V0ID0gbmV3IEZsb2F0MzJBcnJheSgyKVxuICAgIG91dFswXSA9IGFbMF1cbiAgICBvdXRbMV0gPSBhWzFdXG4gICAgcmV0dXJuIG91dFxufSIsIm1vZHVsZS5leHBvcnRzID0gZnJvbVZhbHVlc1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgdmVjMiBpbml0aWFsaXplZCB3aXRoIHRoZSBnaXZlbiB2YWx1ZXNcbiAqXG4gKiBAcGFyYW0ge051bWJlcn0geCBYIGNvbXBvbmVudFxuICogQHBhcmFtIHtOdW1iZXJ9IHkgWSBjb21wb25lbnRcbiAqIEByZXR1cm5zIHt2ZWMyfSBhIG5ldyAyRCB2ZWN0b3JcbiAqL1xuZnVuY3Rpb24gZnJvbVZhbHVlcyh4LCB5KSB7XG4gICAgdmFyIG91dCA9IG5ldyBGbG9hdDMyQXJyYXkoMilcbiAgICBvdXRbMF0gPSB4XG4gICAgb3V0WzFdID0geVxuICAgIHJldHVybiBvdXRcbn0iLCJtb2R1bGUuZXhwb3J0cyA9IGNvcHlcblxuLyoqXG4gKiBDb3B5IHRoZSB2YWx1ZXMgZnJvbSBvbmUgdmVjMiB0byBhbm90aGVyXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjMn0gYSB0aGUgc291cmNlIHZlY3RvclxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG5mdW5jdGlvbiBjb3B5KG91dCwgYSkge1xuICAgIG91dFswXSA9IGFbMF1cbiAgICBvdXRbMV0gPSBhWzFdXG4gICAgcmV0dXJuIG91dFxufSIsIm1vZHVsZS5leHBvcnRzID0gc2V0XG5cbi8qKlxuICogU2V0IHRoZSBjb21wb25lbnRzIG9mIGEgdmVjMiB0byB0aGUgZ2l2ZW4gdmFsdWVzXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7TnVtYmVyfSB4IFggY29tcG9uZW50XG4gKiBAcGFyYW0ge051bWJlcn0geSBZIGNvbXBvbmVudFxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG5mdW5jdGlvbiBzZXQob3V0LCB4LCB5KSB7XG4gICAgb3V0WzBdID0geFxuICAgIG91dFsxXSA9IHlcbiAgICByZXR1cm4gb3V0XG59IiwibW9kdWxlLmV4cG9ydHMgPSBlcXVhbHNcblxudmFyIEVQU0lMT04gPSByZXF1aXJlKCcuL2Vwc2lsb24nKVxuXG4vKipcbiAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIHZlY3RvcnMgaGF2ZSBhcHByb3hpbWF0ZWx5IHRoZSBzYW1lIGVsZW1lbnRzIGluIHRoZSBzYW1lIHBvc2l0aW9uLlxuICpcbiAqIEBwYXJhbSB7dmVjMn0gYSBUaGUgZmlyc3QgdmVjdG9yLlxuICogQHBhcmFtIHt2ZWMyfSBiIFRoZSBzZWNvbmQgdmVjdG9yLlxuICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWYgdGhlIHZlY3RvcnMgYXJlIGVxdWFsLCBmYWxzZSBvdGhlcndpc2UuXG4gKi9cbmZ1bmN0aW9uIGVxdWFscyhhLCBiKSB7XG4gIHZhciBhMCA9IGFbMF1cbiAgdmFyIGExID0gYVsxXVxuICB2YXIgYjAgPSBiWzBdXG4gIHZhciBiMSA9IGJbMV1cbiAgcmV0dXJuIChNYXRoLmFicyhhMCAtIGIwKSA8PSBFUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMCksIE1hdGguYWJzKGIwKSkgJiZcbiAgICAgICAgICBNYXRoLmFicyhhMSAtIGIxKSA8PSBFUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMSksIE1hdGguYWJzKGIxKSkpXG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGV4YWN0RXF1YWxzXG5cbi8qKlxuICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgdmVjdG9ycyBleGFjdGx5IGhhdmUgdGhlIHNhbWUgZWxlbWVudHMgaW4gdGhlIHNhbWUgcG9zaXRpb24gKHdoZW4gY29tcGFyZWQgd2l0aCA9PT0pXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBhIFRoZSBmaXJzdCB2ZWN0b3IuXG4gKiBAcGFyYW0ge3ZlYzJ9IGIgVGhlIHNlY29uZCB2ZWN0b3IuXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gVHJ1ZSBpZiB0aGUgdmVjdG9ycyBhcmUgZXF1YWwsIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xuZnVuY3Rpb24gZXhhY3RFcXVhbHMoYSwgYikge1xuICByZXR1cm4gYVswXSA9PT0gYlswXSAmJiBhWzFdID09PSBiWzFdXG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGFkZFxuXG4vKipcbiAqIEFkZHMgdHdvIHZlYzInc1xuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjMn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xuZnVuY3Rpb24gYWRkKG91dCwgYSwgYikge1xuICAgIG91dFswXSA9IGFbMF0gKyBiWzBdXG4gICAgb3V0WzFdID0gYVsxXSArIGJbMV1cbiAgICByZXR1cm4gb3V0XG59IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL3N1YnRyYWN0JylcbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9tdWx0aXBseScpXG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vZGl2aWRlJylcbiIsIm1vZHVsZS5leHBvcnRzID0gaW52ZXJzZVxuXG4vKipcbiAqIFJldHVybnMgdGhlIGludmVyc2Ugb2YgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWMyXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjMn0gYSB2ZWN0b3IgdG8gaW52ZXJ0XG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbmZ1bmN0aW9uIGludmVyc2Uob3V0LCBhKSB7XG4gIG91dFswXSA9IDEuMCAvIGFbMF1cbiAgb3V0WzFdID0gMS4wIC8gYVsxXVxuICByZXR1cm4gb3V0XG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IG1pblxuXG4vKipcbiAqIFJldHVybnMgdGhlIG1pbmltdW0gb2YgdHdvIHZlYzInc1xuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjMn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xuZnVuY3Rpb24gbWluKG91dCwgYSwgYikge1xuICAgIG91dFswXSA9IE1hdGgubWluKGFbMF0sIGJbMF0pXG4gICAgb3V0WzFdID0gTWF0aC5taW4oYVsxXSwgYlsxXSlcbiAgICByZXR1cm4gb3V0XG59IiwibW9kdWxlLmV4cG9ydHMgPSBtYXhcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBtYXhpbXVtIG9mIHR3byB2ZWMyJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbmZ1bmN0aW9uIG1heChvdXQsIGEsIGIpIHtcbiAgICBvdXRbMF0gPSBNYXRoLm1heChhWzBdLCBiWzBdKVxuICAgIG91dFsxXSA9IE1hdGgubWF4KGFbMV0sIGJbMV0pXG4gICAgcmV0dXJuIG91dFxufSIsIm1vZHVsZS5leHBvcnRzID0gcm90YXRlXG5cbi8qKlxuICogUm90YXRlcyBhIHZlYzIgYnkgYW4gYW5nbGVcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSB2ZWN0b3IgdG8gcm90YXRlXG4gKiBAcGFyYW0ge051bWJlcn0gYW5nbGUgdGhlIGFuZ2xlIG9mIHJvdGF0aW9uIChpbiByYWRpYW5zKVxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG5mdW5jdGlvbiByb3RhdGUob3V0LCBhLCBhbmdsZSkge1xuICB2YXIgYyA9IE1hdGguY29zKGFuZ2xlKSxcbiAgICAgIHMgPSBNYXRoLnNpbihhbmdsZSlcbiAgdmFyIHggPSBhWzBdLFxuICAgICAgeSA9IGFbMV1cblxuICBvdXRbMF0gPSB4ICogYyAtIHkgKiBzXG4gIG91dFsxXSA9IHggKiBzICsgeSAqIGNcblxuICByZXR1cm4gb3V0XG59XG5cbiIsIm1vZHVsZS5leHBvcnRzID0gZmxvb3JcblxuLyoqXG4gKiBNYXRoLmZsb29yIHRoZSBjb21wb25lbnRzIG9mIGEgdmVjMlxuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdmVjdG9yIHRvIGZsb29yXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbmZ1bmN0aW9uIGZsb29yKG91dCwgYSkge1xuICBvdXRbMF0gPSBNYXRoLmZsb29yKGFbMF0pXG4gIG91dFsxXSA9IE1hdGguZmxvb3IoYVsxXSlcbiAgcmV0dXJuIG91dFxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBjZWlsXG5cbi8qKlxuICogTWF0aC5jZWlsIHRoZSBjb21wb25lbnRzIG9mIGEgdmVjMlxuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdmVjdG9yIHRvIGNlaWxcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xuZnVuY3Rpb24gY2VpbChvdXQsIGEpIHtcbiAgb3V0WzBdID0gTWF0aC5jZWlsKGFbMF0pXG4gIG91dFsxXSA9IE1hdGguY2VpbChhWzFdKVxuICByZXR1cm4gb3V0XG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJvdW5kXG5cbi8qKlxuICogTWF0aC5yb3VuZCB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzJcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIHZlY3RvciB0byByb3VuZFxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG5mdW5jdGlvbiByb3VuZChvdXQsIGEpIHtcbiAgb3V0WzBdID0gTWF0aC5yb3VuZChhWzBdKVxuICBvdXRbMV0gPSBNYXRoLnJvdW5kKGFbMV0pXG4gIHJldHVybiBvdXRcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gc2NhbGVcblxuLyoqXG4gKiBTY2FsZXMgYSB2ZWMyIGJ5IGEgc2NhbGFyIG51bWJlclxuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdGhlIHZlY3RvciB0byBzY2FsZVxuICogQHBhcmFtIHtOdW1iZXJ9IGIgYW1vdW50IHRvIHNjYWxlIHRoZSB2ZWN0b3IgYnlcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xuZnVuY3Rpb24gc2NhbGUob3V0LCBhLCBiKSB7XG4gICAgb3V0WzBdID0gYVswXSAqIGJcbiAgICBvdXRbMV0gPSBhWzFdICogYlxuICAgIHJldHVybiBvdXRcbn0iLCJtb2R1bGUuZXhwb3J0cyA9IHNjYWxlQW5kQWRkXG5cbi8qKlxuICogQWRkcyB0d28gdmVjMidzIGFmdGVyIHNjYWxpbmcgdGhlIHNlY29uZCBvcGVyYW5kIGJ5IGEgc2NhbGFyIHZhbHVlXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjMn0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHBhcmFtIHtOdW1iZXJ9IHNjYWxlIHRoZSBhbW91bnQgdG8gc2NhbGUgYiBieSBiZWZvcmUgYWRkaW5nXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbmZ1bmN0aW9uIHNjYWxlQW5kQWRkKG91dCwgYSwgYiwgc2NhbGUpIHtcbiAgICBvdXRbMF0gPSBhWzBdICsgKGJbMF0gKiBzY2FsZSlcbiAgICBvdXRbMV0gPSBhWzFdICsgKGJbMV0gKiBzY2FsZSlcbiAgICByZXR1cm4gb3V0XG59IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Rpc3RhbmNlJylcbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9zcXVhcmVkRGlzdGFuY2UnKVxuIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2xlbmd0aCcpXG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vc3F1YXJlZExlbmd0aCcpXG4iLCJtb2R1bGUuZXhwb3J0cyA9IG5lZ2F0ZVxuXG4vKipcbiAqIE5lZ2F0ZXMgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWMyXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjMn0gYSB2ZWN0b3IgdG8gbmVnYXRlXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbmZ1bmN0aW9uIG5lZ2F0ZShvdXQsIGEpIHtcbiAgICBvdXRbMF0gPSAtYVswXVxuICAgIG91dFsxXSA9IC1hWzFdXG4gICAgcmV0dXJuIG91dFxufSIsIm1vZHVsZS5leHBvcnRzID0gbm9ybWFsaXplXG5cbi8qKlxuICogTm9ybWFsaXplIGEgdmVjMlxuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdmVjdG9yIHRvIG5vcm1hbGl6ZVxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG5mdW5jdGlvbiBub3JtYWxpemUob3V0LCBhKSB7XG4gICAgdmFyIHggPSBhWzBdLFxuICAgICAgICB5ID0gYVsxXVxuICAgIHZhciBsZW4gPSB4KnggKyB5KnlcbiAgICBpZiAobGVuID4gMCkge1xuICAgICAgICAvL1RPRE86IGV2YWx1YXRlIHVzZSBvZiBnbG1faW52c3FydCBoZXJlP1xuICAgICAgICBsZW4gPSAxIC8gTWF0aC5zcXJ0KGxlbilcbiAgICAgICAgb3V0WzBdID0gYVswXSAqIGxlblxuICAgICAgICBvdXRbMV0gPSBhWzFdICogbGVuXG4gICAgfVxuICAgIHJldHVybiBvdXRcbn0iLCJtb2R1bGUuZXhwb3J0cyA9IGRvdFxuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGRvdCBwcm9kdWN0IG9mIHR3byB2ZWMyJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjMn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGRvdCBwcm9kdWN0IG9mIGEgYW5kIGJcbiAqL1xuZnVuY3Rpb24gZG90KGEsIGIpIHtcbiAgICByZXR1cm4gYVswXSAqIGJbMF0gKyBhWzFdICogYlsxXVxufSIsIm1vZHVsZS5leHBvcnRzID0gY3Jvc3NcblxuLyoqXG4gKiBDb21wdXRlcyB0aGUgY3Jvc3MgcHJvZHVjdCBvZiB0d28gdmVjMidzXG4gKiBOb3RlIHRoYXQgdGhlIGNyb3NzIHByb2R1Y3QgbXVzdCBieSBkZWZpbml0aW9uIHByb2R1Y2UgYSAzRCB2ZWN0b3JcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbmZ1bmN0aW9uIGNyb3NzKG91dCwgYSwgYikge1xuICAgIHZhciB6ID0gYVswXSAqIGJbMV0gLSBhWzFdICogYlswXVxuICAgIG91dFswXSA9IG91dFsxXSA9IDBcbiAgICBvdXRbMl0gPSB6XG4gICAgcmV0dXJuIG91dFxufSIsIm1vZHVsZS5leHBvcnRzID0gbGVycFxuXG4vKipcbiAqIFBlcmZvcm1zIGEgbGluZWFyIGludGVycG9sYXRpb24gYmV0d2VlbiB0d28gdmVjMidzXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjMn0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHBhcmFtIHtOdW1iZXJ9IHQgaW50ZXJwb2xhdGlvbiBhbW91bnQgYmV0d2VlbiB0aGUgdHdvIGlucHV0c1xuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG5mdW5jdGlvbiBsZXJwKG91dCwgYSwgYiwgdCkge1xuICAgIHZhciBheCA9IGFbMF0sXG4gICAgICAgIGF5ID0gYVsxXVxuICAgIG91dFswXSA9IGF4ICsgdCAqIChiWzBdIC0gYXgpXG4gICAgb3V0WzFdID0gYXkgKyB0ICogKGJbMV0gLSBheSlcbiAgICByZXR1cm4gb3V0XG59IiwibW9kdWxlLmV4cG9ydHMgPSByYW5kb21cblxuLyoqXG4gKiBHZW5lcmF0ZXMgYSByYW5kb20gdmVjdG9yIHdpdGggdGhlIGdpdmVuIHNjYWxlXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7TnVtYmVyfSBbc2NhbGVdIExlbmd0aCBvZiB0aGUgcmVzdWx0aW5nIHZlY3Rvci4gSWYgb21taXR0ZWQsIGEgdW5pdCB2ZWN0b3Igd2lsbCBiZSByZXR1cm5lZFxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG5mdW5jdGlvbiByYW5kb20ob3V0LCBzY2FsZSkge1xuICAgIHNjYWxlID0gc2NhbGUgfHwgMS4wXG4gICAgdmFyIHIgPSBNYXRoLnJhbmRvbSgpICogMi4wICogTWF0aC5QSVxuICAgIG91dFswXSA9IE1hdGguY29zKHIpICogc2NhbGVcbiAgICBvdXRbMV0gPSBNYXRoLnNpbihyKSAqIHNjYWxlXG4gICAgcmV0dXJuIG91dFxufSIsIm1vZHVsZS5leHBvcnRzID0gdHJhbnNmb3JtTWF0MlxuXG4vKipcbiAqIFRyYW5zZm9ybXMgdGhlIHZlYzIgd2l0aCBhIG1hdDJcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSB2ZWN0b3IgdG8gdHJhbnNmb3JtXG4gKiBAcGFyYW0ge21hdDJ9IG0gbWF0cml4IHRvIHRyYW5zZm9ybSB3aXRoXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbmZ1bmN0aW9uIHRyYW5zZm9ybU1hdDIob3V0LCBhLCBtKSB7XG4gICAgdmFyIHggPSBhWzBdLFxuICAgICAgICB5ID0gYVsxXVxuICAgIG91dFswXSA9IG1bMF0gKiB4ICsgbVsyXSAqIHlcbiAgICBvdXRbMV0gPSBtWzFdICogeCArIG1bM10gKiB5XG4gICAgcmV0dXJuIG91dFxufSIsIm1vZHVsZS5leHBvcnRzID0gdHJhbnNmb3JtTWF0MmRcblxuLyoqXG4gKiBUcmFuc2Zvcm1zIHRoZSB2ZWMyIHdpdGggYSBtYXQyZFxuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdGhlIHZlY3RvciB0byB0cmFuc2Zvcm1cbiAqIEBwYXJhbSB7bWF0MmR9IG0gbWF0cml4IHRvIHRyYW5zZm9ybSB3aXRoXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbmZ1bmN0aW9uIHRyYW5zZm9ybU1hdDJkKG91dCwgYSwgbSkge1xuICAgIHZhciB4ID0gYVswXSxcbiAgICAgICAgeSA9IGFbMV1cbiAgICBvdXRbMF0gPSBtWzBdICogeCArIG1bMl0gKiB5ICsgbVs0XVxuICAgIG91dFsxXSA9IG1bMV0gKiB4ICsgbVszXSAqIHkgKyBtWzVdXG4gICAgcmV0dXJuIG91dFxufSIsIm1vZHVsZS5leHBvcnRzID0gdHJhbnNmb3JtTWF0M1xuXG4vKipcbiAqIFRyYW5zZm9ybXMgdGhlIHZlYzIgd2l0aCBhIG1hdDNcbiAqIDNyZCB2ZWN0b3IgY29tcG9uZW50IGlzIGltcGxpY2l0bHkgJzEnXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjMn0gYSB0aGUgdmVjdG9yIHRvIHRyYW5zZm9ybVxuICogQHBhcmFtIHttYXQzfSBtIG1hdHJpeCB0byB0cmFuc2Zvcm0gd2l0aFxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG5mdW5jdGlvbiB0cmFuc2Zvcm1NYXQzKG91dCwgYSwgbSkge1xuICAgIHZhciB4ID0gYVswXSxcbiAgICAgICAgeSA9IGFbMV1cbiAgICBvdXRbMF0gPSBtWzBdICogeCArIG1bM10gKiB5ICsgbVs2XVxuICAgIG91dFsxXSA9IG1bMV0gKiB4ICsgbVs0XSAqIHkgKyBtWzddXG4gICAgcmV0dXJuIG91dFxufSIsIm1vZHVsZS5leHBvcnRzID0gdHJhbnNmb3JtTWF0NFxuXG4vKipcbiAqIFRyYW5zZm9ybXMgdGhlIHZlYzIgd2l0aCBhIG1hdDRcbiAqIDNyZCB2ZWN0b3IgY29tcG9uZW50IGlzIGltcGxpY2l0bHkgJzAnXG4gKiA0dGggdmVjdG9yIGNvbXBvbmVudCBpcyBpbXBsaWNpdGx5ICcxJ1xuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdGhlIHZlY3RvciB0byB0cmFuc2Zvcm1cbiAqIEBwYXJhbSB7bWF0NH0gbSBtYXRyaXggdG8gdHJhbnNmb3JtIHdpdGhcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xuZnVuY3Rpb24gdHJhbnNmb3JtTWF0NChvdXQsIGEsIG0pIHtcbiAgICB2YXIgeCA9IGFbMF0sIFxuICAgICAgICB5ID0gYVsxXVxuICAgIG91dFswXSA9IG1bMF0gKiB4ICsgbVs0XSAqIHkgKyBtWzEyXVxuICAgIG91dFsxXSA9IG1bMV0gKiB4ICsgbVs1XSAqIHkgKyBtWzEzXVxuICAgIHJldHVybiBvdXRcbn0iLCJtb2R1bGUuZXhwb3J0cyA9IGZvckVhY2hcblxudmFyIHZlYyA9IHJlcXVpcmUoJy4vY3JlYXRlJykoKVxuXG4vKipcbiAqIFBlcmZvcm0gc29tZSBvcGVyYXRpb24gb3ZlciBhbiBhcnJheSBvZiB2ZWMycy5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBhIHRoZSBhcnJheSBvZiB2ZWN0b3JzIHRvIGl0ZXJhdGUgb3ZlclxuICogQHBhcmFtIHtOdW1iZXJ9IHN0cmlkZSBOdW1iZXIgb2YgZWxlbWVudHMgYmV0d2VlbiB0aGUgc3RhcnQgb2YgZWFjaCB2ZWMyLiBJZiAwIGFzc3VtZXMgdGlnaHRseSBwYWNrZWRcbiAqIEBwYXJhbSB7TnVtYmVyfSBvZmZzZXQgTnVtYmVyIG9mIGVsZW1lbnRzIHRvIHNraXAgYXQgdGhlIGJlZ2lubmluZyBvZiB0aGUgYXJyYXlcbiAqIEBwYXJhbSB7TnVtYmVyfSBjb3VudCBOdW1iZXIgb2YgdmVjMnMgdG8gaXRlcmF0ZSBvdmVyLiBJZiAwIGl0ZXJhdGVzIG92ZXIgZW50aXJlIGFycmF5XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBGdW5jdGlvbiB0byBjYWxsIGZvciBlYWNoIHZlY3RvciBpbiB0aGUgYXJyYXlcbiAqIEBwYXJhbSB7T2JqZWN0fSBbYXJnXSBhZGRpdGlvbmFsIGFyZ3VtZW50IHRvIHBhc3MgdG8gZm5cbiAqIEByZXR1cm5zIHtBcnJheX0gYVxuICogQGZ1bmN0aW9uXG4gKi9cbmZ1bmN0aW9uIGZvckVhY2goYSwgc3RyaWRlLCBvZmZzZXQsIGNvdW50LCBmbiwgYXJnKSB7XG4gICAgdmFyIGksIGxcbiAgICBpZighc3RyaWRlKSB7XG4gICAgICAgIHN0cmlkZSA9IDJcbiAgICB9XG5cbiAgICBpZighb2Zmc2V0KSB7XG4gICAgICAgIG9mZnNldCA9IDBcbiAgICB9XG4gICAgXG4gICAgaWYoY291bnQpIHtcbiAgICAgICAgbCA9IE1hdGgubWluKChjb3VudCAqIHN0cmlkZSkgKyBvZmZzZXQsIGEubGVuZ3RoKVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGwgPSBhLmxlbmd0aFxuICAgIH1cblxuICAgIGZvcihpID0gb2Zmc2V0OyBpIDwgbDsgaSArPSBzdHJpZGUpIHtcbiAgICAgICAgdmVjWzBdID0gYVtpXVxuICAgICAgICB2ZWNbMV0gPSBhW2krMV1cbiAgICAgICAgZm4odmVjLCB2ZWMsIGFyZylcbiAgICAgICAgYVtpXSA9IHZlY1swXVxuICAgICAgICBhW2krMV0gPSB2ZWNbMV1cbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIGFcbn0iLCJtb2R1bGUuZXhwb3J0cyA9IGxpbWl0O1xuXG4vKipcbiAqIExpbWl0IHRoZSBtYWduaXR1ZGUgb2YgdGhpcyB2ZWN0b3IgdG8gdGhlIHZhbHVlIHVzZWQgZm9yIHRoZSBgbWF4YFxuICogcGFyYW1ldGVyLlxuICpcbiAqIEBwYXJhbSAge3ZlYzJ9IHRoZSB2ZWN0b3IgdG8gbGltaXRcbiAqIEBwYXJhbSAge051bWJlcn0gbWF4IHRoZSBtYXhpbXVtIG1hZ25pdHVkZSBmb3IgdGhlIHZlY3RvclxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG5mdW5jdGlvbiBsaW1pdChvdXQsIGEsIG1heCkge1xuICB2YXIgbVNxID0gYVswXSAqIGFbMF0gKyBhWzFdICogYVsxXTtcblxuICBpZiAobVNxID4gbWF4ICogbWF4KSB7XG4gICAgdmFyIG4gPSBNYXRoLnNxcnQobVNxKTtcbiAgICBvdXRbMF0gPSBhWzBdIC8gbiAqIG1heDtcbiAgICBvdXRbMV0gPSBhWzFdIC8gbiAqIG1heDtcbiAgfSBlbHNlIHtcbiAgICBvdXRbMF0gPSBhWzBdO1xuICAgIG91dFsxXSA9IGFbMV07XG4gIH1cblxuICByZXR1cm4gb3V0O1xufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBjbG9uZTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IHZlYzMgaW5pdGlhbGl6ZWQgd2l0aCB2YWx1ZXMgZnJvbSBhbiBleGlzdGluZyB2ZWN0b3JcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdmVjdG9yIHRvIGNsb25lXG4gKiBAcmV0dXJucyB7dmVjM30gYSBuZXcgM0QgdmVjdG9yXG4gKi9cbmZ1bmN0aW9uIGNsb25lKGEpIHtcbiAgICB2YXIgb3V0ID0gbmV3IEZsb2F0MzJBcnJheSgzKVxuICAgIG91dFswXSA9IGFbMF1cbiAgICBvdXRbMV0gPSBhWzFdXG4gICAgb3V0WzJdID0gYVsyXVxuICAgIHJldHVybiBvdXRcbn0iLCJtb2R1bGUuZXhwb3J0cyA9IGFuZ2xlXG5cbnZhciBmcm9tVmFsdWVzID0gcmVxdWlyZSgnLi9mcm9tVmFsdWVzJylcbnZhciBub3JtYWxpemUgPSByZXF1aXJlKCcuL25vcm1hbGl6ZScpXG52YXIgZG90ID0gcmVxdWlyZSgnLi9kb3QnKVxuXG4vKipcbiAqIEdldCB0aGUgYW5nbGUgYmV0d2VlbiB0d28gM0QgdmVjdG9yc1xuICogQHBhcmFtIHt2ZWMzfSBhIFRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzN9IGIgVGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgYW5nbGUgaW4gcmFkaWFuc1xuICovXG5mdW5jdGlvbiBhbmdsZShhLCBiKSB7XG4gICAgdmFyIHRlbXBBID0gZnJvbVZhbHVlcyhhWzBdLCBhWzFdLCBhWzJdKVxuICAgIHZhciB0ZW1wQiA9IGZyb21WYWx1ZXMoYlswXSwgYlsxXSwgYlsyXSlcbiBcbiAgICBub3JtYWxpemUodGVtcEEsIHRlbXBBKVxuICAgIG5vcm1hbGl6ZSh0ZW1wQiwgdGVtcEIpXG4gXG4gICAgdmFyIGNvc2luZSA9IGRvdCh0ZW1wQSwgdGVtcEIpXG5cbiAgICBpZihjb3NpbmUgPiAxLjApe1xuICAgICAgICByZXR1cm4gMFxuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBNYXRoLmFjb3MoY29zaW5lKVxuICAgIH0gICAgIFxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBjb3B5O1xuXG4vKipcbiAqIENvcHkgdGhlIHZhbHVlcyBmcm9tIG9uZSB2ZWMzIHRvIGFub3RoZXJcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSBzb3VyY2UgdmVjdG9yXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbmZ1bmN0aW9uIGNvcHkob3V0LCBhKSB7XG4gICAgb3V0WzBdID0gYVswXVxuICAgIG91dFsxXSA9IGFbMV1cbiAgICBvdXRbMl0gPSBhWzJdXG4gICAgcmV0dXJuIG91dFxufSIsIm1vZHVsZS5leHBvcnRzID0gc2V0O1xuXG4vKipcbiAqIFNldCB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzMgdG8gdGhlIGdpdmVuIHZhbHVlc1xuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge051bWJlcn0geCBYIGNvbXBvbmVudFxuICogQHBhcmFtIHtOdW1iZXJ9IHkgWSBjb21wb25lbnRcbiAqIEBwYXJhbSB7TnVtYmVyfSB6IFogY29tcG9uZW50XG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbmZ1bmN0aW9uIHNldChvdXQsIHgsIHksIHopIHtcbiAgICBvdXRbMF0gPSB4XG4gICAgb3V0WzFdID0geVxuICAgIG91dFsyXSA9IHpcbiAgICByZXR1cm4gb3V0XG59IiwibW9kdWxlLmV4cG9ydHMgPSBlcXVhbHNcblxudmFyIEVQU0lMT04gPSByZXF1aXJlKCcuL2Vwc2lsb24nKVxuXG4vKipcbiAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIHZlY3RvcnMgaGF2ZSBhcHByb3hpbWF0ZWx5IHRoZSBzYW1lIGVsZW1lbnRzIGluIHRoZSBzYW1lIHBvc2l0aW9uLlxuICpcbiAqIEBwYXJhbSB7dmVjM30gYSBUaGUgZmlyc3QgdmVjdG9yLlxuICogQHBhcmFtIHt2ZWMzfSBiIFRoZSBzZWNvbmQgdmVjdG9yLlxuICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWYgdGhlIHZlY3RvcnMgYXJlIGVxdWFsLCBmYWxzZSBvdGhlcndpc2UuXG4gKi9cbmZ1bmN0aW9uIGVxdWFscyhhLCBiKSB7XG4gIHZhciBhMCA9IGFbMF1cbiAgdmFyIGExID0gYVsxXVxuICB2YXIgYTIgPSBhWzJdXG4gIHZhciBiMCA9IGJbMF1cbiAgdmFyIGIxID0gYlsxXVxuICB2YXIgYjIgPSBiWzJdXG4gIHJldHVybiAoTWF0aC5hYnMoYTAgLSBiMCkgPD0gRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTApLCBNYXRoLmFicyhiMCkpICYmXG4gICAgICAgICAgTWF0aC5hYnMoYTEgLSBiMSkgPD0gRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTEpLCBNYXRoLmFicyhiMSkpICYmXG4gICAgICAgICAgTWF0aC5hYnMoYTIgLSBiMikgPD0gRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTIpLCBNYXRoLmFicyhiMikpKVxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBleGFjdEVxdWFsc1xuXG4vKipcbiAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIHZlY3RvcnMgZXhhY3RseSBoYXZlIHRoZSBzYW1lIGVsZW1lbnRzIGluIHRoZSBzYW1lIHBvc2l0aW9uICh3aGVuIGNvbXBhcmVkIHdpdGggPT09KVxuICpcbiAqIEBwYXJhbSB7dmVjM30gYSBUaGUgZmlyc3QgdmVjdG9yLlxuICogQHBhcmFtIHt2ZWMzfSBiIFRoZSBzZWNvbmQgdmVjdG9yLlxuICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWYgdGhlIHZlY3RvcnMgYXJlIGVxdWFsLCBmYWxzZSBvdGhlcndpc2UuXG4gKi9cbmZ1bmN0aW9uIGV4YWN0RXF1YWxzKGEsIGIpIHtcbiAgcmV0dXJuIGFbMF0gPT09IGJbMF0gJiYgYVsxXSA9PT0gYlsxXSAmJiBhWzJdID09PSBiWzJdXG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGFkZDtcblxuLyoqXG4gKiBBZGRzIHR3byB2ZWMzJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbmZ1bmN0aW9uIGFkZChvdXQsIGEsIGIpIHtcbiAgICBvdXRbMF0gPSBhWzBdICsgYlswXVxuICAgIG91dFsxXSA9IGFbMV0gKyBiWzFdXG4gICAgb3V0WzJdID0gYVsyXSArIGJbMl1cbiAgICByZXR1cm4gb3V0XG59IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL3N1YnRyYWN0JylcbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9tdWx0aXBseScpXG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vZGl2aWRlJylcbiIsIm1vZHVsZS5leHBvcnRzID0gbWluO1xuXG4vKipcbiAqIFJldHVybnMgdGhlIG1pbmltdW0gb2YgdHdvIHZlYzMnc1xuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuZnVuY3Rpb24gbWluKG91dCwgYSwgYikge1xuICAgIG91dFswXSA9IE1hdGgubWluKGFbMF0sIGJbMF0pXG4gICAgb3V0WzFdID0gTWF0aC5taW4oYVsxXSwgYlsxXSlcbiAgICBvdXRbMl0gPSBNYXRoLm1pbihhWzJdLCBiWzJdKVxuICAgIHJldHVybiBvdXRcbn0iLCJtb2R1bGUuZXhwb3J0cyA9IG1heDtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBtYXhpbXVtIG9mIHR3byB2ZWMzJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbmZ1bmN0aW9uIG1heChvdXQsIGEsIGIpIHtcbiAgICBvdXRbMF0gPSBNYXRoLm1heChhWzBdLCBiWzBdKVxuICAgIG91dFsxXSA9IE1hdGgubWF4KGFbMV0sIGJbMV0pXG4gICAgb3V0WzJdID0gTWF0aC5tYXgoYVsyXSwgYlsyXSlcbiAgICByZXR1cm4gb3V0XG59IiwibW9kdWxlLmV4cG9ydHMgPSBmbG9vclxuXG4vKipcbiAqIE1hdGguZmxvb3IgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWMzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB2ZWN0b3IgdG8gZmxvb3JcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuZnVuY3Rpb24gZmxvb3Iob3V0LCBhKSB7XG4gIG91dFswXSA9IE1hdGguZmxvb3IoYVswXSlcbiAgb3V0WzFdID0gTWF0aC5mbG9vcihhWzFdKVxuICBvdXRbMl0gPSBNYXRoLmZsb29yKGFbMl0pXG4gIHJldHVybiBvdXRcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gY2VpbFxuXG4vKipcbiAqIE1hdGguY2VpbCB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzNcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHZlY3RvciB0byBjZWlsXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbmZ1bmN0aW9uIGNlaWwob3V0LCBhKSB7XG4gIG91dFswXSA9IE1hdGguY2VpbChhWzBdKVxuICBvdXRbMV0gPSBNYXRoLmNlaWwoYVsxXSlcbiAgb3V0WzJdID0gTWF0aC5jZWlsKGFbMl0pXG4gIHJldHVybiBvdXRcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gcm91bmRcblxuLyoqXG4gKiBNYXRoLnJvdW5kIHRoZSBjb21wb25lbnRzIG9mIGEgdmVjM1xuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdmVjdG9yIHRvIHJvdW5kXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbmZ1bmN0aW9uIHJvdW5kKG91dCwgYSkge1xuICBvdXRbMF0gPSBNYXRoLnJvdW5kKGFbMF0pXG4gIG91dFsxXSA9IE1hdGgucm91bmQoYVsxXSlcbiAgb3V0WzJdID0gTWF0aC5yb3VuZChhWzJdKVxuICByZXR1cm4gb3V0XG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHNjYWxlO1xuXG4vKipcbiAqIFNjYWxlcyBhIHZlYzMgYnkgYSBzY2FsYXIgbnVtYmVyXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgdmVjdG9yIHRvIHNjYWxlXG4gKiBAcGFyYW0ge051bWJlcn0gYiBhbW91bnQgdG8gc2NhbGUgdGhlIHZlY3RvciBieVxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG5mdW5jdGlvbiBzY2FsZShvdXQsIGEsIGIpIHtcbiAgICBvdXRbMF0gPSBhWzBdICogYlxuICAgIG91dFsxXSA9IGFbMV0gKiBiXG4gICAgb3V0WzJdID0gYVsyXSAqIGJcbiAgICByZXR1cm4gb3V0XG59IiwibW9kdWxlLmV4cG9ydHMgPSBzY2FsZUFuZEFkZDtcblxuLyoqXG4gKiBBZGRzIHR3byB2ZWMzJ3MgYWZ0ZXIgc2NhbGluZyB0aGUgc2Vjb25kIG9wZXJhbmQgYnkgYSBzY2FsYXIgdmFsdWVcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcGFyYW0ge051bWJlcn0gc2NhbGUgdGhlIGFtb3VudCB0byBzY2FsZSBiIGJ5IGJlZm9yZSBhZGRpbmdcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuZnVuY3Rpb24gc2NhbGVBbmRBZGQob3V0LCBhLCBiLCBzY2FsZSkge1xuICAgIG91dFswXSA9IGFbMF0gKyAoYlswXSAqIHNjYWxlKVxuICAgIG91dFsxXSA9IGFbMV0gKyAoYlsxXSAqIHNjYWxlKVxuICAgIG91dFsyXSA9IGFbMl0gKyAoYlsyXSAqIHNjYWxlKVxuICAgIHJldHVybiBvdXRcbn0iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vZGlzdGFuY2UnKVxuIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL3NxdWFyZWREaXN0YW5jZScpXG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbGVuZ3RoJylcbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9zcXVhcmVkTGVuZ3RoJylcbiIsIm1vZHVsZS5leHBvcnRzID0gbmVnYXRlO1xuXG4vKipcbiAqIE5lZ2F0ZXMgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWMzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB2ZWN0b3IgdG8gbmVnYXRlXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbmZ1bmN0aW9uIG5lZ2F0ZShvdXQsIGEpIHtcbiAgICBvdXRbMF0gPSAtYVswXVxuICAgIG91dFsxXSA9IC1hWzFdXG4gICAgb3V0WzJdID0gLWFbMl1cbiAgICByZXR1cm4gb3V0XG59IiwibW9kdWxlLmV4cG9ydHMgPSBpbnZlcnNlO1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGludmVyc2Ugb2YgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWMzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB2ZWN0b3IgdG8gaW52ZXJ0XG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbmZ1bmN0aW9uIGludmVyc2Uob3V0LCBhKSB7XG4gIG91dFswXSA9IDEuMCAvIGFbMF1cbiAgb3V0WzFdID0gMS4wIC8gYVsxXVxuICBvdXRbMl0gPSAxLjAgLyBhWzJdXG4gIHJldHVybiBvdXRcbn0iLCJtb2R1bGUuZXhwb3J0cyA9IGNyb3NzO1xuXG4vKipcbiAqIENvbXB1dGVzIHRoZSBjcm9zcyBwcm9kdWN0IG9mIHR3byB2ZWMzJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbmZ1bmN0aW9uIGNyb3NzKG91dCwgYSwgYikge1xuICAgIHZhciBheCA9IGFbMF0sIGF5ID0gYVsxXSwgYXogPSBhWzJdLFxuICAgICAgICBieCA9IGJbMF0sIGJ5ID0gYlsxXSwgYnogPSBiWzJdXG5cbiAgICBvdXRbMF0gPSBheSAqIGJ6IC0gYXogKiBieVxuICAgIG91dFsxXSA9IGF6ICogYnggLSBheCAqIGJ6XG4gICAgb3V0WzJdID0gYXggKiBieSAtIGF5ICogYnhcbiAgICByZXR1cm4gb3V0XG59IiwibW9kdWxlLmV4cG9ydHMgPSBsZXJwO1xuXG4vKipcbiAqIFBlcmZvcm1zIGEgbGluZWFyIGludGVycG9sYXRpb24gYmV0d2VlbiB0d28gdmVjMydzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHBhcmFtIHtOdW1iZXJ9IHQgaW50ZXJwb2xhdGlvbiBhbW91bnQgYmV0d2VlbiB0aGUgdHdvIGlucHV0c1xuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG5mdW5jdGlvbiBsZXJwKG91dCwgYSwgYiwgdCkge1xuICAgIHZhciBheCA9IGFbMF0sXG4gICAgICAgIGF5ID0gYVsxXSxcbiAgICAgICAgYXogPSBhWzJdXG4gICAgb3V0WzBdID0gYXggKyB0ICogKGJbMF0gLSBheClcbiAgICBvdXRbMV0gPSBheSArIHQgKiAoYlsxXSAtIGF5KVxuICAgIG91dFsyXSA9IGF6ICsgdCAqIChiWzJdIC0gYXopXG4gICAgcmV0dXJuIG91dFxufSIsIm1vZHVsZS5leHBvcnRzID0gcmFuZG9tO1xuXG4vKipcbiAqIEdlbmVyYXRlcyBhIHJhbmRvbSB2ZWN0b3Igd2l0aCB0aGUgZ2l2ZW4gc2NhbGVcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtOdW1iZXJ9IFtzY2FsZV0gTGVuZ3RoIG9mIHRoZSByZXN1bHRpbmcgdmVjdG9yLiBJZiBvbW1pdHRlZCwgYSB1bml0IHZlY3RvciB3aWxsIGJlIHJldHVybmVkXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbmZ1bmN0aW9uIHJhbmRvbShvdXQsIHNjYWxlKSB7XG4gICAgc2NhbGUgPSBzY2FsZSB8fCAxLjBcblxuICAgIHZhciByID0gTWF0aC5yYW5kb20oKSAqIDIuMCAqIE1hdGguUElcbiAgICB2YXIgeiA9IChNYXRoLnJhbmRvbSgpICogMi4wKSAtIDEuMFxuICAgIHZhciB6U2NhbGUgPSBNYXRoLnNxcnQoMS4wLXoqeikgKiBzY2FsZVxuXG4gICAgb3V0WzBdID0gTWF0aC5jb3MocikgKiB6U2NhbGVcbiAgICBvdXRbMV0gPSBNYXRoLnNpbihyKSAqIHpTY2FsZVxuICAgIG91dFsyXSA9IHogKiBzY2FsZVxuICAgIHJldHVybiBvdXRcbn0iLCJtb2R1bGUuZXhwb3J0cyA9IHRyYW5zZm9ybU1hdDQ7XG5cbi8qKlxuICogVHJhbnNmb3JtcyB0aGUgdmVjMyB3aXRoIGEgbWF0NC5cbiAqIDR0aCB2ZWN0b3IgY29tcG9uZW50IGlzIGltcGxpY2l0bHkgJzEnXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgdmVjdG9yIHRvIHRyYW5zZm9ybVxuICogQHBhcmFtIHttYXQ0fSBtIG1hdHJpeCB0byB0cmFuc2Zvcm0gd2l0aFxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG5mdW5jdGlvbiB0cmFuc2Zvcm1NYXQ0KG91dCwgYSwgbSkge1xuICAgIHZhciB4ID0gYVswXSwgeSA9IGFbMV0sIHogPSBhWzJdLFxuICAgICAgICB3ID0gbVszXSAqIHggKyBtWzddICogeSArIG1bMTFdICogeiArIG1bMTVdXG4gICAgdyA9IHcgfHwgMS4wXG4gICAgb3V0WzBdID0gKG1bMF0gKiB4ICsgbVs0XSAqIHkgKyBtWzhdICogeiArIG1bMTJdKSAvIHdcbiAgICBvdXRbMV0gPSAobVsxXSAqIHggKyBtWzVdICogeSArIG1bOV0gKiB6ICsgbVsxM10pIC8gd1xuICAgIG91dFsyXSA9IChtWzJdICogeCArIG1bNl0gKiB5ICsgbVsxMF0gKiB6ICsgbVsxNF0pIC8gd1xuICAgIHJldHVybiBvdXRcbn0iLCJtb2R1bGUuZXhwb3J0cyA9IHRyYW5zZm9ybU1hdDM7XG5cbi8qKlxuICogVHJhbnNmb3JtcyB0aGUgdmVjMyB3aXRoIGEgbWF0My5cbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSB2ZWN0b3IgdG8gdHJhbnNmb3JtXG4gKiBAcGFyYW0ge21hdDR9IG0gdGhlIDN4MyBtYXRyaXggdG8gdHJhbnNmb3JtIHdpdGhcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuZnVuY3Rpb24gdHJhbnNmb3JtTWF0MyhvdXQsIGEsIG0pIHtcbiAgICB2YXIgeCA9IGFbMF0sIHkgPSBhWzFdLCB6ID0gYVsyXVxuICAgIG91dFswXSA9IHggKiBtWzBdICsgeSAqIG1bM10gKyB6ICogbVs2XVxuICAgIG91dFsxXSA9IHggKiBtWzFdICsgeSAqIG1bNF0gKyB6ICogbVs3XVxuICAgIG91dFsyXSA9IHggKiBtWzJdICsgeSAqIG1bNV0gKyB6ICogbVs4XVxuICAgIHJldHVybiBvdXRcbn0iLCJtb2R1bGUuZXhwb3J0cyA9IHRyYW5zZm9ybVF1YXQ7XG5cbi8qKlxuICogVHJhbnNmb3JtcyB0aGUgdmVjMyB3aXRoIGEgcXVhdFxuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIHZlY3RvciB0byB0cmFuc2Zvcm1cbiAqIEBwYXJhbSB7cXVhdH0gcSBxdWF0ZXJuaW9uIHRvIHRyYW5zZm9ybSB3aXRoXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbmZ1bmN0aW9uIHRyYW5zZm9ybVF1YXQob3V0LCBhLCBxKSB7XG4gICAgLy8gYmVuY2htYXJrczogaHR0cDovL2pzcGVyZi5jb20vcXVhdGVybmlvbi10cmFuc2Zvcm0tdmVjMy1pbXBsZW1lbnRhdGlvbnNcblxuICAgIHZhciB4ID0gYVswXSwgeSA9IGFbMV0sIHogPSBhWzJdLFxuICAgICAgICBxeCA9IHFbMF0sIHF5ID0gcVsxXSwgcXogPSBxWzJdLCBxdyA9IHFbM10sXG5cbiAgICAgICAgLy8gY2FsY3VsYXRlIHF1YXQgKiB2ZWNcbiAgICAgICAgaXggPSBxdyAqIHggKyBxeSAqIHogLSBxeiAqIHksXG4gICAgICAgIGl5ID0gcXcgKiB5ICsgcXogKiB4IC0gcXggKiB6LFxuICAgICAgICBpeiA9IHF3ICogeiArIHF4ICogeSAtIHF5ICogeCxcbiAgICAgICAgaXcgPSAtcXggKiB4IC0gcXkgKiB5IC0gcXogKiB6XG5cbiAgICAvLyBjYWxjdWxhdGUgcmVzdWx0ICogaW52ZXJzZSBxdWF0XG4gICAgb3V0WzBdID0gaXggKiBxdyArIGl3ICogLXF4ICsgaXkgKiAtcXogLSBpeiAqIC1xeVxuICAgIG91dFsxXSA9IGl5ICogcXcgKyBpdyAqIC1xeSArIGl6ICogLXF4IC0gaXggKiAtcXpcbiAgICBvdXRbMl0gPSBpeiAqIHF3ICsgaXcgKiAtcXogKyBpeCAqIC1xeSAtIGl5ICogLXF4XG4gICAgcmV0dXJuIG91dFxufSIsIm1vZHVsZS5leHBvcnRzID0gcm90YXRlWDtcblxuLyoqXG4gKiBSb3RhdGUgYSAzRCB2ZWN0b3IgYXJvdW5kIHRoZSB4LWF4aXNcbiAqIEBwYXJhbSB7dmVjM30gb3V0IFRoZSByZWNlaXZpbmcgdmVjM1xuICogQHBhcmFtIHt2ZWMzfSBhIFRoZSB2ZWMzIHBvaW50IHRvIHJvdGF0ZVxuICogQHBhcmFtIHt2ZWMzfSBiIFRoZSBvcmlnaW4gb2YgdGhlIHJvdGF0aW9uXG4gKiBAcGFyYW0ge051bWJlcn0gYyBUaGUgYW5nbGUgb2Ygcm90YXRpb25cbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuZnVuY3Rpb24gcm90YXRlWChvdXQsIGEsIGIsIGMpe1xuICAgIHZhciBieSA9IGJbMV1cbiAgICB2YXIgYnogPSBiWzJdXG5cbiAgICAvLyBUcmFuc2xhdGUgcG9pbnQgdG8gdGhlIG9yaWdpblxuICAgIHZhciBweSA9IGFbMV0gLSBieVxuICAgIHZhciBweiA9IGFbMl0gLSBielxuXG4gICAgdmFyIHNjID0gTWF0aC5zaW4oYylcbiAgICB2YXIgY2MgPSBNYXRoLmNvcyhjKVxuXG4gICAgLy8gcGVyZm9ybSByb3RhdGlvbiBhbmQgdHJhbnNsYXRlIHRvIGNvcnJlY3QgcG9zaXRpb25cbiAgICBvdXRbMF0gPSBhWzBdXG4gICAgb3V0WzFdID0gYnkgKyBweSAqIGNjIC0gcHogKiBzY1xuICAgIG91dFsyXSA9IGJ6ICsgcHkgKiBzYyArIHB6ICogY2NcblxuICAgIHJldHVybiBvdXRcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gcm90YXRlWTtcblxuLyoqXG4gKiBSb3RhdGUgYSAzRCB2ZWN0b3IgYXJvdW5kIHRoZSB5LWF4aXNcbiAqIEBwYXJhbSB7dmVjM30gb3V0IFRoZSByZWNlaXZpbmcgdmVjM1xuICogQHBhcmFtIHt2ZWMzfSBhIFRoZSB2ZWMzIHBvaW50IHRvIHJvdGF0ZVxuICogQHBhcmFtIHt2ZWMzfSBiIFRoZSBvcmlnaW4gb2YgdGhlIHJvdGF0aW9uXG4gKiBAcGFyYW0ge051bWJlcn0gYyBUaGUgYW5nbGUgb2Ygcm90YXRpb25cbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuZnVuY3Rpb24gcm90YXRlWShvdXQsIGEsIGIsIGMpe1xuICAgIHZhciBieCA9IGJbMF1cbiAgICB2YXIgYnogPSBiWzJdXG5cbiAgICAvLyB0cmFuc2xhdGUgcG9pbnQgdG8gdGhlIG9yaWdpblxuICAgIHZhciBweCA9IGFbMF0gLSBieFxuICAgIHZhciBweiA9IGFbMl0gLSBielxuICAgIFxuICAgIHZhciBzYyA9IE1hdGguc2luKGMpXG4gICAgdmFyIGNjID0gTWF0aC5jb3MoYylcbiAgXG4gICAgLy8gcGVyZm9ybSByb3RhdGlvbiBhbmQgdHJhbnNsYXRlIHRvIGNvcnJlY3QgcG9zaXRpb25cbiAgICBvdXRbMF0gPSBieCArIHB6ICogc2MgKyBweCAqIGNjXG4gICAgb3V0WzFdID0gYVsxXVxuICAgIG91dFsyXSA9IGJ6ICsgcHogKiBjYyAtIHB4ICogc2NcbiAgXG4gICAgcmV0dXJuIG91dFxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSByb3RhdGVaO1xuXG4vKipcbiAqIFJvdGF0ZSBhIDNEIHZlY3RvciBhcm91bmQgdGhlIHotYXhpc1xuICogQHBhcmFtIHt2ZWMzfSBvdXQgVGhlIHJlY2VpdmluZyB2ZWMzXG4gKiBAcGFyYW0ge3ZlYzN9IGEgVGhlIHZlYzMgcG9pbnQgdG8gcm90YXRlXG4gKiBAcGFyYW0ge3ZlYzN9IGIgVGhlIG9yaWdpbiBvZiB0aGUgcm90YXRpb25cbiAqIEBwYXJhbSB7TnVtYmVyfSBjIFRoZSBhbmdsZSBvZiByb3RhdGlvblxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG5mdW5jdGlvbiByb3RhdGVaKG91dCwgYSwgYiwgYyl7XG4gICAgdmFyIGJ4ID0gYlswXVxuICAgIHZhciBieSA9IGJbMV1cblxuICAgIC8vVHJhbnNsYXRlIHBvaW50IHRvIHRoZSBvcmlnaW5cbiAgICB2YXIgcHggPSBhWzBdIC0gYnhcbiAgICB2YXIgcHkgPSBhWzFdIC0gYnlcbiAgXG4gICAgdmFyIHNjID0gTWF0aC5zaW4oYylcbiAgICB2YXIgY2MgPSBNYXRoLmNvcyhjKVxuXG4gICAgLy8gcGVyZm9ybSByb3RhdGlvbiBhbmQgdHJhbnNsYXRlIHRvIGNvcnJlY3QgcG9zaXRpb25cbiAgICBvdXRbMF0gPSBieCArIHB4ICogY2MgLSBweSAqIHNjXG4gICAgb3V0WzFdID0gYnkgKyBweCAqIHNjICsgcHkgKiBjY1xuICAgIG91dFsyXSA9IGFbMl1cbiAgXG4gICAgcmV0dXJuIG91dFxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBmb3JFYWNoO1xuXG52YXIgdmVjID0gcmVxdWlyZSgnLi9jcmVhdGUnKSgpXG5cbi8qKlxuICogUGVyZm9ybSBzb21lIG9wZXJhdGlvbiBvdmVyIGFuIGFycmF5IG9mIHZlYzNzLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGEgdGhlIGFycmF5IG9mIHZlY3RvcnMgdG8gaXRlcmF0ZSBvdmVyXG4gKiBAcGFyYW0ge051bWJlcn0gc3RyaWRlIE51bWJlciBvZiBlbGVtZW50cyBiZXR3ZWVuIHRoZSBzdGFydCBvZiBlYWNoIHZlYzMuIElmIDAgYXNzdW1lcyB0aWdodGx5IHBhY2tlZFxuICogQHBhcmFtIHtOdW1iZXJ9IG9mZnNldCBOdW1iZXIgb2YgZWxlbWVudHMgdG8gc2tpcCBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZSBhcnJheVxuICogQHBhcmFtIHtOdW1iZXJ9IGNvdW50IE51bWJlciBvZiB2ZWMzcyB0byBpdGVyYXRlIG92ZXIuIElmIDAgaXRlcmF0ZXMgb3ZlciBlbnRpcmUgYXJyYXlcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIEZ1bmN0aW9uIHRvIGNhbGwgZm9yIGVhY2ggdmVjdG9yIGluIHRoZSBhcnJheVxuICogQHBhcmFtIHtPYmplY3R9IFthcmddIGFkZGl0aW9uYWwgYXJndW1lbnQgdG8gcGFzcyB0byBmblxuICogQHJldHVybnMge0FycmF5fSBhXG4gKiBAZnVuY3Rpb25cbiAqL1xuZnVuY3Rpb24gZm9yRWFjaChhLCBzdHJpZGUsIG9mZnNldCwgY291bnQsIGZuLCBhcmcpIHtcbiAgICAgICAgdmFyIGksIGxcbiAgICAgICAgaWYoIXN0cmlkZSkge1xuICAgICAgICAgICAgc3RyaWRlID0gM1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoIW9mZnNldCkge1xuICAgICAgICAgICAgb2Zmc2V0ID0gMFxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBpZihjb3VudCkge1xuICAgICAgICAgICAgbCA9IE1hdGgubWluKChjb3VudCAqIHN0cmlkZSkgKyBvZmZzZXQsIGEubGVuZ3RoKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbCA9IGEubGVuZ3RoXG4gICAgICAgIH1cblxuICAgICAgICBmb3IoaSA9IG9mZnNldDsgaSA8IGw7IGkgKz0gc3RyaWRlKSB7XG4gICAgICAgICAgICB2ZWNbMF0gPSBhW2ldIFxuICAgICAgICAgICAgdmVjWzFdID0gYVtpKzFdIFxuICAgICAgICAgICAgdmVjWzJdID0gYVtpKzJdXG4gICAgICAgICAgICBmbih2ZWMsIHZlYywgYXJnKVxuICAgICAgICAgICAgYVtpXSA9IHZlY1swXSBcbiAgICAgICAgICAgIGFbaSsxXSA9IHZlY1sxXSBcbiAgICAgICAgICAgIGFbaSsyXSA9IHZlY1syXVxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gYVxufSIsInZhciBfdHlwZW9mID0gcmVxdWlyZShcIi4vdHlwZW9mLmpzXCIpW1wiZGVmYXVsdFwiXTtcblxuZnVuY3Rpb24gX3JlZ2VuZXJhdG9yUnVudGltZSgpIHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG4gIC8qISByZWdlbmVyYXRvci1ydW50aW1lIC0tIENvcHlyaWdodCAoYykgMjAxNC1wcmVzZW50LCBGYWNlYm9vaywgSW5jLiAtLSBsaWNlbnNlIChNSVQpOiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVnZW5lcmF0b3IvYmxvYi9tYWluL0xJQ0VOU0UgKi9cblxuICBtb2R1bGUuZXhwb3J0cyA9IF9yZWdlbmVyYXRvclJ1bnRpbWUgPSBmdW5jdGlvbiBfcmVnZW5lcmF0b3JSdW50aW1lKCkge1xuICAgIHJldHVybiBleHBvcnRzO1xuICB9LCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZSwgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHM7XG4gIHZhciBleHBvcnRzID0ge30sXG4gICAgICBPcCA9IE9iamVjdC5wcm90b3R5cGUsXG4gICAgICBoYXNPd24gPSBPcC5oYXNPd25Qcm9wZXJ0eSxcbiAgICAgICRTeW1ib2wgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCA/IFN5bWJvbCA6IHt9LFxuICAgICAgaXRlcmF0b3JTeW1ib2wgPSAkU3ltYm9sLml0ZXJhdG9yIHx8IFwiQEBpdGVyYXRvclwiLFxuICAgICAgYXN5bmNJdGVyYXRvclN5bWJvbCA9ICRTeW1ib2wuYXN5bmNJdGVyYXRvciB8fCBcIkBAYXN5bmNJdGVyYXRvclwiLFxuICAgICAgdG9TdHJpbmdUYWdTeW1ib2wgPSAkU3ltYm9sLnRvU3RyaW5nVGFnIHx8IFwiQEB0b1N0cmluZ1RhZ1wiO1xuXG4gIGZ1bmN0aW9uIGRlZmluZShvYmosIGtleSwgdmFsdWUpIHtcbiAgICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICBlbnVtZXJhYmxlOiAhMCxcbiAgICAgIGNvbmZpZ3VyYWJsZTogITAsXG4gICAgICB3cml0YWJsZTogITBcbiAgICB9KSwgb2JqW2tleV07XG4gIH1cblxuICB0cnkge1xuICAgIGRlZmluZSh7fSwgXCJcIik7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGRlZmluZSA9IGZ1bmN0aW9uIGRlZmluZShvYmosIGtleSwgdmFsdWUpIHtcbiAgICAgIHJldHVybiBvYmpba2V5XSA9IHZhbHVlO1xuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiB3cmFwKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0KSB7XG4gICAgdmFyIHByb3RvR2VuZXJhdG9yID0gb3V0ZXJGbiAmJiBvdXRlckZuLnByb3RvdHlwZSBpbnN0YW5jZW9mIEdlbmVyYXRvciA/IG91dGVyRm4gOiBHZW5lcmF0b3IsXG4gICAgICAgIGdlbmVyYXRvciA9IE9iamVjdC5jcmVhdGUocHJvdG9HZW5lcmF0b3IucHJvdG90eXBlKSxcbiAgICAgICAgY29udGV4dCA9IG5ldyBDb250ZXh0KHRyeUxvY3NMaXN0IHx8IFtdKTtcbiAgICByZXR1cm4gZ2VuZXJhdG9yLl9pbnZva2UgPSBmdW5jdGlvbiAoaW5uZXJGbiwgc2VsZiwgY29udGV4dCkge1xuICAgICAgdmFyIHN0YXRlID0gXCJzdXNwZW5kZWRTdGFydFwiO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChtZXRob2QsIGFyZykge1xuICAgICAgICBpZiAoXCJleGVjdXRpbmdcIiA9PT0gc3RhdGUpIHRocm93IG5ldyBFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IHJ1bm5pbmdcIik7XG5cbiAgICAgICAgaWYgKFwiY29tcGxldGVkXCIgPT09IHN0YXRlKSB7XG4gICAgICAgICAgaWYgKFwidGhyb3dcIiA9PT0gbWV0aG9kKSB0aHJvdyBhcmc7XG4gICAgICAgICAgcmV0dXJuIGRvbmVSZXN1bHQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoY29udGV4dC5tZXRob2QgPSBtZXRob2QsIGNvbnRleHQuYXJnID0gYXJnOzspIHtcbiAgICAgICAgICB2YXIgZGVsZWdhdGUgPSBjb250ZXh0LmRlbGVnYXRlO1xuXG4gICAgICAgICAgaWYgKGRlbGVnYXRlKSB7XG4gICAgICAgICAgICB2YXIgZGVsZWdhdGVSZXN1bHQgPSBtYXliZUludm9rZURlbGVnYXRlKGRlbGVnYXRlLCBjb250ZXh0KTtcblxuICAgICAgICAgICAgaWYgKGRlbGVnYXRlUmVzdWx0KSB7XG4gICAgICAgICAgICAgIGlmIChkZWxlZ2F0ZVJlc3VsdCA9PT0gQ29udGludWVTZW50aW5lbCkgY29udGludWU7XG4gICAgICAgICAgICAgIHJldHVybiBkZWxlZ2F0ZVJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoXCJuZXh0XCIgPT09IGNvbnRleHQubWV0aG9kKSBjb250ZXh0LnNlbnQgPSBjb250ZXh0Ll9zZW50ID0gY29udGV4dC5hcmc7ZWxzZSBpZiAoXCJ0aHJvd1wiID09PSBjb250ZXh0Lm1ldGhvZCkge1xuICAgICAgICAgICAgaWYgKFwic3VzcGVuZGVkU3RhcnRcIiA9PT0gc3RhdGUpIHRocm93IHN0YXRlID0gXCJjb21wbGV0ZWRcIiwgY29udGV4dC5hcmc7XG4gICAgICAgICAgICBjb250ZXh0LmRpc3BhdGNoRXhjZXB0aW9uKGNvbnRleHQuYXJnKTtcbiAgICAgICAgICB9IGVsc2UgXCJyZXR1cm5cIiA9PT0gY29udGV4dC5tZXRob2QgJiYgY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwgY29udGV4dC5hcmcpO1xuICAgICAgICAgIHN0YXRlID0gXCJleGVjdXRpbmdcIjtcbiAgICAgICAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2goaW5uZXJGbiwgc2VsZiwgY29udGV4dCk7XG5cbiAgICAgICAgICBpZiAoXCJub3JtYWxcIiA9PT0gcmVjb3JkLnR5cGUpIHtcbiAgICAgICAgICAgIGlmIChzdGF0ZSA9IGNvbnRleHQuZG9uZSA/IFwiY29tcGxldGVkXCIgOiBcInN1c3BlbmRlZFlpZWxkXCIsIHJlY29yZC5hcmcgPT09IENvbnRpbnVlU2VudGluZWwpIGNvbnRpbnVlO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgdmFsdWU6IHJlY29yZC5hcmcsXG4gICAgICAgICAgICAgIGRvbmU6IGNvbnRleHQuZG9uZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBcInRocm93XCIgPT09IHJlY29yZC50eXBlICYmIChzdGF0ZSA9IFwiY29tcGxldGVkXCIsIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiLCBjb250ZXh0LmFyZyA9IHJlY29yZC5hcmcpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0oaW5uZXJGbiwgc2VsZiwgY29udGV4dCksIGdlbmVyYXRvcjtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRyeUNhdGNoKGZuLCBvYmosIGFyZykge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcIm5vcm1hbFwiLFxuICAgICAgICBhcmc6IGZuLmNhbGwob2JqLCBhcmcpXG4gICAgICB9O1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJ0aHJvd1wiLFxuICAgICAgICBhcmc6IGVyclxuICAgICAgfTtcbiAgICB9XG4gIH1cblxuICBleHBvcnRzLndyYXAgPSB3cmFwO1xuICB2YXIgQ29udGludWVTZW50aW5lbCA9IHt9O1xuXG4gIGZ1bmN0aW9uIEdlbmVyYXRvcigpIHt9XG5cbiAgZnVuY3Rpb24gR2VuZXJhdG9yRnVuY3Rpb24oKSB7fVxuXG4gIGZ1bmN0aW9uIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlKCkge31cblxuICB2YXIgSXRlcmF0b3JQcm90b3R5cGUgPSB7fTtcbiAgZGVmaW5lKEl0ZXJhdG9yUHJvdG90eXBlLCBpdGVyYXRvclN5bWJvbCwgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9KTtcbiAgdmFyIGdldFByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mLFxuICAgICAgTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUgPSBnZXRQcm90byAmJiBnZXRQcm90byhnZXRQcm90byh2YWx1ZXMoW10pKSk7XG4gIE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlICYmIE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlICE9PSBPcCAmJiBoYXNPd24uY2FsbChOYXRpdmVJdGVyYXRvclByb3RvdHlwZSwgaXRlcmF0b3JTeW1ib2wpICYmIChJdGVyYXRvclByb3RvdHlwZSA9IE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlKTtcbiAgdmFyIEdwID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUucHJvdG90eXBlID0gR2VuZXJhdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoSXRlcmF0b3JQcm90b3R5cGUpO1xuXG4gIGZ1bmN0aW9uIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhwcm90b3R5cGUpIHtcbiAgICBbXCJuZXh0XCIsIFwidGhyb3dcIiwgXCJyZXR1cm5cIl0uZm9yRWFjaChmdW5jdGlvbiAobWV0aG9kKSB7XG4gICAgICBkZWZpbmUocHJvdG90eXBlLCBtZXRob2QsIGZ1bmN0aW9uIChhcmcpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ludm9rZShtZXRob2QsIGFyZyk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIEFzeW5jSXRlcmF0b3IoZ2VuZXJhdG9yLCBQcm9taXNlSW1wbCkge1xuICAgIGZ1bmN0aW9uIGludm9rZShtZXRob2QsIGFyZywgcmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2goZ2VuZXJhdG9yW21ldGhvZF0sIGdlbmVyYXRvciwgYXJnKTtcblxuICAgICAgaWYgKFwidGhyb3dcIiAhPT0gcmVjb3JkLnR5cGUpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHJlY29yZC5hcmcsXG4gICAgICAgICAgICB2YWx1ZSA9IHJlc3VsdC52YWx1ZTtcbiAgICAgICAgcmV0dXJuIHZhbHVlICYmIFwib2JqZWN0XCIgPT0gX3R5cGVvZih2YWx1ZSkgJiYgaGFzT3duLmNhbGwodmFsdWUsIFwiX19hd2FpdFwiKSA/IFByb21pc2VJbXBsLnJlc29sdmUodmFsdWUuX19hd2FpdCkudGhlbihmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICBpbnZva2UoXCJuZXh0XCIsIHZhbHVlLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICB9LCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgaW52b2tlKFwidGhyb3dcIiwgZXJyLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICB9KSA6IFByb21pc2VJbXBsLnJlc29sdmUodmFsdWUpLnRoZW4oZnVuY3Rpb24gKHVud3JhcHBlZCkge1xuICAgICAgICAgIHJlc3VsdC52YWx1ZSA9IHVud3JhcHBlZCwgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICB9LCBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICByZXR1cm4gaW52b2tlKFwidGhyb3dcIiwgZXJyb3IsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICByZWplY3QocmVjb3JkLmFyZyk7XG4gICAgfVxuXG4gICAgdmFyIHByZXZpb3VzUHJvbWlzZTtcblxuICAgIHRoaXMuX2ludm9rZSA9IGZ1bmN0aW9uIChtZXRob2QsIGFyZykge1xuICAgICAgZnVuY3Rpb24gY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZUltcGwoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgIGludm9rZShtZXRob2QsIGFyZywgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwcmV2aW91c1Byb21pc2UgPSBwcmV2aW91c1Byb21pc2UgPyBwcmV2aW91c1Byb21pc2UudGhlbihjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZywgY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcpIDogY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcoKTtcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gbWF5YmVJbnZva2VEZWxlZ2F0ZShkZWxlZ2F0ZSwgY29udGV4dCkge1xuICAgIHZhciBtZXRob2QgPSBkZWxlZ2F0ZS5pdGVyYXRvcltjb250ZXh0Lm1ldGhvZF07XG5cbiAgICBpZiAodW5kZWZpbmVkID09PSBtZXRob2QpIHtcbiAgICAgIGlmIChjb250ZXh0LmRlbGVnYXRlID0gbnVsbCwgXCJ0aHJvd1wiID09PSBjb250ZXh0Lm1ldGhvZCkge1xuICAgICAgICBpZiAoZGVsZWdhdGUuaXRlcmF0b3JbXCJyZXR1cm5cIl0gJiYgKGNvbnRleHQubWV0aG9kID0gXCJyZXR1cm5cIiwgY29udGV4dC5hcmcgPSB1bmRlZmluZWQsIG1heWJlSW52b2tlRGVsZWdhdGUoZGVsZWdhdGUsIGNvbnRleHQpLCBcInRocm93XCIgPT09IGNvbnRleHQubWV0aG9kKSkgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiLCBjb250ZXh0LmFyZyA9IG5ldyBUeXBlRXJyb3IoXCJUaGUgaXRlcmF0b3IgZG9lcyBub3QgcHJvdmlkZSBhICd0aHJvdycgbWV0aG9kXCIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9XG5cbiAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2gobWV0aG9kLCBkZWxlZ2F0ZS5pdGVyYXRvciwgY29udGV4dC5hcmcpO1xuICAgIGlmIChcInRocm93XCIgPT09IHJlY29yZC50eXBlKSByZXR1cm4gY29udGV4dC5tZXRob2QgPSBcInRocm93XCIsIGNvbnRleHQuYXJnID0gcmVjb3JkLmFyZywgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGwsIENvbnRpbnVlU2VudGluZWw7XG4gICAgdmFyIGluZm8gPSByZWNvcmQuYXJnO1xuICAgIHJldHVybiBpbmZvID8gaW5mby5kb25lID8gKGNvbnRleHRbZGVsZWdhdGUucmVzdWx0TmFtZV0gPSBpbmZvLnZhbHVlLCBjb250ZXh0Lm5leHQgPSBkZWxlZ2F0ZS5uZXh0TG9jLCBcInJldHVyblwiICE9PSBjb250ZXh0Lm1ldGhvZCAmJiAoY29udGV4dC5tZXRob2QgPSBcIm5leHRcIiwgY29udGV4dC5hcmcgPSB1bmRlZmluZWQpLCBjb250ZXh0LmRlbGVnYXRlID0gbnVsbCwgQ29udGludWVTZW50aW5lbCkgOiBpbmZvIDogKGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiLCBjb250ZXh0LmFyZyA9IG5ldyBUeXBlRXJyb3IoXCJpdGVyYXRvciByZXN1bHQgaXMgbm90IGFuIG9iamVjdFwiKSwgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGwsIENvbnRpbnVlU2VudGluZWwpO1xuICB9XG5cbiAgZnVuY3Rpb24gcHVzaFRyeUVudHJ5KGxvY3MpIHtcbiAgICB2YXIgZW50cnkgPSB7XG4gICAgICB0cnlMb2M6IGxvY3NbMF1cbiAgICB9O1xuICAgIDEgaW4gbG9jcyAmJiAoZW50cnkuY2F0Y2hMb2MgPSBsb2NzWzFdKSwgMiBpbiBsb2NzICYmIChlbnRyeS5maW5hbGx5TG9jID0gbG9jc1syXSwgZW50cnkuYWZ0ZXJMb2MgPSBsb2NzWzNdKSwgdGhpcy50cnlFbnRyaWVzLnB1c2goZW50cnkpO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVzZXRUcnlFbnRyeShlbnRyeSkge1xuICAgIHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uIHx8IHt9O1xuICAgIHJlY29yZC50eXBlID0gXCJub3JtYWxcIiwgZGVsZXRlIHJlY29yZC5hcmcsIGVudHJ5LmNvbXBsZXRpb24gPSByZWNvcmQ7XG4gIH1cblxuICBmdW5jdGlvbiBDb250ZXh0KHRyeUxvY3NMaXN0KSB7XG4gICAgdGhpcy50cnlFbnRyaWVzID0gW3tcbiAgICAgIHRyeUxvYzogXCJyb290XCJcbiAgICB9XSwgdHJ5TG9jc0xpc3QuZm9yRWFjaChwdXNoVHJ5RW50cnksIHRoaXMpLCB0aGlzLnJlc2V0KCEwKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHZhbHVlcyhpdGVyYWJsZSkge1xuICAgIGlmIChpdGVyYWJsZSkge1xuICAgICAgdmFyIGl0ZXJhdG9yTWV0aG9kID0gaXRlcmFibGVbaXRlcmF0b3JTeW1ib2xdO1xuICAgICAgaWYgKGl0ZXJhdG9yTWV0aG9kKSByZXR1cm4gaXRlcmF0b3JNZXRob2QuY2FsbChpdGVyYWJsZSk7XG4gICAgICBpZiAoXCJmdW5jdGlvblwiID09IHR5cGVvZiBpdGVyYWJsZS5uZXh0KSByZXR1cm4gaXRlcmFibGU7XG5cbiAgICAgIGlmICghaXNOYU4oaXRlcmFibGUubGVuZ3RoKSkge1xuICAgICAgICB2YXIgaSA9IC0xLFxuICAgICAgICAgICAgbmV4dCA9IGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICAgICAgZm9yICg7ICsraSA8IGl0ZXJhYmxlLmxlbmd0aDspIHtcbiAgICAgICAgICAgIGlmIChoYXNPd24uY2FsbChpdGVyYWJsZSwgaSkpIHJldHVybiBuZXh0LnZhbHVlID0gaXRlcmFibGVbaV0sIG5leHQuZG9uZSA9ICExLCBuZXh0O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBuZXh0LnZhbHVlID0gdW5kZWZpbmVkLCBuZXh0LmRvbmUgPSAhMCwgbmV4dDtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gbmV4dC5uZXh0ID0gbmV4dDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgbmV4dDogZG9uZVJlc3VsdFxuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBkb25lUmVzdWx0KCkge1xuICAgIHJldHVybiB7XG4gICAgICB2YWx1ZTogdW5kZWZpbmVkLFxuICAgICAgZG9uZTogITBcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIEdlbmVyYXRvckZ1bmN0aW9uLnByb3RvdHlwZSA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLCBkZWZpbmUoR3AsIFwiY29uc3RydWN0b3JcIiwgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUpLCBkZWZpbmUoR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUsIFwiY29uc3RydWN0b3JcIiwgR2VuZXJhdG9yRnVuY3Rpb24pLCBHZW5lcmF0b3JGdW5jdGlvbi5kaXNwbGF5TmFtZSA9IGRlZmluZShHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSwgdG9TdHJpbmdUYWdTeW1ib2wsIFwiR2VuZXJhdG9yRnVuY3Rpb25cIiksIGV4cG9ydHMuaXNHZW5lcmF0b3JGdW5jdGlvbiA9IGZ1bmN0aW9uIChnZW5GdW4pIHtcbiAgICB2YXIgY3RvciA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgZ2VuRnVuICYmIGdlbkZ1bi5jb25zdHJ1Y3RvcjtcbiAgICByZXR1cm4gISFjdG9yICYmIChjdG9yID09PSBHZW5lcmF0b3JGdW5jdGlvbiB8fCBcIkdlbmVyYXRvckZ1bmN0aW9uXCIgPT09IChjdG9yLmRpc3BsYXlOYW1lIHx8IGN0b3IubmFtZSkpO1xuICB9LCBleHBvcnRzLm1hcmsgPSBmdW5jdGlvbiAoZ2VuRnVuKSB7XG4gICAgcmV0dXJuIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihnZW5GdW4sIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlKSA6IChnZW5GdW4uX19wcm90b19fID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUsIGRlZmluZShnZW5GdW4sIHRvU3RyaW5nVGFnU3ltYm9sLCBcIkdlbmVyYXRvckZ1bmN0aW9uXCIpKSwgZ2VuRnVuLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoR3ApLCBnZW5GdW47XG4gIH0sIGV4cG9ydHMuYXdyYXAgPSBmdW5jdGlvbiAoYXJnKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIF9fYXdhaXQ6IGFyZ1xuICAgIH07XG4gIH0sIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhBc3luY0l0ZXJhdG9yLnByb3RvdHlwZSksIGRlZmluZShBc3luY0l0ZXJhdG9yLnByb3RvdHlwZSwgYXN5bmNJdGVyYXRvclN5bWJvbCwgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9KSwgZXhwb3J0cy5Bc3luY0l0ZXJhdG9yID0gQXN5bmNJdGVyYXRvciwgZXhwb3J0cy5hc3luYyA9IGZ1bmN0aW9uIChpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdCwgUHJvbWlzZUltcGwpIHtcbiAgICB2b2lkIDAgPT09IFByb21pc2VJbXBsICYmIChQcm9taXNlSW1wbCA9IFByb21pc2UpO1xuICAgIHZhciBpdGVyID0gbmV3IEFzeW5jSXRlcmF0b3Iod3JhcChpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdCksIFByb21pc2VJbXBsKTtcbiAgICByZXR1cm4gZXhwb3J0cy5pc0dlbmVyYXRvckZ1bmN0aW9uKG91dGVyRm4pID8gaXRlciA6IGl0ZXIubmV4dCgpLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgcmV0dXJuIHJlc3VsdC5kb25lID8gcmVzdWx0LnZhbHVlIDogaXRlci5uZXh0KCk7XG4gICAgfSk7XG4gIH0sIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhHcCksIGRlZmluZShHcCwgdG9TdHJpbmdUYWdTeW1ib2wsIFwiR2VuZXJhdG9yXCIpLCBkZWZpbmUoR3AsIGl0ZXJhdG9yU3ltYm9sLCBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0pLCBkZWZpbmUoR3AsIFwidG9TdHJpbmdcIiwgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBcIltvYmplY3QgR2VuZXJhdG9yXVwiO1xuICB9KSwgZXhwb3J0cy5rZXlzID0gZnVuY3Rpb24gKG9iamVjdCkge1xuICAgIHZhciBrZXlzID0gW107XG5cbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqZWN0KSB7XG4gICAgICBrZXlzLnB1c2goa2V5KTtcbiAgICB9XG5cbiAgICByZXR1cm4ga2V5cy5yZXZlcnNlKCksIGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICBmb3IgKDsga2V5cy5sZW5ndGg7KSB7XG4gICAgICAgIHZhciBrZXkgPSBrZXlzLnBvcCgpO1xuICAgICAgICBpZiAoa2V5IGluIG9iamVjdCkgcmV0dXJuIG5leHQudmFsdWUgPSBrZXksIG5leHQuZG9uZSA9ICExLCBuZXh0O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmV4dC5kb25lID0gITAsIG5leHQ7XG4gICAgfTtcbiAgfSwgZXhwb3J0cy52YWx1ZXMgPSB2YWx1ZXMsIENvbnRleHQucHJvdG90eXBlID0ge1xuICAgIGNvbnN0cnVjdG9yOiBDb250ZXh0LFxuICAgIHJlc2V0OiBmdW5jdGlvbiByZXNldChza2lwVGVtcFJlc2V0KSB7XG4gICAgICBpZiAodGhpcy5wcmV2ID0gMCwgdGhpcy5uZXh0ID0gMCwgdGhpcy5zZW50ID0gdGhpcy5fc2VudCA9IHVuZGVmaW5lZCwgdGhpcy5kb25lID0gITEsIHRoaXMuZGVsZWdhdGUgPSBudWxsLCB0aGlzLm1ldGhvZCA9IFwibmV4dFwiLCB0aGlzLmFyZyA9IHVuZGVmaW5lZCwgdGhpcy50cnlFbnRyaWVzLmZvckVhY2gocmVzZXRUcnlFbnRyeSksICFza2lwVGVtcFJlc2V0KSBmb3IgKHZhciBuYW1lIGluIHRoaXMpIHtcbiAgICAgICAgXCJ0XCIgPT09IG5hbWUuY2hhckF0KDApICYmIGhhc093bi5jYWxsKHRoaXMsIG5hbWUpICYmICFpc05hTigrbmFtZS5zbGljZSgxKSkgJiYgKHRoaXNbbmFtZV0gPSB1bmRlZmluZWQpO1xuICAgICAgfVxuICAgIH0sXG4gICAgc3RvcDogZnVuY3Rpb24gc3RvcCgpIHtcbiAgICAgIHRoaXMuZG9uZSA9ICEwO1xuICAgICAgdmFyIHJvb3RSZWNvcmQgPSB0aGlzLnRyeUVudHJpZXNbMF0uY29tcGxldGlvbjtcbiAgICAgIGlmIChcInRocm93XCIgPT09IHJvb3RSZWNvcmQudHlwZSkgdGhyb3cgcm9vdFJlY29yZC5hcmc7XG4gICAgICByZXR1cm4gdGhpcy5ydmFsO1xuICAgIH0sXG4gICAgZGlzcGF0Y2hFeGNlcHRpb246IGZ1bmN0aW9uIGRpc3BhdGNoRXhjZXB0aW9uKGV4Y2VwdGlvbikge1xuICAgICAgaWYgKHRoaXMuZG9uZSkgdGhyb3cgZXhjZXB0aW9uO1xuICAgICAgdmFyIGNvbnRleHQgPSB0aGlzO1xuXG4gICAgICBmdW5jdGlvbiBoYW5kbGUobG9jLCBjYXVnaHQpIHtcbiAgICAgICAgcmV0dXJuIHJlY29yZC50eXBlID0gXCJ0aHJvd1wiLCByZWNvcmQuYXJnID0gZXhjZXB0aW9uLCBjb250ZXh0Lm5leHQgPSBsb2MsIGNhdWdodCAmJiAoY29udGV4dC5tZXRob2QgPSBcIm5leHRcIiwgY29udGV4dC5hcmcgPSB1bmRlZmluZWQpLCAhIWNhdWdodDtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV0sXG4gICAgICAgICAgICByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uO1xuICAgICAgICBpZiAoXCJyb290XCIgPT09IGVudHJ5LnRyeUxvYykgcmV0dXJuIGhhbmRsZShcImVuZFwiKTtcblxuICAgICAgICBpZiAoZW50cnkudHJ5TG9jIDw9IHRoaXMucHJldikge1xuICAgICAgICAgIHZhciBoYXNDYXRjaCA9IGhhc093bi5jYWxsKGVudHJ5LCBcImNhdGNoTG9jXCIpLFxuICAgICAgICAgICAgICBoYXNGaW5hbGx5ID0gaGFzT3duLmNhbGwoZW50cnksIFwiZmluYWxseUxvY1wiKTtcblxuICAgICAgICAgIGlmIChoYXNDYXRjaCAmJiBoYXNGaW5hbGx5KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuY2F0Y2hMb2MpIHJldHVybiBoYW5kbGUoZW50cnkuY2F0Y2hMb2MsICEwKTtcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSByZXR1cm4gaGFuZGxlKGVudHJ5LmZpbmFsbHlMb2MpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoaGFzQ2F0Y2gpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5jYXRjaExvYykgcmV0dXJuIGhhbmRsZShlbnRyeS5jYXRjaExvYywgITApO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoIWhhc0ZpbmFsbHkpIHRocm93IG5ldyBFcnJvcihcInRyeSBzdGF0ZW1lbnQgd2l0aG91dCBjYXRjaCBvciBmaW5hbGx5XCIpO1xuICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHJldHVybiBoYW5kbGUoZW50cnkuZmluYWxseUxvYyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBhYnJ1cHQ6IGZ1bmN0aW9uIGFicnVwdCh0eXBlLCBhcmcpIHtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuXG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPD0gdGhpcy5wcmV2ICYmIGhhc093bi5jYWxsKGVudHJ5LCBcImZpbmFsbHlMb2NcIikgJiYgdGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAgIHZhciBmaW5hbGx5RW50cnkgPSBlbnRyeTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmaW5hbGx5RW50cnkgJiYgKFwiYnJlYWtcIiA9PT0gdHlwZSB8fCBcImNvbnRpbnVlXCIgPT09IHR5cGUpICYmIGZpbmFsbHlFbnRyeS50cnlMb2MgPD0gYXJnICYmIGFyZyA8PSBmaW5hbGx5RW50cnkuZmluYWxseUxvYyAmJiAoZmluYWxseUVudHJ5ID0gbnVsbCk7XG4gICAgICB2YXIgcmVjb3JkID0gZmluYWxseUVudHJ5ID8gZmluYWxseUVudHJ5LmNvbXBsZXRpb24gOiB7fTtcbiAgICAgIHJldHVybiByZWNvcmQudHlwZSA9IHR5cGUsIHJlY29yZC5hcmcgPSBhcmcsIGZpbmFsbHlFbnRyeSA/ICh0aGlzLm1ldGhvZCA9IFwibmV4dFwiLCB0aGlzLm5leHQgPSBmaW5hbGx5RW50cnkuZmluYWxseUxvYywgQ29udGludWVTZW50aW5lbCkgOiB0aGlzLmNvbXBsZXRlKHJlY29yZCk7XG4gICAgfSxcbiAgICBjb21wbGV0ZTogZnVuY3Rpb24gY29tcGxldGUocmVjb3JkLCBhZnRlckxvYykge1xuICAgICAgaWYgKFwidGhyb3dcIiA9PT0gcmVjb3JkLnR5cGUpIHRocm93IHJlY29yZC5hcmc7XG4gICAgICByZXR1cm4gXCJicmVha1wiID09PSByZWNvcmQudHlwZSB8fCBcImNvbnRpbnVlXCIgPT09IHJlY29yZC50eXBlID8gdGhpcy5uZXh0ID0gcmVjb3JkLmFyZyA6IFwicmV0dXJuXCIgPT09IHJlY29yZC50eXBlID8gKHRoaXMucnZhbCA9IHRoaXMuYXJnID0gcmVjb3JkLmFyZywgdGhpcy5tZXRob2QgPSBcInJldHVyblwiLCB0aGlzLm5leHQgPSBcImVuZFwiKSA6IFwibm9ybWFsXCIgPT09IHJlY29yZC50eXBlICYmIGFmdGVyTG9jICYmICh0aGlzLm5leHQgPSBhZnRlckxvYyksIENvbnRpbnVlU2VudGluZWw7XG4gICAgfSxcbiAgICBmaW5pc2g6IGZ1bmN0aW9uIGZpbmlzaChmaW5hbGx5TG9jKSB7XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgaWYgKGVudHJ5LmZpbmFsbHlMb2MgPT09IGZpbmFsbHlMb2MpIHJldHVybiB0aGlzLmNvbXBsZXRlKGVudHJ5LmNvbXBsZXRpb24sIGVudHJ5LmFmdGVyTG9jKSwgcmVzZXRUcnlFbnRyeShlbnRyeSksIENvbnRpbnVlU2VudGluZWw7XG4gICAgICB9XG4gICAgfSxcbiAgICBcImNhdGNoXCI6IGZ1bmN0aW9uIF9jYXRjaCh0cnlMb2MpIHtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuXG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPT09IHRyeUxvYykge1xuICAgICAgICAgIHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uO1xuXG4gICAgICAgICAgaWYgKFwidGhyb3dcIiA9PT0gcmVjb3JkLnR5cGUpIHtcbiAgICAgICAgICAgIHZhciB0aHJvd24gPSByZWNvcmQuYXJnO1xuICAgICAgICAgICAgcmVzZXRUcnlFbnRyeShlbnRyeSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHRocm93bjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbGxlZ2FsIGNhdGNoIGF0dGVtcHRcIik7XG4gICAgfSxcbiAgICBkZWxlZ2F0ZVlpZWxkOiBmdW5jdGlvbiBkZWxlZ2F0ZVlpZWxkKGl0ZXJhYmxlLCByZXN1bHROYW1lLCBuZXh0TG9jKSB7XG4gICAgICByZXR1cm4gdGhpcy5kZWxlZ2F0ZSA9IHtcbiAgICAgICAgaXRlcmF0b3I6IHZhbHVlcyhpdGVyYWJsZSksXG4gICAgICAgIHJlc3VsdE5hbWU6IHJlc3VsdE5hbWUsXG4gICAgICAgIG5leHRMb2M6IG5leHRMb2NcbiAgICAgIH0sIFwibmV4dFwiID09PSB0aGlzLm1ldGhvZCAmJiAodGhpcy5hcmcgPSB1bmRlZmluZWQpLCBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cbiAgfSwgZXhwb3J0cztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfcmVnZW5lcmF0b3JSdW50aW1lLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZSwgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHM7IiwidmFyIGdldFByb3RvdHlwZU9mID0gcmVxdWlyZShcIi4vZ2V0UHJvdG90eXBlT2YuanNcIik7XG5cbmZ1bmN0aW9uIF9zdXBlclByb3BCYXNlKG9iamVjdCwgcHJvcGVydHkpIHtcbiAgd2hpbGUgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSkpIHtcbiAgICBvYmplY3QgPSBnZXRQcm90b3R5cGVPZihvYmplY3QpO1xuICAgIGlmIChvYmplY3QgPT09IG51bGwpIGJyZWFrO1xuICB9XG5cbiAgcmV0dXJuIG9iamVjdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfc3VwZXJQcm9wQmFzZSwgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzOyIsInZhciBhcnJheUxpa2VUb0FycmF5ID0gcmVxdWlyZShcIi4vYXJyYXlMaWtlVG9BcnJheS5qc1wiKTtcblxuZnVuY3Rpb24gX2FycmF5V2l0aG91dEhvbGVzKGFycikge1xuICBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSByZXR1cm4gYXJyYXlMaWtlVG9BcnJheShhcnIpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9hcnJheVdpdGhvdXRIb2xlcywgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzOyIsImZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXkoaXRlcikge1xuICBpZiAodHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBpdGVyW1N5bWJvbC5pdGVyYXRvcl0gIT0gbnVsbCB8fCBpdGVyW1wiQEBpdGVyYXRvclwiXSAhPSBudWxsKSByZXR1cm4gQXJyYXkuZnJvbShpdGVyKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfaXRlcmFibGVUb0FycmF5LCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZSwgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHM7IiwiZnVuY3Rpb24gX25vbkl0ZXJhYmxlU3ByZWFkKCkge1xuICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIHNwcmVhZCBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfbm9uSXRlcmFibGVTcHJlYWQsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlLCBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0czsiLCJ2YXIgYmFzZVBpY2tCeSA9IHJlcXVpcmUoJy4vX2Jhc2VQaWNrQnknKSxcbiAgICBoYXNJbiA9IHJlcXVpcmUoJy4vaGFzSW4nKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5waWNrYCB3aXRob3V0IHN1cHBvcnQgZm9yIGluZGl2aWR1YWxcbiAqIHByb3BlcnR5IGlkZW50aWZpZXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBzb3VyY2Ugb2JqZWN0LlxuICogQHBhcmFtIHtzdHJpbmdbXX0gcGF0aHMgVGhlIHByb3BlcnR5IHBhdGhzIHRvIHBpY2suXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgb2JqZWN0LlxuICovXG5mdW5jdGlvbiBiYXNlUGljayhvYmplY3QsIHBhdGhzKSB7XG4gIHJldHVybiBiYXNlUGlja0J5KG9iamVjdCwgcGF0aHMsIGZ1bmN0aW9uKHZhbHVlLCBwYXRoKSB7XG4gICAgcmV0dXJuIGhhc0luKG9iamVjdCwgcGF0aCk7XG4gIH0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VQaWNrO1xuIiwidmFyIGJhc2VHZXQgPSByZXF1aXJlKCcuL19iYXNlR2V0JyksXG4gICAgYmFzZVNldCA9IHJlcXVpcmUoJy4vX2Jhc2VTZXQnKSxcbiAgICBjYXN0UGF0aCA9IHJlcXVpcmUoJy4vX2Nhc3RQYXRoJyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgIGBfLnBpY2tCeWAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBzb3VyY2Ugb2JqZWN0LlxuICogQHBhcmFtIHtzdHJpbmdbXX0gcGF0aHMgVGhlIHByb3BlcnR5IHBhdGhzIHRvIHBpY2suXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIHByb3BlcnR5LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gYmFzZVBpY2tCeShvYmplY3QsIHBhdGhzLCBwcmVkaWNhdGUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBwYXRocy5sZW5ndGgsXG4gICAgICByZXN1bHQgPSB7fTtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBwYXRoID0gcGF0aHNbaW5kZXhdLFxuICAgICAgICB2YWx1ZSA9IGJhc2VHZXQob2JqZWN0LCBwYXRoKTtcblxuICAgIGlmIChwcmVkaWNhdGUodmFsdWUsIHBhdGgpKSB7XG4gICAgICBiYXNlU2V0KHJlc3VsdCwgY2FzdFBhdGgocGF0aCwgb2JqZWN0KSwgdmFsdWUpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VQaWNrQnk7XG4iLCJ2YXIgY2FzdFBhdGggPSByZXF1aXJlKCcuL19jYXN0UGF0aCcpLFxuICAgIHRvS2V5ID0gcmVxdWlyZSgnLi9fdG9LZXknKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5nZXRgIHdpdGhvdXQgc3VwcG9ydCBmb3IgZGVmYXVsdCB2YWx1ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmVzb2x2ZWQgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGJhc2VHZXQob2JqZWN0LCBwYXRoKSB7XG4gIHBhdGggPSBjYXN0UGF0aChwYXRoLCBvYmplY3QpO1xuXG4gIHZhciBpbmRleCA9IDAsXG4gICAgICBsZW5ndGggPSBwYXRoLmxlbmd0aDtcblxuICB3aGlsZSAob2JqZWN0ICE9IG51bGwgJiYgaW5kZXggPCBsZW5ndGgpIHtcbiAgICBvYmplY3QgPSBvYmplY3RbdG9LZXkocGF0aFtpbmRleCsrXSldO1xuICB9XG4gIHJldHVybiAoaW5kZXggJiYgaW5kZXggPT0gbGVuZ3RoKSA/IG9iamVjdCA6IHVuZGVmaW5lZDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlR2V0O1xuIiwidmFyIGlzQXJyYXkgPSByZXF1aXJlKCcuL2lzQXJyYXknKSxcbiAgICBpc1N5bWJvbCA9IHJlcXVpcmUoJy4vaXNTeW1ib2wnKTtcblxuLyoqIFVzZWQgdG8gbWF0Y2ggcHJvcGVydHkgbmFtZXMgd2l0aGluIHByb3BlcnR5IHBhdGhzLiAqL1xudmFyIHJlSXNEZWVwUHJvcCA9IC9cXC58XFxbKD86W15bXFxdXSp8KFtcIiddKSg/Oig/IVxcMSlbXlxcXFxdfFxcXFwuKSo/XFwxKVxcXS8sXG4gICAgcmVJc1BsYWluUHJvcCA9IC9eXFx3KiQvO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgcHJvcGVydHkgbmFtZSBhbmQgbm90IGEgcHJvcGVydHkgcGF0aC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIG9iamVjdCB0byBxdWVyeSBrZXlzIG9uLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBwcm9wZXJ0eSBuYW1lLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzS2V5KHZhbHVlLCBvYmplY3QpIHtcbiAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICBpZiAodHlwZSA9PSAnbnVtYmVyJyB8fCB0eXBlID09ICdzeW1ib2wnIHx8IHR5cGUgPT0gJ2Jvb2xlYW4nIHx8XG4gICAgICB2YWx1ZSA9PSBudWxsIHx8IGlzU3ltYm9sKHZhbHVlKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiByZUlzUGxhaW5Qcm9wLnRlc3QodmFsdWUpIHx8ICFyZUlzRGVlcFByb3AudGVzdCh2YWx1ZSkgfHxcbiAgICAob2JqZWN0ICE9IG51bGwgJiYgdmFsdWUgaW4gT2JqZWN0KG9iamVjdCkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzS2V5O1xuIiwidmFyIG1lbW9pemVDYXBwZWQgPSByZXF1aXJlKCcuL19tZW1vaXplQ2FwcGVkJyk7XG5cbi8qKiBVc2VkIHRvIG1hdGNoIHByb3BlcnR5IG5hbWVzIHdpdGhpbiBwcm9wZXJ0eSBwYXRocy4gKi9cbnZhciByZVByb3BOYW1lID0gL1teLltcXF1dK3xcXFsoPzooLT9cXGQrKD86XFwuXFxkKyk/KXwoW1wiJ10pKCg/Oig/IVxcMilbXlxcXFxdfFxcXFwuKSo/KVxcMilcXF18KD89KD86XFwufFxcW1xcXSkoPzpcXC58XFxbXFxdfCQpKS9nO1xuXG4vKiogVXNlZCB0byBtYXRjaCBiYWNrc2xhc2hlcyBpbiBwcm9wZXJ0eSBwYXRocy4gKi9cbnZhciByZUVzY2FwZUNoYXIgPSAvXFxcXChcXFxcKT8vZztcblxuLyoqXG4gKiBDb252ZXJ0cyBgc3RyaW5nYCB0byBhIHByb3BlcnR5IHBhdGggYXJyYXkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBwcm9wZXJ0eSBwYXRoIGFycmF5LlxuICovXG52YXIgc3RyaW5nVG9QYXRoID0gbWVtb2l6ZUNhcHBlZChmdW5jdGlvbihzdHJpbmcpIHtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICBpZiAoc3RyaW5nLmNoYXJDb2RlQXQoMCkgPT09IDQ2IC8qIC4gKi8pIHtcbiAgICByZXN1bHQucHVzaCgnJyk7XG4gIH1cbiAgc3RyaW5nLnJlcGxhY2UocmVQcm9wTmFtZSwgZnVuY3Rpb24obWF0Y2gsIG51bWJlciwgcXVvdGUsIHN1YlN0cmluZykge1xuICAgIHJlc3VsdC5wdXNoKHF1b3RlID8gc3ViU3RyaW5nLnJlcGxhY2UocmVFc2NhcGVDaGFyLCAnJDEnKSA6IChudW1iZXIgfHwgbWF0Y2gpKTtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBzdHJpbmdUb1BhdGg7XG4iLCJ2YXIgbWVtb2l6ZSA9IHJlcXVpcmUoJy4vbWVtb2l6ZScpO1xuXG4vKiogVXNlZCBhcyB0aGUgbWF4aW11bSBtZW1vaXplIGNhY2hlIHNpemUuICovXG52YXIgTUFYX01FTU9JWkVfU0laRSA9IDUwMDtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8ubWVtb2l6ZWAgd2hpY2ggY2xlYXJzIHRoZSBtZW1vaXplZCBmdW5jdGlvbidzXG4gKiBjYWNoZSB3aGVuIGl0IGV4Y2VlZHMgYE1BWF9NRU1PSVpFX1NJWkVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBoYXZlIGl0cyBvdXRwdXQgbWVtb2l6ZWQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBtZW1vaXplZCBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gbWVtb2l6ZUNhcHBlZChmdW5jKSB7XG4gIHZhciByZXN1bHQgPSBtZW1vaXplKGZ1bmMsIGZ1bmN0aW9uKGtleSkge1xuICAgIGlmIChjYWNoZS5zaXplID09PSBNQVhfTUVNT0laRV9TSVpFKSB7XG4gICAgICBjYWNoZS5jbGVhcigpO1xuICAgIH1cbiAgICByZXR1cm4ga2V5O1xuICB9KTtcblxuICB2YXIgY2FjaGUgPSByZXN1bHQuY2FjaGU7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWVtb2l6ZUNhcHBlZDtcbiIsInZhciBNYXBDYWNoZSA9IHJlcXVpcmUoJy4vX01hcENhY2hlJyk7XG5cbi8qKiBFcnJvciBtZXNzYWdlIGNvbnN0YW50cy4gKi9cbnZhciBGVU5DX0VSUk9SX1RFWFQgPSAnRXhwZWN0ZWQgYSBmdW5jdGlvbic7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgbWVtb2l6ZXMgdGhlIHJlc3VsdCBvZiBgZnVuY2AuIElmIGByZXNvbHZlcmAgaXNcbiAqIHByb3ZpZGVkLCBpdCBkZXRlcm1pbmVzIHRoZSBjYWNoZSBrZXkgZm9yIHN0b3JpbmcgdGhlIHJlc3VsdCBiYXNlZCBvbiB0aGVcbiAqIGFyZ3VtZW50cyBwcm92aWRlZCB0byB0aGUgbWVtb2l6ZWQgZnVuY3Rpb24uIEJ5IGRlZmF1bHQsIHRoZSBmaXJzdCBhcmd1bWVudFxuICogcHJvdmlkZWQgdG8gdGhlIG1lbW9pemVkIGZ1bmN0aW9uIGlzIHVzZWQgYXMgdGhlIG1hcCBjYWNoZSBrZXkuIFRoZSBgZnVuY2BcbiAqIGlzIGludm9rZWQgd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgb2YgdGhlIG1lbW9pemVkIGZ1bmN0aW9uLlxuICpcbiAqICoqTm90ZToqKiBUaGUgY2FjaGUgaXMgZXhwb3NlZCBhcyB0aGUgYGNhY2hlYCBwcm9wZXJ0eSBvbiB0aGUgbWVtb2l6ZWRcbiAqIGZ1bmN0aW9uLiBJdHMgY3JlYXRpb24gbWF5IGJlIGN1c3RvbWl6ZWQgYnkgcmVwbGFjaW5nIHRoZSBgXy5tZW1vaXplLkNhY2hlYFxuICogY29uc3RydWN0b3Igd2l0aCBvbmUgd2hvc2UgaW5zdGFuY2VzIGltcGxlbWVudCB0aGVcbiAqIFtgTWFwYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtcHJvcGVydGllcy1vZi10aGUtbWFwLXByb3RvdHlwZS1vYmplY3QpXG4gKiBtZXRob2QgaW50ZXJmYWNlIG9mIGBjbGVhcmAsIGBkZWxldGVgLCBgZ2V0YCwgYGhhc2AsIGFuZCBgc2V0YC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGhhdmUgaXRzIG91dHB1dCBtZW1vaXplZC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtyZXNvbHZlcl0gVGhlIGZ1bmN0aW9uIHRvIHJlc29sdmUgdGhlIGNhY2hlIGtleS5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IG1lbW9pemVkIGZ1bmN0aW9uLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEsICdiJzogMiB9O1xuICogdmFyIG90aGVyID0geyAnYyc6IDMsICdkJzogNCB9O1xuICpcbiAqIHZhciB2YWx1ZXMgPSBfLm1lbW9pemUoXy52YWx1ZXMpO1xuICogdmFsdWVzKG9iamVjdCk7XG4gKiAvLyA9PiBbMSwgMl1cbiAqXG4gKiB2YWx1ZXMob3RoZXIpO1xuICogLy8gPT4gWzMsIDRdXG4gKlxuICogb2JqZWN0LmEgPSAyO1xuICogdmFsdWVzKG9iamVjdCk7XG4gKiAvLyA9PiBbMSwgMl1cbiAqXG4gKiAvLyBNb2RpZnkgdGhlIHJlc3VsdCBjYWNoZS5cbiAqIHZhbHVlcy5jYWNoZS5zZXQob2JqZWN0LCBbJ2EnLCAnYiddKTtcbiAqIHZhbHVlcyhvYmplY3QpO1xuICogLy8gPT4gWydhJywgJ2InXVxuICpcbiAqIC8vIFJlcGxhY2UgYF8ubWVtb2l6ZS5DYWNoZWAuXG4gKiBfLm1lbW9pemUuQ2FjaGUgPSBXZWFrTWFwO1xuICovXG5mdW5jdGlvbiBtZW1vaXplKGZ1bmMsIHJlc29sdmVyKSB7XG4gIGlmICh0eXBlb2YgZnVuYyAhPSAnZnVuY3Rpb24nIHx8IChyZXNvbHZlciAhPSBudWxsICYmIHR5cGVvZiByZXNvbHZlciAhPSAnZnVuY3Rpb24nKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcbiAgfVxuICB2YXIgbWVtb2l6ZWQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgYXJncyA9IGFyZ3VtZW50cyxcbiAgICAgICAga2V5ID0gcmVzb2x2ZXIgPyByZXNvbHZlci5hcHBseSh0aGlzLCBhcmdzKSA6IGFyZ3NbMF0sXG4gICAgICAgIGNhY2hlID0gbWVtb2l6ZWQuY2FjaGU7XG5cbiAgICBpZiAoY2FjaGUuaGFzKGtleSkpIHtcbiAgICAgIHJldHVybiBjYWNoZS5nZXQoa2V5KTtcbiAgICB9XG4gICAgdmFyIHJlc3VsdCA9IGZ1bmMuYXBwbHkodGhpcywgYXJncyk7XG4gICAgbWVtb2l6ZWQuY2FjaGUgPSBjYWNoZS5zZXQoa2V5LCByZXN1bHQpIHx8IGNhY2hlO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG4gIG1lbW9pemVkLmNhY2hlID0gbmV3IChtZW1vaXplLkNhY2hlIHx8IE1hcENhY2hlKTtcbiAgcmV0dXJuIG1lbW9pemVkO1xufVxuXG4vLyBFeHBvc2UgYE1hcENhY2hlYC5cbm1lbW9pemUuQ2FjaGUgPSBNYXBDYWNoZTtcblxubW9kdWxlLmV4cG9ydHMgPSBtZW1vaXplO1xuIiwidmFyIGJhc2VUb1N0cmluZyA9IHJlcXVpcmUoJy4vX2Jhc2VUb1N0cmluZycpO1xuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBzdHJpbmcuIEFuIGVtcHR5IHN0cmluZyBpcyByZXR1cm5lZCBmb3IgYG51bGxgXG4gKiBhbmQgYHVuZGVmaW5lZGAgdmFsdWVzLiBUaGUgc2lnbiBvZiBgLTBgIGlzIHByZXNlcnZlZC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBzdHJpbmcuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8udG9TdHJpbmcobnVsbCk7XG4gKiAvLyA9PiAnJ1xuICpcbiAqIF8udG9TdHJpbmcoLTApO1xuICogLy8gPT4gJy0wJ1xuICpcbiAqIF8udG9TdHJpbmcoWzEsIDIsIDNdKTtcbiAqIC8vID0+ICcxLDIsMydcbiAqL1xuZnVuY3Rpb24gdG9TdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID09IG51bGwgPyAnJyA6IGJhc2VUb1N0cmluZyh2YWx1ZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdG9TdHJpbmc7XG4iLCJ2YXIgU3ltYm9sID0gcmVxdWlyZSgnLi9fU3ltYm9sJyksXG4gICAgYXJyYXlNYXAgPSByZXF1aXJlKCcuL19hcnJheU1hcCcpLFxuICAgIGlzQXJyYXkgPSByZXF1aXJlKCcuL2lzQXJyYXknKSxcbiAgICBpc1N5bWJvbCA9IHJlcXVpcmUoJy4vaXNTeW1ib2wnKTtcblxuLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG52YXIgSU5GSU5JVFkgPSAxIC8gMDtcblxuLyoqIFVzZWQgdG8gY29udmVydCBzeW1ib2xzIHRvIHByaW1pdGl2ZXMgYW5kIHN0cmluZ3MuICovXG52YXIgc3ltYm9sUHJvdG8gPSBTeW1ib2wgPyBTeW1ib2wucHJvdG90eXBlIDogdW5kZWZpbmVkLFxuICAgIHN5bWJvbFRvU3RyaW5nID0gc3ltYm9sUHJvdG8gPyBzeW1ib2xQcm90by50b1N0cmluZyA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy50b1N0cmluZ2Agd2hpY2ggZG9lc24ndCBjb252ZXJ0IG51bGxpc2hcbiAqIHZhbHVlcyB0byBlbXB0eSBzdHJpbmdzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBwcm9jZXNzLlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgc3RyaW5nLlxuICovXG5mdW5jdGlvbiBiYXNlVG9TdHJpbmcodmFsdWUpIHtcbiAgLy8gRXhpdCBlYXJseSBmb3Igc3RyaW5ncyB0byBhdm9pZCBhIHBlcmZvcm1hbmNlIGhpdCBpbiBzb21lIGVudmlyb25tZW50cy5cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAvLyBSZWN1cnNpdmVseSBjb252ZXJ0IHZhbHVlcyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgIHJldHVybiBhcnJheU1hcCh2YWx1ZSwgYmFzZVRvU3RyaW5nKSArICcnO1xuICB9XG4gIGlmIChpc1N5bWJvbCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gc3ltYm9sVG9TdHJpbmcgPyBzeW1ib2xUb1N0cmluZy5jYWxsKHZhbHVlKSA6ICcnO1xuICB9XG4gIHZhciByZXN1bHQgPSAodmFsdWUgKyAnJyk7XG4gIHJldHVybiAocmVzdWx0ID09ICcwJyAmJiAoMSAvIHZhbHVlKSA9PSAtSU5GSU5JVFkpID8gJy0wJyA6IHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlVG9TdHJpbmc7XG4iLCIvKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5tYXBgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZVxuICogc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IG1hcHBlZCBhcnJheS5cbiAqL1xuZnVuY3Rpb24gYXJyYXlNYXAoYXJyYXksIGl0ZXJhdGVlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGgsXG4gICAgICByZXN1bHQgPSBBcnJheShsZW5ndGgpO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgcmVzdWx0W2luZGV4XSA9IGl0ZXJhdGVlKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFycmF5TWFwO1xuIiwidmFyIGFzc2lnblZhbHVlID0gcmVxdWlyZSgnLi9fYXNzaWduVmFsdWUnKSxcbiAgICBjYXN0UGF0aCA9IHJlcXVpcmUoJy4vX2Nhc3RQYXRoJyksXG4gICAgaXNJbmRleCA9IHJlcXVpcmUoJy4vX2lzSW5kZXgnKSxcbiAgICBpc09iamVjdCA9IHJlcXVpcmUoJy4vaXNPYmplY3QnKSxcbiAgICB0b0tleSA9IHJlcXVpcmUoJy4vX3RvS2V5Jyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uc2V0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBwYXRoIGNyZWF0aW9uLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqL1xuZnVuY3Rpb24gYmFzZVNldChvYmplY3QsIHBhdGgsIHZhbHVlLCBjdXN0b21pemVyKSB7XG4gIGlmICghaXNPYmplY3Qob2JqZWN0KSkge1xuICAgIHJldHVybiBvYmplY3Q7XG4gIH1cbiAgcGF0aCA9IGNhc3RQYXRoKHBhdGgsIG9iamVjdCk7XG5cbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBwYXRoLmxlbmd0aCxcbiAgICAgIGxhc3RJbmRleCA9IGxlbmd0aCAtIDEsXG4gICAgICBuZXN0ZWQgPSBvYmplY3Q7XG5cbiAgd2hpbGUgKG5lc3RlZCAhPSBudWxsICYmICsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIga2V5ID0gdG9LZXkocGF0aFtpbmRleF0pLFxuICAgICAgICBuZXdWYWx1ZSA9IHZhbHVlO1xuXG4gICAgaWYgKGtleSA9PT0gJ19fcHJvdG9fXycgfHwga2V5ID09PSAnY29uc3RydWN0b3InIHx8IGtleSA9PT0gJ3Byb3RvdHlwZScpIHtcbiAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgfVxuXG4gICAgaWYgKGluZGV4ICE9IGxhc3RJbmRleCkge1xuICAgICAgdmFyIG9ialZhbHVlID0gbmVzdGVkW2tleV07XG4gICAgICBuZXdWYWx1ZSA9IGN1c3RvbWl6ZXIgPyBjdXN0b21pemVyKG9ialZhbHVlLCBrZXksIG5lc3RlZCkgOiB1bmRlZmluZWQ7XG4gICAgICBpZiAobmV3VmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBuZXdWYWx1ZSA9IGlzT2JqZWN0KG9ialZhbHVlKVxuICAgICAgICAgID8gb2JqVmFsdWVcbiAgICAgICAgICA6IChpc0luZGV4KHBhdGhbaW5kZXggKyAxXSkgPyBbXSA6IHt9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgYXNzaWduVmFsdWUobmVzdGVkLCBrZXksIG5ld1ZhbHVlKTtcbiAgICBuZXN0ZWQgPSBuZXN0ZWRba2V5XTtcbiAgfVxuICByZXR1cm4gb2JqZWN0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VTZXQ7XG4iLCJ2YXIgYmFzZUhhc0luID0gcmVxdWlyZSgnLi9fYmFzZUhhc0luJyksXG4gICAgaGFzUGF0aCA9IHJlcXVpcmUoJy4vX2hhc1BhdGgnKTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHBhdGhgIGlzIGEgZGlyZWN0IG9yIGluaGVyaXRlZCBwcm9wZXJ0eSBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgcGF0aGAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSBfLmNyZWF0ZSh7ICdhJzogXy5jcmVhdGUoeyAnYic6IDIgfSkgfSk7XG4gKlxuICogXy5oYXNJbihvYmplY3QsICdhJyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5oYXNJbihvYmplY3QsICdhLmInKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmhhc0luKG9iamVjdCwgWydhJywgJ2InXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5oYXNJbihvYmplY3QsICdiJyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBoYXNJbihvYmplY3QsIHBhdGgpIHtcbiAgcmV0dXJuIG9iamVjdCAhPSBudWxsICYmIGhhc1BhdGgob2JqZWN0LCBwYXRoLCBiYXNlSGFzSW4pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGhhc0luO1xuIiwiLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5oYXNJbmAgd2l0aG91dCBzdXBwb3J0IGZvciBkZWVwIHBhdGhzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBrZXkgVGhlIGtleSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUhhc0luKG9iamVjdCwga2V5KSB7XG4gIHJldHVybiBvYmplY3QgIT0gbnVsbCAmJiBrZXkgaW4gT2JqZWN0KG9iamVjdCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUhhc0luO1xuIiwidmFyIGNhc3RQYXRoID0gcmVxdWlyZSgnLi9fY2FzdFBhdGgnKSxcbiAgICBpc0FyZ3VtZW50cyA9IHJlcXVpcmUoJy4vaXNBcmd1bWVudHMnKSxcbiAgICBpc0FycmF5ID0gcmVxdWlyZSgnLi9pc0FycmF5JyksXG4gICAgaXNJbmRleCA9IHJlcXVpcmUoJy4vX2lzSW5kZXgnKSxcbiAgICBpc0xlbmd0aCA9IHJlcXVpcmUoJy4vaXNMZW5ndGgnKSxcbiAgICB0b0tleSA9IHJlcXVpcmUoJy4vX3RvS2V5Jyk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGBwYXRoYCBleGlzdHMgb24gYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIHRvIGNoZWNrLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaGFzRnVuYyBUaGUgZnVuY3Rpb24gdG8gY2hlY2sgcHJvcGVydGllcy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgcGF0aGAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGhhc1BhdGgob2JqZWN0LCBwYXRoLCBoYXNGdW5jKSB7XG4gIHBhdGggPSBjYXN0UGF0aChwYXRoLCBvYmplY3QpO1xuXG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gcGF0aC5sZW5ndGgsXG4gICAgICByZXN1bHQgPSBmYWxzZTtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBrZXkgPSB0b0tleShwYXRoW2luZGV4XSk7XG4gICAgaWYgKCEocmVzdWx0ID0gb2JqZWN0ICE9IG51bGwgJiYgaGFzRnVuYyhvYmplY3QsIGtleSkpKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgb2JqZWN0ID0gb2JqZWN0W2tleV07XG4gIH1cbiAgaWYgKHJlc3VsdCB8fCArK2luZGV4ICE9IGxlbmd0aCkge1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgbGVuZ3RoID0gb2JqZWN0ID09IG51bGwgPyAwIDogb2JqZWN0Lmxlbmd0aDtcbiAgcmV0dXJuICEhbGVuZ3RoICYmIGlzTGVuZ3RoKGxlbmd0aCkgJiYgaXNJbmRleChrZXksIGxlbmd0aCkgJiZcbiAgICAoaXNBcnJheShvYmplY3QpIHx8IGlzQXJndW1lbnRzKG9iamVjdCkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGhhc1BhdGg7XG4iLCJ2YXIgZmxhdHRlbiA9IHJlcXVpcmUoJy4vZmxhdHRlbicpLFxuICAgIG92ZXJSZXN0ID0gcmVxdWlyZSgnLi9fb3ZlclJlc3QnKSxcbiAgICBzZXRUb1N0cmluZyA9IHJlcXVpcmUoJy4vX3NldFRvU3RyaW5nJyk7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlUmVzdGAgd2hpY2ggZmxhdHRlbnMgdGhlIHJlc3QgYXJyYXkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGFwcGx5IGEgcmVzdCBwYXJhbWV0ZXIgdG8uXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gZmxhdFJlc3QoZnVuYykge1xuICByZXR1cm4gc2V0VG9TdHJpbmcob3ZlclJlc3QoZnVuYywgdW5kZWZpbmVkLCBmbGF0dGVuKSwgZnVuYyArICcnKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmbGF0UmVzdDtcbiIsInZhciBiYXNlRmxhdHRlbiA9IHJlcXVpcmUoJy4vX2Jhc2VGbGF0dGVuJyk7XG5cbi8qKlxuICogRmxhdHRlbnMgYGFycmF5YCBhIHNpbmdsZSBsZXZlbCBkZWVwLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBBcnJheVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGZsYXR0ZW4uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBmbGF0dGVuZWQgYXJyYXkuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uZmxhdHRlbihbMSwgWzIsIFszLCBbNF1dLCA1XV0pO1xuICogLy8gPT4gWzEsIDIsIFszLCBbNF1dLCA1XVxuICovXG5mdW5jdGlvbiBmbGF0dGVuKGFycmF5KSB7XG4gIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgcmV0dXJuIGxlbmd0aCA/IGJhc2VGbGF0dGVuKGFycmF5LCAxKSA6IFtdO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZsYXR0ZW47XG4iLCJ2YXIgYXJyYXlQdXNoID0gcmVxdWlyZSgnLi9fYXJyYXlQdXNoJyksXG4gICAgaXNGbGF0dGVuYWJsZSA9IHJlcXVpcmUoJy4vX2lzRmxhdHRlbmFibGUnKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5mbGF0dGVuYCB3aXRoIHN1cHBvcnQgZm9yIHJlc3RyaWN0aW5nIGZsYXR0ZW5pbmcuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBmbGF0dGVuLlxuICogQHBhcmFtIHtudW1iZXJ9IGRlcHRoIFRoZSBtYXhpbXVtIHJlY3Vyc2lvbiBkZXB0aC5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3ByZWRpY2F0ZT1pc0ZsYXR0ZW5hYmxlXSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHBhcmFtIHtib29sZWFufSBbaXNTdHJpY3RdIFJlc3RyaWN0IHRvIHZhbHVlcyB0aGF0IHBhc3MgYHByZWRpY2F0ZWAgY2hlY2tzLlxuICogQHBhcmFtIHtBcnJheX0gW3Jlc3VsdD1bXV0gVGhlIGluaXRpYWwgcmVzdWx0IHZhbHVlLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmxhdHRlbmVkIGFycmF5LlxuICovXG5mdW5jdGlvbiBiYXNlRmxhdHRlbihhcnJheSwgZGVwdGgsIHByZWRpY2F0ZSwgaXNTdHJpY3QsIHJlc3VsdCkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICBwcmVkaWNhdGUgfHwgKHByZWRpY2F0ZSA9IGlzRmxhdHRlbmFibGUpO1xuICByZXN1bHQgfHwgKHJlc3VsdCA9IFtdKTtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XTtcbiAgICBpZiAoZGVwdGggPiAwICYmIHByZWRpY2F0ZSh2YWx1ZSkpIHtcbiAgICAgIGlmIChkZXB0aCA+IDEpIHtcbiAgICAgICAgLy8gUmVjdXJzaXZlbHkgZmxhdHRlbiBhcnJheXMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICAgICAgYmFzZUZsYXR0ZW4odmFsdWUsIGRlcHRoIC0gMSwgcHJlZGljYXRlLCBpc1N0cmljdCwgcmVzdWx0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFycmF5UHVzaChyZXN1bHQsIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCFpc1N0cmljdCkge1xuICAgICAgcmVzdWx0W3Jlc3VsdC5sZW5ndGhdID0gdmFsdWU7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUZsYXR0ZW47XG4iLCIvKipcbiAqIEFwcGVuZHMgdGhlIGVsZW1lbnRzIG9mIGB2YWx1ZXNgIHRvIGBhcnJheWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge0FycmF5fSB2YWx1ZXMgVGhlIHZhbHVlcyB0byBhcHBlbmQuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAqL1xuZnVuY3Rpb24gYXJyYXlQdXNoKGFycmF5LCB2YWx1ZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSB2YWx1ZXMubGVuZ3RoLFxuICAgICAgb2Zmc2V0ID0gYXJyYXkubGVuZ3RoO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgYXJyYXlbb2Zmc2V0ICsgaW5kZXhdID0gdmFsdWVzW2luZGV4XTtcbiAgfVxuICByZXR1cm4gYXJyYXk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXJyYXlQdXNoO1xuIiwidmFyIFN5bWJvbCA9IHJlcXVpcmUoJy4vX1N5bWJvbCcpLFxuICAgIGlzQXJndW1lbnRzID0gcmVxdWlyZSgnLi9pc0FyZ3VtZW50cycpLFxuICAgIGlzQXJyYXkgPSByZXF1aXJlKCcuL2lzQXJyYXknKTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgc3ByZWFkYWJsZVN5bWJvbCA9IFN5bWJvbCA/IFN5bWJvbC5pc0NvbmNhdFNwcmVhZGFibGUgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBmbGF0dGVuYWJsZSBgYXJndW1lbnRzYCBvYmplY3Qgb3IgYXJyYXkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgZmxhdHRlbmFibGUsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNGbGF0dGVuYWJsZSh2YWx1ZSkge1xuICByZXR1cm4gaXNBcnJheSh2YWx1ZSkgfHwgaXNBcmd1bWVudHModmFsdWUpIHx8XG4gICAgISEoc3ByZWFkYWJsZVN5bWJvbCAmJiB2YWx1ZSAmJiB2YWx1ZVtzcHJlYWRhYmxlU3ltYm9sXSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNGbGF0dGVuYWJsZTtcbiIsImZ1bmN0aW9uIF9pc05hdGl2ZUZ1bmN0aW9uKGZuKSB7XG4gIHJldHVybiBGdW5jdGlvbi50b1N0cmluZy5jYWxsKGZuKS5pbmRleE9mKFwiW25hdGl2ZSBjb2RlXVwiKSAhPT0gLTE7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2lzTmF0aXZlRnVuY3Rpb24sIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlLCBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0czsiLCJ2YXIgc2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKFwiLi9zZXRQcm90b3R5cGVPZi5qc1wiKTtcblxudmFyIGlzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IHJlcXVpcmUoXCIuL2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdC5qc1wiKTtcblxuZnVuY3Rpb24gX2NvbnN0cnVjdChQYXJlbnQsIGFyZ3MsIENsYXNzKSB7XG4gIGlmIChpc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSkge1xuICAgIG1vZHVsZS5leHBvcnRzID0gX2NvbnN0cnVjdCA9IFJlZmxlY3QuY29uc3RydWN0LmJpbmQoKSwgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzO1xuICB9IGVsc2Uge1xuICAgIG1vZHVsZS5leHBvcnRzID0gX2NvbnN0cnVjdCA9IGZ1bmN0aW9uIF9jb25zdHJ1Y3QoUGFyZW50LCBhcmdzLCBDbGFzcykge1xuICAgICAgdmFyIGEgPSBbbnVsbF07XG4gICAgICBhLnB1c2guYXBwbHkoYSwgYXJncyk7XG4gICAgICB2YXIgQ29uc3RydWN0b3IgPSBGdW5jdGlvbi5iaW5kLmFwcGx5KFBhcmVudCwgYSk7XG4gICAgICB2YXIgaW5zdGFuY2UgPSBuZXcgQ29uc3RydWN0b3IoKTtcbiAgICAgIGlmIChDbGFzcykgc2V0UHJvdG90eXBlT2YoaW5zdGFuY2UsIENsYXNzLnByb3RvdHlwZSk7XG4gICAgICByZXR1cm4gaW5zdGFuY2U7XG4gICAgfSwgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzO1xuICB9XG5cbiAgcmV0dXJuIF9jb25zdHJ1Y3QuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfY29uc3RydWN0LCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZSwgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHM7IiwiZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHtcbiAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlO1xuICBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlO1xuICBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlO1xuXG4gIHRyeSB7XG4gICAgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpO1xuICAgIHJldHVybiB0cnVlO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCwgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzOyIsIm1vZHVsZS5leHBvcnRzID0gZGV0ZXJtaW5hbnRcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBkZXRlcm1pbmFudCBvZiBhIG1hdDJcbiAqXG4gKiBAYWxpYXMgbWF0Mi5kZXRlcm1pbmFudFxuICogQHBhcmFtIHttYXQyfSBhIHRoZSBzb3VyY2UgbWF0cml4XG4gKiBAcmV0dXJucyB7TnVtYmVyfSBkZXRlcm1pbmFudCBvZiBhXG4gKi9cbmZ1bmN0aW9uIGRldGVybWluYW50KGEpIHtcbiAgcmV0dXJuIGFbMF0gKiBhWzNdIC0gYVsyXSAqIGFbMV1cbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gdHJhbnNwb3NlXG5cbi8qKlxuICogVHJhbnNwb3NlIHRoZSB2YWx1ZXMgb2YgYSBtYXQyXG4gKlxuICogQGFsaWFzIG1hdDIudHJhbnNwb3NlXG4gKiBAcGFyYW0ge21hdDJ9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQyfSBhIHRoZSBzb3VyY2UgbWF0cml4XG4gKiBAcmV0dXJucyB7bWF0Mn0gb3V0XG4gKi9cbmZ1bmN0aW9uIHRyYW5zcG9zZShvdXQsIGEpIHtcbiAgLy8gSWYgd2UgYXJlIHRyYW5zcG9zaW5nIG91cnNlbHZlcyB3ZSBjYW4gc2tpcCBhIGZldyBzdGVwcyBidXQgaGF2ZSB0byBjYWNoZSBzb21lIHZhbHVlc1xuICBpZiAob3V0ID09PSBhKSB7XG4gICAgdmFyIGExID0gYVsxXVxuICAgIG91dFsxXSA9IGFbMl1cbiAgICBvdXRbMl0gPSBhMVxuICB9IGVsc2Uge1xuICAgIG91dFswXSA9IGFbMF1cbiAgICBvdXRbMV0gPSBhWzJdXG4gICAgb3V0WzJdID0gYVsxXVxuICAgIG91dFszXSA9IGFbM11cbiAgfVxuXG4gIHJldHVybiBvdXRcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gbXVsdGlwbHlcblxuLyoqXG4gKiBNdWx0aXBsaWVzIHR3byBtYXQyJ3NcbiAqXG4gKiBAYWxpYXMgbWF0Mi5tdWx0aXBseVxuICogQHBhcmFtIHttYXQyfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0Mn0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHttYXQyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge21hdDJ9IG91dFxuICovXG5mdW5jdGlvbiBtdWx0aXBseShvdXQsIGEsIGIpIHtcbiAgdmFyIGEwID0gYVswXSwgYTEgPSBhWzFdLCBhMiA9IGFbMl0sIGEzID0gYVszXVxuICB2YXIgYjAgPSBiWzBdLCBiMSA9IGJbMV0sIGIyID0gYlsyXSwgYjMgPSBiWzNdXG4gIG91dFswXSA9IGEwICogYjAgKyBhMiAqIGIxXG4gIG91dFsxXSA9IGExICogYjAgKyBhMyAqIGIxXG4gIG91dFsyXSA9IGEwICogYjIgKyBhMiAqIGIzXG4gIG91dFszXSA9IGExICogYjIgKyBhMyAqIGIzXG4gIHJldHVybiBvdXRcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gaWRlbnRpdHlcblxuLyoqXG4gKiBTZXQgYSBtYXQyIHRvIHRoZSBpZGVudGl0eSBtYXRyaXhcbiAqXG4gKiBAYWxpYXMgbWF0Mi5pZGVudGl0eVxuICogQHBhcmFtIHttYXQyfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEByZXR1cm5zIHttYXQyfSBvdXRcbiAqL1xuZnVuY3Rpb24gaWRlbnRpdHkob3V0KSB7XG4gIG91dFswXSA9IDFcbiAgb3V0WzFdID0gMFxuICBvdXRbMl0gPSAwXG4gIG91dFszXSA9IDFcbiAgcmV0dXJuIG91dFxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBhZGpvaW50XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgYWRqdWdhdGUgb2YgYSBtYXQyXG4gKlxuICogQGFsaWFzIG1hdDIuYWRqb2ludFxuICogQHBhcmFtIHttYXQyfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0Mn0gYSB0aGUgc291cmNlIG1hdHJpeFxuICogQHJldHVybnMge21hdDJ9IG91dFxuICovXG5mdW5jdGlvbiBhZGpvaW50KG91dCwgYSkge1xuICAvLyBDYWNoaW5nIHRoaXMgdmFsdWUgaXMgbmVzc2VjYXJ5IGlmIG91dCA9PSBhXG4gIHZhciBhMCA9ICBhWzBdXG4gIG91dFswXSA9ICBhWzNdXG4gIG91dFsxXSA9IC1hWzFdXG4gIG91dFsyXSA9IC1hWzJdXG4gIG91dFszXSA9ICBhMFxuXG4gIHJldHVybiBvdXRcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gcm90YXRlXG5cbi8qKlxuICogUm90YXRlcyBhIG1hdDIgYnkgdGhlIGdpdmVuIGFuZ2xlXG4gKlxuICogQGFsaWFzIG1hdDIucm90YXRlXG4gKiBAcGFyYW0ge21hdDJ9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQyfSBhIHRoZSBtYXRyaXggdG8gcm90YXRlXG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIHRoZSBhbmdsZSB0byByb3RhdGUgdGhlIG1hdHJpeCBieVxuICogQHJldHVybnMge21hdDJ9IG91dFxuICovXG5mdW5jdGlvbiByb3RhdGUob3V0LCBhLCByYWQpIHtcbiAgdmFyIGEwID0gYVswXSwgYTEgPSBhWzFdLCBhMiA9IGFbMl0sIGEzID0gYVszXVxuICB2YXIgcyA9IE1hdGguc2luKHJhZClcbiAgdmFyIGMgPSBNYXRoLmNvcyhyYWQpXG4gIG91dFswXSA9IGEwICogIGMgKyBhMiAqIHNcbiAgb3V0WzFdID0gYTEgKiAgYyArIGEzICogc1xuICBvdXRbMl0gPSBhMCAqIC1zICsgYTIgKiBjXG4gIG91dFszXSA9IGExICogLXMgKyBhMyAqIGNcbiAgcmV0dXJuIG91dFxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBpbnZlcnRcblxuLyoqXG4gKiBJbnZlcnRzIGEgbWF0MlxuICpcbiAqIEBhbGlhcyBtYXQyLmludmVydFxuICogQHBhcmFtIHttYXQyfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0Mn0gYSB0aGUgc291cmNlIG1hdHJpeFxuICogQHJldHVybnMge21hdDJ9IG91dFxuICovXG5mdW5jdGlvbiBpbnZlcnQob3V0LCBhKSB7XG4gIHZhciBhMCA9IGFbMF1cbiAgdmFyIGExID0gYVsxXVxuICB2YXIgYTIgPSBhWzJdXG4gIHZhciBhMyA9IGFbM11cbiAgdmFyIGRldCA9IGEwICogYTMgLSBhMiAqIGExXG5cbiAgaWYgKCFkZXQpIHJldHVybiBudWxsXG4gIGRldCA9IDEuMCAvIGRldFxuXG4gIG91dFswXSA9ICBhMyAqIGRldFxuICBvdXRbMV0gPSAtYTEgKiBkZXRcbiAgb3V0WzJdID0gLWEyICogZGV0XG4gIG91dFszXSA9ICBhMCAqIGRldFxuXG4gIHJldHVybiBvdXRcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gY3JlYXRlXG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBpZGVudGl0eSBtYXQyXG4gKlxuICogQGFsaWFzIG1hdDIuY3JlYXRlXG4gKiBAcmV0dXJucyB7bWF0Mn0gYSBuZXcgMngyIG1hdHJpeFxuICovXG5mdW5jdGlvbiBjcmVhdGUoKSB7XG4gIHZhciBvdXQgPSBuZXcgRmxvYXQzMkFycmF5KDQpXG4gIG91dFswXSA9IDFcbiAgb3V0WzFdID0gMFxuICBvdXRbMl0gPSAwXG4gIG91dFszXSA9IDFcbiAgcmV0dXJuIG91dFxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBzY2FsZVxuXG4vKipcbiAqIFNjYWxlcyB0aGUgbWF0MiBieSB0aGUgZGltZW5zaW9ucyBpbiB0aGUgZ2l2ZW4gdmVjMlxuICpcbiAqIEBhbGlhcyBtYXQyLnNjYWxlXG4gKiBAcGFyYW0ge21hdDJ9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQyfSBhIHRoZSBtYXRyaXggdG8gcm90YXRlXG4gKiBAcGFyYW0ge3ZlYzJ9IHYgdGhlIHZlYzIgdG8gc2NhbGUgdGhlIG1hdHJpeCBieVxuICogQHJldHVybnMge21hdDJ9IG91dFxuICoqL1xuZnVuY3Rpb24gc2NhbGUob3V0LCBhLCB2KSB7XG4gIHZhciBhMCA9IGFbMF0sIGExID0gYVsxXSwgYTIgPSBhWzJdLCBhMyA9IGFbM11cbiAgdmFyIHYwID0gdlswXSwgdjEgPSB2WzFdXG4gIG91dFswXSA9IGEwICogdjBcbiAgb3V0WzFdID0gYTEgKiB2MFxuICBvdXRbMl0gPSBhMiAqIHYxXG4gIG91dFszXSA9IGEzICogdjFcbiAgcmV0dXJuIG91dFxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBjb3B5XG5cbi8qKlxuICogQ29weSB0aGUgdmFsdWVzIGZyb20gb25lIG1hdDIgdG8gYW5vdGhlclxuICpcbiAqIEBhbGlhcyBtYXQyLmNvcHlcbiAqIEBwYXJhbSB7bWF0Mn0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDJ9IGEgdGhlIHNvdXJjZSBtYXRyaXhcbiAqIEByZXR1cm5zIHttYXQyfSBvdXRcbiAqL1xuZnVuY3Rpb24gY29weShvdXQsIGEpIHtcbiAgb3V0WzBdID0gYVswXVxuICBvdXRbMV0gPSBhWzFdXG4gIG91dFsyXSA9IGFbMl1cbiAgb3V0WzNdID0gYVszXVxuICByZXR1cm4gb3V0XG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZyb2JcblxuLyoqXG4gKiBSZXR1cm5zIEZyb2Jlbml1cyBub3JtIG9mIGEgbWF0MlxuICpcbiAqIEBhbGlhcyBtYXQyLmZyb2JcbiAqIEBwYXJhbSB7bWF0Mn0gYSB0aGUgbWF0cml4IHRvIGNhbGN1bGF0ZSBGcm9iZW5pdXMgbm9ybSBvZlxuICogQHJldHVybnMge051bWJlcn0gRnJvYmVuaXVzIG5vcm1cbiAqL1xuZnVuY3Rpb24gZnJvYihhKSB7XG4gIHJldHVybiBNYXRoLnNxcnQoXG4gICAgTWF0aC5wb3coYVswXSwgMikgK1xuICAgIE1hdGgucG93KGFbMV0sIDIpICtcbiAgICBNYXRoLnBvdyhhWzJdLCAyKSArXG4gICAgTWF0aC5wb3coYVszXSwgMilcbiAgKVxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBsZHVcblxuLyoqXG4gKiBSZXR1cm5zIEwsIEQgYW5kIFUgbWF0cmljZXMgKExvd2VyIHRyaWFuZ3VsYXIsIERpYWdvbmFsIGFuZCBVcHBlciB0cmlhbmd1bGFyKSBieSBmYWN0b3JpemluZyB0aGUgaW5wdXQgbWF0cml4XG4gKlxuICogQGFsaWFzIG1hdDIubGR1XG4gKiBAcGFyYW0ge21hdDJ9IEwgdGhlIGxvd2VyIHRyaWFuZ3VsYXIgbWF0cml4XG4gKiBAcGFyYW0ge21hdDJ9IEQgdGhlIGRpYWdvbmFsIG1hdHJpeFxuICogQHBhcmFtIHttYXQyfSBVIHRoZSB1cHBlciB0cmlhbmd1bGFyIG1hdHJpeFxuICogQHBhcmFtIHttYXQyfSBhIHRoZSBpbnB1dCBtYXRyaXggdG8gZmFjdG9yaXplXG4gKi9cbmZ1bmN0aW9uIGxkdShMLCBELCBVLCBhKSB7XG4gIExbMl0gPSBhWzJdL2FbMF1cbiAgVVswXSA9IGFbMF1cbiAgVVsxXSA9IGFbMV1cbiAgVVszXSA9IGFbM10gLSBMWzJdICogVVsxXVxuICByZXR1cm4gW0wsIEQsIFVdXG59XG4iLCIvKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycyAqL1xuLyogZXNsaW50LWRpc2FibGUgY2xhc3MtbWV0aG9kcy11c2UtdGhpcyAqL1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby1jeWNsZVxuaW1wb3J0IHsgSW1hZ2VXcmFwcGVyIH0gZnJvbSAncXVhZ2dhJztcbmltcG9ydCB7IFF1YWdnYUpTUmVzdWx0T2JqZWN0IH0gZnJvbSAnLi4vLi4vdHlwZS1kZWZpbml0aW9ucy9xdWFnZ2EnO1xuaW1wb3J0IEFycmF5SGVscGVyIGZyb20gJy4uL2NvbW1vbi9hcnJheV9oZWxwZXInO1xuXG4vLyBmb3Igc29tZSByZWFzb24gdGhpcyB0aHJvd3MgYSBzaGFkb3cgZXJyb3Igb24gaXRzZWxmPyFcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zaGFkb3dcbmV4cG9ydCBlbnVtIEJhcmNvZGVEaXJlY3Rpb24ge1xuICAgIEZvcndhcmQgPSAxLFxuICAgIFJldmVyc2UgPSAtMVxufVxuXG5leHBvcnQgdHlwZSBCYXJjb2RlUmVhZGVyVHlwZSA9IHN0cmluZztcbmV4cG9ydCB0eXBlIEJhcmNvZGVGb3JtYXQgPSBzdHJpbmc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgQmFyY29kZVJlYWRlckNvbmZpZyB7XG4gICAgbm9ybWFsaXplQmFyU3BhY2VXaWR0aD86IGJvb2xlYW4sXG4gICAgc3VwcGxlbWVudHM/OiBBcnJheTxCYXJjb2RlUmVhZGVyVHlwZT4sXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQmFyY29kZUNvcnJlY3Rpb24ge1xuICAgIGJhcjogbnVtYmVyLFxuICAgIHNwYWNlOiBudW1iZXIsXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQmFyY29kZVBvc2l0aW9uIHtcbiAgICBlbmQ6IG51bWJlcixcbiAgICBlbmRDb3VudGVyPzogbnVtYmVyLFxuICAgIGVycm9yPzogbnVtYmVyLFxuICAgIHN0YXJ0OiBudW1iZXIsXG4gICAgc3RhcnRDb3VudGVyPzogbnVtYmVyXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQmFyY29kZUluZm8gZXh0ZW5kcyBCYXJjb2RlUG9zaXRpb24ge1xuICAgIGNvZGU6IG51bWJlcixcbiAgICBjb3JyZWN0aW9uPzogQmFyY29kZUNvcnJlY3Rpb24sXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQmFyY29kZSB7XG4gICAgY29kZTogc3RyaW5nLFxuICAgIGNvZGVzZXQ/OiBudW1iZXIsXG4gICAgY29ycmVjdGlvbj86IEJhcmNvZGVDb3JyZWN0aW9uLFxuICAgIGRlY29kZWRDb2Rlcz86IEFycmF5PHN0cmluZyB8IEJhcmNvZGVJbmZvIHwgQmFyY29kZVBvc2l0aW9uPixcbiAgICBkaXJlY3Rpb24/OiBCYXJjb2RlRGlyZWN0aW9uLFxuICAgIGVuZDogbnVtYmVyLFxuICAgIGVuZEluZm8/OiBCYXJjb2RlUG9zaXRpb24sXG4gICAgZm9ybWF0OiBCYXJjb2RlRm9ybWF0LFxuICAgIHN0YXJ0OiBudW1iZXIsXG4gICAgc3RhcnRJbmZvOiBCYXJjb2RlUG9zaXRpb24sXG4gICAgc3VwcGxlbWVudD86IEJhcmNvZGUsXG59XG5cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBCYXJjb2RlUmVhZGVyIHtcbiAgICBfcm93OiBBcnJheTxudW1iZXI+ID0gW107XG5cbiAgICBjb25maWc6IEJhcmNvZGVSZWFkZXJDb25maWcgPSB7fTtcblxuICAgIHN1cHBsZW1lbnRzOiBBcnJheTxCYXJjb2RlUmVhZGVyPiA9IFtdO1xuXG4gICAgU0lOR0xFX0NPREVfRVJST1IgPSAwO1xuXG4gICAgRk9STUFUOiBCYXJjb2RlRm9ybWF0ID0gJ3Vua25vd24nO1xuXG4gICAgQ09ORklHX0tFWVM6IEJhcmNvZGVSZWFkZXJDb25maWcgPSB7fTtcbiAgICAvLyBUT0RPOiBzaG91bGQgYWRkIEFMUEhBQkVUSF9TVFJJTkcsIEFMUEhBQkVULCBDSEFSQUNURVJfRU5DT0RJTkdTIHRvIGJhc2UgY2xhc3MsIGlmIHRoZXlcbiAgICAvLyBhcmUgdXNlZnVsIGluIG1vc3QgcmVhZGVycy5cblxuICAgIHB1YmxpYyBhYnN0cmFjdCBkZWNvZGUocm93PzogQXJyYXk8bnVtYmVyPiwgc3RhcnQ/OiBCYXJjb2RlUG9zaXRpb24gfCBudW1iZXIpOiBCYXJjb2RlIHwgbnVsbDtcblxuICAgIHN0YXRpYyBnZXQgRXhjZXB0aW9uKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgU3RhcnROb3RGb3VuZEV4Y2VwdGlvbjogJ1N0YXJ0LUluZm8gd2FzIG5vdCBmb3VuZCEnLFxuICAgICAgICAgICAgQ29kZU5vdEZvdW5kRXhjZXB0aW9uOiAnQ29kZSBjb3VsZCBub3QgYmUgZm91bmQhJyxcbiAgICAgICAgICAgIFBhdHRlcm5Ob3RGb3VuZEV4Y2VwdGlvbjogJ1BhdHRlcm4gY291bGQgbm90IGJlIGZvdW5kIScsXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgY29uc3RydWN0b3IoY29uZmlnOiBCYXJjb2RlUmVhZGVyQ29uZmlnLCBzdXBwbGVtZW50cz86IEFycmF5PEJhcmNvZGVSZWFkZXI+KSB7XG4gICAgICAgIHRoaXMuX3JvdyA9IFtdO1xuICAgICAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZyB8fCB7fTtcbiAgICAgICAgaWYgKHN1cHBsZW1lbnRzKSB7XG4gICAgICAgICAgICB0aGlzLnN1cHBsZW1lbnRzID0gc3VwcGxlbWVudHM7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgX25leHRVbnNldChsaW5lOiBSZWFkb25seUFycmF5PG51bWJlcj4sIHN0YXJ0ID0gMCk6IG51bWJlciB7XG4gICAgICAgIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IGxpbmUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmICghbGluZVtpXSkgcmV0dXJuIGk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxpbmUubGVuZ3RoO1xuICAgIH1cblxuICAgIHByb3RlY3RlZCBfbWF0Y2hQYXR0ZXJuKGNvdW50ZXI6IFJlYWRvbmx5QXJyYXk8bnVtYmVyPiwgY29kZTogUmVhZG9ubHlBcnJheTxudW1iZXI+LCBtYXhTaW5nbGVFcnJvciA9IHRoaXMuU0lOR0xFX0NPREVfRVJST1IgfHwgMSk6IG51bWJlciB7XG4gICAgICAgIGxldCBlcnJvciA9IDA7XG4gICAgICAgIGxldCBzaW5nbGVFcnJvciA9IDA7XG4gICAgICAgIGxldCBzdW0gPSAwO1xuICAgICAgICBsZXQgbW9kdWxvID0gMDtcbiAgICAgICAgbGV0IGJhcldpZHRoID0gMDtcbiAgICAgICAgbGV0IGNvdW50ID0gMDtcbiAgICAgICAgbGV0IHNjYWxlZCA9IDA7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb3VudGVyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBzdW0gKz0gY291bnRlcltpXTtcbiAgICAgICAgICAgIG1vZHVsbyArPSBjb2RlW2ldO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdW0gPCBtb2R1bG8pIHtcbiAgICAgICAgICAgIHJldHVybiBOdW1iZXIuTUFYX1ZBTFVFO1xuICAgICAgICB9XG5cbiAgICAgICAgYmFyV2lkdGggPSBzdW0gLyBtb2R1bG87XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgICBtYXhTaW5nbGVFcnJvciAqPSBiYXJXaWR0aDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb3VudGVyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb3VudCA9IGNvdW50ZXJbaV07XG4gICAgICAgICAgICBzY2FsZWQgPSBjb2RlW2ldICogYmFyV2lkdGg7XG4gICAgICAgICAgICBzaW5nbGVFcnJvciA9IE1hdGguYWJzKGNvdW50IC0gc2NhbGVkKSAvIHNjYWxlZDtcbiAgICAgICAgICAgIGlmIChzaW5nbGVFcnJvciA+IG1heFNpbmdsZUVycm9yKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIE51bWJlci5NQVhfVkFMVUU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlcnJvciArPSBzaW5nbGVFcnJvcjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZXJyb3IgLyBtb2R1bG87XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIF9uZXh0U2V0KGxpbmU6IFJlYWRvbmx5QXJyYXk8bnVtYmVyPiwgb2Zmc2V0ID0gMCkge1xuICAgICAgICBmb3IgKGxldCBpID0gb2Zmc2V0OyBpIDwgbGluZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGxpbmVbaV0pIHJldHVybiBpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsaW5lLmxlbmd0aDtcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgX2NvcnJlY3RCYXJzKGNvdW50ZXI6IEFycmF5PG51bWJlcj4sIGNvcnJlY3Rpb246IG51bWJlciwgaW5kaWNlczogQXJyYXk8bnVtYmVyPikge1xuICAgICAgICBsZXQgeyBsZW5ndGggfSA9IGluZGljZXM7XG4gICAgICAgIGxldCB0bXAgPSAwO1xuICAgICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgICAgIHRtcCA9IGNvdW50ZXJbaW5kaWNlc1tsZW5ndGhdXSAqICgxIC0gKCgxIC0gY29ycmVjdGlvbikgLyAyKSk7XG4gICAgICAgICAgICBpZiAodG1wID4gMSkge1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgICAgICAgICAgIGNvdW50ZXJbaW5kaWNlc1tsZW5ndGhdXSA9IHRtcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHB1YmxpYyBkZWNvZGVQYXR0ZXJuKHBhdHRlcm46IEFycmF5PG51bWJlcj4pIHtcbiAgICAgICAgLy8gY29uc29sZS53YXJuKCcqIGRlY29kZVBhdHRlcm4nLCBwYXR0ZXJuKTtcbiAgICAgICAgdGhpcy5fcm93ID0gcGF0dGVybjtcbiAgICAgICAgLy8gY29uc29sZS53YXJuKCcqIGRlY29kZVBhdHRlcm4gY2FsbGluZyBkZWNvZGUnLCB0eXBlb2YgdGhpcywgdGhpcy5jb25zdHJ1Y3RvciwgdGhpcy5GT1JNQVQsIEpTT04uc3RyaW5naWZ5KHRoaXMpKTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHRoaXMuZGVjb2RlKCk7XG4gICAgICAgIC8vIGNvbnNvbGUud2FybignKiBmaXJzdCByZXN1bHQ9JywgcmVzdWx0KTtcbiAgICAgICAgaWYgKHJlc3VsdCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5fcm93LnJldmVyc2UoKTtcbiAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMuZGVjb2RlKCk7XG4gICAgICAgICAgICAvLyBjb25zb2xlLndhcm4oJyogcmV2ZXJzZWQgcmVzdWx0PScsIHJlc3VsdCk7XG4gICAgICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LmRpcmVjdGlvbiA9IEJhcmNvZGVEaXJlY3Rpb24uUmV2ZXJzZTtcbiAgICAgICAgICAgICAgICByZXN1bHQuc3RhcnQgPSB0aGlzLl9yb3cubGVuZ3RoIC0gcmVzdWx0LnN0YXJ0O1xuICAgICAgICAgICAgICAgIHJlc3VsdC5lbmQgPSB0aGlzLl9yb3cubGVuZ3RoIC0gcmVzdWx0LmVuZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdC5kaXJlY3Rpb24gPSBCYXJjb2RlRGlyZWN0aW9uLkZvcndhcmQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgICAgcmVzdWx0LmZvcm1hdCA9IHRoaXMuRk9STUFUO1xuICAgICAgICB9XG4gICAgICAgIC8vIGNvbnNvbGUud2FybignKiByZXR1cm5pbmcnLCByZXN1bHQpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIHByb3RlY3RlZCBfbWF0Y2hSYW5nZShzdGFydDogbnVtYmVyLCBlbmQ6IG51bWJlciwgdmFsdWU6IG51bWJlcikge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgICAgc3RhcnQgPSBzdGFydCA8IDAgPyAwIDogc3RhcnQ7XG4gICAgICAgIGxldCBpO1xuICAgICAgICBmb3IgKGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fcm93W2ldICE9PSB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgX2ZpbGxDb3VudGVycyhvZmZzZXQ6IG51bWJlciA9IHRoaXMuX25leHRVbnNldCh0aGlzLl9yb3cpLCBlbmQ6IG51bWJlciA9IHRoaXMuX3Jvdy5sZW5ndGgsIGlzV2hpdGUgPSB0cnVlKSB7XG4gICAgICAgIGNvbnN0IGNvdW50ZXJzOiBBcnJheTxudW1iZXI+ID0gW107XG4gICAgICAgIGxldCBjb3VudGVyUG9zID0gMDtcbiAgICAgICAgY291bnRlcnNbY291bnRlclBvc10gPSAwO1xuICAgICAgICBmb3IgKGxldCBpID0gb2Zmc2V0OyBpIDwgZW5kOyBpKyspIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1iaXR3aXNlXG4gICAgICAgICAgICBpZiAodGhpcy5fcm93W2ldIF4gKGlzV2hpdGUgPyAxIDogMCkpIHtcbiAgICAgICAgICAgICAgICBjb3VudGVyc1tjb3VudGVyUG9zXSsrO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb3VudGVyUG9zKys7XG4gICAgICAgICAgICAgICAgY291bnRlcnNbY291bnRlclBvc10gPSAxO1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgICAgICAgICAgIGlzV2hpdGUgPSAhaXNXaGl0ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY291bnRlcnM7XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIF90b0NvdW50ZXJzKHN0YXJ0OiBudW1iZXIsIGNvdW50ZXJzOiBVaW50MTZBcnJheSB8IEFycmF5PG51bWJlcj4pIHtcbiAgICAgICAgY29uc3QgbnVtQ291bnRlcnMgPSBjb3VudGVycy5sZW5ndGg7XG4gICAgICAgIGNvbnN0IGVuZCA9IHRoaXMuX3Jvdy5sZW5ndGg7XG4gICAgICAgIGxldCBpc1doaXRlID0gIXRoaXMuX3Jvd1tzdGFydF07XG4gICAgICAgIGxldCBjb3VudGVyUG9zID0gMDtcblxuICAgICAgICBBcnJheUhlbHBlci5pbml0KGNvdW50ZXJzLCAwKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1iaXR3aXNlXG4gICAgICAgICAgICBpZiAodGhpcy5fcm93W2ldIF4gKGlzV2hpdGUgPyAxIDogMCkpIHtcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgICAgICAgICAgICBjb3VudGVyc1tjb3VudGVyUG9zXSsrO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb3VudGVyUG9zKys7XG4gICAgICAgICAgICAgICAgaWYgKGNvdW50ZXJQb3MgPT09IG51bUNvdW50ZXJzKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgICAgICAgICAgICAgICBjb3VudGVyc1tjb3VudGVyUG9zXSA9IDE7XG4gICAgICAgICAgICAgICAgICAgIGlzV2hpdGUgPSAhaXNXaGl0ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvdW50ZXJzO1xuICAgIH1cblxuICAgIC8vIG92ZXJyaWRlL2ltcGxlbWVudCB0aGlzIGluIHlvdXIgY3VzdG9tIHJlYWRlcnMuXG4gICAgcHJvdGVjdGVkIGRlY29kZUltYWdlKGltYWdlV3JhcHBlcjogSW1hZ2VXcmFwcGVyKTogUXVhZ2dhSlNSZXN1bHRPYmplY3QgfCBudWxsIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXZvaWRcbiAgICAgICAgdm9pZCBpbWFnZVdyYXBwZXI7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgQmFyY29kZVJlYWRlcjtcbiIsImltcG9ydCBCYXJjb2RlUmVhZGVyLCB7IEJhcmNvZGUsIEJhcmNvZGVJbmZvLCBCYXJjb2RlUG9zaXRpb24gfSBmcm9tICcuL2JhcmNvZGVfcmVhZGVyJztcblxuY29uc3QgTiA9IDE7XG5jb25zdCBXID0gMztcbmNvbnN0IFNUQVJUX1BBVFRFUk4gPSBbVywgTiwgVywgTiwgTiwgTl07XG5jb25zdCBTVE9QX1BBVFRFUk4gPSBbVywgTiwgTiwgTiwgV107XG5jb25zdCBDT0RFX1BBVFRFUk4gPSBbXG4gICAgW04sIE4sIFcsIFcsIE5dLFxuICAgIFtXLCBOLCBOLCBOLCBXXSxcbiAgICBbTiwgVywgTiwgTiwgV10sXG4gICAgW1csIFcsIE4sIE4sIE5dLFxuICAgIFtOLCBOLCBXLCBOLCBXXSxcbiAgICBbVywgTiwgVywgTiwgTl0sXG4gICAgW04sIFcsIFcsIE4sIE5dLFxuICAgIFtOLCBOLCBOLCBXLCBXXSxcbiAgICBbVywgTiwgTiwgVywgTl0sXG4gICAgW04sIFcsIE4sIFcsIE5dLFxuXTtcbmNvbnN0IFNUQVJUX1BBVFRFUk5fTEVOR1RIID0gU1RBUlRfUEFUVEVSTi5yZWR1Y2UoKHN1bSwgdmFsKSA9PiBzdW0gKyB2YWwsIDApO1xuXG5jbGFzcyBUd29PZkZpdmVSZWFkZXIgZXh0ZW5kcyBCYXJjb2RlUmVhZGVyIHtcbiAgICBiYXJTcGFjZVJhdGlvID0gWzEsIDFdO1xuXG4gICAgRk9STUFUID0gJzJvZjUnO1xuXG4gICAgU0lOR0xFX0NPREVfRVJST1IgPSAwLjc4O1xuXG4gICAgQVZHX0NPREVfRVJST1IgPSAwLjMwO1xuXG4gICAgcHJvdGVjdGVkIF9maW5kUGF0dGVybihwYXR0ZXJuOiBSZWFkb25seUFycmF5PG51bWJlcj4sIG9mZnNldDogbnVtYmVyLCBpc1doaXRlID0gZmFsc2UsIHRyeUhhcmRlciA9IGZhbHNlKTogQmFyY29kZUluZm8gfCBudWxsIHtcbiAgICAgICAgY29uc3QgY291bnRlciA9IFtdO1xuICAgICAgICBsZXQgY291bnRlclBvcyA9IDA7XG4gICAgICAgIGNvbnN0IGJlc3RNYXRjaCA9IHtcbiAgICAgICAgICAgIGVycm9yOiBOdW1iZXIuTUFYX1ZBTFVFLFxuICAgICAgICAgICAgY29kZTogLTEsXG4gICAgICAgICAgICBzdGFydDogMCxcbiAgICAgICAgICAgIGVuZDogMCxcbiAgICAgICAgfTtcbiAgICAgICAgbGV0IHN1bSA9IDA7XG4gICAgICAgIGxldCBlcnJvciA9IDA7XG4gICAgICAgIGNvbnN0IGVwc2lsb24gPSB0aGlzLkFWR19DT0RFX0VSUk9SO1xuXG4gICAgICAgIGlmICghb2Zmc2V0KSB7XG4gICAgICAgICAgICBvZmZzZXQgPSB0aGlzLl9uZXh0U2V0KHRoaXMuX3Jvdyk7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhdHRlcm4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvdW50ZXJbaV0gPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IG9mZnNldDsgaSA8IHRoaXMuX3Jvdy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3Jvd1tpXSBeIChpc1doaXRlID8gMSA6IDApKSB7XG4gICAgICAgICAgICAgICAgY291bnRlcltjb3VudGVyUG9zXSsrO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoY291bnRlclBvcyA9PT0gY291bnRlci5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHN1bSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgY291bnRlci5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3VtICs9IGNvdW50ZXJbal07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZXJyb3IgPSB0aGlzLl9tYXRjaFBhdHRlcm4oY291bnRlciwgcGF0dGVybik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnJvciA8IGVwc2lsb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJlc3RNYXRjaC5lcnJvciA9IGVycm9yO1xuICAgICAgICAgICAgICAgICAgICAgICAgYmVzdE1hdGNoLnN0YXJ0ID0gaSAtIHN1bTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJlc3RNYXRjaC5lbmQgPSBpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJlc3RNYXRjaDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodHJ5SGFyZGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGNvdW50ZXIubGVuZ3RoIC0gMjsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY291bnRlcltqXSA9IGNvdW50ZXJbaiArIDJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY291bnRlcltjb3VudGVyLmxlbmd0aCAtIDJdID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50ZXJbY291bnRlci5sZW5ndGggLSAxXSA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb3VudGVyUG9zLS07XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvdW50ZXJQb3MrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY291bnRlcltjb3VudGVyUG9zXSA9IDE7XG4gICAgICAgICAgICAgICAgaXNXaGl0ZSA9ICFpc1doaXRlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHByb3RlY3RlZCBfZmluZFN0YXJ0KCk6IEJhcmNvZGVQb3NpdGlvbiB8IG51bGwge1xuICAgICAgICBsZXQgc3RhcnRJbmZvID0gbnVsbDtcbiAgICAgICAgbGV0IG9mZnNldCA9IHRoaXMuX25leHRTZXQodGhpcy5fcm93KTtcbiAgICAgICAgbGV0IG5hcnJvd0JhcldpZHRoID0gMTtcbiAgICAgICAgbGV0IGxlYWRpbmdXaGl0ZXNwYWNlU3RhcnQgPSAwO1xuXG4gICAgICAgIHdoaWxlICghc3RhcnRJbmZvKSB7XG4gICAgICAgICAgICBzdGFydEluZm8gPSB0aGlzLl9maW5kUGF0dGVybihTVEFSVF9QQVRURVJOLCBvZmZzZXQsIGZhbHNlLCB0cnVlKTtcbiAgICAgICAgICAgIGlmICghc3RhcnRJbmZvKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuYXJyb3dCYXJXaWR0aCA9IE1hdGguZmxvb3IoKHN0YXJ0SW5mby5lbmQgLSBzdGFydEluZm8uc3RhcnQpIC8gU1RBUlRfUEFUVEVSTl9MRU5HVEgpO1xuICAgICAgICAgICAgbGVhZGluZ1doaXRlc3BhY2VTdGFydCA9IHN0YXJ0SW5mby5zdGFydCAtIG5hcnJvd0JhcldpZHRoICogNTtcbiAgICAgICAgICAgIGlmIChsZWFkaW5nV2hpdGVzcGFjZVN0YXJ0ID49IDApIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fbWF0Y2hSYW5nZShsZWFkaW5nV2hpdGVzcGFjZVN0YXJ0LCBzdGFydEluZm8uc3RhcnQsIDApKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzdGFydEluZm87XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb2Zmc2V0ID0gc3RhcnRJbmZvLmVuZDtcbiAgICAgICAgICAgIHN0YXJ0SW5mbyA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0YXJ0SW5mbztcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgX3ZlcmlmeVRyYWlsaW5nV2hpdGVzcGFjZShlbmRJbmZvOiBCYXJjb2RlSW5mbyk6IEJhcmNvZGVQb3NpdGlvbiB8IG51bGwge1xuICAgICAgICBjb25zdCB0cmFpbGluZ1doaXRlc3BhY2VFbmQgPSBlbmRJbmZvLmVuZCArICgoZW5kSW5mby5lbmQgLSBlbmRJbmZvLnN0YXJ0KSAvIDIpO1xuICAgICAgICBpZiAodHJhaWxpbmdXaGl0ZXNwYWNlRW5kIDwgdGhpcy5fcm93Lmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX21hdGNoUmFuZ2UoZW5kSW5mby5lbmQsIHRyYWlsaW5nV2hpdGVzcGFjZUVuZCwgMCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZW5kSW5mbztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgX2ZpbmRFbmQoKTogQmFyY29kZVBvc2l0aW9uIHwgbnVsbCB7XG4gICAgICAgIC8vIFRPRE86IHJldmVyc2UsIGZvbGxvd2VkIGJ5IHNvbWUgY2FsY3MsIGZvbGxvd2VkIGJ5IGFub3RoZXIgcmV2ZXJzZT8gcmVhbGx5P1xuICAgICAgICB0aGlzLl9yb3cucmV2ZXJzZSgpO1xuICAgICAgICBjb25zdCBvZmZzZXQgPSB0aGlzLl9uZXh0U2V0KHRoaXMuX3Jvdyk7XG4gICAgICAgIGNvbnN0IGVuZEluZm8gPSB0aGlzLl9maW5kUGF0dGVybihTVE9QX1BBVFRFUk4sIG9mZnNldCwgZmFsc2UsIHRydWUpO1xuICAgICAgICB0aGlzLl9yb3cucmV2ZXJzZSgpO1xuXG4gICAgICAgIGlmIChlbmRJbmZvID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHJldmVyc2UgbnVtYmVyc1xuICAgICAgICBjb25zdCB0bXAgPSBlbmRJbmZvLnN0YXJ0O1xuICAgICAgICBlbmRJbmZvLnN0YXJ0ID0gdGhpcy5fcm93Lmxlbmd0aCAtIGVuZEluZm8uZW5kO1xuICAgICAgICBlbmRJbmZvLmVuZCA9IHRoaXMuX3Jvdy5sZW5ndGggLSB0bXA7XG5cbiAgICAgICAgcmV0dXJuIGVuZEluZm8gIT09IG51bGwgPyB0aGlzLl92ZXJpZnlUcmFpbGluZ1doaXRlc3BhY2UoZW5kSW5mbykgOiBudWxsO1xuICAgIH1cblxuICAgIHByb3RlY3RlZCBfdmVyaWZ5Q291bnRlckxlbmd0aChjb3VudGVyczogQXJyYXk8bnVtYmVyPikge1xuICAgICAgICByZXR1cm4gKGNvdW50ZXJzLmxlbmd0aCAlIDEwID09PSAwKTtcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgX2RlY29kZUNvZGUoY291bnRlcjogUmVhZG9ubHlBcnJheTxudW1iZXI+KTogQmFyY29kZUluZm8gfCBudWxsIHtcbiAgICAgICAgY29uc3QgZXBzaWxvbiA9IHRoaXMuQVZHX0NPREVfRVJST1I7XG4gICAgICAgIGNvbnN0IGJlc3RNYXRjaCA9IHtcbiAgICAgICAgICAgIGVycm9yOiBOdW1iZXIuTUFYX1ZBTFVFLFxuICAgICAgICAgICAgY29kZTogLTEsXG4gICAgICAgICAgICBzdGFydDogMCxcbiAgICAgICAgICAgIGVuZDogMCxcbiAgICAgICAgfTtcblxuICAgICAgICBmb3IgKGxldCBjb2RlID0gMDsgY29kZSA8IENPREVfUEFUVEVSTi5sZW5ndGg7IGNvZGUrKykge1xuICAgICAgICAgICAgY29uc3QgZXJyb3IgPSB0aGlzLl9tYXRjaFBhdHRlcm4oY291bnRlciwgQ09ERV9QQVRURVJOW2NvZGVdKTtcbiAgICAgICAgICAgIGlmIChlcnJvciA8IGJlc3RNYXRjaC5lcnJvciEpIHtcbiAgICAgICAgICAgICAgICBiZXN0TWF0Y2guY29kZSA9IGNvZGU7XG4gICAgICAgICAgICAgICAgYmVzdE1hdGNoLmVycm9yID0gZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJlc3RNYXRjaC5lcnJvciEgPCBlcHNpbG9uKSB7XG4gICAgICAgICAgICByZXR1cm4gYmVzdE1hdGNoO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHByb3RlY3RlZCBfZGVjb2RlUGF5bG9hZChjb3VudGVyczogUmVhZG9ubHlBcnJheTxudW1iZXI+LCByZXN1bHQ6IEFycmF5PHN0cmluZz4sIGRlY29kZWRDb2RlczogQXJyYXk8QmFyY29kZUluZm8gfCBCYXJjb2RlUG9zaXRpb24+KTogQmFyY29kZUluZm8gfCBudWxsIHtcbiAgICAgICAgbGV0IHBvcyA9IDA7XG4gICAgICAgIGNvbnN0IGNvdW50ZXJMZW5ndGggPSBjb3VudGVycy5sZW5ndGg7XG4gICAgICAgIGNvbnN0IGNvdW50ZXIgPSBbMCwgMCwgMCwgMCwgMF07XG4gICAgICAgIGxldCBjb2RlOiBCYXJjb2RlSW5mbyB8IG51bGwgPSBudWxsO1xuXG4gICAgICAgIHdoaWxlIChwb3MgPCBjb3VudGVyTGVuZ3RoKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDU7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvdW50ZXJbaV0gPSBjb3VudGVyc1twb3NdICogdGhpcy5iYXJTcGFjZVJhdGlvWzBdO1xuICAgICAgICAgICAgICAgIHBvcyArPSAyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29kZSA9IHRoaXMuX2RlY29kZUNvZGUoY291bnRlcik7XG4gICAgICAgICAgICBpZiAoIWNvZGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGAke2NvZGUuY29kZX1gKTtcbiAgICAgICAgICAgIGRlY29kZWRDb2Rlcy5wdXNoKGNvZGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb2RlO1xuICAgIH1cblxuXG4gICAgcHVibGljIGRlY29kZShyb3c/OiBBcnJheTxudW1iZXI+LCBzdGFydD86IEJhcmNvZGVQb3NpdGlvbik6IEJhcmNvZGUgfCBudWxsIHtcbiAgICAgICAgY29uc3Qgc3RhcnRJbmZvID0gdGhpcy5fZmluZFN0YXJ0KCk7XG4gICAgICAgIGlmICghc3RhcnRJbmZvKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGVuZEluZm8gPSB0aGlzLl9maW5kRW5kKCk7XG4gICAgICAgIGlmICghZW5kSW5mbykge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBjb3VudGVycyA9IHRoaXMuX2ZpbGxDb3VudGVycyhzdGFydEluZm8uZW5kLCBlbmRJbmZvLnN0YXJ0LCBmYWxzZSk7XG4gICAgICAgIGlmICghdGhpcy5fdmVyaWZ5Q291bnRlckxlbmd0aChjb3VudGVycykpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRlY29kZWRDb2RlcyA9IFtdO1xuICAgICAgICBkZWNvZGVkQ29kZXMucHVzaChzdGFydEluZm8pO1xuXG4gICAgICAgIGNvbnN0IHJlc3VsdDogQXJyYXk8c3RyaW5nPiA9IFtdO1xuICAgICAgICBjb25zdCBjb2RlID0gdGhpcy5fZGVjb2RlUGF5bG9hZChjb3VudGVycywgcmVzdWx0LCBkZWNvZGVkQ29kZXMpO1xuICAgICAgICBpZiAoIWNvZGUpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQubGVuZ3RoIDwgNSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBkZWNvZGVkQ29kZXMucHVzaChlbmRJbmZvKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNvZGU6IHJlc3VsdC5qb2luKCcnKSxcbiAgICAgICAgICAgIHN0YXJ0OiBzdGFydEluZm8uc3RhcnQsXG4gICAgICAgICAgICBlbmQ6IGVuZEluZm8uZW5kLFxuICAgICAgICAgICAgc3RhcnRJbmZvLFxuICAgICAgICAgICAgZGVjb2RlZENvZGVzLFxuICAgICAgICAgICAgZm9ybWF0OiB0aGlzLkZPUk1BVCxcbiAgICAgICAgfTtcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFR3b09mRml2ZVJlYWRlcjtcbiIsImltcG9ydCBCYXJjb2RlUmVhZGVyLCB7IEJhcmNvZGUsIEJhcmNvZGVQb3NpdGlvbiB9IGZyb20gJy4vYmFyY29kZV9yZWFkZXInO1xuXG4vLyBjb25zdCBBTFBIQUJFVEhfU1RSSU5HID0gJzAxMjM0NTY3ODktJDovLitBQkNEJztcbmNvbnN0IEFMUEhBQkVUID0gWzQ4LCA0OSwgNTAsIDUxLCA1MiwgNTMsIDU0LCA1NSwgNTYsIDU3LCA0NSwgMzYsIDU4LCA0NywgNDYsIDQzLCA2NSwgNjYsIDY3LCA2OF07XG5jb25zdCBDSEFSQUNURVJfRU5DT0RJTkdTID1cbiAgICBbMHgwMDMsIDB4MDA2LCAweDAwOSwgMHgwNjAsIDB4MDEyLCAweDA0MiwgMHgwMjEsIDB4MDI0LCAweDAzMCwgMHgwNDgsIDB4MDBjLCAweDAxOCxcbiAgICAgICAgMHgwNDUsIDB4MDUxLCAweDA1NCwgMHgwMTUsIDB4MDFBLCAweDAyOSwgMHgwMEIsIDB4MDBFXTtcbmNvbnN0IFNUQVJUX0VORCA9IFsweDAxQSwgMHgwMjksIDB4MDBCLCAweDAwRV07XG5jb25zdCBNSU5fRU5DT0RFRF9DSEFSUyA9IDQ7XG5jb25zdCBNQVhfQUNDRVBUQUJMRSA9IDIuMDtcbmNvbnN0IFBBRERJTkcgPSAxLjU7XG5cbmludGVyZmFjZSBUaHJlc2hvbGRTaXplIHtcbiAgICBzaXplOiBudW1iZXIsXG4gICAgY291bnRzOiBudW1iZXIsXG4gICAgbWluOiBudW1iZXIsXG4gICAgbWF4OiBudW1iZXIsXG59O1xuXG5pbnRlcmZhY2UgVGhyZXNob2xkIHtcbiAgICBzcGFjZToge1xuICAgICAgICBuYXJyb3c6IFRocmVzaG9sZFNpemUsXG4gICAgICAgIHdpZGU6IFRocmVzaG9sZFNpemUsXG4gICAgfSxcbiAgICBiYXI6IHtcbiAgICAgICAgbmFycm93OiBUaHJlc2hvbGRTaXplLFxuICAgICAgICB3aWRlOiBUaHJlc2hvbGRTaXplLFxuICAgIH0sXG59O1xuXG5jbGFzcyBOZXdDb2RhYmFyUmVhZGVyIGV4dGVuZHMgQmFyY29kZVJlYWRlciB7XG4gICAgX2NvdW50ZXJzOiBBcnJheTxudW1iZXI+ID0gW107XG4gICAgRk9STUFUID0gJ2NvZGFiYXInO1xuXG4gICAgcHJvdGVjdGVkIF9jb21wdXRlQWx0ZXJuYXRpbmdUaHJlc2hvbGQob2Zmc2V0OiBudW1iZXIsIGVuZDogbnVtYmVyKSB7XG4gICAgICAgIGxldCBtaW4gPSBOdW1iZXIuTUFYX1ZBTFVFO1xuICAgICAgICBsZXQgbWF4ID0gMDtcbiAgICAgICAgbGV0IGNvdW50ZXIgPSAwO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSBvZmZzZXQ7IGkgPCBlbmQ7IGkgKz0gMikge1xuICAgICAgICAgICAgY291bnRlciA9IHRoaXMuX2NvdW50ZXJzW2ldO1xuICAgICAgICAgICAgaWYgKGNvdW50ZXIgPiBtYXgpIHtcbiAgICAgICAgICAgICAgICBtYXggPSBjb3VudGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNvdW50ZXIgPCBtaW4pIHtcbiAgICAgICAgICAgICAgICBtaW4gPSBjb3VudGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuICgobWluICsgbWF4KSAvIDIuMCkgfCAwO1xuICAgIH07XG5cbiAgICBwcm90ZWN0ZWQgX3RvUGF0dGVybihvZmZzZXQ6IG51bWJlcikge1xuICAgICAgICBjb25zdCBudW1Db3VudGVycyA9IDc7XG4gICAgICAgIGNvbnN0IGVuZCA9IG9mZnNldCArIG51bUNvdW50ZXJzO1xuXG4gICAgICAgIGlmIChlbmQgPiB0aGlzLl9jb3VudGVycy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGJhclRocmVzaG9sZCA9IHRoaXMuX2NvbXB1dGVBbHRlcm5hdGluZ1RocmVzaG9sZChvZmZzZXQsIGVuZCk7XG4gICAgICAgIGNvbnN0IHNwYWNlVGhyZXNob2xkID0gdGhpcy5fY29tcHV0ZUFsdGVybmF0aW5nVGhyZXNob2xkKG9mZnNldCArIDEsIGVuZCk7XG5cbiAgICAgICAgbGV0IGJpdG1hc2sgPSAxIDw8IChudW1Db3VudGVycyAtIDEpO1xuICAgICAgICBsZXQgdGhyZXNob2xkID0gMDtcbiAgICAgICAgbGV0IHBhdHRlcm4gPSAwO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtQ291bnRlcnM7IGkrKykge1xuICAgICAgICAgICAgdGhyZXNob2xkID0gKGkgJiAxKSA9PT0gMCA/IGJhclRocmVzaG9sZCA6IHNwYWNlVGhyZXNob2xkO1xuICAgICAgICAgICAgaWYgKHRoaXMuX2NvdW50ZXJzW29mZnNldCArIGldID4gdGhyZXNob2xkKSB7XG4gICAgICAgICAgICAgICAgcGF0dGVybiB8PSBiaXRtYXNrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYml0bWFzayA+Pj0gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBwYXR0ZXJuO1xuICAgIH07XG5cbiAgICBwcm90ZWN0ZWQgX2lzU3RhcnRFbmQocGF0dGVybjogbnVtYmVyKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgU1RBUlRfRU5ELmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoU1RBUlRfRU5EW2ldID09PSBwYXR0ZXJuKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG5cbiAgICBwcm90ZWN0ZWQgX3N1bUNvdW50ZXJzKHN0YXJ0OiBudW1iZXIsIGVuZDogbnVtYmVyKSB7XG4gICAgICAgIGxldCBzdW0gPSAwO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgICAgICAgICBzdW0gKz0gdGhpcy5fY291bnRlcnNbaV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN1bTtcbiAgICB9O1xuXG4gICAgcHJvdGVjdGVkIF9maW5kU3RhcnQoKTogQmFyY29kZVBvc2l0aW9uIHwgbnVsbCB7XG4gICAgICAgIGxldCBzdGFydCA9IHRoaXMuX25leHRVbnNldCh0aGlzLl9yb3cpO1xuICAgICAgICBsZXQgZW5kID0gc3RhcnQ7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCB0aGlzLl9jb3VudGVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgcGF0dGVybiA9IHRoaXMuX3RvUGF0dGVybihpKTtcbiAgICAgICAgICAgIGlmIChwYXR0ZXJuICE9PSAtMSAmJiB0aGlzLl9pc1N0YXJ0RW5kKHBhdHRlcm4pKSB7XG4gICAgICAgICAgICAgICAgLy8gVE9ETzogTG9vayBmb3Igd2hpdGVzcGFjZSBhaGVhZFxuICAgICAgICAgICAgICAgIHN0YXJ0ICs9IHRoaXMuX3N1bUNvdW50ZXJzKDAsIGkpO1xuICAgICAgICAgICAgICAgIGVuZCA9IHN0YXJ0ICsgdGhpcy5fc3VtQ291bnRlcnMoaSwgaSArIDgpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0OiBzdGFydCxcbiAgICAgICAgICAgICAgICAgICAgZW5kOiBlbmQsXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0Q291bnRlcjogaSxcbiAgICAgICAgICAgICAgICAgICAgZW5kQ291bnRlcjogaSArIDgsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgX3BhdHRlcm5Ub0NoYXIocGF0dGVybjogbnVtYmVyKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgQ0hBUkFDVEVSX0VOQ09ESU5HUy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKENIQVJBQ1RFUl9FTkNPRElOR1NbaV0gPT09IHBhdHRlcm4pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShBTFBIQUJFVFtpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcblxuICAgIHByb3RlY3RlZCBfY2FsY3VsYXRlUGF0dGVybkxlbmd0aChvZmZzZXQ6IG51bWJlcikge1xuICAgICAgICBsZXQgc3VtID0gMDtcblxuICAgICAgICBmb3IgKGxldCBpID0gb2Zmc2V0OyBpIDwgb2Zmc2V0ICsgNzsgaSsrKSB7XG4gICAgICAgICAgICBzdW0gKz0gdGhpcy5fY291bnRlcnNbaV07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc3VtO1xuICAgIH07XG5cbiAgICBwcm90ZWN0ZWQgX3ZlcmlmeVdoaXRlc3BhY2Uoc3RhcnRDb3VudGVyOiBudW1iZXIsIGVuZENvdW50ZXI6IG51bWJlcikge1xuICAgICAgICBpZiAoKHN0YXJ0Q291bnRlciAtIDEgPD0gMClcbiAgICAgICAgICAgIHx8IHRoaXMuX2NvdW50ZXJzW3N0YXJ0Q291bnRlciAtIDFdID49ICh0aGlzLl9jYWxjdWxhdGVQYXR0ZXJuTGVuZ3RoKHN0YXJ0Q291bnRlcikgLyAyLjApKSB7XG4gICAgICAgICAgICBpZiAoKGVuZENvdW50ZXIgKyA4ID49IHRoaXMuX2NvdW50ZXJzLmxlbmd0aClcbiAgICAgICAgICAgICAgICB8fCB0aGlzLl9jb3VudGVyc1tlbmRDb3VudGVyICsgN10gPj0gKHRoaXMuX2NhbGN1bGF0ZVBhdHRlcm5MZW5ndGgoZW5kQ291bnRlcikgLyAyLjApKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG5cbiAgICBwcm90ZWN0ZWQgX2NoYXJUb1BhdHRlcm4oY2hhcjogc3RyaW5nKSB7XG4gICAgICAgIGNvbnN0IGNoYXJDb2RlID0gY2hhci5jaGFyQ29kZUF0KDApO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgQUxQSEFCRVQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChBTFBIQUJFVFtpXSA9PT0gY2hhckNvZGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gQ0hBUkFDVEVSX0VOQ09ESU5HU1tpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gMHgwO1xuICAgIH07XG5cbiAgICBwcm90ZWN0ZWQgX3RocmVzaG9sZFJlc3VsdFBhdHRlcm4ocmVzdWx0OiBSZWFkb25seUFycmF5PHN0cmluZz4sIHN0YXJ0Q291bnRlcjogbnVtYmVyKSB7XG4gICAgICAgIGNvbnN0IGNhdGVnb3JpemF0aW9uOiBUaHJlc2hvbGQgPSB7XG4gICAgICAgICAgICAgICAgc3BhY2U6IHtcbiAgICAgICAgICAgICAgICAgICAgbmFycm93OiB7IHNpemU6IDAsIGNvdW50czogMCwgbWluOiAwLCBtYXg6IE51bWJlci5NQVhfVkFMVUUgfSxcbiAgICAgICAgICAgICAgICAgICAgd2lkZTogeyBzaXplOiAwLCBjb3VudHM6IDAsIG1pbjogMCwgbWF4OiBOdW1iZXIuTUFYX1ZBTFVFIH0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBiYXI6IHtcbiAgICAgICAgICAgICAgICAgICAgbmFycm93OiB7IHNpemU6IDAsIGNvdW50czogMCwgbWluOiAwLCBtYXg6IE51bWJlci5NQVhfVkFMVUUgfSxcbiAgICAgICAgICAgICAgICAgICAgd2lkZTogeyBzaXplOiAwLCBjb3VudHM6IDAsIG1pbjogMCwgbWF4OiBOdW1iZXIuTUFYX1ZBTFVFIH0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIGxldCBwb3MgPSBzdGFydENvdW50ZXI7XG4gICAgICAgIGxldCBwYXR0ZXJuOiBudW1iZXI7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZXN1bHQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHBhdHRlcm4gPSB0aGlzLl9jaGFyVG9QYXR0ZXJuKHJlc3VsdFtpXSk7XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gNjsgaiA+PSAwOyBqLS0pIHtcbiAgICAgICAgICAgICAgICBjb25zdCBraW5kID0gKGogJiAxKSA9PT0gMiA/IGNhdGVnb3JpemF0aW9uLmJhciA6IGNhdGVnb3JpemF0aW9uLnNwYWNlO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNhdCA9IChwYXR0ZXJuICYgMSkgPT09IDEgPyBraW5kLndpZGUgOiBraW5kLm5hcnJvdztcbiAgICAgICAgICAgICAgICBjYXQuc2l6ZSArPSB0aGlzLl9jb3VudGVyc1twb3MgKyBqXTtcbiAgICAgICAgICAgICAgICBjYXQuY291bnRzKys7XG4gICAgICAgICAgICAgICAgcGF0dGVybiA+Pj0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBvcyArPSA4O1xuICAgICAgICB9XG5cbiAgICAgICAgKFsnc3BhY2UnLCAnYmFyJ10gYXMgY29uc3QpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgY29uc3QgbmV3a2luZCA9IGNhdGVnb3JpemF0aW9uW2tleV07XG4gICAgICAgICAgICBuZXdraW5kLndpZGUubWluID1cbiAgICAgICAgICAgICAgICBNYXRoLmZsb29yKChuZXdraW5kLm5hcnJvdy5zaXplIC8gbmV3a2luZC5uYXJyb3cuY291bnRzICsgbmV3a2luZC53aWRlLnNpemUgLyBuZXdraW5kLndpZGUuY291bnRzKSAvIDIpO1xuICAgICAgICAgICAgbmV3a2luZC5uYXJyb3cubWF4ID0gTWF0aC5jZWlsKG5ld2tpbmQud2lkZS5taW4pO1xuICAgICAgICAgICAgbmV3a2luZC53aWRlLm1heCA9IE1hdGguY2VpbCgobmV3a2luZC53aWRlLnNpemUgKiBNQVhfQUNDRVBUQUJMRSArIFBBRERJTkcpIC8gbmV3a2luZC53aWRlLmNvdW50cyk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBjYXRlZ29yaXphdGlvbjtcbiAgICB9O1xuXG4gICAgcHJvdGVjdGVkIF92YWxpZGF0ZVJlc3VsdChyZXN1bHQ6IFJlYWRvbmx5QXJyYXk8c3RyaW5nPiwgc3RhcnRDb3VudGVyOiBudW1iZXIpIHtcbiAgICAgICAgY29uc3QgdGhyZXNob2xkcyA9IHRoaXMuX3RocmVzaG9sZFJlc3VsdFBhdHRlcm4ocmVzdWx0LCBzdGFydENvdW50ZXIpO1xuICAgICAgICBsZXQgcG9zID0gc3RhcnRDb3VudGVyO1xuICAgICAgICBsZXQgcGF0dGVybjogbnVtYmVyO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVzdWx0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBwYXR0ZXJuID0gdGhpcy5fY2hhclRvUGF0dGVybihyZXN1bHRbaV0pO1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDY7IGogPj0gMDsgai0tKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qga2luZCA9IChqICYgMSkgPT09IDAgPyB0aHJlc2hvbGRzLmJhciA6IHRocmVzaG9sZHMuc3BhY2U7XG4gICAgICAgICAgICAgICAgY29uc3QgY2F0ID0gKHBhdHRlcm4gJiAxKSA9PT0gMSA/IGtpbmQud2lkZSA6IGtpbmQubmFycm93O1xuICAgICAgICAgICAgICAgIGNvbnN0IHNpemUgPSB0aGlzLl9jb3VudGVyc1twb3MgKyBqXTtcbiAgICAgICAgICAgICAgICBpZiAoc2l6ZSA8IGNhdC5taW4gfHwgc2l6ZSA+IGNhdC5tYXgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwYXR0ZXJuID4+PSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcG9zICs9IDg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcblxuICAgIHB1YmxpYyBkZWNvZGUocm93PzogQXJyYXk8bnVtYmVyPiwgc3RhcnQ/OiBCYXJjb2RlUG9zaXRpb24gfCBudW1iZXIgfCBudWxsKTogQmFyY29kZSB8IG51bGwge1xuXG4gICAgICAgIHRoaXMuX2NvdW50ZXJzID0gdGhpcy5fZmlsbENvdW50ZXJzKCk7XG4gICAgICAgIHN0YXJ0ID0gdGhpcy5fZmluZFN0YXJ0KCk7XG4gICAgICAgIGlmICghc3RhcnQpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGxldCBuZXh0U3RhcnQgPSBzdGFydC5zdGFydENvdW50ZXIgYXMgbnVtYmVyO1xuXG4gICAgICAgIGNvbnN0IHJlc3VsdDogQXJyYXk8c3RyaW5nPiA9IFtdO1xuICAgICAgICBsZXQgcGF0dGVybjogbnVtYmVyO1xuICAgICAgICBkbyB7XG4gICAgICAgICAgICBwYXR0ZXJuID0gdGhpcy5fdG9QYXR0ZXJuKG5leHRTdGFydCk7XG4gICAgICAgICAgICBpZiAocGF0dGVybiA8IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGRlY29kZWRDaGFyID0gdGhpcy5fcGF0dGVyblRvQ2hhcihwYXR0ZXJuKTtcbiAgICAgICAgICAgIGlmIChkZWNvZGVkQ2hhciA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0LnB1c2goZGVjb2RlZENoYXIpO1xuICAgICAgICAgICAgbmV4dFN0YXJ0ICs9IDg7XG4gICAgICAgICAgICBpZiAocmVzdWx0Lmxlbmd0aCA+IDEgJiYgdGhpcy5faXNTdGFydEVuZChwYXR0ZXJuKSkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IHdoaWxlIChuZXh0U3RhcnQgPCB0aGlzLl9jb3VudGVycy5sZW5ndGgpO1xuXG4gICAgICAgIC8vIHZlcmlmeSBlbmRcbiAgICAgICAgaWYgKChyZXN1bHQubGVuZ3RoIC0gMikgPCBNSU5fRU5DT0RFRF9DSEFSUyB8fCAhdGhpcy5faXNTdGFydEVuZChwYXR0ZXJuKSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICAvLyB2ZXJpZnkgZW5kIHdoaXRlIHNwYWNlXG4gICAgICAgIGlmICghdGhpcy5fdmVyaWZ5V2hpdGVzcGFjZShzdGFydC5zdGFydENvdW50ZXIgYXMgbnVtYmVyLCBuZXh0U3RhcnQgLSA4KSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRoaXMuX3ZhbGlkYXRlUmVzdWx0KHJlc3VsdCwgc3RhcnQuc3RhcnRDb3VudGVyIGFzIG51bWJlcikpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgbmV4dFN0YXJ0ID0gbmV4dFN0YXJ0ID4gdGhpcy5fY291bnRlcnMubGVuZ3RoID8gdGhpcy5fY291bnRlcnMubGVuZ3RoIDogbmV4dFN0YXJ0O1xuICAgICAgICBjb25zdCBlbmQgPSBzdGFydC5zdGFydCArIHRoaXMuX3N1bUNvdW50ZXJzKHN0YXJ0LnN0YXJ0Q291bnRlciBhcyBudW1iZXIsIG5leHRTdGFydCAtIDgpO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjb2RlOiByZXN1bHQuam9pbignJyksXG4gICAgICAgICAgICBzdGFydDogc3RhcnQuc3RhcnQsXG4gICAgICAgICAgICBlbmQ6IGVuZCxcbiAgICAgICAgICAgIHN0YXJ0SW5mbzogc3RhcnQsXG4gICAgICAgICAgICBkZWNvZGVkQ29kZXM6IHJlc3VsdCxcbiAgICAgICAgICAgIGZvcm1hdDogdGhpcy5GT1JNQVQsIC8vIFRPRE86IGkgdGhpbmsgaXQgc2hvdWxkIG5vdCBiZSByZXF1aXJlZCB0byByZXR1cm4gZm9ybWF0IGZyb20gdGhpcywgYXMgYmFyY29kZV9yZWFkZXIgZm9yY2Ugc2V0cyB0aGUgZm9ybWF0IGFueXdheVxuICAgICAgICB9O1xuICAgIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IE5ld0NvZGFiYXJSZWFkZXI7XG4iLCJpbXBvcnQgQmFyY29kZVJlYWRlciwgeyBCYXJjb2RlQ29ycmVjdGlvbiwgQmFyY29kZVBvc2l0aW9uLCBCYXJjb2RlLCBCYXJjb2RlSW5mbyB9IGZyb20gJy4vYmFyY29kZV9yZWFkZXInO1xuXG5jbGFzcyBDb2RlMTI4UmVhZGVyIGV4dGVuZHMgQmFyY29kZVJlYWRlciB7XG4gICAgQ09ERV9TSElGVCA9IDk4O1xuICAgIENPREVfQyA9IDk5O1xuICAgIENPREVfQiA9IDEwMDtcbiAgICBDT0RFX0EgPSAxMDE7XG4gICAgU1RBUlRfQ09ERV9BID0gMTAzO1xuICAgIFNUQVJUX0NPREVfQiA9IDEwNDtcbiAgICBTVEFSVF9DT0RFX0MgPSAxMDU7XG4gICAgU1RPUF9DT0RFID0gMTA2O1xuICAgIENPREVfUEFUVEVSTiA9IFtcbiAgICAgICAgICAgIFsyLCAxLCAyLCAyLCAyLCAyXSxcbiAgICAgICAgICAgIFsyLCAyLCAyLCAxLCAyLCAyXSxcbiAgICAgICAgICAgIFsyLCAyLCAyLCAyLCAyLCAxXSxcbiAgICAgICAgICAgIFsxLCAyLCAxLCAyLCAyLCAzXSxcbiAgICAgICAgICAgIFsxLCAyLCAxLCAzLCAyLCAyXSxcbiAgICAgICAgICAgIFsxLCAzLCAxLCAyLCAyLCAyXSxcbiAgICAgICAgICAgIFsxLCAyLCAyLCAyLCAxLCAzXSxcbiAgICAgICAgICAgIFsxLCAyLCAyLCAzLCAxLCAyXSxcbiAgICAgICAgICAgIFsxLCAzLCAyLCAyLCAxLCAyXSxcbiAgICAgICAgICAgIFsyLCAyLCAxLCAyLCAxLCAzXSxcbiAgICAgICAgICAgIFsyLCAyLCAxLCAzLCAxLCAyXSxcbiAgICAgICAgICAgIFsyLCAzLCAxLCAyLCAxLCAyXSxcbiAgICAgICAgICAgIFsxLCAxLCAyLCAyLCAzLCAyXSxcbiAgICAgICAgICAgIFsxLCAyLCAyLCAxLCAzLCAyXSxcbiAgICAgICAgICAgIFsxLCAyLCAyLCAyLCAzLCAxXSxcbiAgICAgICAgICAgIFsxLCAxLCAzLCAyLCAyLCAyXSxcbiAgICAgICAgICAgIFsxLCAyLCAzLCAxLCAyLCAyXSxcbiAgICAgICAgICAgIFsxLCAyLCAzLCAyLCAyLCAxXSxcbiAgICAgICAgICAgIFsyLCAyLCAzLCAyLCAxLCAxXSxcbiAgICAgICAgICAgIFsyLCAyLCAxLCAxLCAzLCAyXSxcbiAgICAgICAgICAgIFsyLCAyLCAxLCAyLCAzLCAxXSxcbiAgICAgICAgICAgIFsyLCAxLCAzLCAyLCAxLCAyXSxcbiAgICAgICAgICAgIFsyLCAyLCAzLCAxLCAxLCAyXSxcbiAgICAgICAgICAgIFszLCAxLCAyLCAxLCAzLCAxXSxcbiAgICAgICAgICAgIFszLCAxLCAxLCAyLCAyLCAyXSxcbiAgICAgICAgICAgIFszLCAyLCAxLCAxLCAyLCAyXSxcbiAgICAgICAgICAgIFszLCAyLCAxLCAyLCAyLCAxXSxcbiAgICAgICAgICAgIFszLCAxLCAyLCAyLCAxLCAyXSxcbiAgICAgICAgICAgIFszLCAyLCAyLCAxLCAxLCAyXSxcbiAgICAgICAgICAgIFszLCAyLCAyLCAyLCAxLCAxXSxcbiAgICAgICAgICAgIFsyLCAxLCAyLCAxLCAyLCAzXSxcbiAgICAgICAgICAgIFsyLCAxLCAyLCAzLCAyLCAxXSxcbiAgICAgICAgICAgIFsyLCAzLCAyLCAxLCAyLCAxXSxcbiAgICAgICAgICAgIFsxLCAxLCAxLCAzLCAyLCAzXSxcbiAgICAgICAgICAgIFsxLCAzLCAxLCAxLCAyLCAzXSxcbiAgICAgICAgICAgIFsxLCAzLCAxLCAzLCAyLCAxXSxcbiAgICAgICAgICAgIFsxLCAxLCAyLCAzLCAxLCAzXSxcbiAgICAgICAgICAgIFsxLCAzLCAyLCAxLCAxLCAzXSxcbiAgICAgICAgICAgIFsxLCAzLCAyLCAzLCAxLCAxXSxcbiAgICAgICAgICAgIFsyLCAxLCAxLCAzLCAxLCAzXSxcbiAgICAgICAgICAgIFsyLCAzLCAxLCAxLCAxLCAzXSxcbiAgICAgICAgICAgIFsyLCAzLCAxLCAzLCAxLCAxXSxcbiAgICAgICAgICAgIFsxLCAxLCAyLCAxLCAzLCAzXSxcbiAgICAgICAgICAgIFsxLCAxLCAyLCAzLCAzLCAxXSxcbiAgICAgICAgICAgIFsxLCAzLCAyLCAxLCAzLCAxXSxcbiAgICAgICAgICAgIFsxLCAxLCAzLCAxLCAyLCAzXSxcbiAgICAgICAgICAgIFsxLCAxLCAzLCAzLCAyLCAxXSxcbiAgICAgICAgICAgIFsxLCAzLCAzLCAxLCAyLCAxXSxcbiAgICAgICAgICAgIFszLCAxLCAzLCAxLCAyLCAxXSxcbiAgICAgICAgICAgIFsyLCAxLCAxLCAzLCAzLCAxXSxcbiAgICAgICAgICAgIFsyLCAzLCAxLCAxLCAzLCAxXSxcbiAgICAgICAgICAgIFsyLCAxLCAzLCAxLCAxLCAzXSxcbiAgICAgICAgICAgIFsyLCAxLCAzLCAzLCAxLCAxXSxcbiAgICAgICAgICAgIFsyLCAxLCAzLCAxLCAzLCAxXSxcbiAgICAgICAgICAgIFszLCAxLCAxLCAxLCAyLCAzXSxcbiAgICAgICAgICAgIFszLCAxLCAxLCAzLCAyLCAxXSxcbiAgICAgICAgICAgIFszLCAzLCAxLCAxLCAyLCAxXSxcbiAgICAgICAgICAgIFszLCAxLCAyLCAxLCAxLCAzXSxcbiAgICAgICAgICAgIFszLCAxLCAyLCAzLCAxLCAxXSxcbiAgICAgICAgICAgIFszLCAzLCAyLCAxLCAxLCAxXSxcbiAgICAgICAgICAgIFszLCAxLCA0LCAxLCAxLCAxXSxcbiAgICAgICAgICAgIFsyLCAyLCAxLCA0LCAxLCAxXSxcbiAgICAgICAgICAgIFs0LCAzLCAxLCAxLCAxLCAxXSxcbiAgICAgICAgICAgIFsxLCAxLCAxLCAyLCAyLCA0XSxcbiAgICAgICAgICAgIFsxLCAxLCAxLCA0LCAyLCAyXSxcbiAgICAgICAgICAgIFsxLCAyLCAxLCAxLCAyLCA0XSxcbiAgICAgICAgICAgIFsxLCAyLCAxLCA0LCAyLCAxXSxcbiAgICAgICAgICAgIFsxLCA0LCAxLCAxLCAyLCAyXSxcbiAgICAgICAgICAgIFsxLCA0LCAxLCAyLCAyLCAxXSxcbiAgICAgICAgICAgIFsxLCAxLCAyLCAyLCAxLCA0XSxcbiAgICAgICAgICAgIFsxLCAxLCAyLCA0LCAxLCAyXSxcbiAgICAgICAgICAgIFsxLCAyLCAyLCAxLCAxLCA0XSxcbiAgICAgICAgICAgIFsxLCAyLCAyLCA0LCAxLCAxXSxcbiAgICAgICAgICAgIFsxLCA0LCAyLCAxLCAxLCAyXSxcbiAgICAgICAgICAgIFsxLCA0LCAyLCAyLCAxLCAxXSxcbiAgICAgICAgICAgIFsyLCA0LCAxLCAyLCAxLCAxXSxcbiAgICAgICAgICAgIFsyLCAyLCAxLCAxLCAxLCA0XSxcbiAgICAgICAgICAgIFs0LCAxLCAzLCAxLCAxLCAxXSxcbiAgICAgICAgICAgIFsyLCA0LCAxLCAxLCAxLCAyXSxcbiAgICAgICAgICAgIFsxLCAzLCA0LCAxLCAxLCAxXSxcbiAgICAgICAgICAgIFsxLCAxLCAxLCAyLCA0LCAyXSxcbiAgICAgICAgICAgIFsxLCAyLCAxLCAxLCA0LCAyXSxcbiAgICAgICAgICAgIFsxLCAyLCAxLCAyLCA0LCAxXSxcbiAgICAgICAgICAgIFsxLCAxLCA0LCAyLCAxLCAyXSxcbiAgICAgICAgICAgIFsxLCAyLCA0LCAxLCAxLCAyXSxcbiAgICAgICAgICAgIFsxLCAyLCA0LCAyLCAxLCAxXSxcbiAgICAgICAgICAgIFs0LCAxLCAxLCAyLCAxLCAyXSxcbiAgICAgICAgICAgIFs0LCAyLCAxLCAxLCAxLCAyXSxcbiAgICAgICAgICAgIFs0LCAyLCAxLCAyLCAxLCAxXSxcbiAgICAgICAgICAgIFsyLCAxLCAyLCAxLCA0LCAxXSxcbiAgICAgICAgICAgIFsyLCAxLCA0LCAxLCAyLCAxXSxcbiAgICAgICAgICAgIFs0LCAxLCAyLCAxLCAyLCAxXSxcbiAgICAgICAgICAgIFsxLCAxLCAxLCAxLCA0LCAzXSxcbiAgICAgICAgICAgIFsxLCAxLCAxLCAzLCA0LCAxXSxcbiAgICAgICAgICAgIFsxLCAzLCAxLCAxLCA0LCAxXSxcbiAgICAgICAgICAgIFsxLCAxLCA0LCAxLCAxLCAzXSxcbiAgICAgICAgICAgIFsxLCAxLCA0LCAzLCAxLCAxXSxcbiAgICAgICAgICAgIFs0LCAxLCAxLCAxLCAxLCAzXSxcbiAgICAgICAgICAgIFs0LCAxLCAxLCAzLCAxLCAxXSxcbiAgICAgICAgICAgIFsxLCAxLCAzLCAxLCA0LCAxXSxcbiAgICAgICAgICAgIFsxLCAxLCA0LCAxLCAzLCAxXSxcbiAgICAgICAgICAgIFszLCAxLCAxLCAxLCA0LCAxXSxcbiAgICAgICAgICAgIFs0LCAxLCAxLCAxLCAzLCAxXSxcbiAgICAgICAgICAgIFsyLCAxLCAxLCA0LCAxLCAyXSxcbiAgICAgICAgICAgIFsyLCAxLCAxLCAyLCAxLCA0XSxcbiAgICAgICAgICAgIFsyLCAxLCAxLCAyLCAzLCAyXSxcbiAgICAgICAgICAgIFsyLCAzLCAzLCAxLCAxLCAxLCAyXSxcbiAgICAgICAgXTtcbiAgICBTSU5HTEVfQ09ERV9FUlJPUiA9IDAuNjQ7XG4gICAgQVZHX0NPREVfRVJST1IgPSAwLjMwO1xuICAgIEZPUk1BVCA9ICdjb2RlXzEyOCc7XG4gICAgTU9EVUxFX0lORElDRVMgPSB7IGJhcjogWzAsIDIsIDRdLCBzcGFjZTogWzEsIDMsIDVdIH07XG5cbiAgICBwcm90ZWN0ZWQgX2RlY29kZUNvZGUoc3RhcnQ6IG51bWJlciwgY29ycmVjdGlvbj86IEJhcmNvZGVDb3JyZWN0aW9uKTogQmFyY29kZUluZm8gfCBudWxsIHtcbiAgICAgICAgY29uc3QgYmVzdE1hdGNoID0ge1xuICAgICAgICAgICAgZXJyb3I6IE51bWJlci5NQVhfVkFMVUUsXG4gICAgICAgICAgICBjb2RlOiAtMSxcbiAgICAgICAgICAgIHN0YXJ0OiBzdGFydCxcbiAgICAgICAgICAgIGVuZDogc3RhcnQsXG4gICAgICAgICAgICBjb3JyZWN0aW9uOiB7XG4gICAgICAgICAgICAgICAgYmFyOiAxLFxuICAgICAgICAgICAgICAgIHNwYWNlOiAxLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICAgICAgbGV0IGNvdW50ZXIgPSBbMCwgMCwgMCwgMCwgMCwgMF07XG4gICAgICAgIGNvbnN0IG9mZnNldCA9IHN0YXJ0O1xuICAgICAgICBsZXQgaXNXaGl0ZSA9ICF0aGlzLl9yb3dbb2Zmc2V0XTtcbiAgICAgICAgbGV0IGNvdW50ZXJQb3MgPSAwO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSBvZmZzZXQ7IGkgPCB0aGlzLl9yb3cubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9yb3dbaV0gXiAoaXNXaGl0ZSA/IDEgOiAwKSkge1xuICAgICAgICAgICAgICAgIGNvdW50ZXJbY291bnRlclBvc10rKztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvdW50ZXJQb3MgPT09IGNvdW50ZXIubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29ycmVjdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fY29ycmVjdChjb3VudGVyLCBjb3JyZWN0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBjb2RlID0gMDsgY29kZSA8IHRoaXMuQ09ERV9QQVRURVJOLmxlbmd0aDsgY29kZSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBlcnJvciA9IHRoaXMuX21hdGNoUGF0dGVybihjb3VudGVyLCB0aGlzLkNPREVfUEFUVEVSTltjb2RlXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3IgPCBiZXN0TWF0Y2guZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiZXN0TWF0Y2guY29kZSA9IGNvZGU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYmVzdE1hdGNoLmVycm9yID0gZXJyb3I7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYmVzdE1hdGNoLmVuZCA9IGk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChiZXN0TWF0Y2guY29kZSA9PT0gLTEgfHwgYmVzdE1hdGNoLmVycm9yID4gdGhpcy5BVkdfQ09ERV9FUlJPUikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuQ09ERV9QQVRURVJOW2Jlc3RNYXRjaC5jb2RlXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYmVzdE1hdGNoLmNvcnJlY3Rpb24uYmFyID0gdGhpcy5jYWxjdWxhdGVDb3JyZWN0aW9uKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuQ09ERV9QQVRURVJOW2Jlc3RNYXRjaC5jb2RlXSwgY291bnRlcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLk1PRFVMRV9JTkRJQ0VTLmJhcik7XG4gICAgICAgICAgICAgICAgICAgICAgICBiZXN0TWF0Y2guY29ycmVjdGlvbi5zcGFjZSA9IHRoaXMuY2FsY3VsYXRlQ29ycmVjdGlvbihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLkNPREVfUEFUVEVSTltiZXN0TWF0Y2guY29kZV0sIGNvdW50ZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5NT0RVTEVfSU5ESUNFUy5zcGFjZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJlc3RNYXRjaDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb3VudGVyUG9zKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvdW50ZXJbY291bnRlclBvc10gPSAxO1xuICAgICAgICAgICAgICAgIGlzV2hpdGUgPSAhaXNXaGl0ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuXG4gICAgcHJvdGVjdGVkIF9jb3JyZWN0KGNvdW50ZXI6IEFycmF5PG51bWJlcj4sIGNvcnJlY3Rpb246IEJhcmNvZGVDb3JyZWN0aW9uKSB7XG4gICAgICAgIHRoaXMuX2NvcnJlY3RCYXJzKGNvdW50ZXIsIGNvcnJlY3Rpb24uYmFyLCB0aGlzLk1PRFVMRV9JTkRJQ0VTLmJhcik7XG4gICAgICAgIHRoaXMuX2NvcnJlY3RCYXJzKGNvdW50ZXIsIGNvcnJlY3Rpb24uc3BhY2UsIHRoaXMuTU9EVUxFX0lORElDRVMuc3BhY2UpO1xuICAgIH07XG5cbiAgICAvLyBUT0RPOiBfZmluZFN0YXJ0IGFuZCBkZWNvZGVDb2RlIHNoYXJlIHNpbWlsYXIgY29kZSwgY2FuIHdlIHJlLXVzZSBzb21lP1xuICAgIHByb3RlY3RlZCBfZmluZFN0YXJ0KCk6IEJhcmNvZGVJbmZvIHwgbnVsbCB7XG4gICAgICAgIGNvbnN0IGNvdW50ZXIgPSBbMCwgMCwgMCwgMCwgMCwgMF07XG4gICAgICAgIGNvbnN0IG9mZnNldCA9IHRoaXMuX25leHRTZXQodGhpcy5fcm93KTtcbiAgICAgICAgY29uc3QgYmVzdE1hdGNoID0ge1xuICAgICAgICAgICAgZXJyb3I6IE51bWJlci5NQVhfVkFMVUUsXG4gICAgICAgICAgICBjb2RlOiAtMSxcbiAgICAgICAgICAgIHN0YXJ0OiAwLFxuICAgICAgICAgICAgZW5kOiAwLFxuICAgICAgICAgICAgY29ycmVjdGlvbjoge1xuICAgICAgICAgICAgICAgIGJhcjogMSxcbiAgICAgICAgICAgICAgICBzcGFjZTogMSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgICAgIGxldCBpc1doaXRlID0gZmFsc2U7XG4gICAgICAgIGxldCBjb3VudGVyUG9zID0gMDtcblxuICAgICAgICBmb3IgKGxldCBpID0gb2Zmc2V0OyBpIDwgdGhpcy5fcm93Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fcm93W2ldIF4gKGlzV2hpdGUgPyAxIDogMCkpIHtcbiAgICAgICAgICAgICAgICBjb3VudGVyW2NvdW50ZXJQb3NdKys7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChjb3VudGVyUG9zID09PSBjb3VudGVyLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3VtID0gY291bnRlci5yZWR1Y2UoKHByZXYsIG5leHQpID0+IHByZXYgKyBuZXh0LCAwKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgY29kZSA9IHRoaXMuU1RBUlRfQ09ERV9BOyBjb2RlIDw9IHRoaXMuU1RBUlRfQ09ERV9DOyBjb2RlKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yID0gdGhpcy5fbWF0Y2hQYXR0ZXJuKGNvdW50ZXIsIHRoaXMuQ09ERV9QQVRURVJOW2NvZGVdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnJvciA8IGJlc3RNYXRjaC5lcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJlc3RNYXRjaC5jb2RlID0gY29kZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiZXN0TWF0Y2guZXJyb3IgPSBlcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoYmVzdE1hdGNoLmVycm9yIDwgdGhpcy5BVkdfQ09ERV9FUlJPUikge1xuICAgICAgICAgICAgICAgICAgICAgICAgYmVzdE1hdGNoLnN0YXJ0ID0gaSAtIHN1bTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJlc3RNYXRjaC5lbmQgPSBpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYmVzdE1hdGNoLmNvcnJlY3Rpb24uYmFyID0gdGhpcy5jYWxjdWxhdGVDb3JyZWN0aW9uKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuQ09ERV9QQVRURVJOW2Jlc3RNYXRjaC5jb2RlXSwgY291bnRlcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLk1PRFVMRV9JTkRJQ0VTLmJhcik7XG4gICAgICAgICAgICAgICAgICAgICAgICBiZXN0TWF0Y2guY29ycmVjdGlvbi5zcGFjZSA9IHRoaXMuY2FsY3VsYXRlQ29ycmVjdGlvbihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLkNPREVfUEFUVEVSTltiZXN0TWF0Y2guY29kZV0sIGNvdW50ZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5NT0RVTEVfSU5ESUNFUy5zcGFjZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYmVzdE1hdGNoO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCA0OyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50ZXJbal0gPSBjb3VudGVyW2ogKyAyXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb3VudGVyWzRdID0gMDtcbiAgICAgICAgICAgICAgICAgICAgY291bnRlcls1XSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGNvdW50ZXJQb3MtLTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb3VudGVyUG9zKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvdW50ZXJbY291bnRlclBvc10gPSAxO1xuICAgICAgICAgICAgICAgIGlzV2hpdGUgPSAhaXNXaGl0ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuXG4gICAgcHVibGljIGRlY29kZShyb3c/OiBBcnJheTxudW1iZXI+LCBzdGFydD86IEJhcmNvZGVQb3NpdGlvbik6IEJhcmNvZGUgfCBudWxsIHtcbiAgICAgICAgY29uc3Qgc3RhcnRJbmZvID0gdGhpcy5fZmluZFN0YXJ0KCk7XG4gICAgICAgIGlmIChzdGFydEluZm8gPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIC8vIHZhciBzZWxmID0gdGhpcyxcbiAgICAgICAgLy8gICAgIGRvbmUgPSBmYWxzZSxcbiAgICAgICAgLy8gICAgIHJlc3VsdCA9IFtdLFxuICAgICAgICAvLyAgICAgbXVsdGlwbGllciA9IDAsXG4gICAgICAgIC8vICAgICBjaGVja3N1bSA9IDAsXG4gICAgICAgIC8vICAgICBjb2Rlc2V0LFxuICAgICAgICAvLyAgICAgcmF3UmVzdWx0ID0gW10sXG4gICAgICAgIC8vICAgICBkZWNvZGVkQ29kZXMgPSBbXSxcbiAgICAgICAgLy8gICAgIHNoaWZ0TmV4dCA9IGZhbHNlLFxuICAgICAgICAvLyAgICAgdW5zaGlmdCxcbiAgICAgICAgLy8gICAgIHJlbW92ZUxhc3RDaGFyYWN0ZXIgPSB0cnVlO1xuXG4gICAgICAgIGxldCBjb2RlOiBCYXJjb2RlSW5mbyB8IG51bGwgPSB7XG4gICAgICAgICAgICBjb2RlOiBzdGFydEluZm8uY29kZSxcbiAgICAgICAgICAgIHN0YXJ0OiBzdGFydEluZm8uc3RhcnQsXG4gICAgICAgICAgICBlbmQ6IHN0YXJ0SW5mby5lbmQsXG4gICAgICAgICAgICBjb3JyZWN0aW9uOiB7XG4gICAgICAgICAgICAgICAgYmFyOiBzdGFydEluZm8uY29ycmVjdGlvbiEuYmFyLFxuICAgICAgICAgICAgICAgIHNwYWNlOiBzdGFydEluZm8uY29ycmVjdGlvbiEuc3BhY2UsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBkZWNvZGVkQ29kZXMgPSBbXTtcbiAgICAgICAgZGVjb2RlZENvZGVzLnB1c2goY29kZSk7XG4gICAgICAgIGxldCBjaGVja3N1bSA9IGNvZGUuY29kZTtcbiAgICAgICAgbGV0IGNvZGVzZXQgPSAoKGM6IG51bWJlcikgPT4ge1xuICAgICAgICAgICAgc3dpdGNoIChjKSB7XG4gICAgICAgICAgICAgICAgY2FzZSB0aGlzLlNUQVJUX0NPREVfQTpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuQ09ERV9BO1xuICAgICAgICAgICAgICAgIGNhc2UgdGhpcy5TVEFSVF9DT0RFX0I6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLkNPREVfQjtcbiAgICAgICAgICAgICAgICBjYXNlIHRoaXMuU1RBUlRfQ09ERV9DOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5DT0RFX0M7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pKGNvZGUuY29kZSk7XG4gICAgICAgIGxldCBkb25lID0gZmFsc2U7XG4gICAgICAgIGxldCBzaGlmdE5leHQgPSBmYWxzZTtcbiAgICAgICAgbGV0IHVuc2hpZnQgPSBzaGlmdE5leHQ7XG4gICAgICAgIGxldCByZW1vdmVMYXN0Q2hhcmFjdGVyID0gdHJ1ZTtcbiAgICAgICAgbGV0IG11bHRpcGxpZXIgPSAwO1xuICAgICAgICBsZXQgcmF3UmVzdWx0OiBBcnJheTxudW1iZXI+ID0gW107XG4gICAgICAgIGxldCByZXN1bHQ6IEFycmF5PHN0cmluZyB8IG51bWJlcj4gPSBbXTsgLy8gVE9ETzogaSB0aGluayB0aGlzIHNob3VsZCBiZSBzdHJpbmcgb25seSwgYnV0IGl0IGNyZWF0ZXMgcHJvYmxlbXMgaWYgaXQgaXNcblxuICAgICAgICB3aGlsZSAoIWRvbmUpIHtcbiAgICAgICAgICAgIHVuc2hpZnQgPSBzaGlmdE5leHQ7XG4gICAgICAgICAgICBzaGlmdE5leHQgPSBmYWxzZTtcbiAgICAgICAgICAgIGNvZGUgPSB0aGlzLl9kZWNvZGVDb2RlKGNvZGUhLmVuZCwgY29kZSEuY29ycmVjdGlvbik7XG4gICAgICAgICAgICBpZiAoY29kZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmIChjb2RlLmNvZGUgIT09IHRoaXMuU1RPUF9DT0RFKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZUxhc3RDaGFyYWN0ZXIgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChjb2RlLmNvZGUgIT09IHRoaXMuU1RPUF9DT0RFKSB7XG4gICAgICAgICAgICAgICAgICAgIHJhd1Jlc3VsdC5wdXNoKGNvZGUuY29kZSk7XG4gICAgICAgICAgICAgICAgICAgIG11bHRpcGxpZXIrKztcbiAgICAgICAgICAgICAgICAgICAgY2hlY2tzdW0gKz0gbXVsdGlwbGllciAqIGNvZGUuY29kZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGVjb2RlZENvZGVzLnB1c2goY29kZSk7XG5cbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGNvZGVzZXQpIHtcbiAgICAgICAgICAgICAgICBjYXNlIHRoaXMuQ09ERV9BOlxuICAgICAgICAgICAgICAgICAgICBpZiAoY29kZS5jb2RlIDwgNjQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUoMzIgKyBjb2RlLmNvZGUpKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjb2RlLmNvZGUgPCA5Nikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlLmNvZGUgLSA2NCkpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvZGUuY29kZSAhPT0gdGhpcy5TVE9QX0NPREUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW1vdmVMYXN0Q2hhcmFjdGVyID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGNvZGUuY29kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSB0aGlzLkNPREVfU0hJRlQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hpZnROZXh0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2Rlc2V0ID0gdGhpcy5DT0RFX0I7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIHRoaXMuQ09ERV9COlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGVzZXQgPSB0aGlzLkNPREVfQjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgdGhpcy5DT0RFX0M6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZXNldCA9IHRoaXMuQ09ERV9DO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSB0aGlzLlNUT1BfQ09ERTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb25lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIHRoaXMuQ09ERV9COlxuICAgICAgICAgICAgICAgICAgICBpZiAoY29kZS5jb2RlIDwgOTYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUoMzIgKyBjb2RlLmNvZGUpKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb2RlLmNvZGUgIT09IHRoaXMuU1RPUF9DT0RFKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlTGFzdENoYXJhY3RlciA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChjb2RlLmNvZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIHRoaXMuQ09ERV9TSElGVDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hpZnROZXh0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZXNldCA9IHRoaXMuQ09ERV9BO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIHRoaXMuQ09ERV9BOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2Rlc2V0ID0gdGhpcy5DT0RFX0E7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgdGhpcy5DT0RFX0M6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGVzZXQgPSB0aGlzLkNPREVfQztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSB0aGlzLlNUT1BfQ09ERTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9uZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgdGhpcy5DT0RFX0M6XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb2RlLmNvZGUgPCAxMDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGNvZGUuY29kZSA8IDEwID8gJzAnICsgY29kZS5jb2RlIDogY29kZS5jb2RlKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb2RlLmNvZGUgIT09IHRoaXMuU1RPUF9DT0RFKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlTGFzdENoYXJhY3RlciA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChjb2RlLmNvZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgdGhpcy5DT0RFX0E6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZXNldCA9IHRoaXMuQ09ERV9BO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSB0aGlzLkNPREVfQjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2Rlc2V0ID0gdGhpcy5DT0RFX0I7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIHRoaXMuU1RPUF9DT0RFOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvbmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZG9uZSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodW5zaGlmdCkge1xuICAgICAgICAgICAgICAgIGNvZGVzZXQgPSBjb2Rlc2V0ID09PSB0aGlzLkNPREVfQSA/IHRoaXMuQ09ERV9CIDogdGhpcy5DT0RFX0E7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY29kZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBjb2RlLmVuZCA9IHRoaXMuX25leHRVbnNldCh0aGlzLl9yb3csIGNvZGUuZW5kKTtcbiAgICAgICAgaWYgKCF0aGlzLl92ZXJpZnlUcmFpbGluZ1doaXRlc3BhY2UoY29kZSkpe1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBjaGVja3N1bSAtPSBtdWx0aXBsaWVyICogcmF3UmVzdWx0W3Jhd1Jlc3VsdC5sZW5ndGggLSAxXTtcbiAgICAgICAgaWYgKGNoZWNrc3VtICUgMTAzICE9PSByYXdSZXN1bHRbcmF3UmVzdWx0Lmxlbmd0aCAtIDFdKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghcmVzdWx0Lmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICAvLyByZW1vdmUgbGFzdCBjb2RlIGZyb20gcmVzdWx0IChjaGVja3N1bSlcbiAgICAgICAgaWYgKHJlbW92ZUxhc3RDaGFyYWN0ZXIpIHtcbiAgICAgICAgICAgIHJlc3VsdC5zcGxpY2UocmVzdWx0Lmxlbmd0aCAtIDEsIDEpO1xuICAgICAgICB9XG5cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY29kZTogcmVzdWx0LmpvaW4oJycpLFxuICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0SW5mby5zdGFydCxcbiAgICAgICAgICAgIGVuZDogY29kZS5lbmQsXG4gICAgICAgICAgICBjb2Rlc2V0OiBjb2Rlc2V0IGFzIG51bWJlcixcbiAgICAgICAgICAgIHN0YXJ0SW5mbzogc3RhcnRJbmZvLFxuICAgICAgICAgICAgZGVjb2RlZENvZGVzOiBkZWNvZGVkQ29kZXMsXG4gICAgICAgICAgICBlbmRJbmZvOiBjb2RlLFxuICAgICAgICAgICAgZm9ybWF0OiB0aGlzLkZPUk1BVCxcbiAgICAgICAgfTtcbiAgICB9O1xuXG4gICAgcHJvdGVjdGVkIF92ZXJpZnlUcmFpbGluZ1doaXRlc3BhY2UoZW5kSW5mbzogQmFyY29kZUluZm8pOiBCYXJjb2RlSW5mbyB8IG51bGwge1xuXG4gICAgICAgIHZhciBzZWxmID0gdGhpcyxcbiAgICAgICAgICAgIHRyYWlsaW5nV2hpdGVzcGFjZUVuZDtcblxuICAgICAgICB0cmFpbGluZ1doaXRlc3BhY2VFbmQgPSBlbmRJbmZvLmVuZCArICgoZW5kSW5mby5lbmQgLSBlbmRJbmZvLnN0YXJ0KSAvIDIpO1xuICAgICAgICBpZiAodHJhaWxpbmdXaGl0ZXNwYWNlRW5kIDwgc2VsZi5fcm93Lmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKHNlbGYuX21hdGNoUmFuZ2UoZW5kSW5mby5lbmQsIHRyYWlsaW5nV2hpdGVzcGFjZUVuZCwgMCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZW5kSW5mbztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuXG5cbiAgICBwdWJsaWMgY2FsY3VsYXRlQ29ycmVjdGlvbihleHBlY3RlZDogUmVhZG9ubHlBcnJheTxudW1iZXI+LCBub3JtYWxpemVkOiBSZWFkb25seUFycmF5PG51bWJlcj4sIGluZGljZXM6IFJlYWRvbmx5QXJyYXk8bnVtYmVyPik6IG51bWJlciB7XG4gICAgICAgIHZhciBsZW5ndGggPSBpbmRpY2VzLmxlbmd0aCxcbiAgICAgICAgICAgIHN1bU5vcm1hbGl6ZWQgPSAwLFxuICAgICAgICAgICAgc3VtRXhwZWN0ZWQgPSAwO1xuXG4gICAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICAgICAgc3VtRXhwZWN0ZWQgKz0gZXhwZWN0ZWRbaW5kaWNlc1tsZW5ndGhdXTtcbiAgICAgICAgICAgIHN1bU5vcm1hbGl6ZWQgKz0gbm9ybWFsaXplZFtpbmRpY2VzW2xlbmd0aF1dO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdW1FeHBlY3RlZCAvIHN1bU5vcm1hbGl6ZWQ7XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBDb2RlMTI4UmVhZGVyO1xuIiwiLyogZXNsaW50LWRpc2FibGUgY2xhc3MtbWV0aG9kcy11c2UtdGhpcyAqL1xuaW1wb3J0IEFycmF5SGVscGVyIGZyb20gJy4uL2NvbW1vbi9hcnJheV9oZWxwZXInO1xuaW1wb3J0IEJhcmNvZGVSZWFkZXIsIHsgdHlwZSBCYXJjb2RlUG9zaXRpb24sIHR5cGUgQmFyY29kZSB9IGZyb20gJy4vYmFyY29kZV9yZWFkZXInO1xuXG5jb25zdCBBTFBIQUJFVEhfU1RSSU5HID0gJzAxMjM0NTY3ODlBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWi0uICokLyslJztcbmNvbnN0IEFMUEhBQkVUID0gbmV3IFVpbnQxNkFycmF5KFsuLi5BTFBIQUJFVEhfU1RSSU5HXS5tYXAoKGNoYXIpID0+IGNoYXIuY2hhckNvZGVBdCgwKSkpO1xuY29uc3QgQ0hBUkFDVEVSX0VOQ09ESU5HUyA9IG5ldyBVaW50MTZBcnJheShbXG4gICAgMHgwMzQsIDB4MTIxLCAweDA2MSwgMHgxNjAsIDB4MDMxLCAweDEzMCwgMHgwNzAsIDB4MDI1LCAweDEyNCwgMHgwNjQsIDB4MTA5LCAweDA0OSxcbiAgICAweDE0OCwgMHgwMTksIDB4MTE4LCAweDA1OCwgMHgwMEQsIDB4MTBDLCAweDA0QywgMHgwMUMsIDB4MTAzLCAweDA0MywgMHgxNDIsIDB4MDEzLCAweDExMiwgMHgwNTIsIDB4MDA3LCAweDEwNixcbiAgICAweDA0NiwgMHgwMTYsIDB4MTgxLCAweDBDMSwgMHgxQzAsIDB4MDkxLCAweDE5MCwgMHgwRDAsIDB4MDg1LCAweDE4NCwgMHgwQzQsIDB4MDk0LCAweDBBOCwgMHgwQTIsIDB4MDhBLCAweDAyQSxcbl0pO1xuY29uc3QgQVNURVJJU0sgPSAweDA5NDtcblxuY2xhc3MgQ29kZTM5UmVhZGVyIGV4dGVuZHMgQmFyY29kZVJlYWRlciB7XG4gICAgRk9STUFUID0gJ2NvZGVfMzknO1xuXG4gICAgcHJvdGVjdGVkIF9maW5kU3RhcnQoKTogQmFyY29kZVBvc2l0aW9uIHwgbnVsbCB7XG4gICAgICAgIGNvbnN0IG9mZnNldCA9IHRoaXMuX25leHRTZXQodGhpcy5fcm93KTtcbiAgICAgICAgbGV0IHBhdHRlcm5TdGFydCA9IG9mZnNldDtcbiAgICAgICAgY29uc3QgY291bnRlciA9IG5ldyBVaW50MTZBcnJheShbMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMF0pO1xuICAgICAgICBsZXQgY291bnRlclBvcyA9IDA7XG4gICAgICAgIGxldCBpc1doaXRlID0gZmFsc2U7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IG9mZnNldDsgaSA8IHRoaXMuX3Jvdy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWJpdHdpc2VcbiAgICAgICAgICAgIGlmICh0aGlzLl9yb3dbaV0gXiAoaXNXaGl0ZSA/IDEgOiAwKSkge1xuICAgICAgICAgICAgICAgIGNvdW50ZXJbY291bnRlclBvc10rKztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvdW50ZXJQb3MgPT09IGNvdW50ZXIubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBmaW5kIHN0YXJ0IHBhdHRlcm5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX3RvUGF0dGVybihjb3VudGVyKSA9PT0gQVNURVJJU0spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHdoaXRlU3BhY2VNdXN0U3RhcnQgPSBNYXRoLmZsb29yKE1hdGgubWF4KDAsIHBhdHRlcm5TdGFydCAtICgoaSAtIHBhdHRlcm5TdGFydCkgLyA0KSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX21hdGNoUmFuZ2Uod2hpdGVTcGFjZU11c3RTdGFydCwgcGF0dGVyblN0YXJ0LCAwKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0OiBwYXR0ZXJuU3RhcnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZDogaSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgcGF0dGVyblN0YXJ0ICs9IGNvdW50ZXJbMF0gKyBjb3VudGVyWzFdO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IDc7IGorKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY291bnRlcltqXSA9IGNvdW50ZXJbaiArIDJdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvdW50ZXJbN10gPSAwO1xuICAgICAgICAgICAgICAgICAgICBjb3VudGVyWzhdID0gMDtcbiAgICAgICAgICAgICAgICAgICAgY291bnRlclBvcy0tO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvdW50ZXJQb3MrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY291bnRlcltjb3VudGVyUG9zXSA9IDE7XG4gICAgICAgICAgICAgICAgaXNXaGl0ZSA9ICFpc1doaXRlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHByb3RlY3RlZCBfdG9QYXR0ZXJuKGNvdW50ZXJzOiBVaW50MTZBcnJheSk6IG51bWJlciB7XG4gICAgICAgIGNvbnN0IG51bUNvdW50ZXJzID0gY291bnRlcnMubGVuZ3RoO1xuICAgICAgICBsZXQgbWF4TmFycm93V2lkdGggPSAwO1xuICAgICAgICBsZXQgbnVtV2lkZUJhcnMgPSBudW1Db3VudGVycztcbiAgICAgICAgbGV0IHdpZGVCYXJXaWR0aCA9IDA7XG5cbiAgICAgICAgd2hpbGUgKG51bVdpZGVCYXJzID4gMykge1xuICAgICAgICAgICAgbWF4TmFycm93V2lkdGggPSB0aGlzLl9maW5kTmV4dFdpZHRoKGNvdW50ZXJzLCBtYXhOYXJyb3dXaWR0aCk7XG4gICAgICAgICAgICBudW1XaWRlQmFycyA9IDA7XG4gICAgICAgICAgICBsZXQgcGF0dGVybiA9IDA7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bUNvdW50ZXJzOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoY291bnRlcnNbaV0gPiBtYXhOYXJyb3dXaWR0aCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tYml0d2lzZVxuICAgICAgICAgICAgICAgICAgICBwYXR0ZXJuIHw9IDEgPDwgKG51bUNvdW50ZXJzIC0gMSAtIGkpO1xuICAgICAgICAgICAgICAgICAgICBudW1XaWRlQmFycysrO1xuICAgICAgICAgICAgICAgICAgICB3aWRlQmFyV2lkdGggKz0gY291bnRlcnNbaV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAobnVtV2lkZUJhcnMgPT09IDMpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bUNvdW50ZXJzICYmIG51bVdpZGVCYXJzID4gMDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb3VudGVyc1tpXSA+IG1heE5hcnJvd1dpZHRoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBudW1XaWRlQmFycy0tO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChjb3VudGVyc1tpXSAqIDIpID49IHdpZGVCYXJXaWR0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcGF0dGVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gLTE7XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIF9maW5kTmV4dFdpZHRoKGNvdW50ZXJzOiBVaW50MTZBcnJheSwgY3VycmVudDogbnVtYmVyKTogbnVtYmVyIHtcbiAgICAgICAgbGV0IG1pbldpZHRoID0gTnVtYmVyLk1BWF9WQUxVRTtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvdW50ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoY291bnRlcnNbaV0gPCBtaW5XaWR0aCAmJiBjb3VudGVyc1tpXSA+IGN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgICBtaW5XaWR0aCA9IGNvdW50ZXJzW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG1pbldpZHRoO1xuICAgIH1cblxuICAgIHByb3RlY3RlZCBfcGF0dGVyblRvQ2hhcihwYXR0ZXJuOiBudW1iZXIpOiBzdHJpbmcgfCBudWxsIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBDSEFSQUNURVJfRU5DT0RJTkdTLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoQ0hBUkFDVEVSX0VOQ09ESU5HU1tpXSA9PT0gcGF0dGVybikge1xuICAgICAgICAgICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKEFMUEhBQkVUW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgX3ZlcmlmeVRyYWlsaW5nV2hpdGVzcGFjZShsYXN0U3RhcnQ6IG51bWJlciwgbmV4dFN0YXJ0OiBudW1iZXIsIGNvdW50ZXJzOiBVaW50MTZBcnJheSk6IGJvb2xlYW4ge1xuICAgICAgICBjb25zdCBwYXR0ZXJuU2l6ZSA9IEFycmF5SGVscGVyLnN1bShjb3VudGVycyk7XG5cbiAgICAgICAgY29uc3QgdHJhaWxpbmdXaGl0ZXNwYWNlRW5kID0gbmV4dFN0YXJ0IC0gbGFzdFN0YXJ0IC0gcGF0dGVyblNpemU7XG4gICAgICAgIGlmICgodHJhaWxpbmdXaGl0ZXNwYWNlRW5kICogMykgPj0gcGF0dGVyblNpemUpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBwdWJsaWMgZGVjb2RlKCk6IEJhcmNvZGUgfCBudWxsIHtcbiAgICAgICAgbGV0IGNvdW50ZXJzID0gbmV3IFVpbnQxNkFycmF5KFswLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwXSk7XG4gICAgICAgIGNvbnN0IHJlc3VsdDogQXJyYXk8c3RyaW5nPiA9IFtdO1xuICAgICAgICBjb25zdCBzdGFydCA9IHRoaXMuX2ZpbmRTdGFydCgpO1xuXG4gICAgICAgIGlmICghc3RhcnQpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGxldCBuZXh0U3RhcnQgPSB0aGlzLl9uZXh0U2V0KHRoaXMuX3Jvdywgc3RhcnQuZW5kKTtcblxuICAgICAgICBsZXQgZGVjb2RlZENoYXI7XG4gICAgICAgIGxldCBsYXN0U3RhcnQ6IG51bWJlcjtcbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgY291bnRlcnMgPSB0aGlzLl90b0NvdW50ZXJzKG5leHRTdGFydCwgY291bnRlcnMpIGFzIFVpbnQxNkFycmF5O1xuICAgICAgICAgICAgY29uc3QgcGF0dGVybiA9IHRoaXMuX3RvUGF0dGVybihjb3VudGVycyk7XG4gICAgICAgICAgICBpZiAocGF0dGVybiA8IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlY29kZWRDaGFyID0gdGhpcy5fcGF0dGVyblRvQ2hhcihwYXR0ZXJuKTtcbiAgICAgICAgICAgIGlmIChkZWNvZGVkQ2hhciA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0LnB1c2goZGVjb2RlZENoYXIpO1xuICAgICAgICAgICAgbGFzdFN0YXJ0ID0gbmV4dFN0YXJ0O1xuICAgICAgICAgICAgbmV4dFN0YXJ0ICs9IEFycmF5SGVscGVyLnN1bShjb3VudGVycyk7XG4gICAgICAgICAgICBuZXh0U3RhcnQgPSB0aGlzLl9uZXh0U2V0KHRoaXMuX3JvdywgbmV4dFN0YXJ0KTtcbiAgICAgICAgfSB3aGlsZSAoZGVjb2RlZENoYXIgIT09ICcqJyk7XG4gICAgICAgIHJlc3VsdC5wb3AoKTtcblxuICAgICAgICBpZiAoIXJlc3VsdC5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0aGlzLl92ZXJpZnlUcmFpbGluZ1doaXRlc3BhY2UobGFzdFN0YXJ0LCBuZXh0U3RhcnQsIGNvdW50ZXJzKSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY29kZTogcmVzdWx0LmpvaW4oJycpLFxuICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0LnN0YXJ0LFxuICAgICAgICAgICAgZW5kOiBuZXh0U3RhcnQsXG4gICAgICAgICAgICBzdGFydEluZm86IHN0YXJ0LFxuICAgICAgICAgICAgZGVjb2RlZENvZGVzOiByZXN1bHQsXG4gICAgICAgICAgICBmb3JtYXQ6IHRoaXMuRk9STUFULFxuICAgICAgICB9O1xuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgQ29kZTM5UmVhZGVyO1xuIiwiaW1wb3J0IENvZGUzOVJlYWRlciBmcm9tICcuL2NvZGVfMzlfcmVhZGVyJztcblxuY29uc3QgcGF0dGVybnMgPSB7XG4gICAgQUVJTzogL1tBRUlPXS9nLFxuICAgIEFaMDk6IC9bQS1aMC05XS8sXG59O1xuXG5jb25zdCBjb2RlMzJzZXQgPSAnMDEyMzQ1Njc4OUJDREZHSEpLTE1OUFFSU1RVVldYWVonO1xuXG5jbGFzcyBDb2RlMzJSZWFkZXIgZXh0ZW5kcyBDb2RlMzlSZWFkZXIge1xuICAgIEZPUk1BVCA9ICdjb2RlXzMyX3JlYWRlcic7XG5cbiAgICBwcm90ZWN0ZWQgX2RlY29kZUNvZGUzMihjb2RlOiBzdHJpbmcpIHtcbiAgICAgICAgaWYgKC9bXjAtOUJDREZHSEpLTE1OUFFSU1RVVldYWVpdLy50ZXN0KGNvZGUpKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcmVzID0gMDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb2RlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICByZXMgPSByZXMgKiAzMiArIGNvZGUzMnNldC5pbmRleE9mKGNvZGVbaV0pO1xuICAgICAgICB9XG4gICAgICAgIGxldCBjb2RlMzIgPSBgJHtyZXN9YDtcbiAgICAgICAgaWYgKGNvZGUzMi5sZW5ndGggPCA5KSB7XG4gICAgICAgICAgICBjb2RlMzIgPSAoJzAwMDAwMDAwMCcgKyBjb2RlMzIpLnNsaWNlKC05KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJ0EnICsgY29kZTMyO1xuICAgIH1cblxuICAgIC8vIFRPRE8gKHRoaXMgd2FzIHRvZG8gaW4gb3JpZ2luYWwgcmVwbywgbm8gdGV4dCB3YXMgdGhlcmUuIHNvcnJ5LilcbiAgICBwcm90ZWN0ZWQgX2NoZWNrQ2hlY2tzdW0oY29kZTogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiAhIWNvZGU7XG4gICAgfVxuXG4gICAgcHVibGljIGRlY29kZSgpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gc3VwZXIuZGVjb2RlKCk7XG4gICAgICAgIGlmICghcmVzdWx0KSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBjb2RlID0gcmVzdWx0LmNvZGU7XG5cbiAgICAgICAgaWYgKCFjb2RlKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvZGUgPSBjb2RlLnJlcGxhY2UocGF0dGVybnMuQUVJTywgJycpO1xuXG4gICAgICAgIGlmICghdGhpcy5fY2hlY2tDaGVja3N1bShjb2RlKSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBjb2RlMzIgPSB0aGlzLl9kZWNvZGVDb2RlMzIoY29kZSk7XG5cbiAgICAgICAgaWYgKCFjb2RlMzIpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVzdWx0LmNvZGUgPSBjb2RlMzI7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBDb2RlMzJSZWFkZXI7XG4iLCIvKiBlc2xpbnQtZGlzYWJsZSBjbGFzcy1tZXRob2RzLXVzZS10aGlzICovXG5pbXBvcnQgeyBCYXJjb2RlIH0gZnJvbSAnLi9iYXJjb2RlX3JlYWRlcic7XG5pbXBvcnQgQ29kZTM5UmVhZGVyIGZyb20gJy4vY29kZV8zOV9yZWFkZXInO1xuXG5jb25zdCBwYXR0ZXJucyA9IHtcbiAgICBJT1E6IC9bSU9RXS9nLFxuICAgIEFaMDk6IC9bQS1aMC05XXsxN30vLFxufTtcblxuY2xhc3MgQ29kZTM5VklOUmVhZGVyIGV4dGVuZHMgQ29kZTM5UmVhZGVyIHtcbiAgICBGT1JNQVQgPSAnY29kZV8zOV92aW4nO1xuXG4gICAgLy8gVE9ETyAodGhpcyB3YXMgdG9kbyBpbiBvcmlnaW5hbCByZXBvLCBubyB0ZXh0IHdhcyB0aGVyZS4gc29ycnkuKVxuICAgIHByb3RlY3RlZCBfY2hlY2tDaGVja3N1bShjb2RlOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuICEhY29kZTtcbiAgICB9XG5cbiAgICAvLyBDcmliYmVkIGZyb206XG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3p4aW5nL3p4aW5nL2Jsb2IvbWFzdGVyL2NvcmUvc3JjL21haW4vamF2YS9jb20vZ29vZ2xlL3p4aW5nL2NsaWVudC9yZXN1bHQvVklOUmVzdWx0UGFyc2VyLmphdmFcbiAgICBwdWJsaWMgZGVjb2RlKCk6IEJhcmNvZGUgfCBudWxsIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gc3VwZXIuZGVjb2RlKCk7XG4gICAgICAgIGlmICghcmVzdWx0KSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCB7IGNvZGUgfSA9IHJlc3VsdDtcblxuICAgICAgICBpZiAoIWNvZGUpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgY29kZSA9IGNvZGUucmVwbGFjZShwYXR0ZXJucy5JT1EsICcnKTtcblxuICAgICAgICBpZiAoIWNvZGUubWF0Y2gocGF0dGVybnMuQVowOSkpIHtcbiAgICAgICAgICAgIGlmIChFTlYuZGV2ZWxvcG1lbnQpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnRmFpbGVkIEFaMDkgcGF0dGVybiBjb2RlOicsIGNvZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRoaXMuX2NoZWNrQ2hlY2tzdW0oY29kZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVzdWx0LmNvZGUgPSBjb2RlO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgQ29kZTM5VklOUmVhZGVyO1xuIiwiaW1wb3J0IEJhcmNvZGVSZWFkZXIsIHsgQmFyY29kZVBvc2l0aW9uLCBCYXJjb2RlIH0gZnJvbSAnLi9iYXJjb2RlX3JlYWRlcic7XG5pbXBvcnQgQXJyYXlIZWxwZXIgZnJvbSAnLi4vY29tbW9uL2FycmF5X2hlbHBlcic7XG5cbmNvbnN0IEFMUEhBQkVUSF9TVFJJTkcgPSAnMDEyMzQ1Njc4OUFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaLS4gJC8rJWFiY2QqJztcbmNvbnN0IEFMUEhBQkVUID0gbmV3IFVpbnQxNkFycmF5KFsuLi5BTFBIQUJFVEhfU1RSSU5HXS5tYXAoY2hhciA9PiBjaGFyLmNoYXJDb2RlQXQoMCkpKTtcbmNvbnN0IENIQVJBQ1RFUl9FTkNPRElOR1MgPSBuZXcgVWludDE2QXJyYXkoW1xuICAgIDB4MTE0LCAweDE0OCwgMHgxNDQsIDB4MTQyLCAweDEyOCwgMHgxMjQsIDB4MTIyLCAweDE1MCwgMHgxMTIsIDB4MTBBLFxuICAgIDB4MUE4LCAweDFBNCwgMHgxQTIsIDB4MTk0LCAweDE5MiwgMHgxOEEsIDB4MTY4LCAweDE2NCwgMHgxNjIsIDB4MTM0LFxuICAgIDB4MTFBLCAweDE1OCwgMHgxNEMsIDB4MTQ2LCAweDEyQywgMHgxMTYsIDB4MUI0LCAweDFCMiwgMHgxQUMsIDB4MUE2LFxuICAgIDB4MTk2LCAweDE5QSwgMHgxNkMsIDB4MTY2LCAweDEzNiwgMHgxM0EsIDB4MTJFLCAweDFENCwgMHgxRDIsIDB4MUNBLFxuICAgIDB4MTZFLCAweDE3NiwgMHgxQUUsIDB4MTI2LCAweDFEQSwgMHgxRDYsIDB4MTMyLCAweDE1RSxcbl0pO1xuY29uc3QgQVNURVJJU0sgPSAweDE1RTtcblxuY2xhc3MgQ29kZTkzUmVhZGVyIGV4dGVuZHMgQmFyY29kZVJlYWRlciB7XG4gICAgRk9STUFUID0gJ2NvZGVfOTMnO1xuICAgIHByb3RlY3RlZCBfcGF0dGVyblRvQ2hhcihwYXR0ZXJuOiBudW1iZXIpOiBzdHJpbmcgfCBudWxsIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBDSEFSQUNURVJfRU5DT0RJTkdTLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoQ0hBUkFDVEVSX0VOQ09ESU5HU1tpXSA9PT0gcGF0dGVybikge1xuICAgICAgICAgICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKEFMUEhBQkVUW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuXG4gICAgcHJvdGVjdGVkIF90b1BhdHRlcm4oY291bnRlcnM6IFVpbnQxNkFycmF5KTogbnVtYmVyIHtcbiAgICAgICAgY29uc3QgbnVtQ291bnRlcnMgPSBjb3VudGVycy5sZW5ndGg7XG4gICAgICAgIGNvbnN0IHN1bSA9IGNvdW50ZXJzLnJlZHVjZSgocHJldiwgbmV4dCkgPT4gcHJldiArIG5leHQsIDApO1xuICAgICAgICBsZXQgcGF0dGVybiA9IDA7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1Db3VudGVyczsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgbm9ybWFsaXplZCA9IE1hdGgucm91bmQoY291bnRlcnNbaV0gKiA5IC8gc3VtKTtcbiAgICAgICAgICAgIGlmIChub3JtYWxpemVkIDwgMSB8fCBub3JtYWxpemVkID4gNCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgoaSAmIDEpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBub3JtYWxpemVkOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgcGF0dGVybiA9IChwYXR0ZXJuIDw8IDEpIHwgMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHBhdHRlcm4gPDw9IG5vcm1hbGl6ZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhdHRlcm47XG4gICAgfTtcblxuICAgIHByb3RlY3RlZCBfZmluZFN0YXJ0KCk6IEJhcmNvZGVQb3NpdGlvbiB8IG51bGwge1xuICAgICAgICBjb25zdCBvZmZzZXQgPSB0aGlzLl9uZXh0U2V0KHRoaXMuX3Jvdyk7XG4gICAgICAgIGxldCBwYXR0ZXJuU3RhcnQgPSBvZmZzZXQ7XG4gICAgICAgIGNvbnN0IGNvdW50ZXIgPSBuZXcgVWludDE2QXJyYXkoWzAsIDAsIDAsIDAsIDAsIDBdKTtcbiAgICAgICAgbGV0IGNvdW50ZXJQb3MgPSAwO1xuICAgICAgICBsZXQgaXNXaGl0ZSA9IGZhbHNlO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSBvZmZzZXQ7IGkgPCB0aGlzLl9yb3cubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9yb3dbaV0gXiAoaXNXaGl0ZSA/IDEgOiAwKSkge1xuICAgICAgICAgICAgICAgIGNvdW50ZXJbY291bnRlclBvc10rKztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvdW50ZXJQb3MgPT09IGNvdW50ZXIubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBmaW5kIHN0YXJ0IHBhdHRlcm5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX3RvUGF0dGVybihjb3VudGVyKSA9PT0gQVNURVJJU0spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHdoaXRlU3BhY2VNdXN0U3RhcnQgPSBNYXRoLmZsb29yKE1hdGgubWF4KDAsIHBhdHRlcm5TdGFydCAtICgoaSAtIHBhdHRlcm5TdGFydCkgLyA0KSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX21hdGNoUmFuZ2Uod2hpdGVTcGFjZU11c3RTdGFydCwgcGF0dGVyblN0YXJ0LCAwKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0OiBwYXR0ZXJuU3RhcnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZDogaSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgcGF0dGVyblN0YXJ0ICs9IGNvdW50ZXJbMF0gKyBjb3VudGVyWzFdO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IDQ7IGorKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY291bnRlcltqXSA9IGNvdW50ZXJbaiArIDJdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvdW50ZXJbNF0gPSAwO1xuICAgICAgICAgICAgICAgICAgICBjb3VudGVyWzVdID0gMDtcbiAgICAgICAgICAgICAgICAgICAgY291bnRlclBvcy0tO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvdW50ZXJQb3MrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY291bnRlcltjb3VudGVyUG9zXSA9IDE7XG4gICAgICAgICAgICAgICAgaXNXaGl0ZSA9ICFpc1doaXRlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG5cbiAgICBwcm90ZWN0ZWQgX3ZlcmlmeUVuZChsYXN0U3RhcnQ6IG51bWJlciwgbmV4dFN0YXJ0OiBudW1iZXIpOiBib29sZWFuIHtcbiAgICAgICAgaWYgKGxhc3RTdGFydCA9PT0gbmV4dFN0YXJ0IHx8ICF0aGlzLl9yb3dbbmV4dFN0YXJ0XSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG5cbiAgICBwcm90ZWN0ZWQgX2RlY29kZUV4dGVuZGVkKGNoYXJBcnJheTogQXJyYXk8c3RyaW5nPik6IHN0cmluZ1tdIHwgbnVsbCB7XG4gICAgICAgIGNvbnN0IGxlbmd0aCA9IGNoYXJBcnJheS5sZW5ndGg7XG4gICAgICAgIGNvbnN0IHJlc3VsdDogQXJyYXk8c3RyaW5nPiA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBjaGFyID0gY2hhckFycmF5W2ldO1xuICAgICAgICAgICAgaWYgKGNoYXIgPj0gJ2EnICYmIGNoYXIgPD0gJ2QnKSB7XG4gICAgICAgICAgICAgICAgaWYgKGkgPiAobGVuZ3RoIC0gMikpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IG5leHRDaGFyID0gY2hhckFycmF5WysraV07XG4gICAgICAgICAgICAgICAgY29uc3QgbmV4dENoYXJDb2RlID0gbmV4dENoYXIuY2hhckNvZGVBdCgwKTtcbiAgICAgICAgICAgICAgICBsZXQgZGVjb2RlZENoYXI7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChjaGFyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2EnOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5leHRDaGFyID49ICdBJyAmJiBuZXh0Q2hhciA8PSAnWicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWNvZGVkQ2hhciA9IFN0cmluZy5mcm9tQ2hhckNvZGUobmV4dENoYXJDb2RlIC0gNjQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdiJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuZXh0Q2hhciA+PSAnQScgJiYgbmV4dENoYXIgPD0gJ0UnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVjb2RlZENoYXIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKG5leHRDaGFyQ29kZSAtIDM4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobmV4dENoYXIgPj0gJ0YnICYmIG5leHRDaGFyIDw9ICdKJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlY29kZWRDaGFyID0gU3RyaW5nLmZyb21DaGFyQ29kZShuZXh0Q2hhckNvZGUgLSAxMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG5leHRDaGFyID49ICdLJyAmJiBuZXh0Q2hhciA8PSAnTycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWNvZGVkQ2hhciA9IFN0cmluZy5mcm9tQ2hhckNvZGUobmV4dENoYXJDb2RlICsgMTYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChuZXh0Q2hhciA+PSAnUCcgJiYgbmV4dENoYXIgPD0gJ1MnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVjb2RlZENoYXIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKG5leHRDaGFyQ29kZSArIDQzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobmV4dENoYXIgPj0gJ1QnICYmIG5leHRDaGFyIDw9ICdaJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlY29kZWRDaGFyID0gU3RyaW5nLmZyb21DaGFyQ29kZSgxMjcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdjJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuZXh0Q2hhciA+PSAnQScgJiYgbmV4dENoYXIgPD0gJ08nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVjb2RlZENoYXIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKG5leHRDaGFyQ29kZSAtIDMyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobmV4dENoYXIgPT09ICdaJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlY29kZWRDaGFyID0gJzonO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdkJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuZXh0Q2hhciA+PSAnQScgJiYgbmV4dENoYXIgPD0gJ1onKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVjb2RlZENoYXIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKG5leHRDaGFyQ29kZSArIDMyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignKiBjb2RlXzkzX3JlYWRlciBfZGVjb2RlRXh0ZW5kZWQgaGl0IGRlZmF1bHQgY2FzZSwgdGhpcyBtYXkgYmUgYW4gZXJyb3InLCBkZWNvZGVkQ2hhcik7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goZGVjb2RlZENoYXIpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChjaGFyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG5cbiAgICBwcm90ZWN0ZWQgX21hdGNoQ2hlY2tDaGFyKGNoYXJBcnJheTogQXJyYXk8c3RyaW5nPiwgaW5kZXg6IG51bWJlciwgbWF4V2VpZ2h0OiBudW1iZXIpOiBib29sZWFuIHtcbiAgICAgICAgY29uc3QgYXJyYXlUb0NoZWNrID0gY2hhckFycmF5LnNsaWNlKDAsIGluZGV4KTtcbiAgICAgICAgY29uc3QgbGVuZ3RoID0gYXJyYXlUb0NoZWNrLmxlbmd0aDtcbiAgICAgICAgY29uc3Qgd2VpZ2h0ZWRTdW1zID0gYXJyYXlUb0NoZWNrLnJlZHVjZSgoc3VtLCBjaGFyLCBpKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB3ZWlnaHQgPSAoKChpICogLTEpICsgKGxlbmd0aCAtIDEpKSAlIG1heFdlaWdodCkgKyAxO1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBBTFBIQUJFVC5pbmRleE9mKGNoYXIuY2hhckNvZGVBdCgwKSk7XG4gICAgICAgICAgICByZXR1cm4gc3VtICsgKHdlaWdodCAqIHZhbHVlKTtcbiAgICAgICAgfSwgMCk7XG5cbiAgICAgICAgY29uc3QgY2hlY2tDaGFyID0gQUxQSEFCRVRbKHdlaWdodGVkU3VtcyAlIDQ3KV07XG4gICAgICAgIHJldHVybiBjaGVja0NoYXIgPT09IGNoYXJBcnJheVtpbmRleF0uY2hhckNvZGVBdCgwKTtcbiAgICB9O1xuXG4gICAgcHJvdGVjdGVkIF92ZXJpZnlDaGVja3N1bXMoY2hhckFycmF5OiBBcnJheTxzdHJpbmc+KTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tYXRjaENoZWNrQ2hhcihjaGFyQXJyYXksIGNoYXJBcnJheS5sZW5ndGggLSAyLCAyMClcbiAgICAgICAgICAgICYmIHRoaXMuX21hdGNoQ2hlY2tDaGFyKGNoYXJBcnJheSwgY2hhckFycmF5Lmxlbmd0aCAtIDEsIDE1KTtcbiAgICB9O1xuXG4gICAgcHVibGljIGRlY29kZShyb3c/OiBBcnJheTxudW1iZXI+LCBzdGFydD86IEJhcmNvZGVQb3NpdGlvbiB8IG51bWJlciB8IG51bGwpOiBCYXJjb2RlIHwgbnVsbCB7XG4gICAgICAgIHN0YXJ0ID0gdGhpcy5fZmluZFN0YXJ0KCk7XG4gICAgICAgIGlmICghc3RhcnQpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGNvdW50ZXJzID0gbmV3IFVpbnQxNkFycmF5KFswLCAwLCAwLCAwLCAwLCAwXSk7XG4gICAgICAgIGxldCByZXN1bHQ6IEFycmF5PHN0cmluZz4gfCBudWxsID0gW107XG4gICAgICAgIGxldCBuZXh0U3RhcnQgPSB0aGlzLl9uZXh0U2V0KHRoaXMuX3Jvdywgc3RhcnQuZW5kKTtcbiAgICAgICAgbGV0IGxhc3RTdGFydDtcbiAgICAgICAgbGV0IGRlY29kZWRDaGFyOiBzdHJpbmcgfCBudWxsO1xuICAgICAgICBkbyB7XG4gICAgICAgICAgICBjb3VudGVycyA9IHRoaXMuX3RvQ291bnRlcnMobmV4dFN0YXJ0LCBjb3VudGVycykgYXMgVWludDE2QXJyYXk7XG4gICAgICAgICAgICBjb25zdCBwYXR0ZXJuID0gdGhpcy5fdG9QYXR0ZXJuKGNvdW50ZXJzKTtcbiAgICAgICAgICAgIGlmIChwYXR0ZXJuIDwgMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVjb2RlZENoYXIgPSB0aGlzLl9wYXR0ZXJuVG9DaGFyKHBhdHRlcm4pO1xuICAgICAgICAgICAgaWYgKGRlY29kZWRDaGFyID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQucHVzaChkZWNvZGVkQ2hhcik7XG4gICAgICAgICAgICBsYXN0U3RhcnQgPSBuZXh0U3RhcnQ7XG4gICAgICAgICAgICBuZXh0U3RhcnQgKz0gQXJyYXlIZWxwZXIuc3VtKGNvdW50ZXJzKTtcbiAgICAgICAgICAgIG5leHRTdGFydCA9IHRoaXMuX25leHRTZXQodGhpcy5fcm93LCBuZXh0U3RhcnQpO1xuICAgICAgICB9IHdoaWxlIChkZWNvZGVkQ2hhciAhPT0gJyonKTtcbiAgICAgICAgcmVzdWx0LnBvcCgpO1xuXG4gICAgICAgIGlmICghcmVzdWx0Lmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRoaXMuX3ZlcmlmeUVuZChsYXN0U3RhcnQsIG5leHRTdGFydCkpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0aGlzLl92ZXJpZnlDaGVja3N1bXMocmVzdWx0KSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICByZXN1bHQgPSByZXN1bHQuc2xpY2UoMCwgcmVzdWx0Lmxlbmd0aCAtIDIpO1xuICAgICAgICAvLyB5ZXMsIHRoaXMgaXMgYW4gYXNzaWduIGluc2lkZSBhbiBpZi5cbiAgICAgICAgaWYgKChyZXN1bHQgPSB0aGlzLl9kZWNvZGVFeHRlbmRlZChyZXN1bHQpKSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY29kZTogcmVzdWx0LmpvaW4oJycpLFxuICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0LnN0YXJ0LFxuICAgICAgICAgICAgZW5kOiBuZXh0U3RhcnQsXG4gICAgICAgICAgICBzdGFydEluZm86IHN0YXJ0LFxuICAgICAgICAgICAgZGVjb2RlZENvZGVzOiByZXN1bHQsXG4gICAgICAgICAgICBmb3JtYXQ6IHRoaXMuRk9STUFULFxuICAgICAgICB9O1xuXG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBDb2RlOTNSZWFkZXI7XG4iLCJpbXBvcnQgQmFyY29kZVJlYWRlciwgeyBCYXJjb2RlUmVhZGVyQ29uZmlnLCBCYXJjb2RlSW5mbywgQmFyY29kZVBvc2l0aW9uLCBCYXJjb2RlIH0gZnJvbSAnLi9iYXJjb2RlX3JlYWRlcic7XG5pbXBvcnQgbWVyZ2UgZnJvbSAnbG9kYXNoL21lcmdlJztcblxuLy8gY29uc3QgQ09ERV9MX1NUQVJUID0gMDtcbmNvbnN0IENPREVfR19TVEFSVCA9IDEwO1xuZXhwb3J0IHsgQ09ERV9HX1NUQVJUIH07XG5jb25zdCBTVEFSVF9QQVRURVJOID0gWzEsIDEsIDFdO1xuY29uc3QgTUlERExFX1BBVFRFUk4gPSBbMSwgMSwgMSwgMSwgMV07XG5leHBvcnQgeyBNSURETEVfUEFUVEVSTiB9O1xuY29uc3QgRVhURU5TSU9OX1NUQVJUX1BBVFRFUk4gPSBbMSwgMSwgMl07XG5jb25zdCBDT0RFX1BBVFRFUk4gPSBbXG4gICAgWzMsIDIsIDEsIDFdLFxuICAgIFsyLCAyLCAyLCAxXSxcbiAgICBbMiwgMSwgMiwgMl0sXG4gICAgWzEsIDQsIDEsIDFdLFxuICAgIFsxLCAxLCAzLCAyXSxcbiAgICBbMSwgMiwgMywgMV0sXG4gICAgWzEsIDEsIDEsIDRdLFxuICAgIFsxLCAzLCAxLCAyXSxcbiAgICBbMSwgMiwgMSwgM10sXG4gICAgWzMsIDEsIDEsIDJdLFxuICAgIFsxLCAxLCAyLCAzXSxcbiAgICBbMSwgMiwgMiwgMl0sXG4gICAgWzIsIDIsIDEsIDJdLFxuICAgIFsxLCAxLCA0LCAxXSxcbiAgICBbMiwgMywgMSwgMV0sXG4gICAgWzEsIDMsIDIsIDFdLFxuICAgIFs0LCAxLCAxLCAxXSxcbiAgICBbMiwgMSwgMywgMV0sXG4gICAgWzMsIDEsIDIsIDFdLFxuICAgIFsyLCAxLCAxLCAzXSxcbl07XG5jb25zdCBDT0RFX0ZSRVFVRU5DWSA9IFswLCAxMSwgMTMsIDE0LCAxOSwgMjUsIDI4LCAyMSwgMjIsIDI2XTtcbi8vIGNvbnN0IFNJTkdMRV9DT0RFX0VSUk9SID0gMC43MDtcbmNvbnN0IEFWR19DT0RFX0VSUk9SID0gMC40ODtcblxuY2xhc3MgRUFOUmVhZGVyIGV4dGVuZHMgQmFyY29kZVJlYWRlciB7XG4gICAgRk9STUFUID0gJ2Vhbl8xMyc7XG4gICAgU0lOR0xFX0NPREVfRVJST1IgPSAwLjcwO1xuICAgIFNUT1BfUEFUVEVSTiA9IFsxLCAxLCAxXTsgLy8gVE9ETzogZG9lcyB0aGlzIG5lZWQgdG8gYmUgaW4gdGhlIGNsYXNzP1xuXG4gICAgY29uc3RydWN0b3IoY29uZmlnPzogQmFyY29kZVJlYWRlckNvbmZpZywgc3VwcGxlbWVudHM/OiBBcnJheTxCYXJjb2RlUmVhZGVyPikge1xuICAgICAgICBzdXBlcihtZXJnZSh7IHN1cHBsZW1lbnRzOiBbXSB9LCBjb25maWcpLCBzdXBwbGVtZW50cyk7XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIF9maW5kUGF0dGVybihwYXR0ZXJuOiBSZWFkb25seUFycmF5PG51bWJlcj4sIG9mZnNldDogbnVtYmVyLCBpc1doaXRlOiBib29sZWFuLCB0cnlIYXJkZXI6IGJvb2xlYW4pOiBCYXJjb2RlUG9zaXRpb24gfCBudWxsIHtcbiAgICAgICAgY29uc3QgY291bnRlciA9IG5ldyBBcnJheTxudW1iZXI+KHBhdHRlcm4ubGVuZ3RoKS5maWxsKDApO1xuICAgICAgICBjb25zdCBiZXN0TWF0Y2g6IEJhcmNvZGVQb3NpdGlvbiA9IHtcbiAgICAgICAgICAgIGVycm9yOiBOdW1iZXIuTUFYX1ZBTFVFLFxuICAgICAgICAgICAgc3RhcnQ6IDAsXG4gICAgICAgICAgICBlbmQ6IDBcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgZXBzaWxvbiA9IEFWR19DT0RFX0VSUk9SO1xuICAgICAgICAvLyBjb25zb2xlLndhcm4oJyogZmluZFBhdHRlcm4nLCBwYXR0ZXJuLCBvZmZzZXQsIGlzV2hpdGUsIHRyeUhhcmRlciwgZXBzaWxvbik7XG4gICAgICAgIGxldCBjb3VudGVyUG9zID0gMDtcbiAgICAgICAgaWYgKCFvZmZzZXQpIHtcbiAgICAgICAgICAgIG9mZnNldCA9IHRoaXMuX25leHRTZXQodGhpcy5fcm93KTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgZm91bmQgPSBmYWxzZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IG9mZnNldDsgaSA8IHRoaXMuX3Jvdy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgLy8gY29uc29sZS53YXJuKGAqIGxvb3AgaT0ke29mZnNldH0gbGVuPSR7dGhpcy5fcm93Lmxlbmd0aH0gaXNXaGl0ZT0ke2lzV2hpdGV9IGNvdW50ZXJQb3M9JHtjb3VudGVyUG9zfWApO1xuICAgICAgICAgICAgaWYgKHRoaXMuX3Jvd1tpXSBeIChpc1doaXRlID8gMSA6IDApKSB7XG4gICAgICAgICAgICAgICAgY291bnRlcltjb3VudGVyUG9zXSArPSAxO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoY291bnRlclBvcyA9PT0gY291bnRlci5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yID0gdGhpcy5fbWF0Y2hQYXR0ZXJuKGNvdW50ZXIsIHBhdHRlcm4pO1xuICAgICAgICAgICAgICAgICAgICAvLyBjb25zb2xlLndhcm4oJyogbWF0Y2hQYXR0ZXJuJywgZXJyb3IsIGNvdW50ZXIsIHBhdHRlcm4pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3IgPCBlcHNpbG9uICYmIGJlc3RNYXRjaC5lcnJvciAmJiBlcnJvciA8IGJlc3RNYXRjaC5lcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm91bmQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYmVzdE1hdGNoLmVycm9yID0gZXJyb3I7XG4gICAgICAgICAgICAgICAgICAgICAgICBiZXN0TWF0Y2guc3RhcnQgPSBpIC0gY291bnRlci5yZWR1Y2UoKHN1bSwgdmFsdWUpID0+IHN1bSArIHZhbHVlLCAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJlc3RNYXRjaC5lbmQgPSBpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY29uc29sZS53YXJuKCcqIHJldHVybiBiZXN0TWF0Y2gnLCBKU09OLnN0cmluZ2lmeShiZXN0TWF0Y2gpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBiZXN0TWF0Y2g7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRyeUhhcmRlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBjb3VudGVyLmxlbmd0aCAtIDI7IGorKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50ZXJbal0gPSBjb3VudGVyW2ogKyAyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50ZXJbY291bnRlci5sZW5ndGggLSAyXSA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb3VudGVyW2NvdW50ZXIubGVuZ3RoIC0gMV0gPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgY291bnRlclBvcy0tO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY291bnRlclBvcysrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb3VudGVyW2NvdW50ZXJQb3NdID0gMTtcbiAgICAgICAgICAgICAgICBpc1doaXRlID0gIWlzV2hpdGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZvdW5kKSB7XG4gICAgICAgICAgICAvLyBjb25zb2xlLndhcm4oJyogcmV0dXJuIGJlc3RNYXRjaCcsIEpTT04uc3RyaW5naWZ5KGJlc3RNYXRjaCkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gY29uc29sZS53YXJuKCcqIHJldHVybiBudWxsJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZvdW5kID8gYmVzdE1hdGNoIDogbnVsbDtcbiAgICB9XG5cbiAgICAvLyBUT0RPOiBmaW5kUGF0dGVybiBhbmQgZGVjb2RlQ29kZSBhcHBlYXIgdG8gc2hhcmUgcXVpdGUgc2ltaWxhciBjb2RlLCBjYW4gaXQgYmUgcmVkdWNlZD9cbiAgICBwcm90ZWN0ZWQgX2RlY29kZUNvZGUoc3RhcnQ6IG51bWJlciwgY29kZXJhbmdlPzogbnVtYmVyKTogQmFyY29kZUluZm8gfCBudWxsIHtcbiAgICAgICAgLy8gY29uc29sZS53YXJuKCcqIGRlY29kZUNvZGUnLCBzdGFydCwgY29kZXJhbmdlKTtcbiAgICAgICAgY29uc3QgY291bnRlciA9IFswLCAwLCAwLCAwXTtcbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gc3RhcnQ7XG4gICAgICAgIGNvbnN0IGJlc3RNYXRjaDogQmFyY29kZUluZm8gPSB7XG4gICAgICAgICAgICBlcnJvcjogTnVtYmVyLk1BWF9WQUxVRSxcbiAgICAgICAgICAgIGNvZGU6IC0xLFxuICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0LFxuICAgICAgICAgICAgZW5kOiBzdGFydFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBlcHNpbG9uID0gQVZHX0NPREVfRVJST1I7XG4gICAgICAgIGxldCBpc1doaXRlID0gIXRoaXMuX3Jvd1tvZmZzZXRdO1xuICAgICAgICBsZXQgY291bnRlclBvcyA9IDA7XG5cbiAgICAgICAgaWYgKCFjb2RlcmFuZ2UpIHtcbiAgICAgICAgICAgIC8vIGNvbnNvbGUud2FybignKiBkZWNvZGVDb2RlIGJlZm9yZSBsZW5ndGgnKTtcbiAgICAgICAgICAgIGNvZGVyYW5nZSA9IENPREVfUEFUVEVSTi5sZW5ndGg7XG4gICAgICAgICAgICAvLyBjb25zb2xlLndhcm4oJyogZGVjb2RlQ29kZSBhZnRlciBsZW5ndGgnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBmb3VuZCA9IGZhbHNlO1xuICAgICAgICBmb3IgKGxldCBpID0gb2Zmc2V0OyBpIDwgdGhpcy5fcm93Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fcm93W2ldIF4gKGlzV2hpdGUgPyAxIDogMCkpIHtcbiAgICAgICAgICAgICAgICBjb3VudGVyW2NvdW50ZXJQb3NdKys7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChjb3VudGVyUG9zID09PSBjb3VudGVyLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgY29kZSA9IDA7IGNvZGUgPCBjb2RlcmFuZ2U7IGNvZGUrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZXJyb3IgPSB0aGlzLl9tYXRjaFBhdHRlcm4oY291bnRlciwgQ09ERV9QQVRURVJOW2NvZGVdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJlc3RNYXRjaC5lbmQgPSBpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yIDwgYmVzdE1hdGNoLmVycm9yISkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJlc3RNYXRjaC5jb2RlID0gY29kZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiZXN0TWF0Y2guZXJyb3IgPSBlcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoYmVzdE1hdGNoLmVycm9yISA+IGVwc2lsb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUud2FybignKiByZXR1cm4gbnVsbCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gY29uc29sZS53YXJuKCcqIHJldHVybiBiZXN0TWF0Y2gnLCBKU09OLnN0cmluZ2lmeShiZXN0TWF0Y2gpKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJlc3RNYXRjaDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb3VudGVyUG9zKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvdW50ZXJbY291bnRlclBvc10gPSAxO1xuICAgICAgICAgICAgICAgIGlzV2hpdGUgPSAhaXNXaGl0ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZm91bmQgPyBiZXN0TWF0Y2ggOiBudWxsO1xuICAgIH1cblxuICAgIHByb3RlY3RlZCBfZmluZFN0YXJ0KCk6IEJhcmNvZGVQb3NpdGlvbiB8IG51bGwge1xuICAgICAgICAvLyBjb25zb2xlLndhcm4oJyogZmluZFN0YXJ0Jyk7XG4gICAgICAgIGxldCBvZmZzZXQgPSB0aGlzLl9uZXh0U2V0KHRoaXMuX3Jvdyk7XG4gICAgICAgIGxldCBzdGFydEluZm86IEJhcmNvZGVQb3NpdGlvbiB8IG51bGwgPSBudWxsO1xuXG4gICAgICAgIHdoaWxlICghc3RhcnRJbmZvKSB7XG4gICAgICAgICAgICBzdGFydEluZm8gPSB0aGlzLl9maW5kUGF0dGVybihTVEFSVF9QQVRURVJOLCBvZmZzZXQsIGZhbHNlLCB0cnVlKTtcbiAgICAgICAgICAgIC8vIGNvbnNvbGUud2FybignKiBzdGFydEluZm89JywgSlNPTi5zdHJpbmdpZnkoc3RhcnRJbmZvKSk7XG4gICAgICAgICAgICBpZiAoIXN0YXJ0SW5mbykge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCBsZWFkaW5nV2hpdGVzcGFjZVN0YXJ0ID0gc3RhcnRJbmZvLnN0YXJ0IC0gKHN0YXJ0SW5mby5lbmQgLSBzdGFydEluZm8uc3RhcnQpO1xuXG4gICAgICAgICAgICBpZiAobGVhZGluZ1doaXRlc3BhY2VTdGFydCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX21hdGNoUmFuZ2UobGVhZGluZ1doaXRlc3BhY2VTdGFydCwgc3RhcnRJbmZvLnN0YXJ0LCAwKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBjb25zb2xlLndhcm4oJyogcmV0dXJuaW5nIHN0YXJ0SW5mbycpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3RhcnRJbmZvO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgb2Zmc2V0ID0gc3RhcnRJbmZvLmVuZDtcbiAgICAgICAgICAgIHN0YXJ0SW5mbyA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgLy8gY29uc29sZS53YXJuKCcqIHJldHVybmluZyBudWxsJyk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHByaXZhdGUgX2NhbGN1bGF0ZUZpcnN0RGlnaXQoY29kZUZyZXF1ZW5jeTogbnVtYmVyKTogbnVtYmVyIHwgbnVsbCB7XG4gICAgICAgIC8vIGNvbnNvbGUud2FybignKiBjYWxjdWxhdGVGaXJzdERpZ2l0JywgY29kZUZyZXF1ZW5jeSk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgQ09ERV9GUkVRVUVOQ1kubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChjb2RlRnJlcXVlbmN5ID09PSBDT0RFX0ZSRVFVRU5DWVtpXSkge1xuICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUud2FybignKiByZXR1cm5pbmcnLCBpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBjb25zb2xlLndhcm4oJyogcmV0dXJuIG51bGwnKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIF9kZWNvZGVQYXlsb2FkKGluQ29kZTogQmFyY29kZVBvc2l0aW9uLCByZXN1bHQ6IEFycmF5PG51bWJlcj4sIGRlY29kZWRDb2RlczogQXJyYXk8QmFyY29kZVBvc2l0aW9uPik6IEJhcmNvZGVJbmZvIHwgbnVsbCB7XG4gICAgICAgIC8vIGNvbnNvbGUud2FybignKiBkZWNvZGVQYXlsb2FkJywgaW5Db2RlLCByZXN1bHQsIGRlY29kZWRDb2Rlcyk7XG4gICAgICAgIGxldCBvdXRDb2RlOiBCYXJjb2RlSW5mbyB8IEJhcmNvZGVQb3NpdGlvbiB8IG51bGwgPSB7IC4uLmluQ29kZSB9O1xuICAgICAgICBsZXQgY29kZUZyZXF1ZW5jeSA9IDB4MDtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDY7IGkrKykge1xuICAgICAgICAgICAgb3V0Q29kZSA9IHRoaXMuX2RlY29kZUNvZGUob3V0Q29kZS5lbmQpO1xuICAgICAgICAgICAgLy8gY29uc29sZS53YXJuKCcqIGRlY29kZUNvZGU9Jywgb3V0Q29kZSk7XG4gICAgICAgICAgICBpZiAoIW91dENvZGUpIHtcbiAgICAgICAgICAgICAgICAvLyBjb25zb2xlLndhcm4oJyogcmV0dXJuIG51bGwnKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgob3V0Q29kZSBhcyBCYXJjb2RlSW5mbykuY29kZSA+PSBDT0RFX0dfU1RBUlQpIHtcbiAgICAgICAgICAgICAgICAob3V0Q29kZSBhcyBCYXJjb2RlSW5mbykuY29kZSAtPSBDT0RFX0dfU1RBUlQ7XG4gICAgICAgICAgICAgICAgY29kZUZyZXF1ZW5jeSB8PSAxIDw8ICg1IC0gaSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvZGVGcmVxdWVuY3kgfD0gMCA8PCAoNSAtIGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0LnB1c2goKG91dENvZGUgYXMgQmFyY29kZUluZm8pLmNvZGUpO1xuICAgICAgICAgICAgZGVjb2RlZENvZGVzLnB1c2gob3V0Q29kZSk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBmaXJzdERpZ2l0ID0gdGhpcy5fY2FsY3VsYXRlRmlyc3REaWdpdChjb2RlRnJlcXVlbmN5KTtcbiAgICAgICAgLy8gY29uc29sZS53YXJuKCcqIGZpcnN0RGlnaXQ9JywgZmlyc3REaWdpdCk7XG4gICAgICAgIGlmIChmaXJzdERpZ2l0ID09PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBjb25zb2xlLndhcm4oJyogcmV0dXJuIG51bGwnKTtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVzdWx0LnVuc2hpZnQoZmlyc3REaWdpdCk7XG5cbiAgICAgICAgbGV0IG1pZGRsZVBhdHRlcm4gPSB0aGlzLl9maW5kUGF0dGVybihNSURETEVfUEFUVEVSTiwgb3V0Q29kZS5lbmQsIHRydWUsIGZhbHNlKTtcbiAgICAgICAgLy8gY29uc29sZS53YXJuKCcqIGZpbmRQYXR0ZXJuPScsIEpTT04uc3RyaW5naWZ5KG1pZGRsZVBhdHRlcm4pKTtcblxuICAgICAgICBpZiAobWlkZGxlUGF0dGVybiA9PT0gbnVsbCB8fCAhbWlkZGxlUGF0dGVybi5lbmQpIHtcbiAgICAgICAgICAgIC8vIGNvbnNvbGUud2FybignKiByZXR1cm4gbnVsbCcpO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBkZWNvZGVkQ29kZXMucHVzaChtaWRkbGVQYXR0ZXJuKTtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDY7IGkrKykge1xuICAgICAgICAgICAgbWlkZGxlUGF0dGVybiA9IHRoaXMuX2RlY29kZUNvZGUobWlkZGxlUGF0dGVybiEuZW5kLCBDT0RFX0dfU1RBUlQpO1xuICAgICAgICAgICAgLy8gY29uc29sZS53YXJuKCcqIGRlY29kZUNvZGU9JywgSlNPTi5zdHJpbmdpZnkobWlkZGxlUGF0dGVybikpO1xuXG4gICAgICAgICAgICBpZiAoIW1pZGRsZVBhdHRlcm4pIHtcbiAgICAgICAgICAgICAgICAvLyBjb25zb2xlLndhcm4oJyogcmV0dXJuIG51bGwnKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZGVjb2RlZENvZGVzLnB1c2gobWlkZGxlUGF0dGVybik7XG4gICAgICAgICAgICByZXN1bHQucHVzaCgobWlkZGxlUGF0dGVybiBhcyBCYXJjb2RlSW5mbykuY29kZSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjb25zb2xlLndhcm4oJyogZW5kIGNvZGU9JywgSlNPTi5zdHJpbmdpZnkobWlkZGxlUGF0dGVybikpO1xuICAgICAgICAvLyBjb25zb2xlLndhcm4oJyogZW5kIHJlc3VsdD0nLCBKU09OLnN0cmluZ2lmeShyZXN1bHQpKTtcbiAgICAgICAgLy8gY29uc29sZS53YXJuKCcqIGVuZCBkZWNvZGVkQ29kZXM9JywgZGVjb2RlZENvZGVzKTtcbiAgICAgICAgcmV0dXJuIG1pZGRsZVBhdHRlcm4gYXMgQmFyY29kZUluZm87XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIF92ZXJpZnlUcmFpbGluZ1doaXRlc3BhY2UoZW5kSW5mbzogQmFyY29kZVBvc2l0aW9uKTogQmFyY29kZVBvc2l0aW9uIHwgbnVsbCB7XG4gICAgICAgIC8vIGNvbnNvbGUud2FybignKiB2ZXJpZnlUcmFpbGluZ1doaXRlc3BhY2UnLCBKU09OLnN0cmluZ2lmeShlbmRJbmZvKSk7XG4gICAgICAgIGNvbnN0IHRyYWlsaW5nV2hpdGVzcGFjZUVuZCA9IGVuZEluZm8uZW5kICsgKGVuZEluZm8uZW5kIC0gZW5kSW5mby5zdGFydCk7XG5cbiAgICAgICAgaWYgKHRyYWlsaW5nV2hpdGVzcGFjZUVuZCA8IHRoaXMuX3Jvdy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9tYXRjaFJhbmdlKGVuZEluZm8uZW5kLCB0cmFpbGluZ1doaXRlc3BhY2VFbmQsIDApKSB7XG4gICAgICAgICAgICAgICAgLy8gY29uc29sZS53YXJuKCcqIHJldHVybmluZycsIEpTT04uc3RyaW5naWZ5KGVuZEluZm8pKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZW5kSW5mbztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBjb25zb2xlLndhcm4oJyogcmV0dXJuIG51bGwnKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIF9maW5kRW5kKG9mZnNldDogbnVtYmVyLCBpc1doaXRlOiBib29sZWFuKTogQmFyY29kZVBvc2l0aW9uIHwgbnVsbCB7XG4gICAgICAgIC8vIGNvbnNvbGUud2FybignKiBmaW5kRW5kJywgb2Zmc2V0LCBpc1doaXRlKTtcbiAgICAgICAgY29uc3QgZW5kSW5mbyA9IHRoaXMuX2ZpbmRQYXR0ZXJuKHRoaXMuU1RPUF9QQVRURVJOLCBvZmZzZXQsIGlzV2hpdGUsIGZhbHNlKTtcblxuICAgICAgICByZXR1cm4gZW5kSW5mbyAhPT0gbnVsbCA/IHRoaXMuX3ZlcmlmeVRyYWlsaW5nV2hpdGVzcGFjZShlbmRJbmZvKSA6IG51bGw7XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIF9jaGVja3N1bShyZXN1bHQ6IEFycmF5PG51bWJlcj4pOiBib29sZWFuIHtcbiAgICAgICAgLy8gY29uc29sZS53YXJuKCcqIF9jaGVja3N1bScsIHJlc3VsdCk7XG4gICAgICAgIGxldCBzdW0gPSAwO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSByZXN1bHQubGVuZ3RoIC0gMjsgaSA+PSAwOyBpIC09IDIpIHtcbiAgICAgICAgICAgIHN1bSArPSByZXN1bHRbaV07XG4gICAgICAgIH1cblxuICAgICAgICBzdW0gKj0gMztcblxuICAgICAgICBmb3IgKGxldCBpID0gcmVzdWx0Lmxlbmd0aCAtIDE7IGkgPj0gMDsgaSAtPSAyKSB7XG4gICAgICAgICAgICBzdW0gKz0gcmVzdWx0W2ldO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gY29uc29sZS53YXJuKCcqIGVuZCBjaGVja3N1bScsIHN1bSAlIDEwID09PSAwKTtcbiAgICAgICAgcmV0dXJuIHN1bSAlIDEwID09PSAwO1xuICAgIH1cblxuICAgIHByaXZhdGUgX2RlY29kZUV4dGVuc2lvbnMob2Zmc2V0OiBudW1iZXIpOiBCYXJjb2RlIHwgbnVsbCB7XG4gICAgICAgIGNvbnN0IHN0YXJ0ID0gdGhpcy5fbmV4dFNldCh0aGlzLl9yb3csIG9mZnNldCk7XG4gICAgICAgIGNvbnN0IHN0YXJ0SW5mbyA9IHRoaXMuX2ZpbmRQYXR0ZXJuKEVYVEVOU0lPTl9TVEFSVF9QQVRURVJOLCBzdGFydCwgZmFsc2UsIGZhbHNlKTtcblxuICAgICAgICBpZiAoc3RhcnRJbmZvID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNvbnNvbGUud2FybignKiBkZWNvZGVFeHRlbnNpb25zJywgdGhpcy5zdXBwbGVtZW50cyk7XG4gICAgICAgIC8vIGNvbnNvbGUud2FybignKiB0aGVyZSBhcmUgJywgdGhpcy5zdXBwbGVtZW50cy5sZW5ndGgsICcgc3VwcGxlbWVudHMnKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnN1cHBsZW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAvLyBjb25zb2xlLndhcm4oJyogZXh0ZW5zaW9ucyBsb29wJywgaSwgdGhpcy5zdXBwbGVtZW50c1tpXSwgdGhpcy5zdXBwbGVtZW50c1tpXS5fZGVjb2RlKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgbGV0IHJlc3VsdCA9IHRoaXMuc3VwcGxlbWVudHNbaV0uZGVjb2RlKHRoaXMuX3Jvdywgc3RhcnRJbmZvLmVuZCk7XG4gICAgICAgICAgICAgICAgLy8gY29uc29sZS53YXJuKCcqIGRlY29kZSByZXN1bHQ9JywgcmVzdWx0KTtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiByZXN1bHQuY29kZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0LFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnRJbmZvLFxuICAgICAgICAgICAgICAgICAgICAgICAgZW5kOiByZXN1bHQuZW5kLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGVjb2RlZENvZGVzOiByZXN1bHQuZGVjb2RlZENvZGVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgZm9ybWF0OiB0aGlzLnN1cHBsZW1lbnRzW2ldLkZPUk1BVCxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCcqIGRlY29kZUV4dGVuc2lvbnMgZXJyb3IgaW4gJywgdGhpcy5zdXBwbGVtZW50c1tpXSwgJzogJywgZXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNvbnNvbGUud2FybignKiBlbmQgZGVjb2RlRXh0ZW5zaW9ucycpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBwdWJsaWMgZGVjb2RlKHJvdz86IEFycmF5PG51bWJlcj4sIHN0YXJ0PzogQmFyY29kZVBvc2l0aW9uIHwgbnVtYmVyKTogQmFyY29kZSB8IG51bGwge1xuICAgICAgICAvLyBjb25zb2xlLndhcm4oJyogZGVjb2RlJywgcm93KTtcbiAgICAgICAgLy8gY29uc29sZS53YXJuKCcqIGRlY29kZScsIHN0YXJ0KTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gbmV3IEFycmF5PG51bWJlcj4oKTtcbiAgICAgICAgY29uc3QgZGVjb2RlZENvZGVzID0gbmV3IEFycmF5PEJhcmNvZGVJbmZvIHwgQmFyY29kZVBvc2l0aW9uPigpO1xuICAgICAgICBsZXQgcmVzdWx0SW5mbzogQmFyY29kZSB8IHt9ID0ge307XG4gICAgICAgIGxldCBzdGFydEluZm8gPSB0aGlzLl9maW5kU3RhcnQoKTtcblxuICAgICAgICBpZiAoIXN0YXJ0SW5mbykge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgY29kZTogQmFyY29kZVBvc2l0aW9uIHwgQmFyY29kZUluZm8gfCBudWxsID0ge1xuICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0SW5mby5zdGFydCxcbiAgICAgICAgICAgIGVuZDogc3RhcnRJbmZvLmVuZFxuICAgICAgICB9O1xuICAgICAgICBkZWNvZGVkQ29kZXMucHVzaChjb2RlKTtcblxuICAgICAgICBjb2RlID0gdGhpcy5fZGVjb2RlUGF5bG9hZChjb2RlLCByZXN1bHQsIGRlY29kZWRDb2Rlcyk7XG5cbiAgICAgICAgaWYgKCFjb2RlKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvZGUgPSB0aGlzLl9maW5kRW5kKGNvZGUuZW5kLCBmYWxzZSk7XG5cbiAgICAgICAgaWYgKCFjb2RlKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGRlY29kZWRDb2Rlcy5wdXNoKGNvZGUpO1xuXG4gICAgICAgIC8vIENoZWNrc3VtXG4gICAgICAgIGlmICghdGhpcy5fY2hlY2tzdW0ocmVzdWx0KSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjb25zb2xlLndhcm4oJyogdGhpcy5zdXBwbGVtZW50cz0nLCB0aGlzLnN1cHBsZW1lbnRzKTtcbiAgICAgICAgaWYgKHRoaXMuc3VwcGxlbWVudHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgY29uc3Qgc3VwcGxlbWVudCA9IHRoaXMuX2RlY29kZUV4dGVuc2lvbnMoY29kZS5lbmQpO1xuICAgICAgICAgICAgLy8gY29uc29sZS53YXJuKCcqIGRlY29kZUV4dGVuc2lvbnMgcmV0dXJucycsIHN1cHBsZW1lbnQpO1xuICAgICAgICAgICAgaWYgKCFzdXBwbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghc3VwcGxlbWVudC5kZWNvZGVkQ29kZXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgbGFzdENvZGUgPSBzdXBwbGVtZW50LmRlY29kZWRDb2Rlc1tzdXBwbGVtZW50LmRlY29kZWRDb2Rlcy5sZW5ndGggLSAxXSBhcyBCYXJjb2RlSW5mbztcbiAgICAgICAgICAgIGNvbnN0IGVuZEluZm8gPSB7XG4gICAgICAgICAgICAgICAgc3RhcnQ6IGxhc3RDb2RlLnN0YXJ0ICsgKCgobGFzdENvZGUuZW5kIC0gbGFzdENvZGUuc3RhcnQpIC8gMikgfCAwKSxcbiAgICAgICAgICAgICAgICBlbmQ6IGxhc3RDb2RlLmVuZFxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgaWYgKCF0aGlzLl92ZXJpZnlUcmFpbGluZ1doaXRlc3BhY2UoZW5kSW5mbykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmVzdWx0SW5mbyA9IHtcbiAgICAgICAgICAgICAgICBzdXBwbGVtZW50LFxuICAgICAgICAgICAgICAgIGNvZGU6IHJlc3VsdC5qb2luKCcnKSArIHN1cHBsZW1lbnQuY29kZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjb2RlOiByZXN1bHQuam9pbignJyksXG4gICAgICAgICAgICBzdGFydDogc3RhcnRJbmZvLnN0YXJ0LFxuICAgICAgICAgICAgZW5kOiBjb2RlLmVuZCxcbiAgICAgICAgICAgIHN0YXJ0SW5mbyxcbiAgICAgICAgICAgIGRlY29kZWRDb2RlcyxcbiAgICAgICAgICAgIC4uLnJlc3VsdEluZm8sXG4gICAgICAgICAgICBmb3JtYXQ6IHRoaXMuRk9STUFULFxuICAgICAgICB9O1xuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgRUFOUmVhZGVyO1xuIiwiaW1wb3J0IEVBTlJlYWRlciwgeyBDT0RFX0dfU1RBUlQgfSBmcm9tICcuL2Vhbl9yZWFkZXInO1xuaW1wb3J0IHsgQmFyY29kZVBvc2l0aW9uLCBCYXJjb2RlLCBCYXJjb2RlSW5mbyB9IGZyb20gJy4vYmFyY29kZV9yZWFkZXInO1xuXG5cbmNsYXNzIEVBTjJSZWFkZXIgZXh0ZW5kcyBFQU5SZWFkZXIge1xuICAgIEZPUk1BVCA9ICdlYW5fMic7XG4gICAgcHVibGljIGRlY29kZShyb3c/OiBBcnJheTxudW1iZXI+LCBzdGFydD86IG51bWJlcik6IEJhcmNvZGUgfCBudWxsIHtcbiAgICAgICAgaWYgKHJvdykge1xuICAgICAgICAgICAgdGhpcy5fcm93ID0gcm93O1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGNvZGVGcmVxdWVuY3kgPSAwO1xuICAgICAgICBsZXQgb2Zmc2V0ID0gc3RhcnQ7XG4gICAgICAgIGNvbnN0IGVuZCA9IHRoaXMuX3Jvdy5sZW5ndGg7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgICAgICBjb25zdCBkZWNvZGVkQ29kZXMgPSBbXTtcbiAgICAgICAgbGV0IGNvZGU6IEJhcmNvZGVJbmZvIHwgbnVsbCA9IG51bGw7XG5cbiAgICAgICAgaWYgKG9mZnNldCA9PT0gdW5kZWZpbmVkKXtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAyICYmIG9mZnNldCA8IGVuZDsgaSsrKSB7XG4gICAgICAgICAgICBjb2RlID0gdGhpcy5fZGVjb2RlQ29kZShvZmZzZXQpO1xuICAgICAgICAgICAgaWYgKCFjb2RlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWNvZGVkQ29kZXMucHVzaChjb2RlKTtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGNvZGUuY29kZSAlIDEwKTtcbiAgICAgICAgICAgIGlmIChjb2RlLmNvZGUgPj0gQ09ERV9HX1NUQVJUKSB7XG4gICAgICAgICAgICAgICAgY29kZUZyZXF1ZW5jeSB8PSAxIDw8ICgxIC0gaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaSAhPT0gMSkge1xuICAgICAgICAgICAgICAgIG9mZnNldCA9IHRoaXMuX25leHRTZXQodGhpcy5fcm93LCBjb2RlLmVuZCk7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ID0gdGhpcy5fbmV4dFVuc2V0KHRoaXMuX3Jvdywgb2Zmc2V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyZXN1bHQubGVuZ3RoICE9PSAyIHx8IChwYXJzZUludChyZXN1bHQuam9pbignJykpICUgNCkgIT09IGNvZGVGcmVxdWVuY3kpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgc3RhcnRJbmZvID0gdGhpcy5fZmluZFN0YXJ0KCk7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNvZGU6IHJlc3VsdC5qb2luKCcnKSxcbiAgICAgICAgICAgIGRlY29kZWRDb2RlcyxcbiAgICAgICAgICAgIGVuZDogKGNvZGUgYXMgQmFyY29kZUluZm8pLmVuZCxcbiAgICAgICAgICAgIGZvcm1hdDogdGhpcy5GT1JNQVQsXG4gICAgICAgICAgICBzdGFydEluZm86IHN0YXJ0SW5mbyBhcyBCYXJjb2RlUG9zaXRpb24sXG4gICAgICAgICAgICBzdGFydDogKHN0YXJ0SW5mbyBhcyBCYXJjb2RlUG9zaXRpb24pLnN0YXJ0LFxuICAgICAgICB9O1xuICAgIH1cbn07XG5cbmV4cG9ydCBkZWZhdWx0IEVBTjJSZWFkZXI7XG4iLCJpbXBvcnQgRUFOUmVhZGVyLCB7IENPREVfR19TVEFSVCB9IGZyb20gJy4vZWFuX3JlYWRlcic7XG5pbXBvcnQgeyBCYXJjb2RlLCBCYXJjb2RlUG9zaXRpb24sIEJhcmNvZGVJbmZvIH0gZnJvbSAnLi9iYXJjb2RlX3JlYWRlcic7XG5cbmNvbnN0IENIRUNLX0RJR0lUX0VOQ09ESU5HUyA9IFsyNCwgMjAsIDE4LCAxNywgMTIsIDYsIDMsIDEwLCA5LCA1XTtcblxuZnVuY3Rpb24gZGV0ZXJtaW5lQ2hlY2tEaWdpdChjb2RlRnJlcXVlbmN5OiBudW1iZXIpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDEwOyBpKyspIHtcbiAgICAgICAgaWYgKGNvZGVGcmVxdWVuY3kgPT09IENIRUNLX0RJR0lUX0VOQ09ESU5HU1tpXSkge1xuICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIGV4dGVuc2lvbkNoZWNrc3VtKHJlc3VsdDogQXJyYXk8bnVtYmVyPikge1xuICAgIGNvbnN0IGxlbmd0aCA9IHJlc3VsdC5sZW5ndGg7XG4gICAgbGV0IHN1bSA9IDA7XG5cbiAgICBmb3IgKGxldCBpID0gbGVuZ3RoIC0gMjsgaSA+PSAwOyBpIC09IDIpIHtcbiAgICAgICAgc3VtICs9IHJlc3VsdFtpXTtcbiAgICB9XG4gICAgc3VtICo9IDM7XG4gICAgZm9yIChsZXQgaSA9IGxlbmd0aCAtIDE7IGkgPj0gMDsgaSAtPSAyKSB7XG4gICAgICAgIHN1bSArPSByZXN1bHRbaV07XG4gICAgfVxuICAgIHN1bSAqPSAzO1xuICAgIHJldHVybiBzdW0gJSAxMDtcbn1cblxuY2xhc3MgRUFONVJlYWRlciBleHRlbmRzIEVBTlJlYWRlciB7XG4gICAgRk9STUFUID0gJ2Vhbl81JztcbiAgICBwdWJsaWMgZGVjb2RlKHJvdz86IEFycmF5PG51bWJlcj4sIHN0YXJ0PzogbnVtYmVyKTogQmFyY29kZSB8IG51bGwge1xuICAgICAgICBpZiAoc3RhcnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocm93KSB7XG4gICAgICAgICAgICB0aGlzLl9yb3cgPSByb3c7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgY29kZUZyZXF1ZW5jeSA9IDA7XG4gICAgICAgIGxldCBvZmZzZXQgPSBzdGFydDtcbiAgICAgICAgY29uc3QgZW5kID0gdGhpcy5fcm93Lmxlbmd0aDtcbiAgICAgICAgbGV0IGNvZGU6IEJhcmNvZGVJbmZvIHwgbnVsbCA9IG51bGw7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgICAgICBjb25zdCBkZWNvZGVkQ29kZXMgPSBbXTtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDUgJiYgb2Zmc2V0IDwgZW5kOyBpKyspIHtcbiAgICAgICAgICAgIGNvZGUgPSB0aGlzLl9kZWNvZGVDb2RlKG9mZnNldCk7XG4gICAgICAgICAgICBpZiAoIWNvZGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlY29kZWRDb2Rlcy5wdXNoKGNvZGUpO1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goY29kZS5jb2RlICUgMTApO1xuICAgICAgICAgICAgaWYgKGNvZGUuY29kZSA+PSBDT0RFX0dfU1RBUlQpIHtcbiAgICAgICAgICAgICAgICBjb2RlRnJlcXVlbmN5IHw9IDEgPDwgKDQgLSBpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpICE9PSA0KSB7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ID0gdGhpcy5fbmV4dFNldCh0aGlzLl9yb3csIGNvZGUuZW5kKTtcbiAgICAgICAgICAgICAgICBvZmZzZXQgPSB0aGlzLl9uZXh0VW5zZXQodGhpcy5fcm93LCBvZmZzZXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJlc3VsdC5sZW5ndGggIT09IDUpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGV4dGVuc2lvbkNoZWNrc3VtKHJlc3VsdCkgIT09IGRldGVybWluZUNoZWNrRGlnaXQoY29kZUZyZXF1ZW5jeSkpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgc3RhcnRJbmZvID0gdGhpcy5fZmluZFN0YXJ0KCk7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNvZGU6IHJlc3VsdC5qb2luKCcnKSxcbiAgICAgICAgICAgIGRlY29kZWRDb2RlcyxcbiAgICAgICAgICAgIGVuZDogKGNvZGUgYXMgQmFyY29kZUluZm8pLmVuZCxcbiAgICAgICAgICAgIGZvcm1hdDogdGhpcy5GT1JNQVQsXG4gICAgICAgICAgICBzdGFydEluZm86IHN0YXJ0SW5mbyBhcyBCYXJjb2RlUG9zaXRpb24sXG4gICAgICAgICAgICBzdGFydDogKHN0YXJ0SW5mbyBhcyBCYXJjb2RlUG9zaXRpb24pLnN0YXJ0LFxuICAgICAgICB9O1xuICAgIH1cbn07XG5cbmV4cG9ydCBkZWZhdWx0IEVBTjVSZWFkZXI7XG4iLCJpbXBvcnQgRUFOUmVhZGVyLCB7IENPREVfR19TVEFSVCwgTUlERExFX1BBVFRFUk4gfSBmcm9tICcuL2Vhbl9yZWFkZXInO1xuaW1wb3J0IHsgQmFyY29kZVBvc2l0aW9uLCBCYXJjb2RlSW5mbyB9IGZyb20gJy4vYmFyY29kZV9yZWFkZXInO1xuXG5jbGFzcyBFQU44UmVhZGVyIGV4dGVuZHMgRUFOUmVhZGVyIHtcbiAgICBGT1JNQVQgPSAnZWFuXzgnO1xuICAgIHByb3RlY3RlZCBfZGVjb2RlUGF5bG9hZChpbkNvZGU6IEJhcmNvZGVQb3NpdGlvbiwgcmVzdWx0OiBBcnJheTxudW1iZXI+LCBkZWNvZGVkQ29kZXM6IEFycmF5PEJhcmNvZGVQb3NpdGlvbj4pOiBCYXJjb2RlSW5mbyB8IG51bGwge1xuICAgICAgICBsZXQgY29kZTogQmFyY29kZUluZm8gfCBCYXJjb2RlUG9zaXRpb24gfCBudWxsID0gaW5Db2RlO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNDsgaSsrKSB7XG4gICAgICAgICAgICBjb2RlID0gdGhpcy5fZGVjb2RlQ29kZShjb2RlLmVuZCwgQ09ERV9HX1NUQVJUKTtcbiAgICAgICAgICAgIGlmICghY29kZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0LnB1c2goKGNvZGUgYXMgQmFyY29kZUluZm8pLmNvZGUpO1xuICAgICAgICAgICAgZGVjb2RlZENvZGVzLnB1c2goY29kZSk7XG4gICAgICAgIH1cblxuICAgICAgICBjb2RlID0gdGhpcy5fZmluZFBhdHRlcm4oTUlERExFX1BBVFRFUk4sIGNvZGUuZW5kLCB0cnVlLCBmYWxzZSk7XG4gICAgICAgIGlmIChjb2RlID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBkZWNvZGVkQ29kZXMucHVzaChjb2RlKTtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDQ7IGkrKykge1xuICAgICAgICAgICAgY29kZSA9IHRoaXMuX2RlY29kZUNvZGUoY29kZS5lbmQsIENPREVfR19TVEFSVCk7XG4gICAgICAgICAgICBpZiAoIWNvZGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlY29kZWRDb2Rlcy5wdXNoKGNvZGUpO1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goKGNvZGUgYXMgQmFyY29kZUluZm8pLmNvZGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNvZGUgYXMgQmFyY29kZUluZm87XG4gICAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgRUFOOFJlYWRlcjtcbiIsIi8vIFRPRE86IGkyb2Y1X3JlYWRlciBhbmQgMm9mNV9yZWFkZXIgc2hhcmUgdmVyeSBzaW1pbGFyIGNvZGUsIG1ha2UgdXNlIG9mIHRoYXRcblxuaW1wb3J0IEJhcmNvZGVSZWFkZXIsIHsgQmFyY29kZVJlYWRlckNvbmZpZywgQmFyY29kZUluZm8sIEJhcmNvZGVQb3NpdGlvbiwgQmFyY29kZSB9IGZyb20gJy4vYmFyY29kZV9yZWFkZXInO1xuaW1wb3J0IG1lcmdlIGZyb20gJ2xvZGFzaC9tZXJnZSc7XG5cbmNvbnN0IE4gPSAxO1xuY29uc3QgVyA9IDM7XG5cbmNsYXNzIEkyb2Y1UmVhZGVyIGV4dGVuZHMgQmFyY29kZVJlYWRlciB7XG4gICAgcHJpdmF0ZSBiYXJTcGFjZVJhdGlvID0gWzEsIDFdO1xuICAgIFNJTkdMRV9DT0RFX0VSUk9SID0gMC43ODtcbiAgICBBVkdfQ09ERV9FUlJPUiA9IDAuMzg7XG5cbiAgICBTVEFSVF9QQVRURVJOID0gW04sIE4sIE4sIE5dO1xuICAgIFNUT1BfUEFUVEVSTiA9IFtOLCBOLCBXXTtcbiAgICBDT0RFX1BBVFRFUk4gPSBbXG4gICAgICAgIFtOLCBOLCBXLCBXLCBOXSxcbiAgICAgICAgW1csIE4sIE4sIE4sIFddLFxuICAgICAgICBbTiwgVywgTiwgTiwgV10sXG4gICAgICAgIFtXLCBXLCBOLCBOLCBOXSxcbiAgICAgICAgW04sIE4sIFcsIE4sIFddLFxuICAgICAgICBbVywgTiwgVywgTiwgTl0sXG4gICAgICAgIFtOLCBXLCBXLCBOLCBOXSxcbiAgICAgICAgW04sIE4sIE4sIFcsIFddLFxuICAgICAgICBbVywgTiwgTiwgVywgTl0sXG4gICAgICAgIFtOLCBXLCBOLCBXLCBOXSxcbiAgICBdO1xuICAgIE1BWF9DT1JSRUNUSU9OX0ZBQ1RPUiA9IDU7XG4gICAgRk9STUFUID0gJ2kyb2Y1JztcblxuICAgIGNvbnN0cnVjdG9yKG9wdHM6IEJhcmNvZGVSZWFkZXJDb25maWcpIHtcbiAgICAgICAgc3VwZXIobWVyZ2UoeyBub3JtYWxpemVCYXJTcGFjZVdpZHRoOiBmYWxzZSB9LCBvcHRzKSk7XG4gICAgICAgIGlmIChvcHRzLm5vcm1hbGl6ZUJhclNwYWNlV2lkdGgpIHtcbiAgICAgICAgICAgIHRoaXMuU0lOR0xFX0NPREVfRVJST1IgPSAwLjM4O1xuICAgICAgICAgICAgdGhpcy5BVkdfQ09ERV9FUlJPUiA9IDAuMDk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jb25maWcgPSBvcHRzO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgX21hdGNoUGF0dGVybihjb3VudGVyOiBBcnJheTxudW1iZXI+LCBjb2RlOiBSZWFkb25seUFycmF5PG51bWJlcj4pOiBudW1iZXIge1xuICAgICAgICBpZiAodGhpcy5jb25maWcubm9ybWFsaXplQmFyU3BhY2VXaWR0aCkge1xuICAgICAgICAgICAgY29uc3QgY291bnRlclN1bSA9IFswLCAwXTtcbiAgICAgICAgICAgIGNvbnN0IGNvZGVTdW0gPSBbMCwgMF07XG4gICAgICAgICAgICBjb25zdCBjb3JyZWN0aW9uID0gWzAsIDBdO1xuICAgICAgICAgICAgY29uc3QgY29ycmVjdGlvblJhdGlvID0gdGhpcy5NQVhfQ09SUkVDVElPTl9GQUNUT1I7XG4gICAgICAgICAgICBjb25zdCBjb3JyZWN0aW9uUmF0aW9JbnZlcnNlID0gMSAvIGNvcnJlY3Rpb25SYXRpbztcblxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb3VudGVyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY291bnRlclN1bVtpICUgMl0gKz0gY291bnRlcltpXTtcbiAgICAgICAgICAgICAgICBjb2RlU3VtW2kgJSAyXSArPSBjb2RlW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29ycmVjdGlvblswXSA9IGNvZGVTdW1bMF0gLyBjb3VudGVyU3VtWzBdO1xuICAgICAgICAgICAgY29ycmVjdGlvblsxXSA9IGNvZGVTdW1bMV0gLyBjb3VudGVyU3VtWzFdO1xuXG4gICAgICAgICAgICBjb3JyZWN0aW9uWzBdID0gTWF0aC5tYXgoTWF0aC5taW4oY29ycmVjdGlvblswXSwgY29ycmVjdGlvblJhdGlvKSwgY29ycmVjdGlvblJhdGlvSW52ZXJzZSk7XG4gICAgICAgICAgICBjb3JyZWN0aW9uWzFdID0gTWF0aC5tYXgoTWF0aC5taW4oY29ycmVjdGlvblsxXSwgY29ycmVjdGlvblJhdGlvKSwgY29ycmVjdGlvblJhdGlvSW52ZXJzZSk7XG4gICAgICAgICAgICB0aGlzLmJhclNwYWNlUmF0aW8gPSBjb3JyZWN0aW9uO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb3VudGVyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY291bnRlcltpXSAqPSB0aGlzLmJhclNwYWNlUmF0aW9baSAlIDJdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdXBlci5fbWF0Y2hQYXR0ZXJuKGNvdW50ZXIsIGNvZGUpO1xuICAgIH07XG5cbiAgICBwcm90ZWN0ZWQgX2ZpbmRQYXR0ZXJuKHBhdHRlcm46IFJlYWRvbmx5QXJyYXk8bnVtYmVyPiwgb2Zmc2V0PzogbnVtYmVyLCBpc1doaXRlOiBib29sZWFuID0gZmFsc2UsIHRyeUhhcmRlcjogYm9vbGVhbiA9IGZhbHNlKTogQmFyY29kZVBvc2l0aW9uIHwgbnVsbCB7XG4gICAgICAgIGNvbnN0IGNvdW50ZXIgPSBuZXcgQXJyYXk8bnVtYmVyPihwYXR0ZXJuLmxlbmd0aCkuZmlsbCgwKTtcbiAgICAgICAgbGV0IGNvdW50ZXJQb3MgPSAwO1xuICAgICAgICBjb25zdCBiZXN0TWF0Y2g6IEJhcmNvZGVQb3NpdGlvbiA9IHtcbiAgICAgICAgICAgIGVycm9yOiBOdW1iZXIuTUFYX1ZBTFVFLFxuICAgICAgICAgICAgc3RhcnQ6IDAsXG4gICAgICAgICAgICBlbmQ6IDAsXG4gICAgICAgIH07XG5cbiAgICAgICAgY29uc3QgZXBzaWxvbiA9IHRoaXMuQVZHX0NPREVfRVJST1I7XG5cbiAgICAgICAgaXNXaGl0ZSA9IGlzV2hpdGUgfHwgZmFsc2U7XG4gICAgICAgIHRyeUhhcmRlciA9IHRyeUhhcmRlciB8fCBmYWxzZTtcblxuICAgICAgICBpZiAoIW9mZnNldCkge1xuICAgICAgICAgICAgb2Zmc2V0ID0gdGhpcy5fbmV4dFNldCh0aGlzLl9yb3cpO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IG9mZnNldDsgaSA8IHRoaXMuX3Jvdy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3Jvd1tpXSBeIChpc1doaXRlID8gMSA6IDApKSB7XG4gICAgICAgICAgICAgICAgY291bnRlcltjb3VudGVyUG9zXSsrO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoY291bnRlclBvcyA9PT0gY291bnRlci5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHN1bSA9IGNvdW50ZXIucmVkdWNlKChwcmV2LCBuZXh0KSA9PiBwcmV2ICsgbmV4dCwgMCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yID0gdGhpcy5fbWF0Y2hQYXR0ZXJuKGNvdW50ZXIsIHBhdHRlcm4pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3IgPCBlcHNpbG9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBiZXN0TWF0Y2guZXJyb3IgPSBlcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJlc3RNYXRjaC5zdGFydCA9IGkgLSBzdW07XG4gICAgICAgICAgICAgICAgICAgICAgICBiZXN0TWF0Y2guZW5kID0gaTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBiZXN0TWF0Y2g7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRyeUhhcmRlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBjb3VudGVyLmxlbmd0aCAtIDI7IGorKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50ZXJbal0gPSBjb3VudGVyW2ogKyAyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50ZXJbY291bnRlci5sZW5ndGggLSAyXSA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb3VudGVyW2NvdW50ZXIubGVuZ3RoIC0gMV0gPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgY291bnRlclBvcy0tO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb3VudGVyUG9zKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvdW50ZXJbY291bnRlclBvc10gPSAxO1xuICAgICAgICAgICAgICAgIGlzV2hpdGUgPSAhaXNXaGl0ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuXG4gICAgcHJvdGVjdGVkIF9maW5kU3RhcnQoKTogQmFyY29kZVBvc2l0aW9uIHwgbnVsbCB7XG4gICAgICAgIGxldCBsZWFkaW5nV2hpdGVzcGFjZVN0YXJ0ID0gMDtcbiAgICAgICAgbGV0IG9mZnNldCA9IHRoaXMuX25leHRTZXQodGhpcy5fcm93KTtcbiAgICAgICAgbGV0IHN0YXJ0SW5mbzogQmFyY29kZVBvc2l0aW9uIHwgbnVsbCA9IG51bGw7XG4gICAgICAgIGxldCBuYXJyb3dCYXJXaWR0aCA9IDE7XG5cbiAgICAgICAgd2hpbGUgKCFzdGFydEluZm8pIHtcbiAgICAgICAgICAgIHN0YXJ0SW5mbyA9IHRoaXMuX2ZpbmRQYXR0ZXJuKHRoaXMuU1RBUlRfUEFUVEVSTiwgb2Zmc2V0LCBmYWxzZSwgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAoIXN0YXJ0SW5mbykge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbmFycm93QmFyV2lkdGggPSBNYXRoLmZsb29yKChzdGFydEluZm8uZW5kIC0gc3RhcnRJbmZvLnN0YXJ0KSAvIDQpO1xuICAgICAgICAgICAgbGVhZGluZ1doaXRlc3BhY2VTdGFydCA9IHN0YXJ0SW5mby5zdGFydCAtIG5hcnJvd0JhcldpZHRoICogMTA7XG4gICAgICAgICAgICBpZiAobGVhZGluZ1doaXRlc3BhY2VTdGFydCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX21hdGNoUmFuZ2UobGVhZGluZ1doaXRlc3BhY2VTdGFydCwgc3RhcnRJbmZvLnN0YXJ0LCAwKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3RhcnRJbmZvO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9mZnNldCA9IHN0YXJ0SW5mby5lbmQ7XG4gICAgICAgICAgICBzdGFydEluZm8gPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG5cbiAgICBwcm90ZWN0ZWQgX3ZlcmlmeVRyYWlsaW5nV2hpdGVzcGFjZShlbmRJbmZvOiBCYXJjb2RlUG9zaXRpb24pOiBCYXJjb2RlUG9zaXRpb24gfCBudWxsIHtcbiAgICAgICAgY29uc3QgdHJhaWxpbmdXaGl0ZXNwYWNlRW5kID0gZW5kSW5mby5lbmQgKyAoKGVuZEluZm8uZW5kIC0gZW5kSW5mby5zdGFydCkgLyAyKTtcbiAgICAgICAgaWYgKHRyYWlsaW5nV2hpdGVzcGFjZUVuZCA8IHRoaXMuX3Jvdy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9tYXRjaFJhbmdlKGVuZEluZm8uZW5kLCB0cmFpbGluZ1doaXRlc3BhY2VFbmQsIDApKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVuZEluZm87XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcblxuICAgIHByb3RlY3RlZCBfZmluZEVuZCgpOiBCYXJjb2RlUG9zaXRpb24gfCBudWxsIHtcbiAgICAgICAgdGhpcy5fcm93LnJldmVyc2UoKTtcbiAgICAgICAgY29uc3QgZW5kSW5mbyA9IHRoaXMuX2ZpbmRQYXR0ZXJuKHRoaXMuU1RPUF9QQVRURVJOKTtcbiAgICAgICAgdGhpcy5fcm93LnJldmVyc2UoKTtcblxuICAgICAgICBpZiAoZW5kSW5mbyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICAvLyByZXZlcnNlIG51bWJlcnNcbiAgICAgICAgY29uc3QgdG1wID0gZW5kSW5mby5zdGFydDtcbiAgICAgICAgZW5kSW5mby5zdGFydCA9IHRoaXMuX3Jvdy5sZW5ndGggLSBlbmRJbmZvLmVuZDtcbiAgICAgICAgZW5kSW5mby5lbmQgPSB0aGlzLl9yb3cubGVuZ3RoIC0gdG1wO1xuXG4gICAgICAgIHJldHVybiBlbmRJbmZvICE9PSBudWxsID8gdGhpcy5fdmVyaWZ5VHJhaWxpbmdXaGl0ZXNwYWNlKGVuZEluZm8pIDogbnVsbDtcbiAgICB9O1xuXG4gICAgcHJvdGVjdGVkIF9kZWNvZGVQYWlyKGNvdW50ZXJQYWlyOiBBcnJheTxBcnJheTxudW1iZXI+Pik6IEFycmF5PEJhcmNvZGVJbmZvPiB8IG51bGwge1xuICAgICAgICBjb25zdCBjb2RlczogQXJyYXk8QmFyY29kZUluZm8+ID0gW107XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb3VudGVyUGFpci5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgY29kZSA9IHRoaXMuX2RlY29kZUNvZGUoY291bnRlclBhaXJbaV0pO1xuICAgICAgICAgICAgaWYgKCFjb2RlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb2Rlcy5wdXNoKGNvZGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb2RlcztcbiAgICB9O1xuXG4gICAgcHJvdGVjdGVkIF9kZWNvZGVDb2RlKGNvdW50ZXI6IEFycmF5PG51bWJlcj4pOiBCYXJjb2RlSW5mbyB8IG51bGwge1xuICAgICAgICBjb25zdCBlcHNpbG9uID0gdGhpcy5BVkdfQ09ERV9FUlJPUjtcblxuICAgICAgICBjb25zdCBiZXN0TWF0Y2g6IEJhcmNvZGVJbmZvID0ge1xuICAgICAgICAgICAgZXJyb3I6IE51bWJlci5NQVhfVkFMVUUsXG4gICAgICAgICAgICBjb2RlOiAtMSxcbiAgICAgICAgICAgIHN0YXJ0OiAwLFxuICAgICAgICAgICAgZW5kOiAwLFxuICAgICAgICB9O1xuXG4gICAgICAgIGZvciAobGV0IGNvZGUgPSAwOyBjb2RlIDwgdGhpcy5DT0RFX1BBVFRFUk4ubGVuZ3RoOyBjb2RlKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGVycm9yID0gdGhpcy5fbWF0Y2hQYXR0ZXJuKGNvdW50ZXIsIHRoaXMuQ09ERV9QQVRURVJOW2NvZGVdKTtcbiAgICAgICAgICAgIGlmIChlcnJvciA8IGJlc3RNYXRjaC5lcnJvciEpIHtcbiAgICAgICAgICAgICAgICBiZXN0TWF0Y2guY29kZSA9IGNvZGU7XG4gICAgICAgICAgICAgICAgYmVzdE1hdGNoLmVycm9yID0gZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJlc3RNYXRjaC5lcnJvciEgPCBlcHNpbG9uKSB7XG4gICAgICAgICAgICByZXR1cm4gYmVzdE1hdGNoO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG5cbiAgICBwcm90ZWN0ZWQgX2RlY29kZVBheWxvYWQoY291bnRlcnM6IFJlYWRvbmx5QXJyYXk8bnVtYmVyPiwgcmVzdWx0OiBBcnJheTxzdHJpbmc+LCBkZWNvZGVkQ29kZXM6IEFycmF5PEJhcmNvZGVJbmZvIHwgQmFyY29kZVBvc2l0aW9uPik6IEFycmF5PEJhcmNvZGVJbmZvPiB8IG51bGwge1xuICAgICAgICBsZXQgcG9zID0gMDtcbiAgICAgICAgY29uc3QgY291bnRlckxlbmd0aCA9IGNvdW50ZXJzLmxlbmd0aDtcbiAgICAgICAgY29uc3QgY291bnRlclBhaXIgPSBbWzAsIDAsIDAsIDAsIDBdLCBbMCwgMCwgMCwgMCwgMF1dO1xuICAgICAgICBsZXQgY29kZXM6IEJhcmNvZGVJbmZvW10gfCBudWxsID0gbnVsbDtcblxuICAgICAgICB3aGlsZSAocG9zIDwgY291bnRlckxlbmd0aCkge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCA1OyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb3VudGVyUGFpclswXVtpXSA9IGNvdW50ZXJzW3Bvc10gKiB0aGlzLmJhclNwYWNlUmF0aW9bMF07XG4gICAgICAgICAgICAgICAgY291bnRlclBhaXJbMV1baV0gPSBjb3VudGVyc1twb3MgKyAxXSAqIHRoaXMuYmFyU3BhY2VSYXRpb1sxXTtcbiAgICAgICAgICAgICAgICBwb3MgKz0gMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvZGVzID0gdGhpcy5fZGVjb2RlUGFpcihjb3VudGVyUGFpcik7XG4gICAgICAgICAgICBpZiAoIWNvZGVzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goY29kZXNbaV0uY29kZSArICcnKTtcbiAgICAgICAgICAgICAgICBkZWNvZGVkQ29kZXMucHVzaChjb2Rlc1tpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvZGVzO1xuICAgIH07XG5cbiAgICBwcm90ZWN0ZWQgX3ZlcmlmeUNvdW50ZXJMZW5ndGgoY291bnRlcnM6IEFycmF5PG51bWJlcj4pIHtcbiAgICAgICAgcmV0dXJuIChjb3VudGVycy5sZW5ndGggJSAxMCA9PT0gMCk7XG4gICAgfTtcblxuICAgIHB1YmxpYyBkZWNvZGUocm93PzogQXJyYXk8bnVtYmVyPiwgc3RhcnQ/OiBCYXJjb2RlUG9zaXRpb24gfCBudW1iZXIpOiBCYXJjb2RlIHwgbnVsbCB7XG4gICAgICAgIHZhciByZXN1bHQgPSBuZXcgQXJyYXk8c3RyaW5nPigpO1xuICAgICAgICB2YXIgZGVjb2RlZENvZGVzID0gbmV3IEFycmF5PEJhcmNvZGVQb3NpdGlvbj4oKTtcblxuICAgICAgICBjb25zdCBzdGFydEluZm8gPSB0aGlzLl9maW5kU3RhcnQoKTtcbiAgICAgICAgaWYgKCFzdGFydEluZm8pIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGRlY29kZWRDb2Rlcy5wdXNoKHN0YXJ0SW5mbyk7XG5cbiAgICAgICAgY29uc3QgZW5kSW5mbyA9IHRoaXMuX2ZpbmRFbmQoKTtcbiAgICAgICAgaWYgKCFlbmRJbmZvKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGNvdW50ZXJzID0gdGhpcy5fZmlsbENvdW50ZXJzKHN0YXJ0SW5mby5lbmQsIGVuZEluZm8uc3RhcnQsIGZhbHNlKTtcbiAgICAgICAgaWYgKCF0aGlzLl92ZXJpZnlDb3VudGVyTGVuZ3RoKGNvdW50ZXJzKSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY29kZSA9IHRoaXMuX2RlY29kZVBheWxvYWQoY291bnRlcnMsIHJlc3VsdCwgZGVjb2RlZENvZGVzKTtcbiAgICAgICAgaWYgKCFjb2RlKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0Lmxlbmd0aCAlIDIgIT09IDAgfHxcbiAgICAgICAgICAgICAgICByZXN1bHQubGVuZ3RoIDwgNikge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBkZWNvZGVkQ29kZXMucHVzaChlbmRJbmZvKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNvZGU6IHJlc3VsdC5qb2luKCcnKSxcbiAgICAgICAgICAgIHN0YXJ0OiBzdGFydEluZm8uc3RhcnQsXG4gICAgICAgICAgICBlbmQ6IGVuZEluZm8uZW5kLFxuICAgICAgICAgICAgc3RhcnRJbmZvOiBzdGFydEluZm8sXG4gICAgICAgICAgICBkZWNvZGVkQ29kZXM6IGRlY29kZWRDb2RlcyxcbiAgICAgICAgICAgIGZvcm1hdDogdGhpcy5GT1JNQVQsXG4gICAgICAgIH07XG4gICAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgSTJvZjVSZWFkZXI7XG4iLCJpbXBvcnQgRUFOUmVhZGVyLCB7IENPREVfR19TVEFSVCB9IGZyb20gJy4vZWFuX3JlYWRlcic7XG5pbXBvcnQgeyBCYXJjb2RlUG9zaXRpb24sIEJhcmNvZGVJbmZvIH0gZnJvbSAnLi9iYXJjb2RlX3JlYWRlcic7XG5cbmNsYXNzIFVQQ0VSZWFkZXIgZXh0ZW5kcyBFQU5SZWFkZXIge1xuICAgIENPREVfRlJFUVVFTkNZID0gW1xuICAgICAgICBbIDU2LCA1MiwgNTAsIDQ5LCA0NCwgMzgsIDM1LCA0MiwgNDEsIDM3IF0sXG4gICAgICAgIFs3LCAxMSwgMTMsIDE0LCAxOSwgMjUsIDI4LCAyMSwgMjIsIDI2XV07XG4gICAgU1RPUF9QQVRURVJOID0gWzEgLyA2ICogNywgMSAvIDYgKiA3LCAxIC8gNiAqIDcsIDEgLyA2ICogNywgMSAvIDYgKiA3LCAxIC8gNiAqIDddO1xuICAgIEZPUk1BVCA9ICd1cGNfZSc7XG4gICAgcHJvdGVjdGVkIF9kZWNvZGVQYXlsb2FkKGluQ29kZTogQmFyY29kZVBvc2l0aW9uLCByZXN1bHQ6IEFycmF5PG51bWJlcj4sIGRlY29kZWRDb2RlczogQXJyYXk8QmFyY29kZVBvc2l0aW9uPik6IEJhcmNvZGVJbmZvIHwgbnVsbCB7XG4gICAgICAgIGxldCBvdXRDb2RlOiBCYXJjb2RlSW5mbyB8IEJhcmNvZGVQb3NpdGlvbiB8IG51bGwgPSB7IC4uLmluQ29kZSB9O1xuICAgICAgICBsZXQgY29kZUZyZXF1ZW5jeSA9IDB4MDtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDY7IGkrKykge1xuICAgICAgICAgICAgb3V0Q29kZSA9IHRoaXMuX2RlY29kZUNvZGUob3V0Q29kZS5lbmQpO1xuICAgICAgICAgICAgaWYgKCFvdXRDb2RlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoKG91dENvZGUgYXMgQmFyY29kZUluZm8pLmNvZGUgPj0gQ09ERV9HX1NUQVJUKSB7XG4gICAgICAgICAgICAgICAgKG91dENvZGUgYXMgQmFyY29kZUluZm8pLmNvZGUgPSAob3V0Q29kZSBhcyBCYXJjb2RlSW5mbykuY29kZSAtIENPREVfR19TVEFSVDtcbiAgICAgICAgICAgICAgICBjb2RlRnJlcXVlbmN5IHw9ICgxIDw8ICg1IC0gaSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0LnB1c2goKG91dENvZGUgYXMgQmFyY29kZUluZm8pLmNvZGUpO1xuICAgICAgICAgICAgZGVjb2RlZENvZGVzLnB1c2gob3V0Q29kZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLl9kZXRlcm1pbmVQYXJpdHkoY29kZUZyZXF1ZW5jeSwgcmVzdWx0KSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG91dENvZGUgYXMgQmFyY29kZUluZm87XG4gICAgfTtcblxuICAgIHByb3RlY3RlZCBfZGV0ZXJtaW5lUGFyaXR5KGNvZGVGcmVxdWVuY3k6IG51bWJlciwgcmVzdWx0OiBBcnJheTxudW1iZXI+KSB7XG4gICAgICAgIGZvciAobGV0IG5yU3lzdGVtID0gMDsgbnJTeXN0ZW0gPCB0aGlzLkNPREVfRlJFUVVFTkNZLmxlbmd0aDsgbnJTeXN0ZW0rKyl7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuQ09ERV9GUkVRVUVOQ1lbbnJTeXN0ZW1dLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvZGVGcmVxdWVuY3kgPT09IHRoaXMuQ09ERV9GUkVRVUVOQ1lbbnJTeXN0ZW1dW2ldKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC51bnNoaWZ0KG5yU3lzdGVtKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goaSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcblxuICAgIHByb3RlY3RlZCBfY29udmVydFRvVVBDQShyZXN1bHQ6IEFycmF5PG51bWJlcj4pIHtcbiAgICAgICAgbGV0IHVwY2EgPSBbcmVzdWx0WzBdXTtcbiAgICAgICAgY29uc3QgbGFzdERpZ2l0ID0gcmVzdWx0W3Jlc3VsdC5sZW5ndGggLSAyXTtcblxuICAgICAgICBpZiAobGFzdERpZ2l0IDw9IDIpIHtcbiAgICAgICAgICAgIHVwY2EgPSB1cGNhLmNvbmNhdChyZXN1bHQuc2xpY2UoMSwgMykpXG4gICAgICAgICAgICAgICAgLmNvbmNhdChbbGFzdERpZ2l0LCAwLCAwLCAwLCAwXSlcbiAgICAgICAgICAgICAgICAuY29uY2F0KHJlc3VsdC5zbGljZSgzLCA2KSk7XG4gICAgICAgIH0gZWxzZSBpZiAobGFzdERpZ2l0ID09PSAzKSB7XG4gICAgICAgICAgICB1cGNhID0gdXBjYS5jb25jYXQocmVzdWx0LnNsaWNlKDEsIDQpKVxuICAgICAgICAgICAgICAgIC5jb25jYXQoWzAsIDAsIDAsIDAsIDBdKVxuICAgICAgICAgICAgICAgIC5jb25jYXQocmVzdWx0LnNsaWNlKDQsIDYpKTtcbiAgICAgICAgfSBlbHNlIGlmIChsYXN0RGlnaXQgPT09IDQpIHtcbiAgICAgICAgICAgIHVwY2EgPSB1cGNhLmNvbmNhdChyZXN1bHQuc2xpY2UoMSwgNSkpXG4gICAgICAgICAgICAgICAgLmNvbmNhdChbMCwgMCwgMCwgMCwgMCwgcmVzdWx0WzVdXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB1cGNhID0gdXBjYS5jb25jYXQocmVzdWx0LnNsaWNlKDEsIDYpKVxuICAgICAgICAgICAgICAgIC5jb25jYXQoWzAsIDAsIDAsIDAsIGxhc3REaWdpdF0pO1xuICAgICAgICB9XG5cbiAgICAgICAgdXBjYS5wdXNoKHJlc3VsdFtyZXN1bHQubGVuZ3RoIC0gMV0pO1xuICAgICAgICByZXR1cm4gdXBjYTtcbiAgICB9O1xuXG4gICAgcHJvdGVjdGVkIF9jaGVja3N1bShyZXN1bHQ6IEFycmF5PG51bWJlcj4pOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHN1cGVyLl9jaGVja3N1bSh0aGlzLl9jb252ZXJ0VG9VUENBKHJlc3VsdCkpO1xuICAgIH1cblxuICAgIHByb3RlY3RlZCBfZmluZEVuZChvZmZzZXQ6IG51bWJlciwgaXNXaGl0ZTogYm9vbGVhbik6IEJhcmNvZGVQb3NpdGlvbiB8IG51bGwge1xuICAgICAgICByZXR1cm4gc3VwZXIuX2ZpbmRFbmQob2Zmc2V0LCB0cnVlKTtcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgX3ZlcmlmeVRyYWlsaW5nV2hpdGVzcGFjZShlbmRJbmZvOiBCYXJjb2RlUG9zaXRpb24pOiBCYXJjb2RlUG9zaXRpb24gfCBudWxsIHtcbiAgICAgICAgY29uc3QgdHJhaWxpbmdXaGl0ZXNwYWNlRW5kID0gZW5kSW5mby5lbmQgKyAoKGVuZEluZm8uZW5kIC0gZW5kSW5mby5zdGFydCkgLyAyKTtcbiAgICAgICAgaWYgKHRyYWlsaW5nV2hpdGVzcGFjZUVuZCA8IHRoaXMuX3Jvdy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9tYXRjaFJhbmdlKGVuZEluZm8uZW5kLCB0cmFpbGluZ1doaXRlc3BhY2VFbmQsIDApKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVuZEluZm87XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgVVBDRVJlYWRlcjtcbiIsImltcG9ydCBFQU5SZWFkZXIgZnJvbSAnLi9lYW5fcmVhZGVyJztcbmltcG9ydCB7IEJhcmNvZGVQb3NpdGlvbiwgQmFyY29kZSB9IGZyb20gJy4vYmFyY29kZV9yZWFkZXInO1xuXG5jbGFzcyBVUENSZWFkZXIgZXh0ZW5kcyBFQU5SZWFkZXIge1xuICAgIEZPUk1BVCA9ICd1cGNfYSc7XG4gICAgZGVjb2RlKHJvdz86IEFycmF5PG51bWJlcj4sIHN0YXJ0PzogQmFyY29kZVBvc2l0aW9uIHwgbnVtYmVyKTogQmFyY29kZSB8IG51bGwge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBFQU5SZWFkZXIucHJvdG90eXBlLmRlY29kZS5jYWxsKHRoaXMpO1xuXG4gICAgICAgIGlmIChyZXN1bHQgJiYgcmVzdWx0LmNvZGUgJiYgcmVzdWx0LmNvZGUubGVuZ3RoID09PSAxMyAmJiByZXN1bHQuY29kZS5jaGFyQXQoMCkgPT09ICcwJykge1xuICAgICAgICAgICAgcmVzdWx0LmNvZGUgPSByZXN1bHQuY29kZS5zdWJzdHJpbmcoMSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgVVBDUmVhZGVyO1xuIiwiY29uc3QgQnJlc2VuaGFtID0ge307XG5cbmNvbnN0IFNsb3BlID0ge1xuICAgIERJUjoge1xuICAgICAgICBVUDogMSxcbiAgICAgICAgRE9XTjogLTEsXG4gICAgfSxcbn07XG4vKipcbiAqIFNjYW5zIGEgbGluZSBvZiB0aGUgZ2l2ZW4gaW1hZ2UgZnJvbSBwb2ludCBwMSB0byBwMiBhbmQgcmV0dXJucyBhIHJlc3VsdCBvYmplY3QgY29udGFpbmluZ1xuICogZ3JheS1zY2FsZSB2YWx1ZXMgKDAtMjU1KSBvZiB0aGUgdW5kZXJseWluZyBwaXhlbHMgaW4gYWRkaXRpb24gdG8gdGhlIG1pblxuICogYW5kIG1heCB2YWx1ZXMuXG4gKiBAcGFyYW0ge09iamVjdH0gaW1hZ2VXcmFwcGVyXG4gKiBAcGFyYW0ge09iamVjdH0gcDEgVGhlIHN0YXJ0IHBvaW50IHt4LHl9XG4gKiBAcGFyYW0ge09iamVjdH0gcDIgVGhlIGVuZCBwb2ludCB7eCx5fVxuICogQHJldHVybnMge2xpbmUsIG1pbiwgbWF4fVxuICovXG5CcmVzZW5oYW0uZ2V0QmFyY29kZUxpbmUgPSBmdW5jdGlvbiAoaW1hZ2VXcmFwcGVyLCBwMSwgcDIpIHtcbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1iaXR3aXNlICovXG4gICAgbGV0IHgwID0gcDEueCB8IDA7XG4gICAgbGV0IHkwID0gcDEueSB8IDA7XG4gICAgbGV0IHgxID0gcDIueCB8IDA7XG4gICAgbGV0IHkxID0gcDIueSB8IDA7XG4gICAgLyogZXNsaW50LWRpc2FibGUgbm8tYml0d2lzZSAqL1xuICAgIGNvbnN0IHN0ZWVwID0gTWF0aC5hYnMoeTEgLSB5MCkgPiBNYXRoLmFicyh4MSAtIHgwKTtcbiAgICBsZXQgZXJyb3I7XG4gICAgbGV0IHk7XG4gICAgbGV0IHRtcDtcbiAgICBsZXQgeDtcbiAgICBjb25zdCBsaW5lID0gW107XG4gICAgY29uc3QgaW1hZ2VEYXRhID0gaW1hZ2VXcmFwcGVyLmRhdGE7XG4gICAgY29uc3Qgd2lkdGggPSBpbWFnZVdyYXBwZXIuc2l6ZS54O1xuICAgIGxldCB2YWw7XG4gICAgbGV0IG1pbiA9IDI1NTtcbiAgICBsZXQgbWF4ID0gMDtcblxuICAgIGZ1bmN0aW9uIHJlYWQoYSwgYikge1xuICAgICAgICB2YWwgPSBpbWFnZURhdGFbYiAqIHdpZHRoICsgYV07XG4gICAgICAgIG1pbiA9IHZhbCA8IG1pbiA/IHZhbCA6IG1pbjtcbiAgICAgICAgbWF4ID0gdmFsID4gbWF4ID8gdmFsIDogbWF4O1xuICAgICAgICBsaW5lLnB1c2godmFsKTtcbiAgICB9XG5cbiAgICBpZiAoc3RlZXApIHtcbiAgICAgICAgdG1wID0geDA7XG4gICAgICAgIHgwID0geTA7XG4gICAgICAgIHkwID0gdG1wO1xuXG4gICAgICAgIHRtcCA9IHgxO1xuICAgICAgICB4MSA9IHkxO1xuICAgICAgICB5MSA9IHRtcDtcbiAgICB9XG4gICAgaWYgKHgwID4geDEpIHtcbiAgICAgICAgdG1wID0geDA7XG4gICAgICAgIHgwID0geDE7XG4gICAgICAgIHgxID0gdG1wO1xuXG4gICAgICAgIHRtcCA9IHkwO1xuICAgICAgICB5MCA9IHkxO1xuICAgICAgICB5MSA9IHRtcDtcbiAgICB9XG4gICAgY29uc3QgZGVsdGFYID0geDEgLSB4MDtcbiAgICBjb25zdCBkZWx0YVkgPSBNYXRoLmFicyh5MSAtIHkwKTtcbiAgICBlcnJvciA9IChkZWx0YVggLyAyKSB8IDA7XG4gICAgeSA9IHkwO1xuICAgIGNvbnN0IHlTdGVwID0geTAgPCB5MSA/IDEgOiAtMTtcbiAgICBmb3IgKHggPSB4MDsgeCA8IHgxOyB4KyspIHtcbiAgICAgICAgaWYgKHN0ZWVwKSB7XG4gICAgICAgICAgICByZWFkKHksIHgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVhZCh4LCB5KTtcbiAgICAgICAgfVxuICAgICAgICBlcnJvciAtPSBkZWx0YVk7XG4gICAgICAgIGlmIChlcnJvciA8IDApIHtcbiAgICAgICAgICAgIHkgKz0geVN0ZXA7XG4gICAgICAgICAgICBlcnJvciArPSBkZWx0YVg7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBsaW5lLFxuICAgICAgICBtaW4sXG4gICAgICAgIG1heCxcbiAgICB9O1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyB0aGUgcmVzdWx0IGZyb20gZ2V0QmFyY29kZUxpbmUgaW50byBhIGJpbmFyeSByZXByZXNlbnRhdGlvblxuICogYWxzbyBjb25zaWRlcmluZyB0aGUgZnJlcXVlbmN5IGFuZCBzbG9wZSBvZiB0aGUgc2lnbmFsIGZvciBtb3JlIHJvYnVzdCByZXN1bHRzXG4gKiBAcGFyYW0ge09iamVjdH0gcmVzdWx0IHtsaW5lLCBtaW4sIG1heH1cbiAqL1xuQnJlc2VuaGFtLnRvQmluYXJ5TGluZSA9IGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICBjb25zdCB7IG1pbiB9ID0gcmVzdWx0O1xuICAgIGNvbnN0IHsgbWF4IH0gPSByZXN1bHQ7XG4gICAgY29uc3QgeyBsaW5lIH0gPSByZXN1bHQ7XG4gICAgbGV0IHNsb3BlO1xuICAgIGxldCBzbG9wZTI7XG4gICAgY29uc3QgY2VudGVyID0gbWluICsgKG1heCAtIG1pbikgLyAyO1xuICAgIGNvbnN0IGV4dHJlbWEgPSBbXTtcbiAgICBsZXQgY3VycmVudERpcjtcbiAgICBsZXQgZGlyO1xuICAgIGxldCB0aHJlc2hvbGQgPSAobWF4IC0gbWluKSAvIDEyO1xuICAgIGNvbnN0IHJUaHJlc2hvbGQgPSAtdGhyZXNob2xkO1xuICAgIGxldCBpO1xuICAgIGxldCBqO1xuXG4gICAgLy8gMS4gZmluZCBleHRyZW1hXG4gICAgY3VycmVudERpciA9IGxpbmVbMF0gPiBjZW50ZXIgPyBTbG9wZS5ESVIuVVAgOiBTbG9wZS5ESVIuRE9XTjtcbiAgICBleHRyZW1hLnB1c2goe1xuICAgICAgICBwb3M6IDAsXG4gICAgICAgIHZhbDogbGluZVswXSxcbiAgICB9KTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGluZS5sZW5ndGggLSAyOyBpKyspIHtcbiAgICAgICAgc2xvcGUgPSAobGluZVtpICsgMV0gLSBsaW5lW2ldKTtcbiAgICAgICAgc2xvcGUyID0gKGxpbmVbaSArIDJdIC0gbGluZVtpICsgMV0pO1xuICAgICAgICBpZiAoKHNsb3BlICsgc2xvcGUyKSA8IHJUaHJlc2hvbGQgJiYgbGluZVtpICsgMV0gPCAoY2VudGVyICogMS41KSkge1xuICAgICAgICAgICAgZGlyID0gU2xvcGUuRElSLkRPV047XG4gICAgICAgIH0gZWxzZSBpZiAoKHNsb3BlICsgc2xvcGUyKSA+IHRocmVzaG9sZCAmJiBsaW5lW2kgKyAxXSA+IChjZW50ZXIgKiAwLjUpKSB7XG4gICAgICAgICAgICBkaXIgPSBTbG9wZS5ESVIuVVA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkaXIgPSBjdXJyZW50RGlyO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGN1cnJlbnREaXIgIT09IGRpcikge1xuICAgICAgICAgICAgZXh0cmVtYS5wdXNoKHtcbiAgICAgICAgICAgICAgICBwb3M6IGksXG4gICAgICAgICAgICAgICAgdmFsOiBsaW5lW2ldLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjdXJyZW50RGlyID0gZGlyO1xuICAgICAgICB9XG4gICAgfVxuICAgIGV4dHJlbWEucHVzaCh7XG4gICAgICAgIHBvczogbGluZS5sZW5ndGgsXG4gICAgICAgIHZhbDogbGluZVtsaW5lLmxlbmd0aCAtIDFdLFxuICAgIH0pO1xuXG4gICAgZm9yIChqID0gZXh0cmVtYVswXS5wb3M7IGogPCBleHRyZW1hWzFdLnBvczsgaisrKSB7XG4gICAgICAgIGxpbmVbal0gPSBsaW5lW2pdID4gY2VudGVyID8gMCA6IDE7XG4gICAgfVxuXG4gICAgLy8gaXRlcmF0ZSBvdmVyIGV4dHJlbWEgYW5kIGNvbnZlcnQgdG8gYmluYXJ5IGJhc2VkIG9uIGF2ZyBiZXR3ZWVuIG1pbm1heFxuICAgIGZvciAoaSA9IDE7IGkgPCBleHRyZW1hLmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgICBpZiAoZXh0cmVtYVtpICsgMV0udmFsID4gZXh0cmVtYVtpXS52YWwpIHtcbiAgICAgICAgICAgIHRocmVzaG9sZCA9IChleHRyZW1hW2ldLnZhbCArICgoZXh0cmVtYVtpICsgMV0udmFsIC0gZXh0cmVtYVtpXS52YWwpIC8gMykgKiAyKSB8IDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJlc2hvbGQgPSAoZXh0cmVtYVtpICsgMV0udmFsICsgKChleHRyZW1hW2ldLnZhbCAtIGV4dHJlbWFbaSArIDFdLnZhbCkgLyAzKSkgfCAwO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChqID0gZXh0cmVtYVtpXS5wb3M7IGogPCBleHRyZW1hW2kgKyAxXS5wb3M7IGorKykge1xuICAgICAgICAgICAgbGluZVtqXSA9IGxpbmVbal0gPiB0aHJlc2hvbGQgPyAwIDogMTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICAgIGxpbmUsXG4gICAgICAgIHRocmVzaG9sZCxcbiAgICB9O1xufTtcblxuLyoqXG4gKiBVc2VkIGZvciBkZXZlbG9wbWVudCBvbmx5XG4gKi9cbkJyZXNlbmhhbS5kZWJ1ZyA9IHtcbiAgICBwcmludEZyZXF1ZW5jeShsaW5lLCBjYW52YXMpIHtcbiAgICAgICAgbGV0IGk7XG4gICAgICAgIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgICAgY2FudmFzLndpZHRoID0gbGluZS5sZW5ndGg7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgICBjYW52YXMuaGVpZ2h0ID0gMjU2O1xuXG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gJ2JsdWUnO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGluZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY3R4Lm1vdmVUbyhpLCAyNTUpO1xuICAgICAgICAgICAgY3R4LmxpbmVUbyhpLCAyNTUgLSBsaW5lW2ldKTtcbiAgICAgICAgfVxuICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICB9LFxuXG4gICAgcHJpbnRQYXR0ZXJuKGxpbmUsIGNhbnZhcykge1xuICAgICAgICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTsgbGV0XG4gICAgICAgICAgICBpO1xuXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgICBjYW52YXMud2lkdGggPSBsaW5lLmxlbmd0aDtcbiAgICAgICAgY3R4LmZpbGxDb2xvciA9ICdibGFjayc7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsaW5lLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAobGluZVtpXSA9PT0gMSkge1xuICAgICAgICAgICAgICAgIGN0eC5maWxsUmVjdChpLCAwLCAxLCAxMDApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcbn07XG5cbmV4cG9ydCBkZWZhdWx0IEJyZXNlbmhhbTtcbiIsIi8qIGVzbGludC1kaXNhYmxlIGltcG9ydC9uby1jeWNsZSAqL1xuXG5pbXBvcnQgSW1hZ2VEZWJ1ZyBmcm9tICcuLi9jb21tb24vaW1hZ2VfZGVidWcnO1xuaW1wb3J0IFR3b09mRml2ZVJlYWRlciBmcm9tICcuLi9yZWFkZXIvMm9mNV9yZWFkZXInO1xuaW1wb3J0IENvZGFiYXJSZWFkZXIgZnJvbSAnLi4vcmVhZGVyL2NvZGFiYXJfcmVhZGVyJztcbmltcG9ydCBDb2RlMTI4UmVhZGVyIGZyb20gJy4uL3JlYWRlci9jb2RlXzEyOF9yZWFkZXInO1xuaW1wb3J0IENvZGUzMlJlYWRlciBmcm9tICcuLi9yZWFkZXIvY29kZV8zMl9yZWFkZXInO1xuaW1wb3J0IENvZGUzOVJlYWRlciBmcm9tICcuLi9yZWFkZXIvY29kZV8zOV9yZWFkZXInO1xuaW1wb3J0IENvZGUzOVZJTlJlYWRlciBmcm9tICcuLi9yZWFkZXIvY29kZV8zOV92aW5fcmVhZGVyJztcbmltcG9ydCBDb2RlOTNSZWFkZXIgZnJvbSAnLi4vcmVhZGVyL2NvZGVfOTNfcmVhZGVyJztcbmltcG9ydCBFQU4yUmVhZGVyIGZyb20gJy4uL3JlYWRlci9lYW5fMl9yZWFkZXInO1xuaW1wb3J0IEVBTjVSZWFkZXIgZnJvbSAnLi4vcmVhZGVyL2Vhbl81X3JlYWRlcic7XG5pbXBvcnQgRUFOOFJlYWRlciBmcm9tICcuLi9yZWFkZXIvZWFuXzhfcmVhZGVyJztcbmltcG9ydCBFQU5SZWFkZXIgZnJvbSAnLi4vcmVhZGVyL2Vhbl9yZWFkZXInO1xuaW1wb3J0IEkyb2Y1UmVhZGVyIGZyb20gJy4uL3JlYWRlci9pMm9mNV9yZWFkZXInO1xuaW1wb3J0IFVQQ0VSZWFkZXIgZnJvbSAnLi4vcmVhZGVyL3VwY19lX3JlYWRlcic7XG5pbXBvcnQgVVBDUmVhZGVyIGZyb20gJy4uL3JlYWRlci91cGNfcmVhZGVyJztcbmltcG9ydCBCcmVzZW5oYW0gZnJvbSAnLi9icmVzZW5oYW0nO1xuXG5jb25zdCBSRUFERVJTID0ge1xuICAgIGNvZGVfMTI4X3JlYWRlcjogQ29kZTEyOFJlYWRlcixcbiAgICBlYW5fcmVhZGVyOiBFQU5SZWFkZXIsXG4gICAgZWFuXzVfcmVhZGVyOiBFQU41UmVhZGVyLFxuICAgIGVhbl8yX3JlYWRlcjogRUFOMlJlYWRlcixcbiAgICBlYW5fOF9yZWFkZXI6IEVBTjhSZWFkZXIsXG4gICAgY29kZV8zOV9yZWFkZXI6IENvZGUzOVJlYWRlcixcbiAgICBjb2RlXzM5X3Zpbl9yZWFkZXI6IENvZGUzOVZJTlJlYWRlcixcbiAgICBjb2RhYmFyX3JlYWRlcjogQ29kYWJhclJlYWRlcixcbiAgICB1cGNfcmVhZGVyOiBVUENSZWFkZXIsXG4gICAgdXBjX2VfcmVhZGVyOiBVUENFUmVhZGVyLFxuICAgIGkyb2Y1X3JlYWRlcjogSTJvZjVSZWFkZXIsXG4gICAgJzJvZjVfcmVhZGVyJzogVHdvT2ZGaXZlUmVhZGVyLFxuICAgIGNvZGVfOTNfcmVhZGVyOiBDb2RlOTNSZWFkZXIsXG4gICAgY29kZV8zMl9yZWFkZXI6IENvZGUzMlJlYWRlcixcbn07XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgICByZWdpc3RlclJlYWRlcjogKG5hbWUsIHJlYWRlcikgPT4ge1xuICAgICAgICBSRUFERVJTW25hbWVdID0gcmVhZGVyO1xuICAgIH0sXG4gICAgY3JlYXRlKGNvbmZpZywgaW5wdXRJbWFnZVdyYXBwZXIpIHtcbiAgICAgICAgY29uc3QgX2NhbnZhcyA9IHtcbiAgICAgICAgICAgIGN0eDoge1xuICAgICAgICAgICAgICAgIGZyZXF1ZW5jeTogbnVsbCxcbiAgICAgICAgICAgICAgICBwYXR0ZXJuOiBudWxsLFxuICAgICAgICAgICAgICAgIG92ZXJsYXk6IG51bGwsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZG9tOiB7XG4gICAgICAgICAgICAgICAgZnJlcXVlbmN5OiBudWxsLFxuICAgICAgICAgICAgICAgIHBhdHRlcm46IG51bGwsXG4gICAgICAgICAgICAgICAgb3ZlcmxheTogbnVsbCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IF9iYXJjb2RlUmVhZGVycyA9IFtdO1xuXG4gICAgICAgIGluaXRDYW52YXMoKTtcbiAgICAgICAgaW5pdFJlYWRlcnMoKTtcbiAgICAgICAgaW5pdENvbmZpZygpO1xuXG4gICAgICAgIGZ1bmN0aW9uIGluaXRDYW52YXMoKSB7XG4gICAgICAgICAgICBpZiAoRU5WLmRldmVsb3BtZW50ICYmIHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICBjb25zdCAkZGVidWcgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjZGVidWcuZGV0ZWN0aW9uJyk7XG4gICAgICAgICAgICAgICAgX2NhbnZhcy5kb20uZnJlcXVlbmN5ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignY2FudmFzLmZyZXF1ZW5jeScpO1xuICAgICAgICAgICAgICAgIGlmICghX2NhbnZhcy5kb20uZnJlcXVlbmN5KSB7XG4gICAgICAgICAgICAgICAgICAgIF9jYW52YXMuZG9tLmZyZXF1ZW5jeSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgICAgICAgICAgICAgICAgICBfY2FudmFzLmRvbS5mcmVxdWVuY3kuY2xhc3NOYW1lID0gJ2ZyZXF1ZW5jeSc7XG4gICAgICAgICAgICAgICAgICAgIGlmICgkZGVidWcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICRkZWJ1Zy5hcHBlbmRDaGlsZChfY2FudmFzLmRvbS5mcmVxdWVuY3kpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF9jYW52YXMuY3R4LmZyZXF1ZW5jeSA9IF9jYW52YXMuZG9tLmZyZXF1ZW5jeS5nZXRDb250ZXh0KCcyZCcpO1xuXG4gICAgICAgICAgICAgICAgX2NhbnZhcy5kb20ucGF0dGVybiA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ2NhbnZhcy5wYXR0ZXJuQnVmZmVyJyk7XG4gICAgICAgICAgICAgICAgaWYgKCFfY2FudmFzLmRvbS5wYXR0ZXJuKSB7XG4gICAgICAgICAgICAgICAgICAgIF9jYW52YXMuZG9tLnBhdHRlcm4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICAgICAgICAgICAgICAgICAgX2NhbnZhcy5kb20ucGF0dGVybi5jbGFzc05hbWUgPSAncGF0dGVybkJ1ZmZlcic7XG4gICAgICAgICAgICAgICAgICAgIGlmICgkZGVidWcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICRkZWJ1Zy5hcHBlbmRDaGlsZChfY2FudmFzLmRvbS5wYXR0ZXJuKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBfY2FudmFzLmN0eC5wYXR0ZXJuID0gX2NhbnZhcy5kb20ucGF0dGVybi5nZXRDb250ZXh0KCcyZCcpO1xuXG4gICAgICAgICAgICAgICAgX2NhbnZhcy5kb20ub3ZlcmxheSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ2NhbnZhcy5kcmF3aW5nQnVmZmVyJyk7XG4gICAgICAgICAgICAgICAgaWYgKF9jYW52YXMuZG9tLm92ZXJsYXkpIHtcbiAgICAgICAgICAgICAgICAgICAgX2NhbnZhcy5jdHgub3ZlcmxheSA9IF9jYW52YXMuZG9tLm92ZXJsYXkuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBpbml0UmVhZGVycygpIHtcbiAgICAgICAgICAgIGNvbmZpZy5yZWFkZXJzLmZvckVhY2goKHJlYWRlckNvbmZpZykgPT4ge1xuICAgICAgICAgICAgICAgIGxldCByZWFkZXI7XG4gICAgICAgICAgICAgICAgbGV0IGNvbmZpZ3VyYXRpb24gPSB7fTtcbiAgICAgICAgICAgICAgICBsZXQgc3VwcGxlbWVudHMgPSBbXTtcblxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcmVhZGVyQ29uZmlnID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgICAgICByZWFkZXIgPSByZWFkZXJDb25maWcuZm9ybWF0O1xuICAgICAgICAgICAgICAgICAgICBjb25maWd1cmF0aW9uID0gcmVhZGVyQ29uZmlnLmNvbmZpZztcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiByZWFkZXJDb25maWcgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlciA9IHJlYWRlckNvbmZpZztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKEVOVi5kZXZlbG9wbWVudCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnQmVmb3JlIHJlZ2lzdGVyaW5nIHJlYWRlcjogJywgcmVhZGVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGNvbmZpZ3VyYXRpb24uc3VwcGxlbWVudHMpIHtcbiAgICAgICAgICAgICAgICAgICAgc3VwcGxlbWVudHMgPSBjb25maWd1cmF0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAuc3VwcGxlbWVudHMubWFwKChzdXBwbGVtZW50KSA9PiBuZXcgUkVBREVSU1tzdXBwbGVtZW50XSgpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVhZGVyT2JqID0gbmV3IFJFQURFUlNbcmVhZGVyXShjb25maWd1cmF0aW9uLCBzdXBwbGVtZW50cyk7XG4gICAgICAgICAgICAgICAgICAgIF9iYXJjb2RlUmVhZGVycy5wdXNoKHJlYWRlck9iaik7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJyogRXJyb3IgY29uc3RydWN0aW5nIHJlYWRlciAnLCByZWFkZXIsIGVycik7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChFTlYuZGV2ZWxvcG1lbnQpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgUmVnaXN0ZXJlZCBSZWFkZXJzOiAke19iYXJjb2RlUmVhZGVyc1xuICAgICAgICAgICAgICAgICAgICAubWFwKChyZWFkZXIpID0+IEpTT04uc3RyaW5naWZ5KHsgZm9ybWF0OiByZWFkZXIuRk9STUFULCBjb25maWc6IHJlYWRlci5jb25maWcgfSkpXG4gICAgICAgICAgICAgICAgICAgIC5qb2luKCcsICcpfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gaW5pdENvbmZpZygpIHtcbiAgICAgICAgICAgIGlmIChFTlYuZGV2ZWxvcG1lbnQgJiYgdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIGxldCBpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHZpcyA9IFt7XG4gICAgICAgICAgICAgICAgICAgIG5vZGU6IF9jYW52YXMuZG9tLmZyZXF1ZW5jeSxcbiAgICAgICAgICAgICAgICAgICAgcHJvcDogY29uZmlnLmRlYnVnLnNob3dGcmVxdWVuY3ksXG4gICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICBub2RlOiBfY2FudmFzLmRvbS5wYXR0ZXJuLFxuICAgICAgICAgICAgICAgICAgICBwcm9wOiBjb25maWcuZGVidWcuc2hvd1BhdHRlcm4sXG4gICAgICAgICAgICAgICAgfV07XG5cbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdmlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2aXNbaV0ucHJvcCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmlzW2ldLm5vZGUuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2aXNbaV0ubm9kZS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIGV4dGVuZCB0aGUgbGluZSBvbiBib3RoIGVuZHNcbiAgICAgICAgICogQHBhcmFtIHtBcnJheX0gbGluZVxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gYW5nbGVcbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIGdldEV4dGVuZGVkTGluZShsaW5lLCBhbmdsZSwgZXh0KSB7XG4gICAgICAgICAgICBmdW5jdGlvbiBleHRlbmRMaW5lKGFtb3VudCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGV4dGVuc2lvbiA9IHtcbiAgICAgICAgICAgICAgICAgICAgeTogYW1vdW50ICogTWF0aC5zaW4oYW5nbGUpLFxuICAgICAgICAgICAgICAgICAgICB4OiBhbW91bnQgKiBNYXRoLmNvcyhhbmdsZSksXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1wYXJhbS1yZWFzc2lnbiAqL1xuICAgICAgICAgICAgICAgIGxpbmVbMF0ueSAtPSBleHRlbnNpb24ueTtcbiAgICAgICAgICAgICAgICBsaW5lWzBdLnggLT0gZXh0ZW5zaW9uLng7XG4gICAgICAgICAgICAgICAgbGluZVsxXS55ICs9IGV4dGVuc2lvbi55O1xuICAgICAgICAgICAgICAgIGxpbmVbMV0ueCArPSBleHRlbnNpb24ueDtcbiAgICAgICAgICAgICAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLXBhcmFtLXJlYXNzaWduICovXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGNoZWNrIGlmIGluc2lkZSBpbWFnZVxuICAgICAgICAgICAgZXh0ZW5kTGluZShleHQpO1xuICAgICAgICAgICAgd2hpbGUgKGV4dCA+IDEgJiYgKCFpbnB1dEltYWdlV3JhcHBlci5pbkltYWdlV2l0aEJvcmRlcihsaW5lWzBdKVxuICAgICAgICAgICAgICAgICAgICB8fCAhaW5wdXRJbWFnZVdyYXBwZXIuaW5JbWFnZVdpdGhCb3JkZXIobGluZVsxXSkpKSB7XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICAgICAgICAgICAgZXh0IC09IE1hdGguY2VpbChleHQgLyAyKTtcbiAgICAgICAgICAgICAgICBleHRlbmRMaW5lKC1leHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGxpbmU7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBnZXRMaW5lKGJveCkge1xuICAgICAgICAgICAgcmV0dXJuIFt7XG4gICAgICAgICAgICAgICAgeDogKGJveFsxXVswXSAtIGJveFswXVswXSkgLyAyICsgYm94WzBdWzBdLFxuICAgICAgICAgICAgICAgIHk6IChib3hbMV1bMV0gLSBib3hbMF1bMV0pIC8gMiArIGJveFswXVsxXSxcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICB4OiAoYm94WzNdWzBdIC0gYm94WzJdWzBdKSAvIDIgKyBib3hbMl1bMF0sXG4gICAgICAgICAgICAgICAgeTogKGJveFszXVsxXSAtIGJveFsyXVsxXSkgLyAyICsgYm94WzJdWzFdLFxuICAgICAgICAgICAgfV07XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiB0cnlEZWNvZGUobGluZSkge1xuICAgICAgICAgICAgbGV0IHJlc3VsdCA9IG51bGw7XG4gICAgICAgICAgICBsZXQgaTtcbiAgICAgICAgICAgIGNvbnN0IGJhcmNvZGVMaW5lID0gQnJlc2VuaGFtLmdldEJhcmNvZGVMaW5lKGlucHV0SW1hZ2VXcmFwcGVyLCBsaW5lWzBdLCBsaW5lWzFdKTtcblxuICAgICAgICAgICAgaWYgKEVOVi5kZXZlbG9wbWVudCAmJiBjb25maWcuZGVidWcuc2hvd0ZyZXF1ZW5jeSkge1xuICAgICAgICAgICAgICAgIEltYWdlRGVidWcuZHJhd1BhdGgobGluZSwgeyB4OiAneCcsIHk6ICd5JyB9LCBfY2FudmFzLmN0eC5vdmVybGF5LCB7IGNvbG9yOiAncmVkJywgbGluZVdpZHRoOiAzIH0pO1xuICAgICAgICAgICAgICAgIEJyZXNlbmhhbS5kZWJ1Zy5wcmludEZyZXF1ZW5jeShiYXJjb2RlTGluZS5saW5lLCBfY2FudmFzLmRvbS5mcmVxdWVuY3kpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBCcmVzZW5oYW0udG9CaW5hcnlMaW5lKGJhcmNvZGVMaW5lKTtcblxuICAgICAgICAgICAgaWYgKEVOVi5kZXZlbG9wbWVudCAmJiBjb25maWcuZGVidWcuc2hvd1BhdHRlcm4pIHtcbiAgICAgICAgICAgICAgICBCcmVzZW5oYW0uZGVidWcucHJpbnRQYXR0ZXJuKGJhcmNvZGVMaW5lLmxpbmUsIF9jYW52YXMuZG9tLnBhdHRlcm4pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgX2JhcmNvZGVSZWFkZXJzLmxlbmd0aCAmJiByZXN1bHQgPT09IG51bGw7IGkrKykge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IF9iYXJjb2RlUmVhZGVyc1tpXS5kZWNvZGVQYXR0ZXJuKGJhcmNvZGVMaW5lLmxpbmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlc3VsdCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBjb2RlUmVzdWx0OiByZXN1bHQsXG4gICAgICAgICAgICAgICAgYmFyY29kZUxpbmUsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoaXMgbWV0aG9kIHNsaWNlcyB0aGUgZ2l2ZW4gYXJlYSBhcGFydCBhbmQgdHJpZXMgdG8gZGV0ZWN0IGEgYmFyY29kZS1wYXR0ZXJuXG4gICAgICAgICAqIGZvciBlYWNoIHNsaWNlLiBJdCByZXR1cm5zIHRoZSBkZWNvZGVkIGJhcmNvZGUsIG9yIG51bGwgaWYgbm90aGluZyB3YXMgZm91bmRcbiAgICAgICAgICogQHBhcmFtIHtBcnJheX0gYm94XG4gICAgICAgICAqIEBwYXJhbSB7QXJyYXl9IGxpbmVcbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IGxpbmVBbmdsZVxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gdHJ5RGVjb2RlQnJ1dGVGb3JjZShib3gsIGxpbmUsIGxpbmVBbmdsZSkge1xuICAgICAgICAgICAgY29uc3Qgc2lkZUxlbmd0aCA9IE1hdGguc3FydChNYXRoLnBvdyhib3hbMV1bMF0gLSBib3hbMF1bMF0sIDIpICsgTWF0aC5wb3coKGJveFsxXVsxXSAtIGJveFswXVsxXSksIDIpKTtcbiAgICAgICAgICAgIGxldCBpO1xuICAgICAgICAgICAgY29uc3Qgc2xpY2VzID0gMTY7XG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gbnVsbDtcbiAgICAgICAgICAgIGxldCBkaXI7XG4gICAgICAgICAgICBsZXQgZXh0ZW5zaW9uO1xuICAgICAgICAgICAgY29uc3QgeGRpciA9IE1hdGguc2luKGxpbmVBbmdsZSk7XG4gICAgICAgICAgICBjb25zdCB5ZGlyID0gTWF0aC5jb3MobGluZUFuZ2xlKTtcblxuICAgICAgICAgICAgZm9yIChpID0gMTsgaSA8IHNsaWNlcyAmJiByZXN1bHQgPT09IG51bGw7IGkrKykge1xuICAgICAgICAgICAgICAgIC8vIG1vdmUgbGluZSBwZXJwZW5kaWN1bGFyIHRvIGFuZ2xlXG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLW1peGVkLW9wZXJhdG9yc1xuICAgICAgICAgICAgICAgIGRpciA9IHNpZGVMZW5ndGggLyBzbGljZXMgKiBpICogKGkgJSAyID09PSAwID8gLTEgOiAxKTtcbiAgICAgICAgICAgICAgICBleHRlbnNpb24gPSB7XG4gICAgICAgICAgICAgICAgICAgIHk6IGRpciAqIHhkaXIsXG4gICAgICAgICAgICAgICAgICAgIHg6IGRpciAqIHlkaXIsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1wYXJhbS1yZWFzc2lnbiAqL1xuICAgICAgICAgICAgICAgIGxpbmVbMF0ueSArPSBleHRlbnNpb24ueDtcbiAgICAgICAgICAgICAgICBsaW5lWzBdLnggLT0gZXh0ZW5zaW9uLnk7XG4gICAgICAgICAgICAgICAgbGluZVsxXS55ICs9IGV4dGVuc2lvbi54O1xuICAgICAgICAgICAgICAgIGxpbmVbMV0ueCAtPSBleHRlbnNpb24ueTtcbiAgICAgICAgICAgICAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLXBhcmFtLXJlYXNzaWduICovXG5cbiAgICAgICAgICAgICAgICByZXN1bHQgPSB0cnlEZWNvZGUobGluZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gZ2V0TGluZUxlbmd0aChsaW5lKSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5zcXJ0KFxuICAgICAgICAgICAgICAgIE1hdGgucG93KE1hdGguYWJzKGxpbmVbMV0ueSAtIGxpbmVbMF0ueSksIDIpXG4gICAgICAgICAgICAgICAgKyBNYXRoLnBvdyhNYXRoLmFicyhsaW5lWzFdLnggLSBsaW5lWzBdLngpLCAyKSxcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICBhc3luYyBmdW5jdGlvbiBkZWNvZGVGcm9tSW1hZ2UoaW1hZ2VXcmFwcGVyKSB7XG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gbnVsbDtcbiAgICAgICAgICAgIGZvciAoY29uc3QgcmVhZGVyIG9mIF9iYXJjb2RlUmVhZGVycykge1xuICAgICAgICAgICAgICAgIGlmIChyZWFkZXIuZGVjb2RlSW1hZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gYXdhaXQgcmVhZGVyLmRlY29kZUltYWdlKGltYWdlV3JhcHBlcik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogV2l0aCB0aGUgaGVscCBvZiB0aGUgY29uZmlndXJlZCByZWFkZXJzIChDb2RlMTI4IG9yIEVBTikgdGhpcyBmdW5jdGlvbiB0cmllcyB0byBkZXRlY3QgYVxuICAgICAgICAgKiB2YWxpZCBiYXJjb2RlIHBhdHRlcm4gd2l0aGluIHRoZSBnaXZlbiBhcmVhLlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gYm94IFRoZSBhcmVhIHRvIHNlYXJjaCBpblxuICAgICAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSB0aGUgcmVzdWx0IHtjb2RlUmVzdWx0LCBsaW5lLCBhbmdsZSwgcGF0dGVybiwgdGhyZXNob2xkfVxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gZGVjb2RlRnJvbUJvdW5kaW5nQm94KGJveCkge1xuICAgICAgICAgICAgbGV0IGxpbmU7XG4gICAgICAgICAgICBjb25zdCBjdHggPSBfY2FudmFzLmN0eC5vdmVybGF5O1xuICAgICAgICAgICAgbGV0IHJlc3VsdDtcblxuICAgICAgICAgICAgaWYgKEVOVi5kZXZlbG9wbWVudCkge1xuICAgICAgICAgICAgICAgIGlmIChjb25maWcuZGVidWcuZHJhd0JvdW5kaW5nQm94ICYmIGN0eCkge1xuICAgICAgICAgICAgICAgICAgICBJbWFnZURlYnVnLmRyYXdQYXRoKGJveCwgeyB4OiAwLCB5OiAxIH0sIGN0eCwgeyBjb2xvcjogJ2JsdWUnLCBsaW5lV2lkdGg6IDIgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsaW5lID0gZ2V0TGluZShib3gpO1xuICAgICAgICAgICAgY29uc3QgbGluZUxlbmd0aCA9IGdldExpbmVMZW5ndGgobGluZSk7XG4gICAgICAgICAgICBjb25zdCBsaW5lQW5nbGUgPSBNYXRoLmF0YW4yKGxpbmVbMV0ueSAtIGxpbmVbMF0ueSwgbGluZVsxXS54IC0gbGluZVswXS54KTtcbiAgICAgICAgICAgIGxpbmUgPSBnZXRFeHRlbmRlZExpbmUobGluZSwgbGluZUFuZ2xlLCBNYXRoLmZsb29yKGxpbmVMZW5ndGggKiAwLjEpKTtcbiAgICAgICAgICAgIGlmIChsaW5lID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJlc3VsdCA9IHRyeURlY29kZShsaW5lKTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSB0cnlEZWNvZGVCcnV0ZUZvcmNlKGJveCwgbGluZSwgbGluZUFuZ2xlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHJlc3VsdCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoRU5WLmRldmVsb3BtZW50ICYmIHJlc3VsdCAmJiBjb25maWcuZGVidWcuZHJhd1NjYW5saW5lICYmIGN0eCkge1xuICAgICAgICAgICAgICAgIEltYWdlRGVidWcuZHJhd1BhdGgobGluZSwgeyB4OiAneCcsIHk6ICd5JyB9LCBjdHgsIHsgY29sb3I6ICdyZWQnLCBsaW5lV2lkdGg6IDMgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgY29kZVJlc3VsdDogcmVzdWx0LmNvZGVSZXN1bHQsXG4gICAgICAgICAgICAgICAgbGluZSxcbiAgICAgICAgICAgICAgICBhbmdsZTogbGluZUFuZ2xlLFxuICAgICAgICAgICAgICAgIHBhdHRlcm46IHJlc3VsdC5iYXJjb2RlTGluZS5saW5lLFxuICAgICAgICAgICAgICAgIHRocmVzaG9sZDogcmVzdWx0LmJhcmNvZGVMaW5lLnRocmVzaG9sZCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZGVjb2RlRnJvbUJvdW5kaW5nQm94KGJveCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBkZWNvZGVGcm9tQm91bmRpbmdCb3goYm94KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkZWNvZGVGcm9tQm91bmRpbmdCb3hlcyhib3hlcykge1xuICAgICAgICAgICAgICAgIGxldCBpOyBsZXQgcmVzdWx0O1xuICAgICAgICAgICAgICAgIGNvbnN0IGJhcmNvZGVzID0gW107XG4gICAgICAgICAgICAgICAgY29uc3QgeyBtdWx0aXBsZSB9ID0gY29uZmlnO1xuXG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGJveGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGJveCA9IGJveGVzW2ldO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBkZWNvZGVGcm9tQm91bmRpbmdCb3goYm94KSB8fCB7fTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmJveCA9IGJveDtcblxuICAgICAgICAgICAgICAgICAgICBpZiAobXVsdGlwbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJhcmNvZGVzLnB1c2gocmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChyZXN1bHQuY29kZVJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGJhcmNvZGVzLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYXN5bmMgZGVjb2RlRnJvbUltYWdlKGltYWdlV3JhcHBlckluKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgZGVjb2RlRnJvbUltYWdlKGltYWdlV3JhcHBlckluKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJlZ2lzdGVyUmVhZGVyKG5hbWUsIHJlYWRlcikge1xuICAgICAgICAgICAgICAgIGlmIChSRUFERVJTW25hbWVdKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignY2Fubm90IHJlZ2lzdGVyIGV4aXN0aW5nIHJlYWRlcicsIG5hbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBSRUFERVJTW25hbWVdID0gcmVhZGVyO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNldFJlYWRlcnMocmVhZGVycykge1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgICAgICAgICAgIGNvbmZpZy5yZWFkZXJzID0gcmVhZGVycztcbiAgICAgICAgICAgICAgICBfYmFyY29kZVJlYWRlcnMubGVuZ3RoID0gMDtcbiAgICAgICAgICAgICAgICBpbml0UmVhZGVycygpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9LFxufTtcbiIsImltcG9ydCBCYXJjb2RlUmVhZGVyIGZyb20gJy4vYmFyY29kZV9yZWFkZXInO1xuaW1wb3J0IFR3b09mRml2ZVJlYWRlciBmcm9tICcuLzJvZjVfcmVhZGVyJztcbmltcG9ydCBOZXdDb2RhYmFyUmVhZGVyIGZyb20gJy4vY29kYWJhcl9yZWFkZXInO1xuaW1wb3J0IENvZGUxMjhSZWFkZXIgZnJvbSAnLi9jb2RlXzEyOF9yZWFkZXInO1xuaW1wb3J0IENvZGUzMlJlYWRlciBmcm9tICcuL2NvZGVfMzJfcmVhZGVyJztcbmltcG9ydCBDb2RlMzlSZWFkZXIgZnJvbSAnLi9jb2RlXzM5X3JlYWRlcic7XG5pbXBvcnQgQ29kZTM5VklOUmVhZGVyIGZyb20gJy4vY29kZV8zOV92aW5fcmVhZGVyJztcbmltcG9ydCBDb2RlOTNSZWFkZXIgZnJvbSAnLi9jb2RlXzkzX3JlYWRlcic7XG5pbXBvcnQgRUFOMlJlYWRlciBmcm9tICcuL2Vhbl8yX3JlYWRlcic7XG5pbXBvcnQgRUFONVJlYWRlciBmcm9tICcuL2Vhbl81X3JlYWRlcic7XG5pbXBvcnQgRUFOOFJlYWRlciBmcm9tICcuL2Vhbl84X3JlYWRlcic7XG5pbXBvcnQgRUFOUmVhZGVyIGZyb20gJy4vZWFuX3JlYWRlcic7XG5pbXBvcnQgSTJvZjVSZWFkZXIgZnJvbSAnLi9pMm9mNV9yZWFkZXInO1xuaW1wb3J0IFVQQ0VSZWFkZXIgZnJvbSAnLi91cGNfZV9yZWFkZXInO1xuaW1wb3J0IFVQQ1JlYWRlciBmcm9tICcuL3VwY19yZWFkZXInO1xuXG5leHBvcnQge1xuICAgIEJhcmNvZGVSZWFkZXIsXG4gICAgVHdvT2ZGaXZlUmVhZGVyLFxuICAgIE5ld0NvZGFiYXJSZWFkZXIsXG4gICAgQ29kZTEyOFJlYWRlcixcbiAgICBDb2RlMzJSZWFkZXIsXG4gICAgQ29kZTM5UmVhZGVyLFxuICAgIENvZGUzOVZJTlJlYWRlcixcbiAgICBDb2RlOTNSZWFkZXIsXG4gICAgRUFOMlJlYWRlcixcbiAgICBFQU41UmVhZGVyLFxuICAgIEVBTjhSZWFkZXIsXG4gICAgRUFOUmVhZGVyLFxuICAgIEkyb2Y1UmVhZGVyLFxuICAgIFVQQ0VSZWFkZXIsXG4gICAgVVBDUmVhZGVyLCAgICBcbn1cbiIsInR5cGUgRXZlbnROYW1lID0gc3RyaW5nO1xuXG5pbnRlcmZhY2UgU3Vic2NyaXB0aW9uIHtcbiAgICBhc3luYz86IGJvb2xlYW47XG4gICAgY2FsbGJhY2s6IEZ1bmN0aW9uO1xuICAgIG9uY2U/OiBib29sZWFuO1xufVxuXG5pbnRlcmZhY2UgRXZlbnREYXRhIHtcbiAgICBzdWJzY3JpYmVyczogQXJyYXk8U3Vic2NyaXB0aW9uPjtcbn1cblxuaW50ZXJmYWNlIEV2ZW50cyB7XG4gICAgW2tleTogc3RyaW5nXTogRXZlbnREYXRhO1xufVxuXG5pbnRlcmZhY2UgRXZlbnRJbnRlcmZhY2Uge1xuICAgIHN1YnNjcmliZShldmVudDogRXZlbnROYW1lLCBjYWxsYmFjazogRnVuY3Rpb24gfCBTdWJzY3JpcHRpb24sIGFzeW5jPzogYm9vbGVhbik6IHZvaWQ7XG4gICAgcHVibGlzaChldmVudE5hbWU6IEV2ZW50TmFtZSwgZGF0YT86IG5ldmVyKTogdm9pZDtcbiAgICBvbmNlKGV2ZW50OiBFdmVudE5hbWUsIGNhbGxiYWNrOiBGdW5jdGlvbiwgYXN5bmM/OiBib29sZWFuKTogdm9pZDtcbiAgICB1bnN1YnNjcmliZShldmVudE5hbWU/OiBFdmVudE5hbWUsIGNhbGxiYWNrPzogRnVuY3Rpb24gfCBTdWJzY3JpcHRpb24pOiB2b2lkO1xufVxuXG5leHBvcnQgZGVmYXVsdCAoZnVuY3Rpb24gRXZlbnRJbnRlcmZhY2UoKTogRXZlbnRJbnRlcmZhY2Uge1xuICAgIGxldCBldmVudHM6IEV2ZW50cyA9IHt9O1xuXG4gICAgZnVuY3Rpb24gZ2V0RXZlbnQoZXZlbnROYW1lOiBFdmVudE5hbWUpOiBFdmVudERhdGEge1xuICAgICAgICBpZiAoIWV2ZW50c1tldmVudE5hbWVdKSB7XG4gICAgICAgICAgICBldmVudHNbZXZlbnROYW1lXSA9IHtcbiAgICAgICAgICAgICAgICBzdWJzY3JpYmVyczogW10sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBldmVudHNbZXZlbnROYW1lXTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjbGVhckV2ZW50cygpOiB2b2lkIHtcbiAgICAgICAgZXZlbnRzID0ge307XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcHVibGlzaFN1YnNjcmlwdGlvbihzdWJzY3JpcHRpb246IFN1YnNjcmlwdGlvbiwgZGF0YTogbmV2ZXIpOiB2b2lkIHtcbiAgICAgICAgaWYgKHN1YnNjcmlwdGlvbi5hc3luYykge1xuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgc3Vic2NyaXB0aW9uLmNhbGxiYWNrKGRhdGEpO1xuICAgICAgICAgICAgfSwgNCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdWJzY3JpcHRpb24uY2FsbGJhY2soZGF0YSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfc3Vic2NyaWJlKGV2ZW50OiBFdmVudE5hbWUsIGNhbGxiYWNrOiBGdW5jdGlvbiB8IFN1YnNjcmlwdGlvbiwgYXN5bmM/OiBib29sZWFuKTogdm9pZCB7XG4gICAgICAgIGxldCBzdWJzY3JpcHRpb247XG5cbiAgICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgc3Vic2NyaXB0aW9uID0ge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrLFxuICAgICAgICAgICAgICAgIGFzeW5jLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN1YnNjcmlwdGlvbiA9IGNhbGxiYWNrO1xuICAgICAgICAgICAgaWYgKCFzdWJzY3JpcHRpb24uY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NhbGxiYWNrIHdhcyBub3Qgc3BlY2lmaWVkIG9uIG9wdGlvbnMnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGdldEV2ZW50KGV2ZW50KS5zdWJzY3JpYmVycy5wdXNoKHN1YnNjcmlwdGlvbik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgc3Vic2NyaWJlKGV2ZW50OiBFdmVudE5hbWUsIGNhbGxiYWNrOiBGdW5jdGlvbiB8IFN1YnNjcmlwdGlvbiwgYXN5bmM/OiBib29sZWFuKTogdm9pZCB7XG4gICAgICAgICAgICByZXR1cm4gX3N1YnNjcmliZShldmVudCwgY2FsbGJhY2ssIGFzeW5jKTtcbiAgICAgICAgfSxcbiAgICAgICAgcHVibGlzaChldmVudE5hbWU6IEV2ZW50TmFtZSwgZGF0YT86IG5ldmVyKTogdm9pZCB7XG4gICAgICAgICAgICBjb25zdCBldmVudCA9IGdldEV2ZW50KGV2ZW50TmFtZSk7XG4gICAgICAgICAgICBjb25zdCB7IHN1YnNjcmliZXJzIH0gPSBldmVudDtcblxuICAgICAgICAgICAgLy8gUHVibGlzaCBvbmUtdGltZSBzdWJzY3JpcHRpb25zXG4gICAgICAgICAgICBzdWJzY3JpYmVycy5maWx0ZXIoKHN1YnNjcmliZXIpID0+ICEhc3Vic2NyaWJlci5vbmNlKS5mb3JFYWNoKChzdWJzY3JpYmVyKSA9PiB7XG4gICAgICAgICAgICAgICAgcHVibGlzaFN1YnNjcmlwdGlvbihzdWJzY3JpYmVyLCBkYXRhIGFzIG5ldmVyKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyByZW1vdmUgdGhlbSBmcm9tIHRoZSBzdWJzY3JpYmVyXG4gICAgICAgICAgICBldmVudC5zdWJzY3JpYmVycyA9IHN1YnNjcmliZXJzLmZpbHRlcigoc3Vic2NyaWJlcikgPT4gIXN1YnNjcmliZXIub25jZSk7XG5cbiAgICAgICAgICAgIC8vIHB1Ymxpc2ggdGhlIHJlc3RcbiAgICAgICAgICAgIGV2ZW50LnN1YnNjcmliZXJzLmZvckVhY2goKHN1YnNjcmliZXIpID0+IHtcbiAgICAgICAgICAgICAgICBwdWJsaXNoU3Vic2NyaXB0aW9uKHN1YnNjcmliZXIsIGRhdGEgYXMgbmV2ZXIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uY2UoZXZlbnQ6IEV2ZW50TmFtZSwgY2FsbGJhY2s6IEZ1bmN0aW9uLCBhc3luYyA9IGZhbHNlKTogdm9pZCB7XG4gICAgICAgICAgICBfc3Vic2NyaWJlKGV2ZW50LCB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2ssXG4gICAgICAgICAgICAgICAgYXN5bmMsXG4gICAgICAgICAgICAgICAgb25jZTogdHJ1ZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICB1bnN1YnNjcmliZShldmVudE5hbWU/OiBFdmVudE5hbWUsIGNhbGxiYWNrPzogRnVuY3Rpb24gfCBTdWJzY3JpcHRpb24pOiB2b2lkIHtcbiAgICAgICAgICAgIGlmIChldmVudE5hbWUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBldmVudCA9IGdldEV2ZW50KGV2ZW50TmFtZSk7XG4gICAgICAgICAgICAgICAgaWYgKGV2ZW50ICYmIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50LnN1YnNjcmliZXJzID0gZXZlbnQuc3Vic2NyaWJlcnMuZmlsdGVyKChzdWJzY3JpYmVyKSA9PiBzdWJzY3JpYmVyLmNhbGxiYWNrICE9PSBjYWxsYmFjayk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQuc3Vic2NyaWJlcnMgPSBbXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNsZWFyRXZlbnRzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgfTtcbn0oKSk7XG4iLCJleHBvcnQgZGVmYXVsdCBjbGFzcyBFeGNlcHRpb24gZXh0ZW5kcyBFcnJvciB7XG4gICAgY29kZT86IG51bWJlcjtcblxuICAgIGNvbnN0cnVjdG9yKG06IHN0cmluZywgY29kZT86IG51bWJlcikge1xuICAgICAgICBzdXBlcihtKTtcbiAgICAgICAgdGhpcy5jb2RlID0gY29kZTtcbiAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKHRoaXMsIEV4Y2VwdGlvbi5wcm90b3R5cGUpO1xuICAgIH1cbn1cbiIsImltcG9ydCBFeGNlcHRpb24gZnJvbSAnLi4vcXVhZ2dhL0V4Y2VwdGlvbic7XG5cbmNvbnN0IEVSUk9SX0RFU0MgPSAnVGhpcyBtYXkgbWVhbiB0aGF0IHRoZSB1c2VyIGhhcyBkZWNsaW5lZCBjYW1lcmEgYWNjZXNzLCBvciB0aGUgYnJvd3NlciBkb2VzIG5vdCBzdXBwb3J0IG1lZGlhIEFQSXMuIElmIHlvdSBhcmUgcnVubmluZyBpbiBpT1MsIHlvdSBtdXN0IHVzZSBTYWZhcmkuJztcblxuZXhwb3J0IGZ1bmN0aW9uIGVudW1lcmF0ZURldmljZXMoKTogUHJvbWlzZTxBcnJheTxNZWRpYURldmljZUluZm8+PiB7XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIG5hdmlnYXRvci5tZWRpYURldmljZXMuZW51bWVyYXRlRGV2aWNlcygpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBjb25zdCBlcnJvcjogRXJyb3IgPSBuZXcgRXhjZXB0aW9uKGBlbnVtZXJhdGVEZXZpY2VzIGlzIG5vdCBkZWZpbmVkLiAke0VSUk9SX0RFU0N9YCwgLTEpO1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyb3IpO1xuICAgIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFVzZXJNZWRpYShjb25zdHJhaW50czogTWVkaWFTdHJlYW1Db25zdHJhaW50cyk6IFByb21pc2U8TWVkaWFTdHJlYW0+IHtcbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXRVc2VyTWVkaWEoY29uc3RyYWludHMpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBjb25zdCBlcnJvcjogRXJyb3IgPSBuZXcgRXhjZXB0aW9uKGBnZXRVc2VyTWVkaWEgaXMgbm90IGRlZmluZWQuICR7RVJST1JfREVTQ31gLCAtMSk7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnJvcik7XG4gICAgfVxufVxuIiwiLy8gVE9ETzogd2hlbiB0aGlzIGZpbGUgd2FzIHdyaXR0ZW4geWVhcnMgYWdvLCBIVE1MTWVkaWFFbGVtZW50LnBsYXkoKSBkaWQgbm90IHJldHVybiBhIHVzZWZ1bCB2YWx1ZVxuLy8gdG8gbGV0IHVzIGtub3cgd2hlbiB0aGUgdmlkZW8gc3RhcnRlZCBwbGF5aW5nLiAgTm93LCBpdCBkb2VzLiAgU28sIHdlIHNob3VsZG4ndCBuZWVkIHRvIHJ1biB0aGlzXG4vLyBvZGQgd2FpdEZvclZpZGVvKCkgZnVuY3Rpb24gdGhhdCBwb2xscyB0byBzZWUgaWYgdGhlIHZpZGVvIGhhcyBzdGFydGVkLlxuaW1wb3J0IHBpY2sgZnJvbSAnbG9kYXNoL3BpY2snO1xuaW1wb3J0IHsgZ2V0VXNlck1lZGlhLCBlbnVtZXJhdGVEZXZpY2VzIH0gZnJvbSAnLi4vY29tbW9uL21lZGlhRGV2aWNlcyc7XG5pbXBvcnQgRXhjZXB0aW9uIGZyb20gJy4uL3F1YWdnYS9FeGNlcHRpb24nO1xuaW1wb3J0IHR5cGUge1xuICAgIE1lZGlhVHJhY2tDb25zdHJhaW50c1dpdGhEZXByZWNhdGVkLFxuICAgIFF1YWdnYUpTQ2FtZXJhQWNjZXNzIGFzIENhbWVyYUFjY2Vzc1R5cGUsXG59IGZyb20gJy4uLy4uL3R5cGUtZGVmaW5pdGlvbnMvcXVhZ2dhLmQnO1xuXG5sZXQgc3RyZWFtUmVmOiBNZWRpYVN0cmVhbSB8IG51bGw7XG5cbmZ1bmN0aW9uIHdhaXRGb3JWaWRlbyh2aWRlbzogSFRNTFZpZGVvRWxlbWVudCk6IFByb21pc2U8dm9pZD4ge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIGxldCBhdHRlbXB0cyA9IDEwO1xuXG4gICAgICAgIGZ1bmN0aW9uIGNoZWNrVmlkZW8oKTogdm9pZCB7XG4gICAgICAgICAgICBpZiAoYXR0ZW1wdHMgPiAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKHZpZGVvLnZpZGVvV2lkdGggPiAxMCAmJiB2aWRlby52aWRlb0hlaWdodCA+IDEwKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChFTlYuZGV2ZWxvcG1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGAqIGRldjogY2hlY2tWaWRlbyBmb3VuZCAke3ZpZGVvLnZpZGVvV2lkdGh9cHggeCAke3ZpZGVvLnZpZGVvSGVpZ2h0fXB4YCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHdpbmRvdy5zZXRUaW1lb3V0KGNoZWNrVmlkZW8sIDUwMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZWplY3QobmV3IEV4Y2VwdGlvbignVW5hYmxlIHRvIHBsYXkgdmlkZW8gc3RyZWFtLiBJcyB3ZWJjYW0gd29ya2luZz8nLCAtMSkpOyAvLyBUT0RPOiBhZGQgZXJyb3IgY29kZVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXR0ZW1wdHMtLTtcbiAgICAgICAgfVxuICAgICAgICBjaGVja1ZpZGVvKCk7XG4gICAgfSk7XG59XG5cbi8qKlxuICogVHJpZXMgdG8gYXR0YWNoIHRoZSBjYW1lcmEtc3RyZWFtIHRvIGEgZ2l2ZW4gdmlkZW8tZWxlbWVudFxuICogYW5kIGNhbGxzIHRoZSBjYWxsYmFjayBmdW5jdGlvbiB3aGVuIHRoZSBjb250ZW50IGlzIHJlYWR5XG4gKiBAcGFyYW0ge09iamVjdH0gY29uc3RyYWludHNcbiAqIEBwYXJhbSB7T2JqZWN0fSB2aWRlb1xuICovXG5hc3luYyBmdW5jdGlvbiBpbml0Q2FtZXJhKHZpZGVvOiBIVE1MVmlkZW9FbGVtZW50IHwgbnVsbCwgY29uc3RyYWludHM6IE1lZGlhU3RyZWFtQ29uc3RyYWludHMpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBjb25zdCBzdHJlYW0gPSBhd2FpdCBnZXRVc2VyTWVkaWEoY29uc3RyYWludHMpO1xuICAgIHN0cmVhbVJlZiA9IHN0cmVhbTtcbiAgICBpZiAodmlkZW8pIHtcbiAgICAgICAgdmlkZW8uc2V0QXR0cmlidXRlKCdhdXRvcGxheScsICd0cnVlJyk7XG4gICAgICAgIHZpZGVvLnNldEF0dHJpYnV0ZSgnbXV0ZWQnLCAndHJ1ZScpO1xuICAgICAgICB2aWRlby5zZXRBdHRyaWJ1dGUoJ3BsYXlzaW5saW5lJywgJ3RydWUnKTsgLy8gbm90IGxpc3RlZCBvbiBNRE4uLi5cbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICAgIHZpZGVvLnNyY09iamVjdCA9IHN0cmVhbTtcbiAgICAgICAgdmlkZW8uYWRkRXZlbnRMaXN0ZW5lcignbG9hZGVkbWV0YWRhdGEnLCAoKSA9PiB7XG4gICAgICAgICAgICB2aWRlby5wbGF5KCkuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignKiBFcnJvciB3aGlsZSB0cnlpbmcgdG8gcGxheSB2aWRlbyBzdHJlYW06JywgZXJyKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHdhaXRGb3JWaWRlbyh2aWRlbyk7XG4gICAgfVxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbn1cblxuZnVuY3Rpb24gZGVwcmVjYXRlZENvbnN0cmFpbnRzKHZpZGVvQ29uc3RyYWludHM6IE1lZGlhVHJhY2tDb25zdHJhaW50c1dpdGhEZXByZWNhdGVkKTogTWVkaWFUcmFja0NvbnN0cmFpbnRzIHtcbiAgICBjb25zdCBub3JtYWxpemVkID0gcGljayh2aWRlb0NvbnN0cmFpbnRzLCBbJ3dpZHRoJywgJ2hlaWdodCcsICdmYWNpbmdNb2RlJyxcbiAgICAgICAgJ2FzcGVjdFJhdGlvJywgJ2RldmljZUlkJ10pO1xuXG4gICAgaWYgKHR5cGVvZiB2aWRlb0NvbnN0cmFpbnRzLm1pbkFzcGVjdFJhdGlvICE9PSAndW5kZWZpbmVkJ1xuICAgICAgICAgICAgJiYgdmlkZW9Db25zdHJhaW50cy5taW5Bc3BlY3RSYXRpbyA+IDApIHtcbiAgICAgICAgbm9ybWFsaXplZC5hc3BlY3RSYXRpbyA9IHZpZGVvQ29uc3RyYWludHMubWluQXNwZWN0UmF0aW87XG4gICAgICAgIGNvbnNvbGUubG9nKCdXQVJOSU5HOiBDb25zdHJhaW50IFxcJ21pbkFzcGVjdFJhdGlvXFwnIGlzIGRlcHJlY2F0ZWQ7IFVzZSBcXCdhc3BlY3RSYXRpb1xcJyBpbnN0ZWFkJyk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgdmlkZW9Db25zdHJhaW50cy5mYWNpbmcgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIG5vcm1hbGl6ZWQuZmFjaW5nTW9kZSA9IHZpZGVvQ29uc3RyYWludHMuZmFjaW5nO1xuICAgICAgICBjb25zb2xlLmxvZygnV0FSTklORzogQ29uc3RyYWludCBcXCdmYWNpbmdcXCcgaXMgZGVwcmVjYXRlZC4gVXNlIFxcJ2ZhY2luZ01vZGVcXCcgaW5zdGVhZFxcJycpO1xuICAgIH1cbiAgICByZXR1cm4gbm9ybWFsaXplZDtcbn1cblxuLy8gVE9ETzogIzE5MiBJIGRvbid0IHRoaW5rIHRoZXJlJ3MgYW55IGdvb2QgcmVhc29uIHBpY2tDb25zdHJhaW50cyBzaG91bGQgcmV0dXJuIGEgUHJvbWlzZSxcbi8vIEkgdGhpbmsgaXQgd2FzIGp1c3QgdGhhdCB3YXkgc28gaXQgY291bGQgYmUgY2hhaW5lZCB0byBvdGhlciBmdW5jdGlvbnMgdGhhdCBkaWQgcmV0dXJuIGEgUHJvbWlzZS5cbi8vIFRoYXQncyBub3QgbmVjZXNzYXJ5IHdpdGggYXN5bmMgZnVuY3Rpb25zIGJlaW5nIGEgdGhpbmcsIHNvIHRoYXQgc2hvdWxkIGJlIGZpeGVkLlxuZXhwb3J0IGZ1bmN0aW9uIHBpY2tDb25zdHJhaW50cyh2aWRlb0NvbnN0cmFpbnRzOiBNZWRpYVRyYWNrQ29uc3RyYWludHNXaXRoRGVwcmVjYXRlZCA9IHt9KTogUHJvbWlzZTxNZWRpYVN0cmVhbUNvbnN0cmFpbnRzPiB7XG4gICAgY29uc3QgdmlkZW8gPSBkZXByZWNhdGVkQ29uc3RyYWludHModmlkZW9Db25zdHJhaW50cyk7XG5cbiAgICBpZiAodmlkZW8gJiYgdmlkZW8uZGV2aWNlSWQgJiYgdmlkZW8uZmFjaW5nTW9kZSkge1xuICAgICAgICBkZWxldGUgdmlkZW8uZmFjaW5nTW9kZTtcbiAgICB9XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7IGF1ZGlvOiBmYWxzZSwgdmlkZW8gfSk7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGVudW1lcmF0ZVZpZGVvRGV2aWNlcygpOiBQcm9taXNlPEFycmF5PE1lZGlhRGV2aWNlSW5mbz4+IHtcbiAgICBjb25zdCBkZXZpY2VzID0gYXdhaXQgZW51bWVyYXRlRGV2aWNlcygpO1xuICAgIHJldHVybiBkZXZpY2VzLmZpbHRlcigoZGV2aWNlOiBNZWRpYURldmljZUluZm8pID0+IGRldmljZS5raW5kID09PSAndmlkZW9pbnB1dCcpO1xufVxuXG5mdW5jdGlvbiBnZXRBY3RpdmVUcmFjaygpOiBNZWRpYVN0cmVhbVRyYWNrIHwgbnVsbCB7XG4gICAgaWYgKCFzdHJlYW1SZWYpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IHRyYWNrcyA9IHN0cmVhbVJlZi5nZXRWaWRlb1RyYWNrcygpO1xuICAgIHJldHVybiB0cmFja3MgJiYgdHJhY2tzPy5sZW5ndGggPyB0cmFja3NbMF0gOiBudWxsO1xufVxuXG4vKipcbiAqIFVzZWQgZm9yIGFjY2Vzc2luZyBpbmZvcm1hdGlvbiBhYm91dCB0aGUgYWN0aXZlIHN0cmVhbSB0cmFjayBhbmQgYXZhaWxhYmxlIHZpZGVvIGRldmljZXMuXG4gKi9cbmNvbnN0IFF1YWdnYUpTQ2FtZXJhQWNjZXNzOiBDYW1lcmFBY2Nlc3NUeXBlID0ge1xuICAgIHJlcXVlc3RlZFZpZGVvRWxlbWVudDogbnVsbCxcbiAgICBhc3luYyByZXF1ZXN0KHZpZGVvOiBIVE1MVmlkZW9FbGVtZW50IHwgbnVsbCwgdmlkZW9Db25zdHJhaW50cz86IE1lZGlhVHJhY2tDb25zdHJhaW50c1dpdGhEZXByZWNhdGVkKTogUHJvbWlzZTxhbnk+IHtcbiAgICAgICAgUXVhZ2dhSlNDYW1lcmFBY2Nlc3MucmVxdWVzdGVkVmlkZW9FbGVtZW50ID0gdmlkZW87XG4gICAgICAgIGNvbnN0IG5ld0NvbnN0cmFpbnRzID0gYXdhaXQgcGlja0NvbnN0cmFpbnRzKHZpZGVvQ29uc3RyYWludHMpO1xuICAgICAgICByZXR1cm4gaW5pdENhbWVyYSh2aWRlbywgbmV3Q29uc3RyYWludHMpO1xuICAgIH0sXG4gICAgcmVsZWFzZSgpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAgICAgY29uc3QgdHJhY2tzID0gc3RyZWFtUmVmICYmIHN0cmVhbVJlZi5nZXRWaWRlb1RyYWNrcygpO1xuICAgICAgICBpZiAoUXVhZ2dhSlNDYW1lcmFBY2Nlc3MucmVxdWVzdGVkVmlkZW9FbGVtZW50ICE9PSBudWxsKSB7XG4gICAgICAgICAgICBRdWFnZ2FKU0NhbWVyYUFjY2Vzcy5yZXF1ZXN0ZWRWaWRlb0VsZW1lbnQucGF1c2UoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2U8dm9pZD4oKHJlc29sdmUpID0+IHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0cmFja3MgJiYgdHJhY2tzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICB0cmFja3MuZm9yRWFjaCgodHJhY2spID0+IHRyYWNrLnN0b3AoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHN0cmVhbVJlZiA9IG51bGw7XG4gICAgICAgICAgICAgICAgUXVhZ2dhSlNDYW1lcmFBY2Nlc3MucmVxdWVzdGVkVmlkZW9FbGVtZW50ID0gbnVsbDtcbiAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICB9LCAwKTtcbiAgICAgICAgfSk7XG4gICAgfSxcbiAgICBlbnVtZXJhdGVWaWRlb0RldmljZXMsXG4gICAgZ2V0QWN0aXZlU3RyZWFtTGFiZWwoKTogc3RyaW5nIHtcbiAgICAgICAgY29uc3QgdHJhY2sgPSBnZXRBY3RpdmVUcmFjaygpO1xuICAgICAgICByZXR1cm4gdHJhY2sgPyB0cmFjay5sYWJlbCA6ICcnO1xuICAgIH0sXG4gICAgZ2V0QWN0aXZlVHJhY2ssXG4gICAgYXN5bmMgZGlzYWJsZVRvcmNoKCkge1xuICAgICAgICBjb25zdCB0cmFjayA9IGdldEFjdGl2ZVRyYWNrKCk7XG4gICAgICAgIC8vIFRPRE86IHNob3VsZCB3ZSBhY3F1aXJlIGNhbWVyYSBhY2Nlc3MgZXZlbiBpZiB0aGVyZSdzIG5vIGN1cnJlbnQgY2FtZXJhIG9wZW4/XG4gICAgICAgIC8vIFRPRE86IHdoYXQgaGFwcGVucyBvbiBpT1Mgb3IgYW5vdGhlciBkZXZpY2Ugd2hlcmUgdG9yY2ggaXNuJ3Qgc3VwcG9ydGVkIGF0IGFsbD8gU2hvdWxkIHdlIHRocm93IGFuIGVycm9yP1xuICAgICAgICBpZiAodHJhY2spIHtcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmUgLy8gdHlwZXNjcmlwdCBkb2Vzbid0IGtub3cgdGhlIHRvcmNoIHByb3BlcnR5XG4gICAgICAgICAgICBhd2FpdCB0cmFjay5hcHBseUNvbnN0cmFpbnRzKHsgdG9yY2g6IGZhbHNlIH0pO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBhc3luYyBlbmFibGVUb3JjaCgpIHtcbiAgICAgICAgY29uc3QgdHJhY2sgPSBnZXRBY3RpdmVUcmFjaygpO1xuICAgICAgICAvLyBUT0RPOiBzaG91bGQgd2UgYWNxdWlyZSBjYW1lcmEgYWNjZXNzIGV2ZW4gaWYgdGhlcmUncyBubyBjdXJyZW50IGNhbWVyYSBvcGVuP1xuICAgICAgICAvLyBUT0RPOiB3aGF0IGhhcHBlbnMgb24gaU9TIG9yIGFub3RoZXIgZGV2aWNlIHdoZXJlIHRvcmNoIGlzbid0IHN1cHBvcnRlZCBhdCBhbGw/IFNob3VsZCB3ZSB0aHJvdyBhbiBlcnJvcj9cbiAgICAgICAgaWYgKHRyYWNrKSB7XG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlIC8vIHR5cGVzY3JpcHQgZG9lc24ndCBrbm93IHRoZSB0b3JjaCBwcm9wZXJ0eVxuICAgICAgICAgICAgYXdhaXQgdHJhY2suYXBwbHlDb25zdHJhaW50cyh7IHRvcmNoOiB0cnVlIH0pO1xuICAgICAgICB9XG4gICAgfSxcbn07XG5cbmV4cG9ydCBkZWZhdWx0IFF1YWdnYUpTQ2FtZXJhQWNjZXNzO1xuIiwiaW1wb3J0IEltYWdlRGVidWcgZnJvbSAnLi4vY29tbW9uL2ltYWdlX2RlYnVnJztcbmltcG9ydCB7XG4gICAgUXVhZ2dhSlNDb2RlUmVzdWx0LFxuICAgIFF1YWdnYUpTUmVzdWx0Q29sbGVjdG9yLFxuICAgIFF1YWdnYUpTUmVzdWx0Q29sbGVjdG9yRmlsdGVyRnVuY3Rpb24sXG4gICAgWFlTaXplLFxuICAgIFF1YWdnYUltYWdlRGF0YSxcbn0gZnJvbSAnLi4vLi4vdHlwZS1kZWZpbml0aW9ucy9xdWFnZ2EuZCc7XG5cbmZ1bmN0aW9uIGNvbnRhaW5zKGNvZGVSZXN1bHQ6IFF1YWdnYUpTQ29kZVJlc3VsdCwgbGlzdDogQXJyYXk8UXVhZ2dhSlNDb2RlUmVzdWx0Pik6IGJvb2xlYW4ge1xuICAgIHJldHVybiBsaXN0ICYmIGxpc3Quc29tZSgoaXRlbSkgPT4ge1xuICAgICAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoaXRlbSkgYXMgQXJyYXk8a2V5b2YgUXVhZ2dhSlNDb2RlUmVzdWx0PjtcbiAgICAgICAgcmV0dXJuIGtleXMuZXZlcnkoKGtleSkgPT4gaXRlbVtrZXldID09PSBjb2RlUmVzdWx0W2tleV0pO1xuICAgIH0pO1xufVxuXG5mdW5jdGlvbiBwYXNzZXNGaWx0ZXIoXG4gICAgY29kZVJlc3VsdDogUXVhZ2dhSlNDb2RlUmVzdWx0LFxuICAgIGZpbHRlcjogUXVhZ2dhSlNSZXN1bHRDb2xsZWN0b3JGaWx0ZXJGdW5jdGlvbiB8IHVuZGVmaW5lZCxcbik6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0eXBlb2YgZmlsdGVyID09PSAnZnVuY3Rpb24nID8gZmlsdGVyKGNvZGVSZXN1bHQpIDogdHJ1ZTtcbn1cblxuaW50ZXJmYWNlIFJlc3VsdENvbGxlY3RvciB7XG4gICAgYWRkUmVzdWx0OiAoZGF0YTogUXVhZ2dhSW1hZ2VEYXRhLCBpbWFnZVNpemU6IFhZU2l6ZSwgY29kZVJlc3VsdDogUXVhZ2dhSlNDb2RlUmVzdWx0KSA9PiB2b2lkO1xuICAgIGdldFJlc3VsdHM6ICgpID0+IEFycmF5PFF1YWdnYUpTQ29kZVJlc3VsdD47XG59XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgICBjcmVhdGUoY29uZmlnOiBRdWFnZ2FKU1Jlc3VsdENvbGxlY3Rvcik6IFJlc3VsdENvbGxlY3RvciB7XG4gICAgICAgIGNvbnN0IGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgICAgICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKSBhcyBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQ7XG4gICAgICAgIGNvbnN0IHJlc3VsdHM6IEFycmF5PFF1YWdnYUpTQ29kZVJlc3VsdD4gPSBbXTtcbiAgICAgICAgbGV0IGNhcGFjaXR5ID0gY29uZmlnLmNhcGFjaXR5ID8/IDIwO1xuICAgICAgICBjb25zdCBjYXB0dXJlID0gY29uZmlnLmNhcHR1cmUgPT09IHRydWU7XG5cbiAgICAgICAgZnVuY3Rpb24gbWF0Y2hlc0NvbnN0cmFpbnRzKGNvZGVSZXN1bHQ6IFF1YWdnYUpTQ29kZVJlc3VsdCk6IGJvb2xlYW4ge1xuICAgICAgICAgICAgcmV0dXJuICEhY2FwYWNpdHlcbiAgICAgICAgICAgICAgICAmJiBjb2RlUmVzdWx0XG4gICAgICAgICAgICAgICAgJiYgIWNvbnRhaW5zKGNvZGVSZXN1bHQsIGNvbmZpZy5ibGFja2xpc3QgYXMgQXJyYXk8UXVhZ2dhSlNDb2RlUmVzdWx0PilcbiAgICAgICAgICAgICAgICAmJiBwYXNzZXNGaWx0ZXIoY29kZVJlc3VsdCwgY29uZmlnLmZpbHRlcik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYWRkUmVzdWx0KGRhdGE6IFF1YWdnYUltYWdlRGF0YSwgaW1hZ2VTaXplOiBYWVNpemUsIGNvZGVSZXN1bHQ6IFF1YWdnYUpTQ29kZVJlc3VsdCk6IHZvaWQge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdDogYW55ID0geyB9OyAvLyB0aGlzIGlzICdhbnknIHRvIGF2b2lkIGhhdmluZyB0byBjb25zdHJ1Y3QgYSB3aG9sZSBRdWFnZ2FKU0NvZGVSZXN1bHQgOnxcbiAgICAgICAgICAgICAgICBpZiAobWF0Y2hlc0NvbnN0cmFpbnRzKGNvZGVSZXN1bHQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhcGFjaXR5LS07XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5jb2RlUmVzdWx0ID0gY29kZVJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNhcHR1cmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbnZhcy53aWR0aCA9IGltYWdlU2l6ZS54O1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FudmFzLmhlaWdodCA9IGltYWdlU2l6ZS55O1xuICAgICAgICAgICAgICAgICAgICAgICAgSW1hZ2VEZWJ1Zy5kcmF3SW1hZ2UoZGF0YSwgaW1hZ2VTaXplLCBjdHgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmZyYW1lID0gY2FudmFzLnRvRGF0YVVSTCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaChyZXN1bHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXRSZXN1bHRzKCk6IEFycmF5PFF1YWdnYUpTQ29kZVJlc3VsdD4ge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9LFxufTtcbiIsImltcG9ydCB7IFF1YWdnYUpTQ29uZmlnT2JqZWN0IH0gZnJvbSAnLi4vLi4vdHlwZS1kZWZpbml0aW9ucy9xdWFnZ2EuZCc7XG5cbmNvbnN0IERldkNvbmZpZzogUXVhZ2dhSlNDb25maWdPYmplY3QgPSB7XG4gICAgaW5wdXRTdHJlYW06IHtcbiAgICAgICAgbmFtZTogJ0xpdmUnLFxuICAgICAgICB0eXBlOiAnTGl2ZVN0cmVhbScsXG4gICAgICAgIGNvbnN0cmFpbnRzOiB7XG4gICAgICAgICAgICB3aWR0aDogNjQwLFxuICAgICAgICAgICAgaGVpZ2h0OiA0ODAsXG4gICAgICAgICAgICAvLyBhc3BlY3RSYXRpbzogNjQwLzQ4MCwgLy8gb3B0aW9uYWxcbiAgICAgICAgICAgIGZhY2luZ01vZGU6ICdlbnZpcm9ubWVudCcsIC8vIG9yIHVzZXJcbiAgICAgICAgICAgIC8vIGRldmljZUlkOiBcIjM4NzQ1OTgzNDU3Mzg3NTk4Mzc1OTgzNzU5ODM0XCJcbiAgICAgICAgfSxcbiAgICAgICAgYXJlYToge1xuICAgICAgICAgICAgdG9wOiAnMCUnLFxuICAgICAgICAgICAgcmlnaHQ6ICcwJScsXG4gICAgICAgICAgICBsZWZ0OiAnMCUnLFxuICAgICAgICAgICAgYm90dG9tOiAnMCUnLFxuICAgICAgICB9LFxuICAgICAgICBzaW5nbGVDaGFubmVsOiBmYWxzZSwgLy8gdHJ1ZTogb25seSB0aGUgcmVkIGNvbG9yLWNoYW5uZWwgaXMgcmVhZFxuICAgIH0sXG4gICAgbG9jYXRlOiB0cnVlLFxuICAgIG51bU9mV29ya2VyczogMCxcbiAgICBkZWNvZGVyOiB7XG4gICAgICAgIHJlYWRlcnM6IFtcbiAgICAgICAgICAgICdjb2RlXzEyOF9yZWFkZXInLFxuICAgICAgICBdLFxuICAgICAgICBkZWJ1Zzoge1xuICAgICAgICAgICAgZHJhd0JvdW5kaW5nQm94OiBmYWxzZSxcbiAgICAgICAgICAgIHNob3dGcmVxdWVuY3k6IGZhbHNlLFxuICAgICAgICAgICAgZHJhd1NjYW5saW5lOiBmYWxzZSxcbiAgICAgICAgICAgIHNob3dQYXR0ZXJuOiBmYWxzZSxcbiAgICAgICAgfSxcbiAgICB9LFxuICAgIGxvY2F0b3I6IHtcbiAgICAgICAgaGFsZlNhbXBsZTogdHJ1ZSxcbiAgICAgICAgcGF0Y2hTaXplOiAnbWVkaXVtJywgLy8geC1zbWFsbCwgc21hbGwsIG1lZGl1bSwgbGFyZ2UsIHgtbGFyZ2VcbiAgICAgICAgZGVidWc6IHtcbiAgICAgICAgICAgIHNob3dDYW52YXM6IGZhbHNlLFxuICAgICAgICAgICAgc2hvd1BhdGNoZXM6IGZhbHNlLFxuICAgICAgICAgICAgc2hvd0ZvdW5kUGF0Y2hlczogZmFsc2UsXG4gICAgICAgICAgICBzaG93U2tlbGV0b246IGZhbHNlLFxuICAgICAgICAgICAgc2hvd0xhYmVsczogZmFsc2UsXG4gICAgICAgICAgICBzaG93UGF0Y2hMYWJlbHM6IGZhbHNlLFxuICAgICAgICAgICAgc2hvd1JlbWFpbmluZ1BhdGNoTGFiZWxzOiBmYWxzZSxcbiAgICAgICAgICAgIGJveEZyb21QYXRjaGVzOiB7XG4gICAgICAgICAgICAgICAgc2hvd1RyYW5zZm9ybWVkOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBzaG93VHJhbnNmb3JtZWRCb3g6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHNob3dCQjogZmFsc2UsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgIH0sXG59O1xuXG5leHBvcnQgZGVmYXVsdCBEZXZDb25maWc7XG4iLCJpbXBvcnQgeyBRdWFnZ2FKU0NvbmZpZ09iamVjdCB9IGZyb20gJy4uLy4uL3R5cGUtZGVmaW5pdGlvbnMvcXVhZ2dhLmQnO1xuXG5jb25zdCBOb2RlQ29uZmlnOiBRdWFnZ2FKU0NvbmZpZ09iamVjdCA9IHtcbiAgICBpbnB1dFN0cmVhbToge1xuICAgICAgICB0eXBlOiAnSW1hZ2VTdHJlYW0nLFxuICAgICAgICBzZXF1ZW5jZTogZmFsc2UsXG4gICAgICAgIHNpemU6IDgwMCxcbiAgICAgICAgYXJlYToge1xuICAgICAgICAgICAgdG9wOiAnMCUnLFxuICAgICAgICAgICAgcmlnaHQ6ICcwJScsXG4gICAgICAgICAgICBsZWZ0OiAnMCUnLFxuICAgICAgICAgICAgYm90dG9tOiAnMCUnLFxuICAgICAgICB9LFxuICAgICAgICBzaW5nbGVDaGFubmVsOiBmYWxzZSwgLy8gdHJ1ZTogb25seSB0aGUgcmVkIGNvbG9yLWNoYW5uZWwgaXMgcmVhZFxuICAgIH0sXG4gICAgbG9jYXRlOiB0cnVlLFxuICAgIG51bU9mV29ya2VyczogMCxcbiAgICBkZWNvZGVyOiB7XG4gICAgICAgIHJlYWRlcnM6IFtcbiAgICAgICAgICAgICdjb2RlXzEyOF9yZWFkZXInLFxuICAgICAgICBdLFxuICAgIH0sXG4gICAgbG9jYXRvcjoge1xuICAgICAgICBoYWxmU2FtcGxlOiB0cnVlLFxuICAgICAgICBwYXRjaFNpemU6ICdtZWRpdW0nLCAvLyB4LXNtYWxsLCBzbWFsbCwgbWVkaXVtLCBsYXJnZSwgeC1sYXJnZVxuICAgIH0sXG59O1xuXG5leHBvcnQgZGVmYXVsdCBOb2RlQ29uZmlnO1xuIiwiaW1wb3J0IHsgUXVhZ2dhSlNDb25maWdPYmplY3QgfSBmcm9tICcuLi8uLi90eXBlLWRlZmluaXRpb25zL3F1YWdnYS5kJztcblxuY29uc3QgUHJvZENvbmZpZzogUXVhZ2dhSlNDb25maWdPYmplY3QgPSB7XG4gICAgaW5wdXRTdHJlYW06IHtcbiAgICAgICAgbmFtZTogJ0xpdmUnLFxuICAgICAgICB0eXBlOiAnTGl2ZVN0cmVhbScsXG4gICAgICAgIGNvbnN0cmFpbnRzOiB7XG4gICAgICAgICAgICB3aWR0aDogNjQwLFxuICAgICAgICAgICAgaGVpZ2h0OiA0ODAsXG4gICAgICAgICAgICAvLyBhc3BlY3RSYXRpbzogNjQwLzQ4MCwgLy8gb3B0aW9uYWxcbiAgICAgICAgICAgIGZhY2luZ01vZGU6ICdlbnZpcm9ubWVudCcsIC8vIG9yIHVzZXJcbiAgICAgICAgICAgIC8vIGRldmljZUlkOiBcIjM4NzQ1OTgzNDU3Mzg3NTk4Mzc1OTgzNzU5ODM0XCJcbiAgICAgICAgfSxcbiAgICAgICAgYXJlYToge1xuICAgICAgICAgICAgdG9wOiAnMCUnLFxuICAgICAgICAgICAgcmlnaHQ6ICcwJScsXG4gICAgICAgICAgICBsZWZ0OiAnMCUnLFxuICAgICAgICAgICAgYm90dG9tOiAnMCUnLFxuICAgICAgICB9LFxuICAgICAgICBzaW5nbGVDaGFubmVsOiBmYWxzZSwgLy8gdHJ1ZTogb25seSB0aGUgcmVkIGNvbG9yLWNoYW5uZWwgaXMgcmVhZFxuICAgIH0sXG4gICAgbG9jYXRlOiB0cnVlLFxuICAgIG51bU9mV29ya2VyczogNCxcbiAgICBkZWNvZGVyOiB7XG4gICAgICAgIHJlYWRlcnM6IFtcbiAgICAgICAgICAgICdjb2RlXzEyOF9yZWFkZXInLFxuICAgICAgICBdLFxuICAgIH0sXG4gICAgbG9jYXRvcjoge1xuICAgICAgICBoYWxmU2FtcGxlOiB0cnVlLFxuICAgICAgICBwYXRjaFNpemU6ICdtZWRpdW0nLCAvLyB4LXNtYWxsLCBzbWFsbCwgbWVkaXVtLCBsYXJnZSwgeC1sYXJnZVxuICAgIH0sXG59O1xuXG5leHBvcnQgZGVmYXVsdCBQcm9kQ29uZmlnO1xuIiwiaW1wb3J0IHsgUXVhZ2dhSlNDb25maWdPYmplY3QgfSBmcm9tICcuLi8uLi90eXBlLWRlZmluaXRpb25zL3F1YWdnYS5kJztcbmltcG9ydCBEZXZDb25maWcgZnJvbSAnLi9jb25maWcuZGV2JztcbmltcG9ydCBOb2RlQ29uZmlnIGZyb20gJy4vY29uZmlnLm5vZGUnO1xuaW1wb3J0IFByb2RDb25maWcgZnJvbSAnLi9jb25maWcucHJvZCc7XG5cbmNvbnN0IEV4cG9ydENvbmZpZzogUXVhZ2dhSlNDb25maWdPYmplY3QgPSAoKCkgPT4ge1xuICAgIGxldCBRdWFnZ2FDb25maWc6IFF1YWdnYUpTQ29uZmlnT2JqZWN0O1xuICAgIGlmICh0eXBlb2YgRU5WID09PSAndW5kZWZpbmVkJyB8fCBFTlYuZGV2ZWxvcG1lbnQpIHtcbiAgICAgICAgUXVhZ2dhQ29uZmlnID0gRGV2Q29uZmlnO1xuICAgIH0gZWxzZSBpZiAoRU5WLm5vZGUpIHtcbiAgICAgICAgUXVhZ2dhQ29uZmlnID0gTm9kZUNvbmZpZztcbiAgICB9IGVsc2Uge1xuICAgICAgICBRdWFnZ2FDb25maWcgPSBQcm9kQ29uZmlnO1xuICAgIH1cbiAgICByZXR1cm4gUXVhZ2dhQ29uZmlnO1xufSkoKTtcblxuZXhwb3J0IGRlZmF1bHQgRXhwb3J0Q29uZmlnO1xuIiwiLy8gTk9URSBGT1IgQU5ZT05FIElOIEhFUkUgSU4gVEhFIEZVVFVSRTpcbi8vIHdlYnBhY2suY29uZmlnLmpzIHJlcGxhY2VzIHRoZSBmcmFtZV9ncmFiYmVyIG1vZHVsZSB3aXRoIFRISVMgbW9kdWxlIHdoZW4gaXQgaXMgYnVpbGRpbmcgZm9yIGEgQnJvd3NlciBlbnZpcm9ubWVudC5cblxuaW1wb3J0IHtcbiAgICBpbWFnZVJlZixcbiAgICBncmF5QW5kSGFsZlNhbXBsZUZyb21DYW52YXNEYXRhLFxuICAgIGNvbXB1dGVHcmF5LFxufSBmcm9tICcuLi9jb21tb24vY3ZfdXRpbHMnO1xuXG5jb25zdCBUT19SQURJQU5TID0gTWF0aC5QSSAvIDE4MDtcblxuZnVuY3Rpb24gYWRqdXN0Q2FudmFzU2l6ZShjYW52YXMsIHRhcmdldFNpemUpIHtcbiAgICBpZiAoY2FudmFzLndpZHRoICE9PSB0YXJnZXRTaXplLngpIHtcbiAgICAgICAgaWYgKEVOVi5kZXZlbG9wbWVudCkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ1dBUk5JTkc6IGNhbnZhcy1zaXplIG5lZWRzIHRvIGJlIGFkanVzdGVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgY2FudmFzLndpZHRoID0gdGFyZ2V0U2l6ZS54O1xuICAgIH1cbiAgICBpZiAoY2FudmFzLmhlaWdodCAhPT0gdGFyZ2V0U2l6ZS55KSB7XG4gICAgICAgIGlmIChFTlYuZGV2ZWxvcG1lbnQpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdXQVJOSU5HOiBjYW52YXMtc2l6ZSBuZWVkcyB0byBiZSBhZGp1c3RlZCcpO1xuICAgICAgICB9XG4gICAgICAgIGNhbnZhcy5oZWlnaHQgPSB0YXJnZXRTaXplLnk7XG4gICAgfVxufVxuXG5jb25zdCBGcmFtZUdyYWJiZXIgPSB7fTtcblxuRnJhbWVHcmFiYmVyLmNyZWF0ZSA9IGZ1bmN0aW9uIChpbnB1dFN0cmVhbSwgY2FudmFzKSB7XG4gICAgLy8gY29uc29sZS53YXJuKCcqKiogRnJhbWVHcmFiYmVyQnJvd3NlciBjcmVhdGUnKTtcbiAgICBjb25zdCBfdGhhdCA9IHt9O1xuICAgIGNvbnN0IF9zdHJlYW1Db25maWcgPSBpbnB1dFN0cmVhbS5nZXRDb25maWcoKTtcbiAgICBjb25zdCBfdmlkZW9TaXplID0gaW1hZ2VSZWYoaW5wdXRTdHJlYW0uZ2V0UmVhbFdpZHRoKCksIGlucHV0U3RyZWFtLmdldFJlYWxIZWlnaHQoKSk7XG4gICAgY29uc3QgX2NhbnZhc1NpemUgPSBpbnB1dFN0cmVhbS5nZXRDYW52YXNTaXplKCk7XG4gICAgY29uc3QgX3NpemUgPSBpbWFnZVJlZihpbnB1dFN0cmVhbS5nZXRXaWR0aCgpLCBpbnB1dFN0cmVhbS5nZXRIZWlnaHQoKSk7XG4gICAgY29uc3QgdG9wUmlnaHQgPSBpbnB1dFN0cmVhbS5nZXRUb3BSaWdodCgpO1xuICAgIGNvbnN0IF9zeCA9IHRvcFJpZ2h0Lng7XG4gICAgY29uc3QgX3N5ID0gdG9wUmlnaHQueTtcbiAgICBsZXQgX2NhbnZhcztcbiAgICBsZXQgX2N0eCA9IG51bGw7XG4gICAgbGV0IF9kYXRhID0gbnVsbDtcblxuICAgIF9jYW52YXMgPSBjYW52YXMgfHwgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgX2NhbnZhcy53aWR0aCA9IF9jYW52YXNTaXplLng7XG4gICAgX2NhbnZhcy5oZWlnaHQgPSBfY2FudmFzU2l6ZS55O1xuICAgIF9jdHggPSBfY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgX2RhdGEgPSBuZXcgVWludDhBcnJheShfc2l6ZS54ICogX3NpemUueSk7XG4gICAgaWYgKEVOVi5kZXZlbG9wbWVudCkge1xuICAgICAgICBjb25zb2xlLmxvZygnRnJhbWVHcmFiYmVyJywgSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgc2l6ZTogX3NpemUsXG4gICAgICAgICAgICB0b3BSaWdodCxcbiAgICAgICAgICAgIHZpZGVvU2l6ZTogX3ZpZGVvU2l6ZSxcbiAgICAgICAgICAgIGNhbnZhc1NpemU6IF9jYW52YXNTaXplLFxuICAgICAgICB9KSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXNlcyB0aGUgZ2l2ZW4gYXJyYXkgYXMgZnJhbWUtYnVmZmVyXG4gICAgICovXG4gICAgX3RoYXQuYXR0YWNoRGF0YSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIF9kYXRhID0gZGF0YTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgdXNlZCBmcmFtZS1idWZmZXJcbiAgICAgKi9cbiAgICBfdGhhdC5nZXREYXRhID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX2RhdGE7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEZldGNoZXMgYSBmcmFtZSBmcm9tIHRoZSBpbnB1dC1zdHJlYW0gYW5kIHB1dHMgaW50byB0aGUgZnJhbWUtYnVmZmVyLlxuICAgICAqIFRoZSBpbWFnZS1kYXRhIGlzIGNvbnZlcnRlZCB0byBncmF5LXNjYWxlIGFuZCB0aGVuIGhhbGYtc2FtcGxlZCBpZiBjb25maWd1cmVkLlxuICAgICAqL1xuICAgIF90aGF0LmdyYWIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNvbnN0IGRvSGFsZlNhbXBsZSA9IF9zdHJlYW1Db25maWcuaGFsZlNhbXBsZTtcbiAgICAgICAgY29uc3QgZnJhbWUgPSBpbnB1dFN0cmVhbS5nZXRGcmFtZSgpO1xuICAgICAgICBsZXQgZHJhd2FibGUgPSBmcmFtZTtcbiAgICAgICAgbGV0IGRyYXdBbmdsZSA9IDA7XG4gICAgICAgIGxldCBjdHhEYXRhO1xuICAgICAgICBpZiAoZHJhd2FibGUpIHtcbiAgICAgICAgICAgIGFkanVzdENhbnZhc1NpemUoX2NhbnZhcywgX2NhbnZhc1NpemUpO1xuICAgICAgICAgICAgaWYgKF9zdHJlYW1Db25maWcudHlwZSA9PT0gJ0ltYWdlU3RyZWFtJykge1xuICAgICAgICAgICAgICAgIGRyYXdhYmxlID0gZnJhbWUuaW1nO1xuICAgICAgICAgICAgICAgIGlmIChmcmFtZS50YWdzICYmIGZyYW1lLnRhZ3Mub3JpZW50YXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChmcmFtZS50YWdzLm9yaWVudGF0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZHJhd0FuZ2xlID0gOTAgKiBUT19SQURJQU5TO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRyYXdBbmdsZSA9IC05MCAqIFRPX1JBRElBTlM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChkcmF3QW5nbGUgIT09IDApIHtcbiAgICAgICAgICAgICAgICBfY3R4LnRyYW5zbGF0ZShfY2FudmFzU2l6ZS54IC8gMiwgX2NhbnZhc1NpemUueSAvIDIpO1xuICAgICAgICAgICAgICAgIF9jdHgucm90YXRlKGRyYXdBbmdsZSk7XG4gICAgICAgICAgICAgICAgX2N0eC5kcmF3SW1hZ2UoZHJhd2FibGUsIC1fY2FudmFzU2l6ZS55IC8gMiwgLV9jYW52YXNTaXplLnggLyAyLCBfY2FudmFzU2l6ZS55LCBfY2FudmFzU2l6ZS54KTtcbiAgICAgICAgICAgICAgICBfY3R4LnJvdGF0ZSgtZHJhd0FuZ2xlKTtcbiAgICAgICAgICAgICAgICBfY3R4LnRyYW5zbGF0ZSgtX2NhbnZhc1NpemUueCAvIDIsIC1fY2FudmFzU2l6ZS55IC8gMik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIF9jdHguZHJhd0ltYWdlKGRyYXdhYmxlLCAwLCAwLCBfY2FudmFzU2l6ZS54LCBfY2FudmFzU2l6ZS55KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY3R4RGF0YSA9IF9jdHguZ2V0SW1hZ2VEYXRhKF9zeCwgX3N5LCBfc2l6ZS54LCBfc2l6ZS55KS5kYXRhO1xuICAgICAgICAgICAgaWYgKGRvSGFsZlNhbXBsZSkge1xuICAgICAgICAgICAgICAgIGdyYXlBbmRIYWxmU2FtcGxlRnJvbUNhbnZhc0RhdGEoY3R4RGF0YSwgX3NpemUsIF9kYXRhKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29tcHV0ZUdyYXkoY3R4RGF0YSwgX2RhdGEsIF9zdHJlYW1Db25maWcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG5cbiAgICBfdGhhdC5nZXRTaXplID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX3NpemU7XG4gICAgfTtcblxuICAgIHJldHVybiBfdGhhdDtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IEZyYW1lR3JhYmJlcjtcbiIsIi8vIE5PVEU6IChTT01FIE9GKSBUSElTIElTIEJST1dTRVIgT05MWSBDT0RFLiAgTm9kZSBkb2VzIG5vdCBoYXZlICdhdG9iJyBidWlsdCBpbiwgbm9yIFhNTEh0dHBSZXF1ZXN0LlxuLy8gSG93IGV4YWN0bHkgaXMgdGhpcyBzZXQgb2YgZnVuY3Rpb25zIHVzZWQgaW4gUXVhZ2dhPyBEbyB3ZSBuZWVkIHRoZSBicm93c2VyIHNwZWNpZmljIGNvZGU/IERvIHdlXG4vLyBuZWVkIHRvIHBvcnQgYW55IHBhcnQgb2YgdGhpcyB0aGF0IGRvZXNuJ3Qgd29yayBpbiBOb2RlIHRvIG5vZGU/XG5cbi8vIFRhZ3Mgc2NyYXBlZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9leGlmLWpzL2V4aWYtanNcbmNvbnN0IEV4aWZUYWdzID0geyAweDAxMTI6ICdvcmllbnRhdGlvbicgfTtcbmV4cG9ydCBjb25zdCBBdmFpbGFibGVUYWdzID0gT2JqZWN0LmtleXMoRXhpZlRhZ3MpLm1hcCgoa2V5KSA9PiBFeGlmVGFnc1trZXldKTtcblxuZXhwb3J0IGZ1bmN0aW9uIGZpbmRUYWdzSW5PYmplY3RVUkwoc3JjLCB0YWdzID0gQXZhaWxhYmxlVGFncykge1xuICAgIGlmICgvXmJsb2I6L2kudGVzdChzcmMpKSB7XG4gICAgICAgIHJldHVybiBvYmplY3RVUkxUb0Jsb2Ioc3JjKVxuICAgICAgICAgICAgLnRoZW4ocmVhZFRvQnVmZmVyKVxuICAgICAgICAgICAgLnRoZW4oKGJ1ZmZlcikgPT4gZmluZFRhZ3NJbkJ1ZmZlcihidWZmZXIsIHRhZ3MpKTtcbiAgICB9XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShudWxsKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGJhc2U2NFRvQXJyYXlCdWZmZXIoZGF0YVVybCkge1xuICAgIGNvbnN0IGJhc2U2NCA9IGRhdGFVcmwucmVwbGFjZSgvXmRhdGE6KFteO10rKTtiYXNlNjQsL2dtaSwgJycpO1xuICAgIGNvbnN0IGJpbmFyeSA9IGF0b2IoYmFzZTY0KTtcbiAgICBjb25zdCBsZW4gPSBiaW5hcnkubGVuZ3RoO1xuICAgIGNvbnN0IGJ1ZmZlciA9IG5ldyBBcnJheUJ1ZmZlcihsZW4pO1xuICAgIGNvbnN0IHZpZXcgPSBuZXcgVWludDhBcnJheShidWZmZXIpO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICB2aWV3W2ldID0gYmluYXJ5LmNoYXJDb2RlQXQoaSk7XG4gICAgfVxuICAgIHJldHVybiBidWZmZXI7XG59XG5cbmZ1bmN0aW9uIHJlYWRUb0J1ZmZlcihibG9iKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgIGNvbnN0IGZpbGVSZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xuICAgICAgICBmaWxlUmVhZGVyLm9ubG9hZCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzb2x2ZShlLnRhcmdldC5yZXN1bHQpO1xuICAgICAgICB9O1xuICAgICAgICBmaWxlUmVhZGVyLnJlYWRBc0FycmF5QnVmZmVyKGJsb2IpO1xuICAgIH0pO1xufVxuXG5mdW5jdGlvbiBvYmplY3RVUkxUb0Jsb2IodXJsKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgY29uc3QgaHR0cCA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgICAgICBodHRwLm9wZW4oJ0dFVCcsIHVybCwgdHJ1ZSk7XG4gICAgICAgIGh0dHAucmVzcG9uc2VUeXBlID0gJ2Jsb2InO1xuICAgICAgICBodHRwLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChodHRwLnJlYWR5U3RhdGUgPT09IFhNTEh0dHBSZXF1ZXN0LkRPTkUgJiYgKGh0dHAuc3RhdHVzID09PSAyMDAgfHwgaHR0cC5zdGF0dXMgPT09IDApKSB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZSh0aGlzLnJlc3BvbnNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgaHR0cC5vbmVycm9yID0gcmVqZWN0O1xuICAgICAgICBodHRwLnNlbmQoKTtcbiAgICB9KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGZpbmRUYWdzSW5CdWZmZXIoZmlsZSwgc2VsZWN0ZWRUYWdzID0gQXZhaWxhYmxlVGFncykge1xuICAgIGNvbnN0IGRhdGFWaWV3ID0gbmV3IERhdGFWaWV3KGZpbGUpO1xuICAgIGNvbnN0IGxlbmd0aCA9IGZpbGUuYnl0ZUxlbmd0aDtcbiAgICBjb25zdCBleGlmVGFncyA9IHNlbGVjdGVkVGFncy5yZWR1Y2UoKHJlc3VsdCwgc2VsZWN0ZWRUYWcpID0+IHtcbiAgICAgICAgY29uc3QgZXhpZlRhZyA9IE9iamVjdC5rZXlzKEV4aWZUYWdzKS5maWx0ZXIoKHRhZykgPT4gRXhpZlRhZ3NbdGFnXSA9PT0gc2VsZWN0ZWRUYWcpWzBdO1xuICAgICAgICBpZiAoZXhpZlRhZykge1xuICAgICAgICAgICAgcmVzdWx0W2V4aWZUYWddID0gc2VsZWN0ZWRUYWc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LCB7fSk7XG4gICAgbGV0IG9mZnNldCA9IDI7XG4gICAgbGV0IG1hcmtlcjtcblxuICAgIGlmICgoZGF0YVZpZXcuZ2V0VWludDgoMCkgIT09IDB4RkYpIHx8IChkYXRhVmlldy5nZXRVaW50OCgxKSAhPT0gMHhEOCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHdoaWxlIChvZmZzZXQgPCBsZW5ndGgpIHtcbiAgICAgICAgaWYgKGRhdGFWaWV3LmdldFVpbnQ4KG9mZnNldCkgIT09IDB4RkYpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIG1hcmtlciA9IGRhdGFWaWV3LmdldFVpbnQ4KG9mZnNldCArIDEpO1xuICAgICAgICBpZiAobWFya2VyID09PSAweEUxKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVhZEVYSUZEYXRhKGRhdGFWaWV3LCBvZmZzZXQgKyA0LCBleGlmVGFncyk7XG4gICAgICAgIH1cbiAgICAgICAgb2Zmc2V0ICs9IDIgKyBkYXRhVmlldy5nZXRVaW50MTYob2Zmc2V0ICsgMik7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiByZWFkRVhJRkRhdGEoZmlsZSwgc3RhcnQsIGV4aWZUYWdzKSB7XG4gICAgaWYgKGdldFN0cmluZ0Zyb21CdWZmZXIoZmlsZSwgc3RhcnQsIDQpICE9PSAnRXhpZicpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGNvbnN0IHRpZmZPZmZzZXQgPSBzdGFydCArIDY7XG4gICAgbGV0IGJpZ0VuZDtcblxuICAgIGlmIChmaWxlLmdldFVpbnQxNih0aWZmT2Zmc2V0KSA9PT0gMHg0OTQ5KSB7XG4gICAgICAgIGJpZ0VuZCA9IGZhbHNlO1xuICAgIH0gZWxzZSBpZiAoZmlsZS5nZXRVaW50MTYodGlmZk9mZnNldCkgPT09IDB4NEQ0RCkge1xuICAgICAgICBiaWdFbmQgPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoZmlsZS5nZXRVaW50MTYodGlmZk9mZnNldCArIDIsICFiaWdFbmQpICE9PSAweDAwMkEpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGNvbnN0IGZpcnN0SUZET2Zmc2V0ID0gZmlsZS5nZXRVaW50MzIodGlmZk9mZnNldCArIDQsICFiaWdFbmQpO1xuICAgIGlmIChmaXJzdElGRE9mZnNldCA8IDB4MDAwMDAwMDgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGNvbnN0IHRhZ3MgPSByZWFkVGFncyhmaWxlLCB0aWZmT2Zmc2V0LCB0aWZmT2Zmc2V0ICsgZmlyc3RJRkRPZmZzZXQsIGV4aWZUYWdzLCBiaWdFbmQpO1xuICAgIHJldHVybiB0YWdzO1xufVxuXG5mdW5jdGlvbiByZWFkVGFncyhmaWxlLCB0aWZmU3RhcnQsIGRpclN0YXJ0LCBzdHJpbmdzLCBiaWdFbmQpIHtcbiAgICBjb25zdCBlbnRyaWVzID0gZmlsZS5nZXRVaW50MTYoZGlyU3RhcnQsICFiaWdFbmQpO1xuICAgIGNvbnN0IHRhZ3MgPSB7fTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZW50cmllczsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGVudHJ5T2Zmc2V0ID0gZGlyU3RhcnQgKyBpICogMTIgKyAyO1xuICAgICAgICBjb25zdCB0YWcgPSBzdHJpbmdzW2ZpbGUuZ2V0VWludDE2KGVudHJ5T2Zmc2V0LCAhYmlnRW5kKV07XG4gICAgICAgIGlmICh0YWcpIHtcbiAgICAgICAgICAgIHRhZ3NbdGFnXSA9IHJlYWRUYWdWYWx1ZShmaWxlLCBlbnRyeU9mZnNldCwgdGlmZlN0YXJ0LCBkaXJTdGFydCwgYmlnRW5kKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGFncztcbn1cblxuZnVuY3Rpb24gcmVhZFRhZ1ZhbHVlKGZpbGUsIGVudHJ5T2Zmc2V0LCB0aWZmU3RhcnQsIGRpclN0YXJ0LCBiaWdFbmQpIHtcbiAgICBjb25zdCB0eXBlID0gZmlsZS5nZXRVaW50MTYoZW50cnlPZmZzZXQgKyAyLCAhYmlnRW5kKTtcbiAgICBjb25zdCBudW1WYWx1ZXMgPSBmaWxlLmdldFVpbnQzMihlbnRyeU9mZnNldCArIDQsICFiaWdFbmQpO1xuXG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIGlmIChudW1WYWx1ZXMgPT09IDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmlsZS5nZXRVaW50MTYoZW50cnlPZmZzZXQgKyA4LCAhYmlnRW5kKTtcbiAgICAgICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gZ2V0U3RyaW5nRnJvbUJ1ZmZlcihidWZmZXIsIHN0YXJ0LCBsZW5ndGgpIHtcbiAgICBsZXQgb3V0c3RyID0gJyc7XG4gICAgZm9yIChsZXQgbiA9IHN0YXJ0OyBuIDwgc3RhcnQgKyBsZW5ndGg7IG4rKykge1xuICAgICAgICBvdXRzdHIgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZmZXIuZ2V0VWludDgobikpO1xuICAgIH1cbiAgICByZXR1cm4gb3V0c3RyO1xufVxuIiwiaW1wb3J0IHsgZmluZFRhZ3NJbk9iamVjdFVSTCB9IGZyb20gJy4vZXhpZl9oZWxwZXInO1xuXG5jb25zdCBJbWFnZUxvYWRlciA9IHt9O1xuSW1hZ2VMb2FkZXIubG9hZCA9IGZ1bmN0aW9uIChkaXJlY3RvcnksIGNhbGxiYWNrLCBvZmZzZXQsIHNpemUsIHNlcXVlbmNlKSB7XG4gICAgY29uc3QgaHRtbEltYWdlc1NyY0FycmF5ID0gbmV3IEFycmF5KHNpemUpO1xuICAgIGNvbnN0IGh0bWxJbWFnZXNBcnJheSA9IG5ldyBBcnJheShodG1sSW1hZ2VzU3JjQXJyYXkubGVuZ3RoKTtcbiAgICBsZXQgaTtcbiAgICBsZXQgaW1nO1xuICAgIGxldCBudW07XG5cbiAgICBpZiAoc2VxdWVuY2UgPT09IGZhbHNlKSB7XG4gICAgICAgIGh0bWxJbWFnZXNTcmNBcnJheVswXSA9IGRpcmVjdG9yeTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgaHRtbEltYWdlc1NyY0FycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBudW0gPSAob2Zmc2V0ICsgaSk7XG4gICAgICAgICAgICBodG1sSW1hZ2VzU3JjQXJyYXlbaV0gPSBgJHtkaXJlY3Rvcnl9aW1hZ2UtJHsoYDAwJHtudW19YCkuc2xpY2UoLTMpfS5qcGdgO1xuICAgICAgICB9XG4gICAgfVxuICAgIGh0bWxJbWFnZXNBcnJheS5ub3RMb2FkZWQgPSBbXTtcbiAgICBodG1sSW1hZ2VzQXJyYXkuYWRkSW1hZ2UgPSBmdW5jdGlvbiAoaW1hZ2UpIHtcbiAgICAgICAgaHRtbEltYWdlc0FycmF5Lm5vdExvYWRlZC5wdXNoKGltYWdlKTtcbiAgICB9O1xuICAgIGh0bWxJbWFnZXNBcnJheS5sb2FkZWQgPSBmdW5jdGlvbiAobG9hZGVkSW1nKSB7XG4gICAgICAgIGNvbnN0IG5vdGxvYWRlZEltZ3MgPSBodG1sSW1hZ2VzQXJyYXkubm90TG9hZGVkO1xuICAgICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IG5vdGxvYWRlZEltZ3MubGVuZ3RoOyB4KyspIHtcbiAgICAgICAgICAgIGlmIChub3Rsb2FkZWRJbWdzW3hdID09PSBsb2FkZWRJbWcpIHtcbiAgICAgICAgICAgICAgICBub3Rsb2FkZWRJbWdzLnNwbGljZSh4LCAxKTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCB5ID0gMDsgeSA8IGh0bWxJbWFnZXNTcmNBcnJheS5sZW5ndGg7IHkrKykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBpbWdOYW1lID0gaHRtbEltYWdlc1NyY0FycmF5W3ldLnN1YnN0cihodG1sSW1hZ2VzU3JjQXJyYXlbeV0ubGFzdEluZGV4T2YoJy8nKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsb2FkZWRJbWcuc3JjLmxhc3RJbmRleE9mKGltZ05hbWUpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaHRtbEltYWdlc0FycmF5W3ldID0geyBpbWc6IGxvYWRlZEltZyB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vdGxvYWRlZEltZ3MubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBpZiAoRU5WLmRldmVsb3BtZW50KSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ0ltYWdlcyBsb2FkZWQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzZXF1ZW5jZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBmaW5kVGFnc0luT2JqZWN0VVJMKGRpcmVjdG9yeSwgWydvcmllbnRhdGlvbiddKVxuICAgICAgICAgICAgICAgICAgICAudGhlbigodGFncykgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaHRtbEltYWdlc0FycmF5WzBdLnRhZ3MgPSB0YWdzO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soaHRtbEltYWdlc0FycmF5KTtcbiAgICAgICAgICAgICAgICAgICAgfSkuY2F0Y2goKGUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soaHRtbEltYWdlc0FycmF5KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKGh0bWxJbWFnZXNBcnJheSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGh0bWxJbWFnZXNTcmNBcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICBpbWcgPSBuZXcgSW1hZ2UoKTtcbiAgICAgICAgaHRtbEltYWdlc0FycmF5LmFkZEltYWdlKGltZyk7XG4gICAgICAgIGFkZE9ubG9hZEhhbmRsZXIoaW1nLCBodG1sSW1hZ2VzQXJyYXkpO1xuICAgICAgICBpbWcuc3JjID0gaHRtbEltYWdlc1NyY0FycmF5W2ldO1xuICAgIH1cbn07XG5cbmZ1bmN0aW9uIGFkZE9ubG9hZEhhbmRsZXIoaW1nLCBodG1sSW1hZ2VzQXJyYXkpIHtcbiAgICBpbWcub25sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBodG1sSW1hZ2VzQXJyYXkubG9hZGVkKHRoaXMpO1xuICAgIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IChJbWFnZUxvYWRlcik7XG4iLCIvKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55ICovXG5cbmltcG9ydCBJbWFnZUxvYWRlciBmcm9tICcuLi9pbWFnZV9sb2FkZXInO1xuaW1wb3J0IHsgWFlTaXplLCBQb2ludCB9IGZyb20gJy4uLy4uLy4uL3R5cGUtZGVmaW5pdGlvbnMvcXVhZ2dhLmQnO1xuaW1wb3J0IHsgSW5wdXRTdHJlYW1GYWN0b3J5LCBJbnB1dFN0cmVhbSwgRXZlbnRIYW5kbGVyTGlzdCB9IGZyb20gJy4vaW5wdXRfc3RyZWFtLmQnO1xuXG5jb25zdCBpbnB1dFN0cmVhbUZhY3Rvcnk6IElucHV0U3RyZWFtRmFjdG9yeSA9IHtcbiAgICBjcmVhdGVWaWRlb1N0cmVhbSh2aWRlbyk6IElucHV0U3RyZWFtIHtcbiAgICAgICAgY29uc29sZS53YXJuKCcqKioqIElucHV0U3RyZWFtQnJvd3NlciBjcmVhdGVWaWRlb1N0cmVhbScpO1xuICAgICAgICBsZXQgX2NvbmZpZzogeyBzaXplOiBudW1iZXI7IHR5cGU6IHN0cmluZyB9IHwgbnVsbCA9IG51bGw7XG4gICAgICAgIGNvbnN0IF9ldmVudE5hbWVzID0gWydjYW5yZWNvcmQnLCAnZW5kZWQnXTtcbiAgICAgICAgY29uc3QgX2V2ZW50SGFuZGxlcnM6IEV2ZW50SGFuZGxlckxpc3QgPSB7fTtcbiAgICAgICAgbGV0IF9jYWxjdWxhdGVkV2lkdGg6IG51bWJlcjtcbiAgICAgICAgbGV0IF9jYWxjdWxhdGVkSGVpZ2h0OiBudW1iZXI7XG4gICAgICAgIGNvbnN0IF90b3BSaWdodDogUG9pbnQgPSB7IHg6IDAsIHk6IDAsIHR5cGU6ICdQb2ludCcgfTtcbiAgICAgICAgY29uc3QgX2NhbnZhc1NpemU6IFhZU2l6ZSA9IHsgeDogMCwgeTogMCwgdHlwZTogJ1hZU2l6ZScgfTtcblxuICAgICAgICBmdW5jdGlvbiBpbml0U2l6ZSgpOiB2b2lkIHtcbiAgICAgICAgICAgIGNvbnN0IHdpZHRoID0gdmlkZW8udmlkZW9XaWR0aDtcbiAgICAgICAgICAgIGNvbnN0IGhlaWdodCA9IHZpZGVvLnZpZGVvSGVpZ2h0O1xuXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbmVzdGVkLXRlcm5hcnlcbiAgICAgICAgICAgIF9jYWxjdWxhdGVkV2lkdGggPSBfY29uZmlnPy5zaXplID8gd2lkdGggLyBoZWlnaHQgPiAxID8gX2NvbmZpZy5zaXplIDogTWF0aC5mbG9vcigod2lkdGggLyBoZWlnaHQpICogX2NvbmZpZy5zaXplKSA6IHdpZHRoO1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLW5lc3RlZC10ZXJuYXJ5XG4gICAgICAgICAgICBfY2FsY3VsYXRlZEhlaWdodCA9IF9jb25maWc/LnNpemUgPyB3aWR0aCAvIGhlaWdodCA+IDEgPyBNYXRoLmZsb29yKChoZWlnaHQgLyB3aWR0aCkgKiBfY29uZmlnLnNpemUpIDogX2NvbmZpZy5zaXplIDogaGVpZ2h0O1xuXG4gICAgICAgICAgICBfY2FudmFzU2l6ZS54ID0gX2NhbGN1bGF0ZWRXaWR0aDtcbiAgICAgICAgICAgIF9jYW52YXNTaXplLnkgPSBfY2FsY3VsYXRlZEhlaWdodDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpbnB1dFN0cmVhbTogSW5wdXRTdHJlYW0gPSB7XG4gICAgICAgICAgICBnZXRSZWFsV2lkdGgoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZpZGVvLnZpZGVvV2lkdGg7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBnZXRSZWFsSGVpZ2h0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB2aWRlby52aWRlb0hlaWdodDtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGdldFdpZHRoKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfY2FsY3VsYXRlZFdpZHRoO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgZ2V0SGVpZ2h0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfY2FsY3VsYXRlZEhlaWdodDtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIHNldFdpZHRoKHdpZHRoKSB7XG4gICAgICAgICAgICAgICAgX2NhbGN1bGF0ZWRXaWR0aCA9IHdpZHRoO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgc2V0SGVpZ2h0KGhlaWdodCkge1xuICAgICAgICAgICAgICAgIF9jYWxjdWxhdGVkSGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgc2V0SW5wdXRTdHJlYW0oY29uZmlnKSB7XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtYXNzaWdubWVudFxuICAgICAgICAgICAgICAgIF9jb25maWcgPSBjb25maWc7XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtbWVtYmVyLWFjY2Vzc1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0QXR0cmlidXRlKCdzcmMnLCAodHlwZW9mIGNvbmZpZy5zcmMgIT09ICd1bmRlZmluZWQnKSA/IGNvbmZpZy5zcmMgOiAnJyk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBlbmRlZCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmlkZW8uZW5kZWQ7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBnZXRDb25maWcoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb25maWc7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBzZXRBdHRyaWJ1dGUobmFtZSwgdmFsdWUpIHtcbiAgICAgICAgICAgICAgICBpZiAodmlkZW8pIHtcbiAgICAgICAgICAgICAgICAgICAgdmlkZW8uc2V0QXR0cmlidXRlKG5hbWUsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBwYXVzZSgpIHtcbiAgICAgICAgICAgICAgICB2aWRlby5wYXVzZSgpO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgcGxheSgpIHtcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWZsb2F0aW5nLXByb21pc2VzXG4gICAgICAgICAgICAgICAgdmlkZW8ucGxheSgpO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgc2V0Q3VycmVudFRpbWUodGltZSkge1xuICAgICAgICAgICAgICAgIGlmIChfY29uZmlnPy50eXBlICE9PSAnTGl2ZVN0cmVhbScpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ2N1cnJlbnRUaW1lJywgdGltZS50b1N0cmluZygpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBhZGRFdmVudExpc3RlbmVyKGV2ZW50LCBmLCBib29sKSB7XG4gICAgICAgICAgICAgICAgaWYgKF9ldmVudE5hbWVzLmluZGV4T2YoZXZlbnQpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIV9ldmVudEhhbmRsZXJzW2V2ZW50XSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX2V2ZW50SGFuZGxlcnNbZXZlbnRdID0gW107XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgX2V2ZW50SGFuZGxlcnNbZXZlbnRdLnB1c2goZik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmlkZW8uYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgZiwgYm9vbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgY2xlYXJFdmVudEhhbmRsZXJzKCkge1xuICAgICAgICAgICAgICAgIF9ldmVudE5hbWVzLmZvckVhY2goKGV2ZW50TmFtZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBoYW5kbGVycyA9IF9ldmVudEhhbmRsZXJzW2V2ZW50TmFtZV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChoYW5kbGVycyAmJiBoYW5kbGVycy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGVycy5mb3JFYWNoKChoYW5kbGVyKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmlkZW8ucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGhhbmRsZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIHRyaWdnZXIoZXZlbnROYW1lLCBhcmdzKSB7XG4gICAgICAgICAgICAgICAgbGV0IGo7XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtbWVtYmVyLWFjY2Vzc1xuICAgICAgICAgICAgICAgIGNvbnN0IGhhbmRsZXJzID0gX2V2ZW50SGFuZGxlcnNbZXZlbnROYW1lXTtcblxuICAgICAgICAgICAgICAgIGlmIChldmVudE5hbWUgPT09ICdjYW5yZWNvcmQnKSB7XG4gICAgICAgICAgICAgICAgICAgIGluaXRTaXplKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChoYW5kbGVycyAmJiBoYW5kbGVycy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBoYW5kbGVycy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlcnNbal0uYXBwbHkoaW5wdXRTdHJlYW0sIGFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgc2V0VG9wUmlnaHQodG9wUmlnaHQpIHtcbiAgICAgICAgICAgICAgICBfdG9wUmlnaHQueCA9IHRvcFJpZ2h0Lng7XG4gICAgICAgICAgICAgICAgX3RvcFJpZ2h0LnkgPSB0b3BSaWdodC55O1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgZ2V0VG9wUmlnaHQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF90b3BSaWdodDtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIHNldENhbnZhc1NpemUoc2l6ZSkge1xuICAgICAgICAgICAgICAgIF9jYW52YXNTaXplLnggPSBzaXplLng7XG4gICAgICAgICAgICAgICAgX2NhbnZhc1NpemUueSA9IHNpemUueTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGdldENhbnZhc1NpemUoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jYW52YXNTaXplO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgZ2V0RnJhbWUoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZpZGVvO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGlucHV0U3RyZWFtO1xuICAgIH0sXG4gICAgY3JlYXRlTGl2ZVN0cmVhbSh2aWRlbyk6IElucHV0U3RyZWFtIHtcbiAgICAgICAgY29uc29sZS53YXJuKCcqKioqIElucHV0U3RyZWFtQnJvd3NlciBjcmVhdGVMaXZlU3RyZWFtJyk7XG4gICAgICAgIGlmICh2aWRlbykge1xuICAgICAgICAgICAgdmlkZW8uc2V0QXR0cmlidXRlKCdhdXRvcGxheScsICd0cnVlJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdGhhdCA9IGlucHV0U3RyZWFtRmFjdG9yeS5jcmVhdGVWaWRlb1N0cmVhbSh2aWRlbyk7XG4gICAgICAgIHRoYXQuZW5kZWQgPSBmdW5jdGlvbiBlbmRlZCgpOiBmYWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB0aGF0O1xuICAgIH0sXG4gICAgY3JlYXRlSW1hZ2VTdHJlYW0oKTogSW5wdXRTdHJlYW0ge1xuICAgICAgICAvLyBjb25zb2xlLndhcm4oJyoqKiogSW5wdXRTdHJlYW1Ccm93c2VyIGNyZWF0ZUltYWdlU3RyZWFtJyk7XG4gICAgICAgIGxldCBfY29uZmlnOiB7IHNpemU6IG51bWJlcjsgc2VxdWVuY2U6IGFueSB9IHwgbnVsbCA9IG51bGw7XG5cbiAgICAgICAgbGV0IHdpZHRoID0gMDtcbiAgICAgICAgbGV0IGhlaWdodCA9IDA7XG4gICAgICAgIGxldCBmcmFtZUlkeCA9IDA7XG4gICAgICAgIGxldCBwYXVzZWQgPSB0cnVlO1xuICAgICAgICBsZXQgbG9hZGVkID0gZmFsc2U7XG4gICAgICAgIGxldCBpbWdBcnJheTogYW55W10gfCBudWxsID0gbnVsbDtcbiAgICAgICAgbGV0IHNpemUgPSAwO1xuICAgICAgICBjb25zdCBvZmZzZXQgPSAxO1xuICAgICAgICBsZXQgYmFzZVVybDogc3RyaW5nIHwgbnVsbCA9IG51bGw7XG4gICAgICAgIGxldCBlbmRlZCA9IGZhbHNlO1xuICAgICAgICBsZXQgY2FsY3VsYXRlZFdpZHRoOiBudW1iZXI7XG4gICAgICAgIGxldCBjYWxjdWxhdGVkSGVpZ2h0OiBudW1iZXI7XG4gICAgICAgIGNvbnN0IF9ldmVudE5hbWVzID0gWydjYW5yZWNvcmQnLCAnZW5kZWQnXTtcbiAgICAgICAgY29uc3QgX2V2ZW50SGFuZGxlcnM6IEV2ZW50SGFuZGxlckxpc3QgPSB7fTtcbiAgICAgICAgY29uc3QgX3RvcFJpZ2h0OiBQb2ludCA9IHsgeDogMCwgeTogMCwgdHlwZTogJ1BvaW50JyB9O1xuICAgICAgICBjb25zdCBfY2FudmFzU2l6ZTogWFlTaXplID0geyB4OiAwLCB5OiAwLCB0eXBlOiAnWFlTaXplJyB9O1xuXG4gICAgICAgIGZ1bmN0aW9uIGxvYWRJbWFnZXMoKTogdm9pZCB7XG4gICAgICAgICAgICBsb2FkZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIEltYWdlTG9hZGVyLmxvYWQoYmFzZVVybCwgKGltZ3M6IEFycmF5PHsgdGFnczogYW55OyBpbWc6IEhUTUxJbWFnZUVsZW1lbnR9PikgPT4ge1xuICAgICAgICAgICAgICAgIGltZ0FycmF5ID0gaW1ncztcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1tZW1iZXItYWNjZXNzXG4gICAgICAgICAgICAgICAgaWYgKGltZ3NbMF0udGFncyAmJiBpbWdzWzBdLnRhZ3Mub3JpZW50YXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtbWVtYmVyLWFjY2Vzc1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGltZ3NbMF0udGFncy5vcmllbnRhdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoID0gaW1nc1swXS5pbWcuaGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodCA9IGltZ3NbMF0uaW1nLndpZHRoO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWR0aCA9IGltZ3NbMF0uaW1nLndpZHRoO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodCA9IGltZ3NbMF0uaW1nLmhlaWdodDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHdpZHRoID0gaW1nc1swXS5pbWcud2lkdGg7XG4gICAgICAgICAgICAgICAgICAgIGhlaWdodCA9IGltZ3NbMF0uaW1nLmhlaWdodDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLW5lc3RlZC10ZXJuYXJ5XG4gICAgICAgICAgICAgICAgY2FsY3VsYXRlZFdpZHRoID0gX2NvbmZpZz8uc2l6ZSA/IHdpZHRoIC8gaGVpZ2h0ID4gMSA/IF9jb25maWcuc2l6ZSA6IE1hdGguZmxvb3IoKHdpZHRoIC8gaGVpZ2h0KSAqIF9jb25maWcuc2l6ZSkgOiB3aWR0aDtcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbmVzdGVkLXRlcm5hcnlcbiAgICAgICAgICAgICAgICBjYWxjdWxhdGVkSGVpZ2h0ID0gX2NvbmZpZz8uc2l6ZSA/IHdpZHRoIC8gaGVpZ2h0ID4gMSA/IE1hdGguZmxvb3IoKGhlaWdodCAvIHdpZHRoKSAqIF9jb25maWcuc2l6ZSkgOiBfY29uZmlnLnNpemUgOiBoZWlnaHQ7XG4gICAgICAgICAgICAgICAgX2NhbnZhc1NpemUueCA9IGNhbGN1bGF0ZWRXaWR0aDtcbiAgICAgICAgICAgICAgICBfY2FudmFzU2l6ZS55ID0gY2FsY3VsYXRlZEhlaWdodDtcbiAgICAgICAgICAgICAgICBsb2FkZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGZyYW1lSWR4ID0gMDtcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11c2UtYmVmb3JlLWRlZmluZVxuICAgICAgICAgICAgICAgICAgICBwdWJsaXNoRXZlbnQoJ2NhbnJlY29yZCcsIFtdKTtcbiAgICAgICAgICAgICAgICB9LCAwKTtcbiAgICAgICAgICAgIH0sIG9mZnNldCwgc2l6ZSwgX2NvbmZpZz8uc2VxdWVuY2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gcHVibGlzaEV2ZW50KGV2ZW50TmFtZTogc3RyaW5nLCBhcmdzOiBBcnJheTxhbnk+KTogdm9pZCB7XG4gICAgICAgICAgICBsZXQgajtcbiAgICAgICAgICAgIGNvbnN0IGhhbmRsZXJzID0gX2V2ZW50SGFuZGxlcnNbZXZlbnROYW1lXTtcblxuICAgICAgICAgICAgaWYgKGhhbmRsZXJzICYmIGhhbmRsZXJzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgaGFuZGxlcnMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11c2UtYmVmb3JlLWRlZmluZVxuICAgICAgICAgICAgICAgICAgICBoYW5kbGVyc1tqXS5hcHBseShpbnB1dFN0cmVhbSwgYXJncyBhcyBhbnkpOyAvLyBUT0RPOiB0eXBlc2NyaXB0IGNvbXBsYWlucyB0aGF0IGFueVtdIGlzIG5vdCB2YWxpZCBmb3IgYSBzZWNvbmQgYXJnIGZvciBhcHBseT8hXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gVE9ETzogYW55IGNvZGUgc2hhcmVkIHdpdGggdGhlIGZpcnN0IElucHV0U3RyZWFtIGFib3ZlIHNob3VsZCBiZSBzaGFyZWQgbm90IGNvcGllZFxuICAgICAgICAvLyBUT0RPOiBwdWJsaXNoRXZlbnQgbmVlZHMgYWNjZXNzIHRvIGlucHV0U3RyZWFtLCBidXQgaW5wdXRTdHJlYW0gbmVlZHMgYWNjZXNzIHRvIHB1Ymxpc2hFdmVudFxuICAgICAgICAvLyBUT0RPOiBUaGlzIGlzIHdoeSBpdCdzIGEgJ3ZhcicsIHNvIGl0IGhvaXN0cyBiYWNrLiAgVGhpcyBpcyB1Z2x5LCBhbmQgc2hvdWxkIGJlIGNoYW5nZWQuXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby12YXIsdmFycy1vbi10b3BcbiAgICAgICAgdmFyIGlucHV0U3RyZWFtOiBJbnB1dFN0cmVhbSA9IHtcblxuICAgICAgICAgICAgdHJpZ2dlcjogcHVibGlzaEV2ZW50LFxuXG4gICAgICAgICAgICBnZXRXaWR0aCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FsY3VsYXRlZFdpZHRoO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgZ2V0SGVpZ2h0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjYWxjdWxhdGVkSGVpZ2h0O1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgc2V0V2lkdGgobmV3V2lkdGgpIHtcbiAgICAgICAgICAgICAgICBjYWxjdWxhdGVkV2lkdGggPSBuZXdXaWR0aDtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIHNldEhlaWdodChuZXdIZWlnaHQpIHtcbiAgICAgICAgICAgICAgICBjYWxjdWxhdGVkSGVpZ2h0ID0gbmV3SGVpZ2h0O1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgZ2V0UmVhbFdpZHRoKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB3aWR0aDtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGdldFJlYWxIZWlnaHQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGhlaWdodDtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIHNldElucHV0U3RyZWFtKHN0cmVhbSkge1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWFzc2lnbm1lbnRcbiAgICAgICAgICAgICAgICBfY29uZmlnID0gc3RyZWFtO1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLW1lbWJlci1hY2Nlc3NcbiAgICAgICAgICAgICAgICBpZiAoc3RyZWFtLnNlcXVlbmNlID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1hc3NpZ25tZW50LEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtbWVtYmVyLWFjY2Vzc1xuICAgICAgICAgICAgICAgICAgICBiYXNlVXJsID0gc3RyZWFtLnNyYztcbiAgICAgICAgICAgICAgICAgICAgc2l6ZSA9IDE7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtYXNzaWdubWVudCxAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLW1lbWJlci1hY2Nlc3NcbiAgICAgICAgICAgICAgICAgICAgYmFzZVVybCA9IHN0cmVhbS5zcmM7XG4gICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWFzc2lnbm1lbnQsQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1tZW1iZXItYWNjZXNzXG4gICAgICAgICAgICAgICAgICAgIHNpemUgPSBzdHJlYW0ubGVuZ3RoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsb2FkSW1hZ2VzKCk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBlbmRlZCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZW5kZWQ7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBzZXRBdHRyaWJ1dGUoKSB7fSxcblxuICAgICAgICAgICAgZ2V0Q29uZmlnKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfY29uZmlnO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgcGF1c2UoKSB7XG4gICAgICAgICAgICAgICAgcGF1c2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIHBsYXkoKSB7XG4gICAgICAgICAgICAgICAgcGF1c2VkID0gZmFsc2U7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBzZXRDdXJyZW50VGltZSh0aW1lKSB7XG4gICAgICAgICAgICAgICAgZnJhbWVJZHggPSB0aW1lO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgZikge1xuICAgICAgICAgICAgICAgIGlmIChfZXZlbnROYW1lcy5pbmRleE9mKGV2ZW50KSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFfZXZlbnRIYW5kbGVyc1tldmVudF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9ldmVudEhhbmRsZXJzW2V2ZW50XSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIF9ldmVudEhhbmRsZXJzW2V2ZW50XS5wdXNoKGYpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGNsZWFyRXZlbnRIYW5kbGVycygpIHtcbiAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyhfZXZlbnRIYW5kbGVycykuZm9yRWFjaCgoaW5kKSA9PiBkZWxldGUgX2V2ZW50SGFuZGxlcnNbaW5kXSk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBzZXRUb3BSaWdodCh0b3BSaWdodCkge1xuICAgICAgICAgICAgICAgIF90b3BSaWdodC54ID0gdG9wUmlnaHQueDtcbiAgICAgICAgICAgICAgICBfdG9wUmlnaHQueSA9IHRvcFJpZ2h0Lnk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBnZXRUb3BSaWdodCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3RvcFJpZ2h0O1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgc2V0Q2FudmFzU2l6ZShjYW52YXNTaXplKSB7XG4gICAgICAgICAgICAgICAgX2NhbnZhc1NpemUueCA9IGNhbnZhc1NpemUueDtcbiAgICAgICAgICAgICAgICBfY2FudmFzU2l6ZS55ID0gY2FudmFzU2l6ZS55O1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgZ2V0Q2FudmFzU2l6ZSgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NhbnZhc1NpemU7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBnZXRGcmFtZSgpIHtcbiAgICAgICAgICAgICAgICBsZXQgZnJhbWU7XG5cbiAgICAgICAgICAgICAgICBpZiAoIWxvYWRlZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFwYXVzZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtYXNzaWdubWVudFxuICAgICAgICAgICAgICAgICAgICBmcmFtZSA9IGltZ0FycmF5Py5bZnJhbWVJZHhdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZnJhbWVJZHggPCAoc2l6ZSAtIDEpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmcmFtZUlkeCsrO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHB1Ymxpc2hFdmVudCgnZW5kZWQnLCBbXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LCAwKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1yZXR1cm5cbiAgICAgICAgICAgICAgICByZXR1cm4gZnJhbWU7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gaW5wdXRTdHJlYW07XG4gICAgfSxcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGlucHV0U3RyZWFtRmFjdG9yeTtcbiIsImltcG9ydCB7IFF1YWdnYUpTQ29uZmlnT2JqZWN0IH0gZnJvbSBcIi4uL3R5cGUtZGVmaW5pdGlvbnMvcXVhZ2dhXCI7XG5pbXBvcnQgSW1hZ2VXcmFwcGVyIGZyb20gXCJjb21tb24vaW1hZ2Vfd3JhcHBlclwiO1xuXG5leHBvcnQgY2xhc3MgUXVhZ2dhQ29udGV4dCB7XG4gICAgcHVibGljIGNvbmZpZz86IFF1YWdnYUpTQ29uZmlnT2JqZWN0O1xuXG4gICAgcHVibGljIGlucHV0U3RyZWFtOiBhbnk7XG5cbiAgICBwdWJsaWMgZnJhbWVncmFiYmVyOiBhbnk7XG5cbiAgICBwdWJsaWMgaW5wdXRJbWFnZVdyYXBwZXI/OiBJbWFnZVdyYXBwZXI7XG5cbiAgICBwdWJsaWMgc3RvcHBlZDogYm9vbGVhbiA9IGZhbHNlO1xuXG4gICAgcHVibGljIGJveFNpemU6IGFueTtcblxuICAgIHB1YmxpYyByZXN1bHRDb2xsZWN0b3I6IGFueTtcblxuICAgIHB1YmxpYyBkZWNvZGVyOiBhbnk7XG5cbiAgICBwdWJsaWMgd29ya2VyUG9vbDogYW55W10gPSBbXTtcblxuICAgIHB1YmxpYyBvblVJVGhyZWFkID0gdHJ1ZTtcblxuICAgIHB1YmxpYyByZWFkb25seSBjYW52YXNDb250YWluZXIgPSBuZXcgQ2FudmFzQ29udGFpbmVyKCk7XG59XG5cbmV4cG9ydCBjbGFzcyBDYW52YXNJbmZvIHtcbiAgICBpbWFnZTogYW55O1xuICAgIG92ZXJsYXk6IGFueTtcbn1cblxuZXhwb3J0IGNsYXNzIENhbnZhc0NvbnRhaW5lciB7XG4gICAgcHVibGljIHJlYWRvbmx5IGN0eDogQ2FudmFzSW5mbztcbiAgICBwdWJsaWMgcmVhZG9ubHkgZG9tOiBDYW52YXNJbmZvO1xuXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuY3R4ID0gbmV3IENhbnZhc0luZm8oKTtcbiAgICAgICAgdGhpcy5kb20gPSBuZXcgQ2FudmFzSW5mbygpO1xuICAgIH1cbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldFZpZXdQb3J0KHRhcmdldD86IEVsZW1lbnQgfCBzdHJpbmcpOiBFbGVtZW50IHwgbnVsbCB7XG4gICAgaWYgKHR5cGVvZiBkb2N1bWVudCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgaWYgdGFyZ2V0IGlzIGFscmVhZHkgYSBET00gZWxlbWVudFxuICAgIGlmICh0YXJnZXQgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCAmJiB0YXJnZXQubm9kZU5hbWUgJiYgdGFyZ2V0Lm5vZGVUeXBlID09PSAxKSB7XG4gICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfVxuICAgIC8vIFVzZSAnI2ludGVyYWN0aXZlLnZpZXdwb3J0JyBhcyBhIGZhbGxiYWNrIHNlbGVjdG9yIChiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSlcbiAgICBjb25zdCBzZWxlY3RvciA9IHR5cGVvZiB0YXJnZXQgPT09ICdzdHJpbmcnID8gdGFyZ2V0IDogJyNpbnRlcmFjdGl2ZS52aWV3cG9ydCc7XG4gICAgcmV0dXJuIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3Ioc2VsZWN0b3IpO1xufVxuIiwiaW1wb3J0IHsgY2xvbmUgfSBmcm9tICdnbC12ZWMyJztcbmltcG9ydCBJbWFnZVdyYXBwZXIgZnJvbSAnLi4vY29tbW9uL2ltYWdlX3dyYXBwZXInO1xuaW1wb3J0IHR5cGUgeyBJbnB1dFN0cmVhbSB9IGZyb20gJy4uL2lucHV0L2lucHV0X3N0cmVhbS9pbnB1dF9zdHJlYW0uZCc7XG5pbXBvcnQgQmFyY29kZUxvY2F0b3IgZnJvbSAnLi4vbG9jYXRvci9iYXJjb2RlX2xvY2F0b3InO1xuXG50eXBlIEJ1ZmZlclJldHVybiA9IHtcbiAgICAvLyBib3hTaXplIHNob3VsZCBiZSBsaWtlIFtbIG51bWJlciwgbnVtYmVyXSwgLi4uXSBidXQgY2xvbmUncyBzaWduYXR1cmUgZG9lc24ndCBzZWVtIHRvIGFsbG93IHRoYXRcbiAgICBib3hTaXplOiBBcnJheTxBcnJheTxudW1iZXI+PjtcbiAgICBpbnB1dEltYWdlV3JhcHBlcjogSW1hZ2VXcmFwcGVyO1xufTtcblxuLy8gVE9ETzogbmVlZCB0eXBlc2NyaXB0IGRlZiBmb3IgQmFyY29kZUxvY2F0b3JcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGluaXRCdWZmZXJzKFxuICAgIGlucHV0U3RyZWFtOiBJbnB1dFN0cmVhbSxcbiAgICBpbWFnZVdyYXBwZXI6IEltYWdlV3JhcHBlciB8IHVuZGVmaW5lZCxcbiAgICBsb2NhdG9yOiBhbnksXG4pOiBCdWZmZXJSZXR1cm4ge1xuICAgIGNvbnN0IGlucHV0SW1hZ2VXcmFwcGVyID0gaW1hZ2VXcmFwcGVyIHx8IG5ldyBJbWFnZVdyYXBwZXIoe1xuICAgICAgICB4OiBpbnB1dFN0cmVhbS5nZXRXaWR0aCgpLFxuICAgICAgICB5OiBpbnB1dFN0cmVhbS5nZXRIZWlnaHQoKSxcbiAgICAgICAgdHlwZTogJ1hZU2l6ZScsXG4gICAgfSk7XG5cbiAgICBpZiAoRU5WLmRldmVsb3BtZW50KSB7XG4gICAgICAgIGNvbnNvbGUubG9nKGBpbWFnZSB3cmFwcGVyIHNpemUgJHtpbnB1dEltYWdlV3JhcHBlci5zaXplfWApO1xuICAgIH1cbiAgICBjb25zdCBib3hTaXplID0gW1xuICAgICAgICBjbG9uZShbMCwgMF0pLFxuICAgICAgICBjbG9uZShbMCwgaW5wdXRJbWFnZVdyYXBwZXIuc2l6ZS55XSksXG4gICAgICAgIGNsb25lKFtpbnB1dEltYWdlV3JhcHBlci5zaXplLngsIGlucHV0SW1hZ2VXcmFwcGVyLnNpemUueV0pLFxuICAgICAgICBjbG9uZShbaW5wdXRJbWFnZVdyYXBwZXIuc2l6ZS54LCAwXSksXG4gICAgXTtcbiAgICBCYXJjb2RlTG9jYXRvci5pbml0KGlucHV0SW1hZ2VXcmFwcGVyLCBsb2NhdG9yKTtcbiAgICByZXR1cm4geyBpbnB1dEltYWdlV3JhcHBlciwgYm94U2l6ZSB9O1xufVxuIiwiaW1wb3J0IHsgUXVhZ2dhQ29udGV4dCwgQ2FudmFzQ29udGFpbmVyIH0gZnJvbSAnUXVhZ2dhQ29udGV4dCc7XG5pbXBvcnQgdHlwZSB7IFhZU2l6ZSB9IGZyb20gJy4uLy4uL3R5cGUtZGVmaW5pdGlvbnMvcXVhZ2dhLmQnO1xuaW1wb3J0IGdldFZpZXdQb3J0IGZyb20gJy4vZ2V0Vmlld1BvcnQnO1xuXG5mdW5jdGlvbiBmaW5kT3JDcmVhdGVDYW52YXMoc2VsZWN0b3I6IHN0cmluZywgY2xhc3NOYW1lOiBzdHJpbmcpIHtcbiAgICBsZXQgY2FudmFzOiBIVE1MQ2FudmFzRWxlbWVudCB8IG51bGwgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHNlbGVjdG9yKTtcbiAgICBpZiAoIWNhbnZhcykge1xuICAgICAgICBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICAgICAgY2FudmFzLmNsYXNzTmFtZSA9IGNsYXNzTmFtZTtcbiAgICB9XG4gICAgcmV0dXJuIGNhbnZhcztcbn1cblxuZnVuY3Rpb24gZ2V0Q2FudmFzQW5kQ29udGV4dChzZWxlY3Rvcjogc3RyaW5nLCBjbGFzc05hbWU6IHN0cmluZykge1xuICAgIGNvbnN0IGNhbnZhcyA9IGZpbmRPckNyZWF0ZUNhbnZhcyhzZWxlY3RvciwgY2xhc3NOYW1lKTtcbiAgICBjb25zdCBjb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgcmV0dXJuIHsgY2FudmFzLCBjb250ZXh0IH07XG59XG5cbmZ1bmN0aW9uIGluaXRDYW52YXNlcyhjYW52YXNTaXplOiBYWVNpemUpOiBDYW52YXNDb250YWluZXIgfCBudWxsIHtcbiAgICBpZiAodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBjb25zdCBpbWFnZSA9IGdldENhbnZhc0FuZENvbnRleHQoJ2NhbnZhcy5pbWdCdWZmZXInLCAnaW1nQnVmZmVyJyk7XG4gICAgICAgIGNvbnN0IG92ZXJsYXkgPSBnZXRDYW52YXNBbmRDb250ZXh0KCdjYW52YXMuZHJhd2luZ0J1ZmZlcicsICdkcmF3aW5nQnVmZmVyJyk7XG5cbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLW11bHRpLWFzc2lnblxuICAgICAgICBpbWFnZS5jYW52YXMud2lkdGggPSBvdmVybGF5LmNhbnZhcy53aWR0aCA9IGNhbnZhc1NpemUueDtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLW11bHRpLWFzc2lnblxuICAgICAgICBpbWFnZS5jYW52YXMuaGVpZ2h0ID0gb3ZlcmxheS5jYW52YXMuaGVpZ2h0ID0gY2FudmFzU2l6ZS55O1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkb206IHtcbiAgICAgICAgICAgICAgICBpbWFnZTogaW1hZ2UuY2FudmFzLFxuICAgICAgICAgICAgICAgIG92ZXJsYXk6IG92ZXJsYXkuY2FudmFzLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGN0eDoge1xuICAgICAgICAgICAgICAgIGltYWdlOiBpbWFnZS5jb250ZXh0LFxuICAgICAgICAgICAgICAgIG92ZXJsYXk6IG92ZXJsYXkuY29udGV4dCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBpbml0Q2FudmFzKGNvbnRleHQ6IFF1YWdnYUNvbnRleHQpOiBDYW52YXNDb250YWluZXIgfCBudWxsIHtcbiAgICBjb25zdCB2aWV3cG9ydCA9IGdldFZpZXdQb3J0KGNvbnRleHQ/LmNvbmZpZz8uaW5wdXRTdHJlYW0/LnRhcmdldCk7XG4gICAgY29uc3QgdHlwZSA9IGNvbnRleHQ/LmNvbmZpZz8uaW5wdXRTdHJlYW0/LnR5cGU7XG4gICAgaWYgKCF0eXBlKSByZXR1cm4gbnVsbDtcbiAgICBjb25zdCBjb250YWluZXIgPSBpbml0Q2FudmFzZXMoY29udGV4dC5pbnB1dFN0cmVhbS5nZXRDYW52YXNTaXplKCkpO1xuICAgIGlmICghY29udGFpbmVyKSByZXR1cm4geyBkb206IHsgaW1hZ2U6IG51bGwsIG92ZXJsYXk6IG51bGwgfSwgY3R4OiB7IGltYWdlOiBudWxsLCBvdmVybGF5OiBudWxsIH0gfTtcblxuICAgIGNvbnN0IHsgZG9tIH0gPSBjb250YWluZXI7XG4gICAgaWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgaWYgKHZpZXdwb3J0KSB7XG4gICAgICAgICAgICBpZiAodHlwZSA9PT0gJ0ltYWdlU3RyZWFtJyAmJiAhdmlld3BvcnQuY29udGFpbnMoZG9tLmltYWdlKSkge1xuICAgICAgICAgICAgICAgIHZpZXdwb3J0LmFwcGVuZENoaWxkKGRvbS5pbWFnZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXZpZXdwb3J0LmNvbnRhaW5zKGRvbS5vdmVybGF5KSkge1xuICAgICAgICAgICAgICAgIHZpZXdwb3J0LmFwcGVuZENoaWxkKGRvbS5vdmVybGF5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY29udGFpbmVyO1xufVxuIiwiLyogV29ya2VyIGZ1bmN0aW9ucy4gVGhlc2UgYXJlIHN0cmFpZ2h0IGZyb20gdGhlIG9yaWdpbmFsIHF1YWdnYS5qcyBmaWxlLlxuICogTm90IHByZXNlbnRseSB1c2VkLCBhcyB3b3JrZXIgc3VwcG9ydCBpcyBub24tZnVuY3Rpb25hbC4gIEtlZXBpbmcgdGhlbSBhcm91bmQgdGVtcG9yYXJpbHlcbiAqIHRvIHJlZmVyIHRvIHVudGlsIGl0IGlzIHJlLWltcGxlbWVudGVkLiBXZSBtYXkgYmUgYWJsZSB0byBmaXgvdXNlIHNvbWUgb2YgdGhpcy5cbiAqL1xuXG5pbXBvcnQgeyBRdWFnZ2FKU0NvbmZpZ09iamVjdCwgUXVhZ2dhSlNSZWFkZXJDb25maWcgfSBmcm9tIFwiLi4vLi4vdHlwZS1kZWZpbml0aW9ucy9xdWFnZ2FcIjtcblxuLy8gVE9ETzogbmVlZCBhIHR5cGVzY3JpcHQgaW50ZXJmYWNlIGZvciBGcmFtZUdyYWJiZXJcblxuaW50ZXJmYWNlIFFXb3JrZXJUaHJlYWQge1xuICAgIGltYWdlRGF0YTogVWludDhBcnJheTtcbiAgICBidXN5OiBib29sZWFuO1xuICAgIHdvcmtlcjogV29ya2VyO1xufVxuXG5sZXQgd29ya2VyUG9vbDogQXJyYXk8UVdvcmtlclRocmVhZD4gPSBbXTtcblxuZXhwb3J0IGZ1bmN0aW9uIHVwZGF0ZVdvcmtlcnMoZnJhbWVHcmFiYmVyOiBhbnkpIHtcbiAgICBsZXQgYXZhaWxhYmxlV29ya2VyOiBRV29ya2VyVGhyZWFkO1xuICAgIGlmICh3b3JrZXJQb29sLmxlbmd0aCkge1xuICAgICAgICBhdmFpbGFibGVXb3JrZXIgPSB3b3JrZXJQb29sLmZpbHRlcigod29ya2VyVGhyZWFkKSA9PiAhd29ya2VyVGhyZWFkLmJ1c3kpWzBdO1xuICAgICAgICBpZiAoYXZhaWxhYmxlV29ya2VyKSB7XG4gICAgICAgICAgICBmcmFtZUdyYWJiZXIuYXR0YWNoRGF0YShhdmFpbGFibGVXb3JrZXIuaW1hZ2VEYXRhKTtcbiAgICAgICAgICAgIGlmIChmcmFtZUdyYWJiZXIuZ3JhYigpKSB7XG4gICAgICAgICAgICAgICAgYXZhaWxhYmxlV29ya2VyLmJ1c3kgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGF2YWlsYWJsZVdvcmtlci53b3JrZXIucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgICAgICAgICAgICBjbWQ6ICdwcm9jZXNzJyxcbiAgICAgICAgICAgICAgICAgICAgaW1hZ2VEYXRhOiBhdmFpbGFibGVXb3JrZXIuaW1hZ2VEYXRhLFxuICAgICAgICAgICAgICAgIH0sIFthdmFpbGFibGVXb3JrZXIuaW1hZ2VEYXRhLmJ1ZmZlcl0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIGNvbmZpZ0Zvcldvcmtlcihjb25maWc6IFF1YWdnYUpTQ29uZmlnT2JqZWN0KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLi4uY29uZmlnLFxuICAgICAgICBpbnB1dFN0cmVhbToge1xuICAgICAgICAgICAgLi4uY29uZmlnLmlucHV0U3RyZWFtLFxuICAgICAgICAgICAgdGFyZ2V0OiBudWxsLFxuICAgICAgICB9LFxuICAgIH07XG59XG5cbi8vIEB0cy1pZ25vcmVcbmZ1bmN0aW9uIHdvcmtlckludGVyZmFjZShmYWN0b3J5KSB7XG4gICAgaWYgKGZhY3RvcnkpIHtcbiAgICAgICAgdmFyIFF1YWdnYSA9IGZhY3RvcnkoKS5kZWZhdWx0O1xuICAgICAgICBpZiAoIVF1YWdnYSkge1xuLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgc2VsZi5wb3N0TWVzc2FnZSh7ICdldmVudCc6ICdlcnJvcicsIG1lc3NhZ2U6ICdRdWFnZ2EgY291bGQgbm90IGJlIGNyZWF0ZWQnIH0pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgfVxuLy8gQHRzLWlnbm9yZVxuICAgIHZhciBpbWFnZVdyYXBwZXI7XG5cbi8vIEB0cy1pZ25vcmVcbiAgICBmdW5jdGlvbiBvblByb2Nlc3NlZChyZXN1bHQpIHtcbiAgICAgICAgc2VsZi5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgICAnZXZlbnQnOiAncHJvY2Vzc2VkJyxcbi8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIGltYWdlRGF0YTogaW1hZ2VXcmFwcGVyLmRhdGEsXG4gICAgICAgICAgICByZXN1bHQ6IHJlc3VsdCxcbi8vIEB0cy1pZ25vcmVcbiAgICAgICAgfSwgW2ltYWdlV3JhcHBlci5kYXRhLmJ1ZmZlcl0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHdvcmtlckludGVyZmFjZVJlYWR5KCkge1xuICAgICAgICBzZWxmLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICAgICdldmVudCc6ICdpbml0aWFsaXplZCcsXG4vLyBAdHMtaWdub3JlXG4gICAgICAgICAgICBpbWFnZURhdGE6IGltYWdlV3JhcHBlci5kYXRhLFxuLy8gQHRzLWlnbm9yZVxuICAgICAgICB9LCBbaW1hZ2VXcmFwcGVyLmRhdGEuYnVmZmVyXSk7XG4gICAgfVxuXG4vLyBAdHMtaWdub3JlXG4gICAgc2VsZi5vbm1lc3NhZ2UgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICBpZiAoZS5kYXRhLmNtZCA9PT0gJ2luaXQnKSB7XG4gICAgICAgICAgICB2YXIgY29uZmlnID0gZS5kYXRhLmNvbmZpZztcbiAgICAgICAgICAgIGNvbmZpZy5udW1PZldvcmtlcnMgPSAwO1xuICAgICAgICAgICAgaW1hZ2VXcmFwcGVyID0gbmV3IFF1YWdnYS5JbWFnZVdyYXBwZXIoe1xuICAgICAgICAgICAgICAgIHg6IGUuZGF0YS5zaXplLngsXG4gICAgICAgICAgICAgICAgeTogZS5kYXRhLnNpemUueSxcbiAgICAgICAgICAgIH0sIG5ldyBVaW50OEFycmF5KGUuZGF0YS5pbWFnZURhdGEpKTtcbiAgICAgICAgICAgIFF1YWdnYS5pbml0KGNvbmZpZywgd29ya2VySW50ZXJmYWNlUmVhZHksIGltYWdlV3JhcHBlcik7XG4gICAgICAgICAgICBRdWFnZ2Eub25Qcm9jZXNzZWQob25Qcm9jZXNzZWQpO1xuICAgICAgICB9IGVsc2UgaWYgKGUuZGF0YS5jbWQgPT09ICdwcm9jZXNzJykge1xuLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgaW1hZ2VXcmFwcGVyLmRhdGEgPSBuZXcgVWludDhBcnJheShlLmRhdGEuaW1hZ2VEYXRhKTtcbiAgICAgICAgICAgIFF1YWdnYS5zdGFydCgpO1xuICAgICAgICB9IGVsc2UgaWYgKGUuZGF0YS5jbWQgPT09ICdzZXRSZWFkZXJzJykge1xuICAgICAgICAgICAgUXVhZ2dhLnNldFJlYWRlcnMoZS5kYXRhLnJlYWRlcnMpO1xuICAgICAgICB9IGVsc2UgaWYgKGUuZGF0YS5jbWQgPT09ICdyZWdpc3RlclJlYWRlcicpIHtcbiAgICAgICAgICAgIFF1YWdnYS5yZWdpc3RlclJlYWRlcihlLmRhdGEubmFtZSwgZS5kYXRhLnJlYWRlcik7XG4gICAgICAgIH1cbiAgICB9O1xufVxuXG5mdW5jdGlvbiBnZW5lcmF0ZVdvcmtlckJsb2IoKSB7XG4gICAgdmFyIGJsb2IsXG4gICAgICAgIGZhY3RvcnlTb3VyY2U7XG5cbiAgICAvKiBqc2hpbnQgaWdub3JlOnN0YXJ0ICovXG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIGlmICh0eXBlb2YgX19mYWN0b3J5U291cmNlX18gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgZmFjdG9yeVNvdXJjZSA9IF9fZmFjdG9yeVNvdXJjZV9fOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG4gICAgfVxuICAgIC8qIGpzaGludCBpZ25vcmU6ZW5kICovXG5cbiAgICBibG9iID0gbmV3IEJsb2IoWycoJyArIHdvcmtlckludGVyZmFjZS50b1N0cmluZygpICsgJykoJyArIGZhY3RvcnlTb3VyY2UgKyAnKTsnXSxcbiAgICAgICAgeyB0eXBlOiAndGV4dC9qYXZhc2NyaXB0JyB9KTtcblxuICAgIHJldHVybiB3aW5kb3cuVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGluaXRXb3JrZXIoY29uZmlnOiBRdWFnZ2FKU0NvbmZpZ09iamVjdCwgaW5wdXRTdHJlYW06IGFueSwgY2I6IEZ1bmN0aW9uKSB7XG4gICAgY29uc3QgYmxvYlVSTCA9IGdlbmVyYXRlV29ya2VyQmxvYigpO1xuICAgIGNvbnN0IHdvcmtlciA9IG5ldyBXb3JrZXIoYmxvYlVSTCk7XG5cbiAgICBjb25zdCB3b3JrZXJUaHJlYWQ6IFFXb3JrZXJUaHJlYWQgPSB7XG4gICAgICAgIHdvcmtlcixcbiAgICAgICAgaW1hZ2VEYXRhOiBuZXcgVWludDhBcnJheShpbnB1dFN0cmVhbS5nZXRXaWR0aCgpICogaW5wdXRTdHJlYW0uZ2V0SGVpZ2h0KCkpLFxuICAgICAgICBidXN5OiB0cnVlLFxuICAgIH07XG5cbiAgICB3b3JrZXJUaHJlYWQud29ya2VyLm9ubWVzc2FnZSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGlmIChlLmRhdGEuZXZlbnQgPT09ICdpbml0aWFsaXplZCcpIHtcbiAgICAgICAgICAgIFVSTC5yZXZva2VPYmplY3RVUkwoYmxvYlVSTCk7XG4gICAgICAgICAgICB3b3JrZXJUaHJlYWQuYnVzeSA9IGZhbHNlO1xuICAgICAgICAgICAgd29ya2VyVGhyZWFkLmltYWdlRGF0YSA9IG5ldyBVaW50OEFycmF5KGUuZGF0YS5pbWFnZURhdGEpO1xuICAgICAgICAgICAgaWYgKEVOVi5kZXZlbG9wbWVudCkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdXb3JrZXIgaW5pdGlhbGl6ZWQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNiKHdvcmtlclRocmVhZCk7XG4gICAgICAgIH0gZWxzZSBpZiAoZS5kYXRhLmV2ZW50ID09PSAncHJvY2Vzc2VkJykge1xuICAgICAgICAgICAgd29ya2VyVGhyZWFkLmltYWdlRGF0YSA9IG5ldyBVaW50OEFycmF5KGUuZGF0YS5pbWFnZURhdGEpO1xuICAgICAgICAgICAgd29ya2VyVGhyZWFkLmJ1c3kgPSBmYWxzZTtcbiAgICAgICAgICAgIC8vIFRPRE86IGhvdyB0byB0aHJlYWQgcHVibGlzaFJlc3VsdCBpbnRvIGhlcmU/XG4gICAgICAgICAgICAvLyBwdWJsaXNoUmVzdWx0KGUuZGF0YS5yZXN1bHQsIHdvcmtlclRocmVhZC5pbWFnZURhdGEpO1xuICAgICAgICB9IGVsc2UgaWYgKGUuZGF0YS5ldmVudCA9PT0gJ2Vycm9yJykge1xuICAgICAgICAgICAgaWYgKEVOVi5kZXZlbG9wbWVudCkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdXb3JrZXIgZXJyb3I6ICcgKyBlLmRhdGEubWVzc2FnZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgd29ya2VyVGhyZWFkLndvcmtlci5wb3N0TWVzc2FnZSh7XG4gICAgICAgIGNtZDogJ2luaXQnLFxuICAgICAgICBzaXplOiB7IHg6IGlucHV0U3RyZWFtLmdldFdpZHRoKCksIHk6IGlucHV0U3RyZWFtLmdldEhlaWdodCgpIH0sXG4gICAgICAgIGltYWdlRGF0YTogd29ya2VyVGhyZWFkLmltYWdlRGF0YSxcbiAgICAgICAgY29uZmlnOiBjb25maWdGb3JXb3JrZXIoY29uZmlnKSxcbiAgICB9LCBbd29ya2VyVGhyZWFkLmltYWdlRGF0YS5idWZmZXJdKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFkanVzdFdvcmtlclBvb2woY2FwYWNpdHk6IG51bWJlciwgY29uZmlnPzogUXVhZ2dhSlNDb25maWdPYmplY3QsIGlucHV0U3RyZWFtPzogYW55LCBjYj86IEZ1bmN0aW9uKSB7XG4gICAgY29uc3QgaW5jcmVhc2VCeSA9IGNhcGFjaXR5IC0gd29ya2VyUG9vbC5sZW5ndGg7XG4gICAgaWYgKGluY3JlYXNlQnkgPT09IDAgJiYgY2IpIHtcbiAgICAgICAgY2IoKTtcbiAgICB9IGVsc2UgaWYgKGluY3JlYXNlQnkgPCAwKSB7XG4gICAgICAgIGNvbnN0IHdvcmtlcnNUb1Rlcm1pbmF0ZSA9IHdvcmtlclBvb2wuc2xpY2UoaW5jcmVhc2VCeSk7XG4gICAgICAgIHdvcmtlcnNUb1Rlcm1pbmF0ZS5mb3JFYWNoKGZ1bmN0aW9uICh3b3JrZXJUaHJlYWQpIHtcbiAgICAgICAgICAgIHdvcmtlclRocmVhZC53b3JrZXIudGVybWluYXRlKCk7XG4gICAgICAgICAgICBpZiAoRU5WLmRldmVsb3BtZW50KSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ1dvcmtlciB0ZXJtaW5hdGVkIScpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgd29ya2VyUG9vbCA9IHdvcmtlclBvb2wuc2xpY2UoMCwgaW5jcmVhc2VCeSk7XG4gICAgICAgIGlmIChjYikge1xuICAgICAgICAgICAgY2IoKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHdvcmtlckluaXRpYWxpemVkID0gKHdvcmtlclRocmVhZDogUVdvcmtlclRocmVhZCkgPT4ge1xuICAgICAgICAgICAgd29ya2VyUG9vbC5wdXNoKHdvcmtlclRocmVhZCk7XG4gICAgICAgICAgICBpZiAod29ya2VyUG9vbC5sZW5ndGggPj0gY2FwYWNpdHkgJiYgY2IpIHtcbiAgICAgICAgICAgICAgICBjYigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChjb25maWcpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5jcmVhc2VCeTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaW5pdFdvcmtlcihjb25maWcsIGlucHV0U3RyZWFtLCB3b3JrZXJJbml0aWFsaXplZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzZXRSZWFkZXJzKHJlYWRlcnM6IEFycmF5PFF1YWdnYUpTUmVhZGVyQ29uZmlnPikge1xuICAgIHdvcmtlclBvb2wuZm9yRWFjaCgod29ya2VyVGhyZWFkKSA9PiB3b3JrZXJUaHJlYWQud29ya2VyLnBvc3RNZXNzYWdlKHsgY21kOiAnc2V0UmVhZGVycycsIHJlYWRlcnMgfSkpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVnaXN0ZXJSZWFkZXIobmFtZTogc3RyaW5nLCByZWFkZXI6IGFueSkge1xuICAgIHdvcmtlclBvb2wuZm9yRWFjaCgod29ya2VyVGhyZWFkKSA9PiB3b3JrZXJUaHJlYWQud29ya2VyLnBvc3RNZXNzYWdlKHsgY21kOiAncmVnaXN0ZXJSZWFkZXInLCBuYW1lLCByZWFkZXIgfSkpO1xufVxuIiwiaW1wb3J0IHsgSW5wdXRTdHJlYW1GYWN0b3J5IH0gZnJvbSAnaW5wdXQvaW5wdXRfc3RyZWFtL2lucHV0X3N0cmVhbS5kJztcbmltcG9ydCB0eXBlIHsgSW5wdXRTdHJlYW1UeXBlIH0gZnJvbSAnLi4vLi4vdHlwZS1kZWZpbml0aW9ucy9xdWFnZ2EuZCc7XG5cbi8vIFRPRE86IG5lZWQgdG8gY3JlYXRlIGFuIElucHV0U3RyZWFtIHR5cGVzY3JpcHQgaW50ZXJmYWNlLCBzbyB3ZSBkb24ndCBoYXZlIGFuIFwiYW55XCIgaW4gdGhlIG5leHQgbGluZVxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gc2V0dXBJbnB1dFN0cmVhbSh0eXBlOiBJbnB1dFN0cmVhbVR5cGUgPSAnTGl2ZVN0cmVhbScsIHZpZXdwb3J0OiBFbGVtZW50IHwgbnVsbCwgaW5wdXRTdHJlYW1GYWN0b3J5OiBJbnB1dFN0cmVhbUZhY3RvcnkpIHtcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSAnVmlkZW9TdHJlYW0nOiB7XG4gICAgICAgICAgICBjb25zdCB2aWRlbyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3ZpZGVvJyk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHZpZGVvLFxuICAgICAgICAgICAgICAgIGlucHV0U3RyZWFtOiBpbnB1dFN0cmVhbUZhY3RvcnkuY3JlYXRlVmlkZW9TdHJlYW0odmlkZW8pLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdJbWFnZVN0cmVhbSc6XG4gICAgICAgICAgICByZXR1cm4geyBpbnB1dFN0cmVhbTogaW5wdXRTdHJlYW1GYWN0b3J5LmNyZWF0ZUltYWdlU3RyZWFtKCkgfTtcbiAgICAgICAgY2FzZSAnTGl2ZVN0cmVhbSc6IHtcbiAgICAgICAgICAgIGxldCB2aWRlbzogSFRNTFZpZGVvRWxlbWVudCB8IG51bGwgPSBudWxsO1xuICAgICAgICAgICAgaWYgKHZpZXdwb3J0KSB7XG4gICAgICAgICAgICAgICAgdmlkZW8gPSB2aWV3cG9ydC5xdWVyeVNlbGVjdG9yKCd2aWRlbycpO1xuICAgICAgICAgICAgICAgIGlmICghdmlkZW8pIHtcbiAgICAgICAgICAgICAgICAgICAgdmlkZW8gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd2aWRlbycpO1xuICAgICAgICAgICAgICAgICAgICB2aWV3cG9ydC5hcHBlbmRDaGlsZCh2aWRlbyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB2aWRlbyxcbiAgICAgICAgICAgICAgICBpbnB1dFN0cmVhbTogaW5wdXRTdHJlYW1GYWN0b3J5LmNyZWF0ZUxpdmVTdHJlYW0odmlkZW8gYXMgSFRNTFZpZGVvRWxlbWVudCksXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGAqIHNldHVwSW5wdXRTdHJlYW0gaW52YWxpZCB0eXBlICR7dHlwZX1gKTtcbiAgICAgICAgICAgIHJldHVybiB7IHZpZGVvOiBudWxsLCBpbnB1dFN0cmVhbTogbnVsbCB9O1xuICAgIH1cbn1cbiIsIi8qIGVzbGludC1kaXNhYmxlIG5vLXBhcmFtLXJlYXNzaWduICovXG5pbXBvcnQgdHlwZSB7IFBvaW50IH0gZnJvbSAnLi4vLi4vdHlwZS1kZWZpbml0aW9ucy9xdWFnZ2EuZCc7XG5cbmV4cG9ydCB0eXBlIEJveCA9IEFycmF5PFsgbnVtYmVyLCBudW1iZXIgXT47XG5cbmV4cG9ydCB0eXBlIExpbmUgPSBbIFBvaW50LCBQb2ludCBdO1xuXG5leHBvcnQgZnVuY3Rpb24gbW92ZUJveChib3g6IEJveCwgeE9mZnNldDogbnVtYmVyLCB5T2Zmc2V0OiBudW1iZXIpOiB2b2lkIHtcbiAgICBsZXQgY29ybmVyID0gYm94Lmxlbmd0aDtcbiAgICB3aGlsZSAoY29ybmVyLS0pIHtcbiAgICAgICAgYm94W2Nvcm5lcl1bMF0gKz0geE9mZnNldDtcbiAgICAgICAgYm94W2Nvcm5lcl1bMV0gKz0geU9mZnNldDtcbiAgICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBtb3ZlTGluZShsaW5lOiBMaW5lLCB4T2Zmc2V0OiBudW1iZXIsIHlPZmZzZXQ6IG51bWJlcik6IHZvaWQge1xuICAgIGxpbmVbMF0ueCArPSB4T2Zmc2V0O1xuICAgIGxpbmVbMF0ueSArPSB5T2Zmc2V0O1xuICAgIGxpbmVbMV0ueCArPSB4T2Zmc2V0O1xuICAgIGxpbmVbMV0ueSArPSB5T2Zmc2V0O1xufVxuIiwiaW1wb3J0IHsgY2xvbmUgfSBmcm9tICdnbC12ZWMyJztcbmltcG9ydCB7IFF1YWdnYUpTUmVzdWx0T2JqZWN0LCBRdWFnZ2FKU1JlYWRlckNvbmZpZyB9IGZyb20gJy4uLy4uL3R5cGUtZGVmaW5pdGlvbnMvcXVhZ2dhLmQnO1xuaW1wb3J0IEV2ZW50cyBmcm9tICcuLi9jb21tb24vZXZlbnRzJztcbmltcG9ydCBJbWFnZVdyYXBwZXIgZnJvbSAnLi4vY29tbW9uL2ltYWdlX3dyYXBwZXInO1xuaW1wb3J0IEJhcmNvZGVEZWNvZGVyIGZyb20gJy4uL2RlY29kZXIvYmFyY29kZV9kZWNvZGVyJztcbmltcG9ydCBDYW1lcmFBY2Nlc3MgZnJvbSAnLi4vaW5wdXQvY2FtZXJhX2FjY2Vzcyc7XG5pbXBvcnQgRnJhbWVHcmFiYmVyIGZyb20gJy4uL2lucHV0L2ZyYW1lX2dyYWJiZXIuanMnO1xuaW1wb3J0IElucHV0U3RyZWFtIGZyb20gJy4uL2lucHV0L2lucHV0X3N0cmVhbS9pbnB1dF9zdHJlYW0nO1xuaW1wb3J0IEJhcmNvZGVMb2NhdG9yIGZyb20gJy4uL2xvY2F0b3IvYmFyY29kZV9sb2NhdG9yJztcbmltcG9ydCB7IFF1YWdnYUNvbnRleHQgfSBmcm9tICcuLi9RdWFnZ2FDb250ZXh0JztcbmltcG9ydCB7IEJhcmNvZGVJbmZvIH0gZnJvbSAnLi4vcmVhZGVyL2JhcmNvZGVfcmVhZGVyJztcbmltcG9ydCBfZ2V0Vmlld1BvcnQgZnJvbSAnLi9nZXRWaWV3UG9ydCc7XG5pbXBvcnQgX2luaXRCdWZmZXJzIGZyb20gJy4vaW5pdEJ1ZmZlcnMnO1xuaW1wb3J0IF9pbml0Q2FudmFzIGZyb20gJy4vaW5pdENhbnZhcyc7XG5pbXBvcnQgKiBhcyBRV29ya2VycyBmcm9tICcuL3F3b3JrZXInO1xuaW1wb3J0IHNldHVwSW5wdXRTdHJlYW0gZnJvbSAnLi9zZXR1cElucHV0U3RyZWFtJztcbmltcG9ydCB7IG1vdmVMaW5lLCBtb3ZlQm94IH0gZnJvbSAnLi90cmFuc2Zvcm0nO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBRdWFnZ2Ege1xuICAgIGNvbnRleHQ6IFF1YWdnYUNvbnRleHQgPSBuZXcgUXVhZ2dhQ29udGV4dCgpO1xuXG4gICAgaW5pdEJ1ZmZlcnMoaW1hZ2VXcmFwcGVyPzogSW1hZ2VXcmFwcGVyKTogdm9pZCB7XG4gICAgICAgIGlmICghdGhpcy5jb250ZXh0LmNvbmZpZykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgaW5wdXRJbWFnZVdyYXBwZXIsIGJveFNpemUgfSA9IF9pbml0QnVmZmVycyhcbiAgICAgICAgICAgIHRoaXMuY29udGV4dC5pbnB1dFN0cmVhbSxcbiAgICAgICAgICAgIGltYWdlV3JhcHBlcixcbiAgICAgICAgICAgIHRoaXMuY29udGV4dC5jb25maWcubG9jYXRvcixcbiAgICAgICAgKTtcbiAgICAgICAgdGhpcy5jb250ZXh0LmlucHV0SW1hZ2VXcmFwcGVyID0gaW5wdXRJbWFnZVdyYXBwZXI7XG4gICAgICAgIHRoaXMuY29udGV4dC5ib3hTaXplID0gYm94U2l6ZTtcbiAgICB9XG5cbiAgICBpbml0aWFsaXplRGF0YShpbWFnZVdyYXBwZXI/OiBJbWFnZVdyYXBwZXIpOiB2b2lkIHtcbiAgICAgICAgaWYgKCF0aGlzLmNvbnRleHQuY29uZmlnKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pbml0QnVmZmVycyhpbWFnZVdyYXBwZXIpO1xuICAgICAgICB0aGlzLmNvbnRleHQuZGVjb2RlciA9IEJhcmNvZGVEZWNvZGVyLmNyZWF0ZSh0aGlzLmNvbnRleHQuY29uZmlnLmRlY29kZXIsIHRoaXMuY29udGV4dC5pbnB1dEltYWdlV3JhcHBlcik7XG4gICAgfVxuXG4gICAgZ2V0Vmlld1BvcnQoKTogRWxlbWVudCB8IG51bGwge1xuICAgICAgICBpZiAoIXRoaXMuY29udGV4dC5jb25maWcgfHwgIXRoaXMuY29udGV4dC5jb25maWcuaW5wdXRTdHJlYW0pIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgdGFyZ2V0IH0gPSB0aGlzLmNvbnRleHQuY29uZmlnLmlucHV0U3RyZWFtO1xuICAgICAgICByZXR1cm4gX2dldFZpZXdQb3J0KHRhcmdldCk7XG4gICAgfVxuXG4gICAgcmVhZHkoY2FsbGJhY2s6ICgpID0+IHZvaWQpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5jb250ZXh0LmlucHV0U3RyZWFtLnBsYXkoKTtcbiAgICAgICAgY2FsbGJhY2soKTtcbiAgICB9XG5cbiAgICBpbml0Q2FudmFzKCk6IHZvaWQge1xuICAgICAgICBjb25zdCBjb250YWluZXIgPSBfaW5pdENhbnZhcyh0aGlzLmNvbnRleHQpO1xuICAgICAgICBpZiAoIWNvbnRhaW5lcikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgY3R4LCBkb20gfSA9IGNvbnRhaW5lcjtcbiAgICAgICAgdGhpcy5jb250ZXh0LmNhbnZhc0NvbnRhaW5lci5kb20uaW1hZ2UgPSBkb20uaW1hZ2U7XG4gICAgICAgIHRoaXMuY29udGV4dC5jYW52YXNDb250YWluZXIuZG9tLm92ZXJsYXkgPSBkb20ub3ZlcmxheTtcbiAgICAgICAgdGhpcy5jb250ZXh0LmNhbnZhc0NvbnRhaW5lci5jdHguaW1hZ2UgPSBjdHguaW1hZ2U7XG4gICAgICAgIHRoaXMuY29udGV4dC5jYW52YXNDb250YWluZXIuY3R4Lm92ZXJsYXkgPSBjdHgub3ZlcmxheTtcbiAgICB9XG5cbiAgICBjYW5SZWNvcmQgPSAoY2FsbGJhY2s6ICgpID0+IHZvaWQpOiB2b2lkID0+IHtcbiAgICAgICAgaWYgKCF0aGlzLmNvbnRleHQuY29uZmlnKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgQmFyY29kZUxvY2F0b3IuY2hlY2tJbWFnZUNvbnN0cmFpbnRzKHRoaXMuY29udGV4dC5pbnB1dFN0cmVhbSwgdGhpcy5jb250ZXh0LmNvbmZpZz8ubG9jYXRvcik7XG4gICAgICAgIHRoaXMuaW5pdENhbnZhcygpO1xuICAgICAgICB0aGlzLmNvbnRleHQuZnJhbWVncmFiYmVyID0gRnJhbWVHcmFiYmVyLmNyZWF0ZShcbiAgICAgICAgICAgIHRoaXMuY29udGV4dC5pbnB1dFN0cmVhbSxcbiAgICAgICAgICAgIHRoaXMuY29udGV4dC5jYW52YXNDb250YWluZXIuZG9tLmltYWdlLFxuICAgICAgICApO1xuXG4gICAgICAgIGlmICh0aGlzLmNvbnRleHQuY29uZmlnLm51bU9mV29ya2VycyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLmNvbnRleHQuY29uZmlnLm51bU9mV29ya2VycyA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICBRV29ya2Vycy5hZGp1c3RXb3JrZXJQb29sKFxuICAgICAgICAgICAgdGhpcy5jb250ZXh0LmNvbmZpZy5udW1PZldvcmtlcnMsXG4gICAgICAgICAgICB0aGlzLmNvbnRleHQuY29uZmlnLFxuICAgICAgICAgICAgdGhpcy5jb250ZXh0LmlucHV0U3RyZWFtLFxuICAgICAgICAgICAgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNvbnRleHQuY29uZmlnPy5udW1PZldvcmtlcnMgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbml0aWFsaXplRGF0YSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnJlYWR5KGNhbGxiYWNrKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICk7XG4gICAgfTtcblxuICAgIGluaXRJbnB1dFN0cmVhbShjYWxsYmFjazogKGVycj86IEVycm9yKSA9PiB2b2lkKTogdm9pZCB7XG4gICAgICAgIGlmICghdGhpcy5jb250ZXh0LmNvbmZpZyB8fCAhdGhpcy5jb250ZXh0LmNvbmZpZy5pbnB1dFN0cmVhbSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgdHlwZTogaW5wdXRUeXBlLCBjb25zdHJhaW50cyB9ID0gdGhpcy5jb250ZXh0LmNvbmZpZy5pbnB1dFN0cmVhbTtcbiAgICAgICAgY29uc3QgeyB2aWRlbywgaW5wdXRTdHJlYW0gfSA9IHNldHVwSW5wdXRTdHJlYW0oaW5wdXRUeXBlLCB0aGlzLmdldFZpZXdQb3J0KCksIElucHV0U3RyZWFtKTtcblxuICAgICAgICBpZiAoaW5wdXRUeXBlID09PSAnTGl2ZVN0cmVhbScgJiYgdmlkZW8pIHtcbiAgICAgICAgICAgIENhbWVyYUFjY2Vzcy5yZXF1ZXN0KHZpZGVvLCBjb25zdHJhaW50cylcbiAgICAgICAgICAgICAgICAudGhlbigoKSA9PiBpbnB1dFN0cmVhbS50cmlnZ2VyKCdjYW5yZWNvcmQnKSlcbiAgICAgICAgICAgICAgICAuY2F0Y2goKGVycikgPT4gY2FsbGJhY2soZXJyKSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaW5wdXRTdHJlYW0pIHtcbiAgICAgICAgICAgIGlucHV0U3RyZWFtLnNldEF0dHJpYnV0ZSgncHJlbG9hZCcsICdhdXRvJyk7XG4gICAgICAgICAgICBpbnB1dFN0cmVhbS5zZXRJbnB1dFN0cmVhbSh0aGlzLmNvbnRleHQuY29uZmlnLmlucHV0U3RyZWFtKTtcbiAgICAgICAgICAgIGlucHV0U3RyZWFtLmFkZEV2ZW50TGlzdGVuZXIoJ2NhbnJlY29yZCcsIHRoaXMuY2FuUmVjb3JkLmJpbmQodW5kZWZpbmVkLCBjYWxsYmFjaykpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5jb250ZXh0LmlucHV0U3RyZWFtID0gaW5wdXRTdHJlYW07XG4gICAgfVxuXG4gICAgZ2V0Qm91bmRpbmdCb3hlcygpOiBBcnJheTxBcnJheTxudW1iZXI+PiB8IG51bGwge1xuICAgICAgICByZXR1cm4gdGhpcy5jb250ZXh0LmNvbmZpZz8ubG9jYXRlID8gQmFyY29kZUxvY2F0b3IubG9jYXRlKClcbiAgICAgICAgICAgIDogW1tcbiAgICAgICAgICAgICAgICBjbG9uZSh0aGlzLmNvbnRleHQuYm94U2l6ZVswXSksXG4gICAgICAgICAgICAgICAgY2xvbmUodGhpcy5jb250ZXh0LmJveFNpemVbMV0pLFxuICAgICAgICAgICAgICAgIGNsb25lKHRoaXMuY29udGV4dC5ib3hTaXplWzJdKSxcbiAgICAgICAgICAgICAgICBjbG9uZSh0aGlzLmNvbnRleHQuYm94U2l6ZVszXSksXG4gICAgICAgICAgICBdXTtcbiAgICB9XG5cbiAgICAvLyBUT0RPOiBuZWVkIGEgdHlwZXNjcmlwdCB0eXBlIGZvciByZXN1bHQgaGVyZS5cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2V4cGxpY2l0LW1vZHVsZS1ib3VuZGFyeS10eXBlc1xuICAgIHRyYW5zZm9ybVJlc3VsdChyZXN1bHQ6IGFueSk6IHZvaWQge1xuICAgICAgICBjb25zdCB0b3BSaWdodCA9IHRoaXMuY29udGV4dC5pbnB1dFN0cmVhbS5nZXRUb3BSaWdodCgpO1xuICAgICAgICBjb25zdCB4T2Zmc2V0ID0gdG9wUmlnaHQueDtcbiAgICAgICAgY29uc3QgeU9mZnNldCA9IHRvcFJpZ2h0Lnk7XG5cbiAgICAgICAgaWYgKHhPZmZzZXQgPT09IDAgJiYgeU9mZnNldCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJlc3VsdC5iYXJjb2Rlcykge1xuICAgICAgICAgICAgLy8gVE9ETzogQmFyY29kZUluZm8gbWF5IG5vdCBiZSB0aGUgcmlnaHQgdHlwZSBoZXJlLlxuICAgICAgICAgICAgcmVzdWx0LmJhcmNvZGVzLmZvckVhY2goKGJhcmNvZGU6IEJhcmNvZGVJbmZvKSA9PiB0aGlzLnRyYW5zZm9ybVJlc3VsdChiYXJjb2RlKSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocmVzdWx0LmxpbmUgJiYgcmVzdWx0LmxpbmUubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgICBtb3ZlTGluZShyZXN1bHQubGluZSwgeE9mZnNldCwgeU9mZnNldCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocmVzdWx0LmJveCkge1xuICAgICAgICAgICAgbW92ZUJveChyZXN1bHQuYm94LCB4T2Zmc2V0LCB5T2Zmc2V0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyZXN1bHQuYm94ZXMgJiYgcmVzdWx0LmJveGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVzdWx0LmJveGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbW92ZUJveChyZXN1bHQuYm94ZXNbaV0sIHhPZmZzZXQsIHlPZmZzZXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgYWRkUmVzdWx0KHJlc3VsdDogUXVhZ2dhSlNSZXN1bHRPYmplY3QsIGltYWdlRGF0YTogQXJyYXk8bnVtYmVyPik6IHZvaWQge1xuICAgICAgICBpZiAoIWltYWdlRGF0YSB8fCAhdGhpcy5jb250ZXh0LnJlc3VsdENvbGxlY3Rvcikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVE9ETzogRmlndXJlIG91dCB3aGF0IGRhdGEgc3RydWN0dXJlIGhvbGRzIGEgXCJiYXJjb2Rlc1wiIHJlc3VsdCwgaWYgYW55Li4uXG4gICAgICAgIGlmIChyZXN1bHQuYmFyY29kZXMpIHtcbiAgICAgICAgICAgIHJlc3VsdC5iYXJjb2Rlcy5maWx0ZXIoKGJhcmNvZGU6IFF1YWdnYUpTUmVzdWx0T2JqZWN0KSA9PiBiYXJjb2RlLmNvZGVSZXN1bHQpXG4gICAgICAgICAgICAgICAgLmZvckVhY2goKGJhcmNvZGU6IFF1YWdnYUpTUmVzdWx0T2JqZWN0KSA9PiB0aGlzLmFkZFJlc3VsdChiYXJjb2RlLCBpbWFnZURhdGEpKTtcbiAgICAgICAgfSBlbHNlIGlmIChyZXN1bHQuY29kZVJlc3VsdCkge1xuICAgICAgICAgICAgdGhpcy5jb250ZXh0LnJlc3VsdENvbGxlY3Rvci5hZGRSZXN1bHQoXG4gICAgICAgICAgICAgICAgaW1hZ2VEYXRhLFxuICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5pbnB1dFN0cmVhbS5nZXRDYW52YXNTaXplKCksXG4gICAgICAgICAgICAgICAgcmVzdWx0LmNvZGVSZXN1bHQsXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNsYXNzLW1ldGhvZHMtdXNlLXRoaXNcbiAgICBoYXNDb2RlUmVzdWx0KHJlc3VsdDogUXVhZ2dhSlNSZXN1bHRPYmplY3QpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuICEhKHJlc3VsdCAmJiAocmVzdWx0LmJhcmNvZGVzXG4gICAgICAgICAgICA/IHJlc3VsdC5iYXJjb2Rlcy5zb21lKChiYXJjb2RlKSA9PiBiYXJjb2RlLmNvZGVSZXN1bHQpXG4gICAgICAgICAgICA6IHJlc3VsdC5jb2RlUmVzdWx0KSk7XG4gICAgfVxuXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9leHBsaWNpdC1tb2R1bGUtYm91bmRhcnktdHlwZXNcbiAgICBwdWJsaXNoUmVzdWx0KHJlc3VsdDogUXVhZ2dhSlNSZXN1bHRPYmplY3QgfCBudWxsID0gbnVsbCwgaW1hZ2VEYXRhPzogYW55KTogdm9pZCB7XG4gICAgICAgIGxldCByZXN1bHRUb1B1Ymxpc2g6IEFycmF5PFF1YWdnYUpTUmVzdWx0T2JqZWN0PiB8IFF1YWdnYUpTUmVzdWx0T2JqZWN0IHwgbnVsbCA9IHJlc3VsdDtcblxuICAgICAgICBpZiAocmVzdWx0ICYmIHRoaXMuY29udGV4dC5vblVJVGhyZWFkKSB7XG4gICAgICAgICAgICB0aGlzLnRyYW5zZm9ybVJlc3VsdChyZXN1bHQpO1xuICAgICAgICAgICAgdGhpcy5hZGRSZXN1bHQocmVzdWx0LCBpbWFnZURhdGEpO1xuICAgICAgICAgICAgcmVzdWx0VG9QdWJsaXNoID0gcmVzdWx0LmJhcmNvZGVzIHx8IHJlc3VsdDtcbiAgICAgICAgfVxuXG4gICAgICAgIEV2ZW50cy5wdWJsaXNoKCdwcm9jZXNzZWQnLCByZXN1bHRUb1B1Ymxpc2ggYXMgbmV2ZXIpO1xuICAgICAgICBpZiAodGhpcy5oYXNDb2RlUmVzdWx0KHJlc3VsdCBhcyBRdWFnZ2FKU1Jlc3VsdE9iamVjdCkpIHtcbiAgICAgICAgICAgIEV2ZW50cy5wdWJsaXNoKCdkZXRlY3RlZCcsIHJlc3VsdFRvUHVibGlzaCBhcyBuZXZlcik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBhc3luYyBsb2NhdGVBbmREZWNvZGUoKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgICAgIGNvbnN0IGJveGVzID0gdGhpcy5nZXRCb3VuZGluZ0JveGVzKCk7XG4gICAgICAgIGlmIChib3hlcykge1xuICAgICAgICAgICAgY29uc3QgZGVjb2RlUmVzdWx0ID0gKGF3YWl0IHRoaXMuY29udGV4dC5kZWNvZGVyLmRlY29kZUZyb21Cb3VuZGluZ0JveGVzKGJveGVzKSkgfHwge307XG4gICAgICAgICAgICBkZWNvZGVSZXN1bHQuYm94ZXMgPSBib3hlcztcbiAgICAgICAgICAgIHRoaXMucHVibGlzaFJlc3VsdChkZWNvZGVSZXN1bHQsIHRoaXMuY29udGV4dC5pbnB1dEltYWdlV3JhcHBlcj8uZGF0YSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBpbWFnZVJlc3VsdCA9IGF3YWl0IHRoaXMuY29udGV4dC5kZWNvZGVyLmRlY29kZUZyb21JbWFnZSh0aGlzLmNvbnRleHQuaW5wdXRJbWFnZVdyYXBwZXIpO1xuICAgICAgICAgICAgaWYgKGltYWdlUmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wdWJsaXNoUmVzdWx0KGltYWdlUmVzdWx0LCB0aGlzLmNvbnRleHQuaW5wdXRJbWFnZVdyYXBwZXI/LmRhdGEpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnB1Ymxpc2hSZXN1bHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHVwZGF0ZSA9ICgpOiB2b2lkID0+IHtcbiAgICAgICAgaWYgKHRoaXMuY29udGV4dC5vblVJVGhyZWFkKSB7XG4gICAgICAgICAgICBjb25zdCB3b3JrZXJzVXBkYXRlZCA9IFFXb3JrZXJzLnVwZGF0ZVdvcmtlcnModGhpcy5jb250ZXh0LmZyYW1lZ3JhYmJlcik7XG4gICAgICAgICAgICBpZiAoIXdvcmtlcnNVcGRhdGVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LmZyYW1lZ3JhYmJlci5hdHRhY2hEYXRhKHRoaXMuY29udGV4dC5pbnB1dEltYWdlV3JhcHBlcj8uZGF0YSk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY29udGV4dC5mcmFtZWdyYWJiZXIuZ3JhYigpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghd29ya2Vyc1VwZGF0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubG9jYXRlQW5kRGVjb2RlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmNvbnRleHQuZnJhbWVncmFiYmVyLmF0dGFjaERhdGEodGhpcy5jb250ZXh0LmlucHV0SW1hZ2VXcmFwcGVyPy5kYXRhKTtcbiAgICAgICAgICAgIHRoaXMuY29udGV4dC5mcmFtZWdyYWJiZXIuZ3JhYigpO1xuICAgICAgICAgICAgdGhpcy5sb2NhdGVBbmREZWNvZGUoKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBzdGFydENvbnRpbnVvdXNVcGRhdGUoKTogdm9pZCB7XG4gICAgICAgIGxldCBuZXh0OiBudW1iZXIgfCBudWxsID0gbnVsbDtcbiAgICAgICAgY29uc3QgZGVsYXkgPSAxMDAwIC8gKHRoaXMuY29udGV4dC5jb25maWc/LmZyZXF1ZW5jeSB8fCA2MCk7XG5cbiAgICAgICAgdGhpcy5jb250ZXh0LnN0b3BwZWQgPSBmYWxzZTtcbiAgICAgICAgY29uc3QgeyBjb250ZXh0IH0gPSB0aGlzO1xuXG4gICAgICAgIGNvbnN0IG5ld0ZyYW1lID0gKHRpbWVzdGFtcDogbnVtYmVyKSA9PiB7XG4gICAgICAgICAgICBuZXh0ID0gbmV4dCB8fCB0aW1lc3RhbXA7XG4gICAgICAgICAgICBpZiAoIWNvbnRleHQuc3RvcHBlZCkge1xuICAgICAgICAgICAgICAgIGlmICh0aW1lc3RhbXAgPj0gbmV4dCkge1xuICAgICAgICAgICAgICAgICAgICBuZXh0ICs9IGRlbGF5O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKG5ld0ZyYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBuZXdGcmFtZShwZXJmb3JtYW5jZS5ub3coKSk7XG4gICAgfVxuXG4gICAgc3RhcnQoKTogdm9pZCB7XG4gICAgICAgIGlmICh0aGlzLmNvbnRleHQub25VSVRocmVhZCAmJiB0aGlzLmNvbnRleHQuY29uZmlnPy5pbnB1dFN0cmVhbT8udHlwZSA9PT0gJ0xpdmVTdHJlYW0nKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXJ0Q29udGludW91c1VwZGF0ZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGFzeW5jIHN0b3AoKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgICAgIHRoaXMuY29udGV4dC5zdG9wcGVkID0gdHJ1ZTtcbiAgICAgICAgUVdvcmtlcnMuYWRqdXN0V29ya2VyUG9vbCgwKTtcbiAgICAgICAgaWYgKHRoaXMuY29udGV4dC5jb25maWc/LmlucHV0U3RyZWFtICYmIHRoaXMuY29udGV4dC5jb25maWcuaW5wdXRTdHJlYW0udHlwZSA9PT0gJ0xpdmVTdHJlYW0nKSB7XG4gICAgICAgICAgICBhd2FpdCBDYW1lcmFBY2Nlc3MucmVsZWFzZSgpO1xuICAgICAgICAgICAgdGhpcy5jb250ZXh0LmlucHV0U3RyZWFtLmNsZWFyRXZlbnRIYW5kbGVycygpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgc2V0UmVhZGVycyhyZWFkZXJzOiBBcnJheTxRdWFnZ2FKU1JlYWRlckNvbmZpZz4pOiB2b2lkIHtcbiAgICAgICAgaWYgKHRoaXMuY29udGV4dC5kZWNvZGVyKSB7XG4gICAgICAgICAgICB0aGlzLmNvbnRleHQuZGVjb2Rlci5zZXRSZWFkZXJzKHJlYWRlcnMpO1xuICAgICAgICB9XG4gICAgICAgIFFXb3JrZXJzLnNldFJlYWRlcnMocmVhZGVycyk7XG4gICAgfVxuXG4gICAgcmVnaXN0ZXJSZWFkZXIobmFtZTogc3RyaW5nLCByZWFkZXI6IFF1YWdnYUpTUmVhZGVyQ29uZmlnKTogdm9pZCB7XG4gICAgICAgIEJhcmNvZGVEZWNvZGVyLnJlZ2lzdGVyUmVhZGVyKG5hbWUsIHJlYWRlcik7XG4gICAgICAgIGlmICh0aGlzLmNvbnRleHQuZGVjb2Rlcikge1xuICAgICAgICAgICAgdGhpcy5jb250ZXh0LmRlY29kZXIucmVnaXN0ZXJSZWFkZXIobmFtZSwgcmVhZGVyKTtcbiAgICAgICAgfVxuICAgICAgICBRV29ya2Vycy5yZWdpc3RlclJlYWRlcihuYW1lLCByZWFkZXIpO1xuICAgIH1cbn1cbiIsImltcG9ydCBtZXJnZSBmcm9tICdsb2Rhc2gvbWVyZ2UnO1xuaW1wb3J0IFR5cGVEZWZzIGZyb20gJy4vY29tbW9uL3R5cGVkZWZzJzsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuaW1wb3J0IEltYWdlV3JhcHBlciBmcm9tICcuL2NvbW1vbi9pbWFnZV93cmFwcGVyJztcbmltcG9ydCBCYXJjb2RlRGVjb2RlciBmcm9tICcuL2RlY29kZXIvYmFyY29kZV9kZWNvZGVyJztcbmltcG9ydCAqIGFzIFJlYWRlcnMgZnJvbSAnLi9yZWFkZXIvaW5kZXgnO1xuaW1wb3J0IEV2ZW50cyBmcm9tICcuL2NvbW1vbi9ldmVudHMnO1xuaW1wb3J0IENhbWVyYUFjY2VzcyBmcm9tICcuL2lucHV0L2NhbWVyYV9hY2Nlc3MnO1xuaW1wb3J0IEltYWdlRGVidWcgZnJvbSAnLi9jb21tb24vaW1hZ2VfZGVidWcnO1xuaW1wb3J0IFJlc3VsdENvbGxlY3RvciBmcm9tICcuL2FuYWx5dGljcy9yZXN1bHRfY29sbGVjdG9yJztcbmltcG9ydCBDb25maWcgZnJvbSAnLi9jb25maWcvY29uZmlnJztcblxuaW1wb3J0IFF1YWdnYSBmcm9tICcuL3F1YWdnYS9xdWFnZ2EnO1xuXG5jb25zdCBpbnN0YW5jZSA9IG5ldyBRdWFnZ2EoKTtcbmNvbnN0IF9jb250ZXh0ID0gaW5zdGFuY2UuY29udGV4dDtcblxuY29uc3QgUXVhZ2dhSlNTdGF0aWNJbnRlcmZhY2UgPSB7XG4gICAgaW5pdDogZnVuY3Rpb24gKGNvbmZpZywgY2IsIGltYWdlV3JhcHBlciwgcXVhZ2dhSW5zdGFuY2UgPSBpbnN0YW5jZSkge1xuICAgICAgICBsZXQgcHJvbWlzZTtcbiAgICAgICAgaWYgKCFjYikge1xuICAgICAgICAgICAgcHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgICAgICBjYiA9IChlcnIpID0+IHsgZXJyID8gcmVqZWN0KGVycikgOiByZXNvbHZlKCk7IH07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBxdWFnZ2FJbnN0YW5jZS5jb250ZXh0LmNvbmZpZyA9IG1lcmdlKHt9LCBDb25maWcsIGNvbmZpZyk7XG4gICAgICAgIC8vIFRPRE8gIzE3OTogcGVuZGluZyByZXN0cnVjdHVyZSBpbiBJc3N1ZSAjMTc5LCB3ZSBhcmUgdGVtcCBkaXNhYmxpbmcgd29ya2Vyc1xuICAgICAgICBpZiAocXVhZ2dhSW5zdGFuY2UuY29udGV4dC5jb25maWcubnVtT2ZXb3JrZXJzID4gMCkge1xuICAgICAgICAgICAgcXVhZ2dhSW5zdGFuY2UuY29udGV4dC5jb25maWcubnVtT2ZXb3JrZXJzID0gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW1hZ2VXcmFwcGVyKSB7XG4gICAgICAgICAgICBxdWFnZ2FJbnN0YW5jZS5jb250ZXh0Lm9uVUlUaHJlYWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHF1YWdnYUluc3RhbmNlLmluaXRpYWxpemVEYXRhKGltYWdlV3JhcHBlcik7XG4gICAgICAgICAgICBpZiAoY2IpIHtcbiAgICAgICAgICAgICAgICBjYigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcXVhZ2dhSW5zdGFuY2UuaW5pdElucHV0U3RyZWFtKGNiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICB9LFxuICAgIHN0YXJ0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBpbnN0YW5jZS5zdGFydCgpO1xuICAgIH0sXG4gICAgc3RvcDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gaW5zdGFuY2Uuc3RvcCgpO1xuICAgIH0sXG4gICAgcGF1c2U6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX2NvbnRleHQuc3RvcHBlZCA9IHRydWU7XG4gICAgfSxcbiAgICBvbkRldGVjdGVkOiBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKCFjYWxsYmFjayB8fCAodHlwZW9mIGNhbGxiYWNrICE9PSAnZnVuY3Rpb24nICYmICh0eXBlb2YgY2FsbGJhY2sgIT09ICdvYmplY3QnIHx8ICFjYWxsYmFjay5jYWxsYmFjaykpKSB7XG4gICAgICAgICAgICBjb25zb2xlLnRyYWNlKCcqIHdhcm5pbmc6IFF1YWdnYS5vbkRldGVjdGVkIGNhbGxlZCB3aXRoIGludmFsaWQgY2FsbGJhY2ssIGlnbm9yaW5nJyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgRXZlbnRzLnN1YnNjcmliZSgnZGV0ZWN0ZWQnLCBjYWxsYmFjayk7XG4gICAgfSxcbiAgICBvZmZEZXRlY3RlZDogZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgIEV2ZW50cy51bnN1YnNjcmliZSgnZGV0ZWN0ZWQnLCBjYWxsYmFjayk7XG4gICAgfSxcbiAgICBvblByb2Nlc3NlZDogZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgIGlmICghY2FsbGJhY2sgfHwgKHR5cGVvZiBjYWxsYmFjayAhPT0gJ2Z1bmN0aW9uJyAmJiAodHlwZW9mIGNhbGxiYWNrICE9PSAnb2JqZWN0JyB8fCAhY2FsbGJhY2suY2FsbGJhY2spKSkge1xuICAgICAgICAgICAgY29uc29sZS50cmFjZSgnKiB3YXJuaW5nOiBRdWFnZ2Eub25Qcm9jZXNzZWQgY2FsbGVkIHdpdGggaW52YWxpZCBjYWxsYmFjaywgaWdub3JpbmcnKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBFdmVudHMuc3Vic2NyaWJlKCdwcm9jZXNzZWQnLCBjYWxsYmFjayk7XG4gICAgfSxcbiAgICBvZmZQcm9jZXNzZWQ6IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICBFdmVudHMudW5zdWJzY3JpYmUoJ3Byb2Nlc3NlZCcsIGNhbGxiYWNrKTtcbiAgICB9LFxuICAgIHNldFJlYWRlcnM6IGZ1bmN0aW9uIChyZWFkZXJzKSB7XG4gICAgICAgIGlmICghcmVhZGVycykge1xuICAgICAgICAgICAgY29uc29sZS50cmFjZSgnKiB3YXJuaW5nOiBRdWFnZ2Euc2V0UmVhZGVycyBjYWxsZWQgd2l0aCBubyByZWFkZXJzLCBpZ25vcmluZycpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGluc3RhbmNlLnNldFJlYWRlcnMocmVhZGVycyk7XG4gICAgfSxcbiAgICByZWdpc3RlclJlYWRlcjogZnVuY3Rpb24gKG5hbWUsIHJlYWRlcikge1xuICAgICAgICBpZiAoIW5hbWUpIHtcbiAgICAgICAgICAgIGNvbnNvbGUudHJhY2UoJyogd2FybmluZzogUXVhZ2dhLnJlZ2lzdGVyUmVhZGVyIGNhbGxlZCB3aXRoIG5vIG5hbWUsIGlnbm9yaW5nJyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFyZWFkZXIpIHtcbiAgICAgICAgICAgIGNvbnNvbGUudHJhY2UoJyogd2FybmluZzogUXVhZ2dhLnJlZ2lzdGVyUmVhZGVyIGNhbGxlZCB3aXRoIG5vIHJlYWRlciwgaWdub3JpbmcnKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpbnN0YW5jZS5yZWdpc3RlclJlYWRlcihuYW1lLCByZWFkZXIpO1xuICAgIH0sXG4gICAgcmVnaXN0ZXJSZXN1bHRDb2xsZWN0b3I6IGZ1bmN0aW9uIChyZXN1bHRDb2xsZWN0b3IpIHtcbiAgICAgICAgaWYgKHJlc3VsdENvbGxlY3RvciAmJiB0eXBlb2YgcmVzdWx0Q29sbGVjdG9yLmFkZFJlc3VsdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgX2NvbnRleHQucmVzdWx0Q29sbGVjdG9yID0gcmVzdWx0Q29sbGVjdG9yO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBnZXQgY2FudmFzKCkge1xuICAgICAgICByZXR1cm4gX2NvbnRleHQuY2FudmFzQ29udGFpbmVyO1xuICAgIH0sXG4gICAgZGVjb2RlU2luZ2xlOiBmdW5jdGlvbiAoY29uZmlnLCByZXN1bHRDYWxsYmFjaykge1xuICAgICAgICBjb25zdCBxdWFnZ2FJbnN0YW5jZSA9IG5ldyBRdWFnZ2EoKTtcbiAgICAgICAgY29uZmlnID0gbWVyZ2Uoe1xuICAgICAgICAgICAgaW5wdXRTdHJlYW06IHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnSW1hZ2VTdHJlYW0nLFxuICAgICAgICAgICAgICAgIHNlcXVlbmNlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBzaXplOiA4MDAsXG4gICAgICAgICAgICAgICAgc3JjOiBjb25maWcuc3JjLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG51bU9mV29ya2VyczogKEVOVi5kZXZlbG9wbWVudCAmJiBjb25maWcuZGVidWcpID8gMCA6IDEsXG4gICAgICAgICAgICBsb2NhdG9yOiB7XG4gICAgICAgICAgICAgICAgaGFsZlNhbXBsZTogZmFsc2UsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9LCBjb25maWcpO1xuICAgICAgICAvLyBUT0RPICMxNzU6IHJlc3RydWN0dXJlIHdvcmtlciBzdXBwb3J0IHNvIHRoYXQgaXQgd2lsbCB3b3JrIHdpdGggdHlwZXNjcmlwdCB1c2luZyB3b3JrZXItbG9hZGVyXG4gICAgICAgIC8vIGh0dHBzOi8vd2VicGFjay5qcy5vcmcvbG9hZGVycy93b3JrZXItbG9hZGVyL1xuICAgICAgICBpZiAoY29uZmlnLm51bU9mV29ya2VycyA+IDApIHtcbiAgICAgICAgICAgIGNvbmZpZy5udW1PZldvcmtlcnMgPSAwO1xuICAgICAgICB9XG4gICAgICAgIC8vIHdvcmtlcnMgcmVxdWlyZSBXb3JrZXIgYW5kIEJsb2Igc3VwcG9ydCBwcmVzZW50bHksIHNvIGlmIG5vIEJsb2Igb3IgV29ya2VyIHRoZW4gc2V0XG4gICAgICAgIC8vIHdvcmtlcnMgdG8gMC5cbiAgICAgICAgaWYgKGNvbmZpZy5udW1PZldvcmtlcnMgPiAwICYmICh0eXBlb2YgQmxvYiA9PT0gJ3VuZGVmaW5lZCcgfHwgdHlwZW9mIFdvcmtlciA9PT0gJ3VuZGVmaW5lZCcpKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJyogbm8gV29ya2VyIGFuZC9vciBCbG9iIHN1cHBvcnQgLSBmb3JjaW5nIG51bU9mV29ya2VycyB0byAwJyk7XG4gICAgICAgICAgICBjb25maWcubnVtT2ZXb3JrZXJzID0gMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB0aGlzLmluaXQoY29uZmlnLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIEV2ZW50cy5vbmNlKCdwcm9jZXNzZWQnLCAocmVzdWx0KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBxdWFnZ2FJbnN0YW5jZS5zdG9wKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0Q2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRDYWxsYmFjay5jYWxsKG51bGwsIHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgIH0sIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICBxdWFnZ2FJbnN0YW5jZS5zdGFydCgpO1xuICAgICAgICAgICAgICAgIH0sIG51bGwsIHF1YWdnYUluc3RhbmNlKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9LFxuICAgIC8vIGFkZCB0aGUgdXN1YWxseSBleHBlY3RlZCBcImRlZmF1bHRcIiBmb3IgdXNlIHdpdGggcmVxdWlyZSwgYnVpbGQgc3RlcCB3b24ndCBhbGxvdyB1cyB0b1xuICAgIC8vIHdyaXRlIHRvIG1vZHVsZS5leHBvcnRzIHNvIGRvIGl0IGhlcmUuXG4gICAgZ2V0IGRlZmF1bHQoKSB7XG4gICAgICAgIHJldHVybiBRdWFnZ2FKU1N0YXRpY0ludGVyZmFjZTtcbiAgICB9LFxuICAgIFJlYWRlcnMsXG4gICAgQ2FtZXJhQWNjZXNzLFxuICAgIEltYWdlRGVidWcsXG4gICAgSW1hZ2VXcmFwcGVyLFxuICAgIFJlc3VsdENvbGxlY3Rvcixcbn07XG5cbmV4cG9ydCBkZWZhdWx0IFF1YWdnYUpTU3RhdGljSW50ZXJmYWNlO1xuLy8gZXhwb3J0IEJhcmNvZGVSZWFkZXIgYW5kIG90aGVyIHV0aWxpdGllcyBmb3IgZXh0ZXJuYWwgcGx1Z2luc1xuZXhwb3J0IHtcbiAgICBCYXJjb2RlRGVjb2RlcixcbiAgICBSZWFkZXJzLFxuICAgIENhbWVyYUFjY2VzcyxcbiAgICBJbWFnZURlYnVnLFxuICAgIEltYWdlV3JhcHBlcixcbiAgICBSZXN1bHRDb2xsZWN0b3IsXG59O1xuIl0sInNvdXJjZVJvb3QiOiIifQ==
